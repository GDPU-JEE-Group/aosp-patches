diff --git a/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java b/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
index 5b599e9318..2f53a3bed9 100644
--- a/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -406,6 +406,14 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.BiFunction;
 
+import android.app.ActivityThread;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.os.RemoteException;
+import android.util.Slog;
+import android.os.UserHandle;
+
+
 public class ActivityManagerService extends IActivityManager.Stub
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
 
@@ -1199,10 +1207,10 @@ public class ActivityManagerService extends IActivityManager.Stub
     volatile boolean mSystemReady = false;
     volatile boolean mOnBattery = false;
     final int mFactoryTest;
-    volatile boolean mBooting = false;
+    volatile boolean mBooting = false; //指示系统当前是否处于启动阶段。使用 volatile 确保多个线程能够正确地读取该变量的最新值。
 
-    @GuardedBy("this") boolean mCallFinishBooting = false;
-    @GuardedBy("this") boolean mBootAnimationComplete = false;
+    @GuardedBy("this") boolean mCallFinishBooting = false;//指示系统当前是否处于启动阶段。使用 volatile 确保多个线程能够正确地读取该变量的最新值。
+    @GuardedBy("this") boolean mBootAnimationComplete = false;//指示启动动画是否已完成，这对于启动流程中的其他操作和判断至关重要。
 
     final Context mContext;
 
@@ -9115,6 +9123,18 @@ public class ActivityManagerService extends IActivityManager.Stub
             // Now that we have cleaned up any update processes, we
             // are ready to start launching real processes and know that
             // we won't trample on them any more.
+            
+            // 启动你的应用
+            Intent intent2 = new Intent();
+            intent2.setComponent(new ComponentName("com.android.ext", "com.android.ext.root.RootActivity"));
+            intent2.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+
+            try {
+                mContext.startActivity(intent2);
+            } catch (Exception e) {
+                Slog.e(TAG, "Failed to start RootActivity", e);
+            }
+            startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);//!
             mProcessesReady = true;
         }
 
@@ -9169,7 +9189,6 @@ public class ActivityManagerService extends IActivityManager.Stub
         synchronized (this) {
             // Only start up encryption-aware persistent apps; once user is
             // unlocked we'll come back around and start unaware apps
-            startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);
 
             // Start up initial activity.
             mBooting = true;
diff --git a/vendor/ntimespace/ExtProvider/src/com/android/ext/root/ManagerService.java b/vendor/ntimespace/ExtProvider/src/com/android/ext/root/ManagerService.java
index ce6c2a00d9..73daa448c3 100644
--- a/vendor/ntimespace/ExtProvider/src/com/android/ext/root/ManagerService.java
+++ b/vendor/ntimespace/ExtProvider/src/com/android/ext/root/ManagerService.java
@@ -72,12 +72,19 @@ public class ManagerService {
                 Method method = mSockFd.getClass().getDeclaredMethod("setInt$", int.class);
                 method.setAccessible(true);
                 method.invoke(mSockFd, socket);
+
+                Log.d("ManagerService-root","|||||||||||||||||||||||||||||||");
+                Log.d("ManagerService-root","createServerSocket() succeeful");
+                Log.d("ManagerService-root","==============================");
             } catch (Exception e) {
                 logger.w("FileDescriptor.setInt$ error", e);
+                Log.d("ManagerService-root","============FileDescriptor.setInt$ error==================");
             }
         } else {
             logger.w("warn: createServerSocket is -1");
+            Log.d("ManagerService-root","============createServerSocket is -1==================");
         }
+
     }
 
     public void stop() {
diff --git a/vendor/ntimespace/proc_watcher/SocketConnection.cpp b/vendor/ntimespace/proc_watcher/SocketConnection.cpp
index f49f2c4dd1..4eb2f0ca40 100644
--- a/vendor/ntimespace/proc_watcher/SocketConnection.cpp
+++ b/vendor/ntimespace/proc_watcher/SocketConnection.cpp
@@ -29,10 +29,20 @@ bool SocketConnection::doOpen(const char* sock_path) {
   setsockopt(mFd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
   setsockopt(mFd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
 
-  ret = connect(mFd, (struct sockaddr *)&un, sizeof(un));
-  if (ret < 0) {
-    doClose();
-    ALOGW("Connect socket err: %s", strerror(errno));
+  int i=20;//最大重连次数
+  ALOGI("ManagerService-root   doOpen()!!");//!
+  while (i-->0) {
+    ret = connect(mFd, (struct sockaddr *)&un, sizeof(un));
+    if (ret < 0) {
+      doClose();
+      ALOGW("Connect socket err: %s,Reconnect for the %d time", strerror(errno),i);//!
+      std::this_thread::sleep_for(std::chrono::milliseconds(200)); // 等待 0.2 秒重试
+    }else {
+      break;//succeed
+    }
+  }
+  if (i==0) {
+    ALOGE("Connect socket err: %s ,Maximum reconnection exceeded!!!", strerror(errno));//!
     return false;
   }
   return true;
@@ -53,6 +63,39 @@ bool SocketConnection::request(const char* message, char* result, int result_siz
   return true;
 }
 
+// 读写失败会重连
+bool SocketConnection::request_retry(const char* message, char* result, int result_size,const char* sock_path) {
+    int max_retries = 5; // 最大重试次数    
+    for (int i = 0; i < max_retries; ++i) {
+        int ret = write(mFd, message, strlen(message));
+        if (ret < 0) {
+            ALOGW("Write socket err: %s", strerror(errno));
+            if (SocketConnection::doOpen(sock_path)) { // 尝试重新连接
+                ALOGW("Reconnected, retrying write...");
+                continue; // 重新尝试写
+            }
+            return false; // 连接失败，返回
+        }
+
+        ret = read(mFd, result, result_size);
+        if (ret < 0) {
+            ALOGW("Read socket err: %s", strerror(errno));
+            if (SocketConnection::doOpen(sock_path)) { // 尝试重新连接
+                ALOGW("Reconnected, retrying read...");
+                continue; // 重新尝试读
+            }
+            return false; // 连接失败，返回
+        }
+        
+        return true; // 成功
+    }
+    
+    ALOGE("Maximum retry limit reached for request.");
+    return false; // 超过最大重试次数
+}
+
+
+
 void SocketConnection::doClose() {
   if (mFd > 0) {
     close(mFd);
diff --git a/vendor/ntimespace/proc_watcher/SocketConnection.h b/vendor/ntimespace/proc_watcher/SocketConnection.h
index 39b9767d45..04f8110396 100644
--- a/vendor/ntimespace/proc_watcher/SocketConnection.h
+++ b/vendor/ntimespace/proc_watcher/SocketConnection.h
@@ -8,11 +8,17 @@
 #include <sys/un.h>
 #include <sys/mount.h>
 #include <unistd.h>
+#include <chrono>               // 支持时间操作
+#include <thread>                // 支持线程
+#include <atomic>               // 支持原子操作
+#include <chrono>               // 支持时间操作
+#include <cstring>              // 支持字符串操作
 
 class SocketConnection {
 public:
   bool doOpen(const char* path);
   bool request(const char* message, char* result, int size);
+  bool request_retry(const char* message, char* result, int result_size,const char* sock_path);
   void doClose();
 private:
   int mFd;
