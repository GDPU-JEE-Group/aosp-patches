diff --git a/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java b/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
index 5b599e9318..37b00b81f7 100644
--- a/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -406,6 +406,14 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.BiFunction;
 
+import android.app.ActivityThread;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.os.RemoteException;
+import android.util.Slog;
+import android.os.UserHandle;
+
+
 public class ActivityManagerService extends IActivityManager.Stub
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
 
@@ -9115,6 +9123,17 @@ public class ActivityManagerService extends IActivityManager.Stub
             // Now that we have cleaned up any update processes, we
             // are ready to start launching real processes and know that
             // we won't trample on them any more.
+            
+            // 启动你的应用
+            Intent intent2 = new Intent();
+            intent2.setComponent(new ComponentName("com.android.ext", "com.android.ext.root.RootActivity"));
+            intent2.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+
+            try {
+                mContext.startActivity(intent2);
+            } catch (Exception e) {
+                Slog.e(TAG, "Failed to start RootActivity", e);
+            }
             mProcessesReady = true;
         }
 
diff --git a/vendor/ntimespace/ExtProvider/src/com/android/ext/RootModule.java b/vendor/ntimespace/ExtProvider/src/com/android/ext/RootModule.java
index 62703cb1a1..f2bd673052 100644
--- a/vendor/ntimespace/ExtProvider/src/com/android/ext/RootModule.java
+++ b/vendor/ntimespace/ExtProvider/src/com/android/ext/RootModule.java
@@ -13,12 +13,14 @@ import com.android.ext.root.ManagerService;
 import com.android.ext.root.RootActivity;
 import com.android.ext.root.RootController;
 import com.android.libutils.Package;
+import android.util.Log;
 
 public class RootModule {
 
     private RootController mController;
 
     public void onCreate(Context context) {
+        Log.d("RootModule-root","onCreate()");
         Configuration.init(context);
 
         mController = RootController.getInstance(context);
diff --git a/vendor/ntimespace/ExtProvider/src/com/android/ext/root/ManagerService.java b/vendor/ntimespace/ExtProvider/src/com/android/ext/root/ManagerService.java
index ce6c2a00d9..a5bc0de08f 100644
--- a/vendor/ntimespace/ExtProvider/src/com/android/ext/root/ManagerService.java
+++ b/vendor/ntimespace/ExtProvider/src/com/android/ext/root/ManagerService.java
@@ -72,11 +72,15 @@ public class ManagerService {
                 Method method = mSockFd.getClass().getDeclaredMethod("setInt$", int.class);
                 method.setAccessible(true);
                 method.invoke(mSockFd, socket);
+
+                Log.d("ManagerService-root","createServerSocket() succeeful");
             } catch (Exception e) {
                 logger.w("FileDescriptor.setInt$ error", e);
+                Log.d("ManagerService-root","============FileDescriptor.setInt$ error==================");
             }
         } else {
             logger.w("warn: createServerSocket is -1");
+            Log.d("ManagerService-root","============createServerSocket is -1==================");
         }
     }
 
diff --git a/vendor/ntimespace/proc_watcher/GrantRoot.cpp b/vendor/ntimespace/proc_watcher/GrantRoot.cpp
index 78144f22a2..4ece122640 100644
--- a/vendor/ntimespace/proc_watcher/GrantRoot.cpp
+++ b/vendor/ntimespace/proc_watcher/GrantRoot.cpp
@@ -1,6 +1,8 @@
 #include "GrantRoot.h"
 
 bool GrantRoot::startGrantRoot() {
+  ALOGI("root---startGrantRoot()");
+
   mode_t cmask = umask(026);
   struct stat info;
 
@@ -58,6 +60,8 @@ bool GrantRoot::startGrantRoot() {
 }
 
 bool GrantRoot::checkRootable() {
+  ALOGI("root---checkRootable(");
+
   char buffer[64];
   char data[48];
 
@@ -67,6 +71,7 @@ bool GrantRoot::checkRootable() {
 
   SocketConnection socket;
   if (!socket.doOpen("/data/system/root_sock")) {
+    ALOGE("root---socket.doOpen(),failed!");
     return false;
   }
 
@@ -76,10 +81,11 @@ bool GrantRoot::checkRootable() {
   length = snprintf(data, sizeof(data), "root:%d", mUid);
   snprintf(buffer, sizeof(buffer), "%02d|%s", length, data);
 
-  result = socket.request(buffer, &response, sizeof(response));
+  result = socket.request_retry(buffer, &response, sizeof(response),"/data/system/root_sock");
   socket.doClose();
   ALOGI("root---checkRootable result: %d, response: %c ,uid:%d", result, response,mUid);
   if (!result) {
+    ALOGE("root---result:%d",result);
     return false;
   }
   return response == '1';
diff --git a/vendor/ntimespace/proc_watcher/SocketConnection.cpp b/vendor/ntimespace/proc_watcher/SocketConnection.cpp
index f49f2c4dd1..3746faf8b2 100644
--- a/vendor/ntimespace/proc_watcher/SocketConnection.cpp
+++ b/vendor/ntimespace/proc_watcher/SocketConnection.cpp
@@ -29,10 +29,20 @@ bool SocketConnection::doOpen(const char* sock_path) {
   setsockopt(mFd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
   setsockopt(mFd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
 
-  ret = connect(mFd, (struct sockaddr *)&un, sizeof(un));
-  if (ret < 0) {
-    doClose();
-    ALOGW("Connect socket err: %s", strerror(errno));
+  int i=20;//最大重连次数
+  ALOGI("ManagerService-root   doOpen()!!");//!
+  while (i-->0) {
+    ret = connect(mFd, (struct sockaddr *)&un, sizeof(un));
+    if (ret < 0) {
+      doClose();
+      // ALOGW("Connect socket err: %s,Reconnect for the %d time", strerror(errno),i);//!
+      std::this_thread::sleep_for(std::chrono::milliseconds(200)); // 等待 0.2 秒重试
+    }else {
+      break;//succeed
+    }
+  }
+  if (i==0) {
+    ALOGE("Connect socket err: %s ,Maximum reconnection exceeded!!!", strerror(errno));//!
     return false;
   }
   return true;
@@ -53,6 +63,39 @@ bool SocketConnection::request(const char* message, char* result, int result_siz
   return true;
 }
 
+// 读写失败会重连
+bool SocketConnection::request_retry(const char* message, char* result, int result_size,const char* sock_path) {
+    int max_retries = 3; // 最大重试次数    
+    for (int i = 0; i < max_retries; ++i) {
+        int ret = write(mFd, message, strlen(message));
+        if (ret < 0) {
+            ALOGW("Write socket err: %s", strerror(errno));
+            if (SocketConnection::doOpen(sock_path)) { // 尝试重新连接
+                ALOGW("Reconnected, retrying write...");
+                continue; // 重新尝试写
+            }
+            return false; // 连接失败，返回
+        }
+
+        ret = read(mFd, result, result_size);
+        if (ret < 0) {
+            ALOGW("Read socket err: %s", strerror(errno));
+            if (SocketConnection::doOpen(sock_path)) { // 尝试重新连接
+                ALOGW("Reconnected, retrying read...");
+                continue; // 重新尝试读
+            }
+            return false; // 连接失败，返回
+        }
+        
+        return true; // 成功
+    }
+    
+    ALOGE("Maximum retry limit reached for request.");
+    return false; // 超过最大重试次数
+}
+
+
+
 void SocketConnection::doClose() {
   if (mFd > 0) {
     close(mFd);
diff --git a/vendor/ntimespace/proc_watcher/SocketConnection.h b/vendor/ntimespace/proc_watcher/SocketConnection.h
index 39b9767d45..04f8110396 100644
--- a/vendor/ntimespace/proc_watcher/SocketConnection.h
+++ b/vendor/ntimespace/proc_watcher/SocketConnection.h
@@ -8,11 +8,17 @@
 #include <sys/un.h>
 #include <sys/mount.h>
 #include <unistd.h>
+#include <chrono>               // 支持时间操作
+#include <thread>                // 支持线程
+#include <atomic>               // 支持原子操作
+#include <chrono>               // 支持时间操作
+#include <cstring>              // 支持字符串操作
 
 class SocketConnection {
 public:
   bool doOpen(const char* path);
   bool request(const char* message, char* result, int size);
+  bool request_retry(const char* message, char* result, int result_size,const char* sock_path);
   void doClose();
 private:
   int mFd;
