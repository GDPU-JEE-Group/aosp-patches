diff --git a/device/rockchip/rk3588/device.mk b/device/rockchip/rk3588/device.mk
index 679c22adbb..166d2d83ac 100644
--- a/device/rockchip/rk3588/device.mk
+++ b/device/rockchip/rk3588/device.mk
@@ -103,3 +103,5 @@ PRODUCT_PROPERTY_OVERRIDES += \
                 ro.build.shutdown_timeout=6 \
                 persist.enable_task_snapshots=false \
                 ro.vendor.frameratelock=true
+
+$(call inherit-product-if-exists, vendor/redroid_ext/device.mk)
\ No newline at end of file
diff --git a/device/rockchip/rk3588/rk3588_docker/BoardConfig.mk b/device/rockchip/rk3588/rk3588_docker/BoardConfig.mk
index a61a45eb03..672979e196 100644
--- a/device/rockchip/rk3588/rk3588_docker/BoardConfig.mk
+++ b/device/rockchip/rk3588/rk3588_docker/BoardConfig.mk
@@ -42,3 +42,5 @@ BOARD_GSENSOR_MXC6655XA_SUPPORT := false
 BOARD_CAMERA_SUPPORT_EXT := false
 BOARD_HS_ETHERNET := true
 BOARD_RECORD_COMMIT_ID := false
+
+include vendor/redroid_ext/BoardConfig.mk
\ No newline at end of file
diff --git a/device/rockchip/space-common/device.mk b/device/rockchip/space-common/device.mk
index 2fadf9f128..567d5355fc 100644
--- a/device/rockchip/space-common/device.mk
+++ b/device/rockchip/space-common/device.mk
@@ -98,3 +98,8 @@ PRODUCT_COPY_FILES += $(PRODUCT_MOCK_CONFIG):system/etc/default_mock.prop
 endif
 
 PRODUCT_LOCALES += en_US af_ZA am_ET ar_EG ar_XB as_IN az_AZ be_BY bg_BG bn_BD bs_BA ca_ES cs_CZ da_DK de_DE el_GR en_AU en_CA en_GB en_IN en_XA es_ES es_US et_EE eu_ES fa_IR fi_FI fr_CA fr_FR gl_ES gu_IN hi_IN hr_HR hu_HU hy_AM in_ID is_IS it_IT iw_IL ja_JP ka_GE kk_KZ km_KH kn_IN ko_KR ky_KG lo_LA lt_LT lv_LV mk_MK ml_IN mn_MN mr_IN ms_MY my_MM nb_NO ne_NP nl_NL or_IN pa_IN pl_PL pt_BR pt_PT ro_RO ru_RU si_LK sk_SK sl_SI sq_AL sr_Latn_RS sr_RS sv_SE sw_TZ ta_IN te_IN th_TH tl_PH tr_TR uk_UA ur_PK uz_UZ vi_VN zh_CN zh_HK zh_TW zu_ZA
+
+# wifi
+PRODUCT_PROPERTY_OVERRIDES += \
+        androidboot.redroid_virtual_wifi=1 \
+        ro.boot.redroid_virtual_wifi=1 
diff --git a/external/wpa_supplicant_8/hostapd/main.c b/external/wpa_supplicant_8/hostapd/main.c
index b9df58442b..fe2c5c7fe3 100644
--- a/external/wpa_supplicant_8/hostapd/main.c
+++ b/external/wpa_supplicant_8/hostapd/main.c
@@ -266,14 +266,17 @@ hostapd_interface_init(struct hapd_interfaces *interfaces, const char *if_name,
 	int k;
 
 	wpa_printf(MSG_ERROR, "Configuration file: %s", config_fname);
+	wpa_printf(MSG_INFO, "------wifi: 11111111111111");
 	iface = hostapd_init(interfaces, config_fname);
 	if (!iface)
 		return NULL;
+	wpa_printf(MSG_INFO, "------wifi: 222222222222222");
 
 	if (if_name) {
 		os_strlcpy(iface->conf->bss[0]->iface, if_name,
 			   sizeof(iface->conf->bss[0]->iface));
 	}
+	wpa_printf(MSG_INFO, "------wifi: 333333333333333");
 
 	iface->interfaces = interfaces;
 
@@ -281,6 +284,7 @@ hostapd_interface_init(struct hapd_interfaces *interfaces, const char *if_name,
 		if (iface->bss[0]->conf->logger_stdout_level > 0)
 			iface->bss[0]->conf->logger_stdout_level--;
 	}
+	wpa_printf(MSG_INFO, "------wifi: 44444444444444");
 
 	if (iface->conf->bss[0]->iface[0] == '\0' &&
 	    !hostapd_drv_none(iface->bss[0])) {
@@ -290,6 +294,7 @@ hostapd_interface_init(struct hapd_interfaces *interfaces, const char *if_name,
 		hostapd_interface_deinit_free(iface);
 		return NULL;
 	}
+	wpa_printf(MSG_INFO, "------wifi: 555555555555");
 
 	return iface;
 }
diff --git a/external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant_conf.mk b/external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant_conf.mk
index 429397627e..d8831eb538 100644
--- a/external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant_conf.mk
+++ b/external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant_conf.mk
@@ -1,34 +1,34 @@
-#
-# Copyright (C) 2010 The Android Open Source Project
-#
-# This software may be distributed under the terms of the BSD license.
-# See README for more details.
-#
+# #
+# # Copyright (C) 2010 The Android Open Source Project
+# #
+# # This software may be distributed under the terms of the BSD license.
+# # See README for more details.
+# #
 
-# Include this makefile to generate your hardware specific wpa_supplicant.conf
-# Requires: WIFI_DRIVER_SOCKET_IFACE
+# # Include this makefile to generate your hardware specific wpa_supplicant.conf
+# # Requires: WIFI_DRIVER_SOCKET_IFACE
 
-LOCAL_PATH := $(call my-dir)
+# LOCAL_PATH := $(call my-dir)
 
-########################
-include $(CLEAR_VARS)
+# ########################
+# include $(CLEAR_VARS)
 
-LOCAL_MODULE := wpa_supplicant.conf
-LOCAL_MODULE_CLASS := ETC
-LOCAL_MODULE_TAGS := optional
-LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/wifi
+# LOCAL_MODULE := wpa_supplicant.conf
+# LOCAL_MODULE_CLASS := ETC
+# LOCAL_MODULE_TAGS := optional
+# LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/wifi
 
-include $(BUILD_SYSTEM)/base_rules.mk
+# include $(BUILD_SYSTEM)/base_rules.mk
 
-WPA_SUPPLICANT_CONF_TEMPLATE := $(LOCAL_PATH)/wpa_supplicant_template.conf
-WPA_SUPPLICANT_CONF_SCRIPT := $(LOCAL_PATH)/wpa_supplicant_conf.sh
-$(LOCAL_BUILT_MODULE): PRIVATE_WIFI_DRIVER_SOCKET_IFACE := $(WIFI_DRIVER_SOCKET_IFACE)
-$(LOCAL_BUILT_MODULE): PRIVATE_WPA_SUPPLICANT_CONF_TEMPLATE := $(WPA_SUPPLICANT_CONF_TEMPLATE)
-$(LOCAL_BUILT_MODULE): PRIVATE_WPA_SUPPLICANT_CONF_SCRIPT := $(WPA_SUPPLICANT_CONF_SCRIPT)
-$(LOCAL_BUILT_MODULE) : $(WPA_SUPPLICANT_CONF_TEMPLATE) $(WPA_SUPPLICANT_CONF_SCRIPT)
-	@echo Target wpa_supplicant.conf: $@
-	@mkdir -p $(dir $@)
-	$(hide) WIFI_DRIVER_SOCKET_IFACE="$(PRIVATE_WIFI_DRIVER_SOCKET_IFACE)" \
-		bash $(PRIVATE_WPA_SUPPLICANT_CONF_SCRIPT) $(PRIVATE_WPA_SUPPLICANT_CONF_TEMPLATE) > $@
+# WPA_SUPPLICANT_CONF_TEMPLATE := $(LOCAL_PATH)/wpa_supplicant_template.conf
+# WPA_SUPPLICANT_CONF_SCRIPT := $(LOCAL_PATH)/wpa_supplicant_conf.sh
+# $(LOCAL_BUILT_MODULE): PRIVATE_WIFI_DRIVER_SOCKET_IFACE := $(WIFI_DRIVER_SOCKET_IFACE)
+# $(LOCAL_BUILT_MODULE): PRIVATE_WPA_SUPPLICANT_CONF_TEMPLATE := $(WPA_SUPPLICANT_CONF_TEMPLATE)
+# $(LOCAL_BUILT_MODULE): PRIVATE_WPA_SUPPLICANT_CONF_SCRIPT := $(WPA_SUPPLICANT_CONF_SCRIPT)
+# $(LOCAL_BUILT_MODULE) : $(WPA_SUPPLICANT_CONF_TEMPLATE) $(WPA_SUPPLICANT_CONF_SCRIPT)
+# 	@echo Target wpa_supplicant.conf: $@
+# 	@mkdir -p $(dir $@)
+# 	$(hide) WIFI_DRIVER_SOCKET_IFACE="$(PRIVATE_WIFI_DRIVER_SOCKET_IFACE)" \
+# 		bash $(PRIVATE_WPA_SUPPLICANT_CONF_SCRIPT) $(PRIVATE_WPA_SUPPLICANT_CONF_TEMPLATE) > $@
 
-########################
+# ########################
diff --git a/vendor/redroid_ext/Android.mk b/vendor/redroid_ext/Android.mk
new file mode 100644
index 0000000000..640ddfc5c0
--- /dev/null
+++ b/vendor/redroid_ext/Android.mk
@@ -0,0 +1,4 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/vendor/redroid_ext/BoardConfig.mk b/vendor/redroid_ext/BoardConfig.mk
new file mode 100644
index 0000000000..0ad6ea137c
--- /dev/null
+++ b/vendor/redroid_ext/BoardConfig.mk
@@ -0,0 +1,15 @@
+
+
+
+######################
+# wifi相关配置
+######################
+BOARD_WLAN_DEVICE           := emulator
+BOARD_HOSTAPD_DRIVER        := NL80211
+BOARD_WPA_SUPPLICANT_DRIVER := NL80211
+BOARD_HOSTAPD_PRIVATE_LIB   := lib_driver_cmd_simulated
+BOARD_WPA_SUPPLICANT_PRIVATE_LIB := lib_driver_cmd_simulated
+WPA_SUPPLICANT_VERSION      := VER_0_8_X
+WIFI_DRIVER_FW_PATH_PARAM   := "/dev/null"
+WIFI_DRIVER_FW_PATH_STA     := "/dev/null"
+WIFI_DRIVER_FW_PATH_AP      := "/dev/null"
diff --git a/vendor/redroid_ext/device.mk b/vendor/redroid_ext/device.mk
new file mode 100644
index 0000000000..f7eaab6a23
--- /dev/null
+++ b/vendor/redroid_ext/device.mk
@@ -0,0 +1,46 @@
+include vendor/redroid_ext/BoardConfig.mk
+
+######################
+# common config
+######################
+PRODUCT_BROKEN_VERIFY_USES_LIBRARIES := true
+
+PRODUCT_COPY_FILES += \
+    vendor/redroid_ext/redroid.ext.rc:$(TARGET_COPY_OUT_VENDOR)/etc/init/redroid.ext.rc \
+
+######################
+# wifi config
+######################
+PRODUCT_SOONG_NAMESPACES += \
+    device/generic/goldfish \
+
+PRODUCT_PACKAGES += \
+    iw_vendor \
+    dhcpclient2 \
+    dhcpserver2 \
+
+PRODUCT_PACKAGES += \
+    create_radios2 \
+    createns2 \
+    execns2 \
+    ipv6proxy2 \
+    hostapd \
+    hostapd_nohidl \
+    wpa_supplicant \
+
+PRODUCT_COPY_FILES += \
+    $(LOCAL_PATH)/wifi/init.redroid.wifi.sh:$(TARGET_COPY_OUT_VENDOR)/bin/hw/init.redroid.wifi.sh \
+    $(LOCAL_PATH)/wifi/hostapd.conf:$(TARGET_COPY_OUT_VENDOR)/etc/hostapd.conf \
+    $(LOCAL_PATH)/wifi/wpa_supplicant.conf:$(TARGET_COPY_OUT_VENDOR)/etc/wifi/wpa_supplicant.conf \
+    frameworks/native/data/etc/android.hardware.wifi.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.wifi.xml \
+    frameworks/native/data/etc/android.hardware.wifi.passpoint.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.wifi.passpoint.xml \
+    frameworks/native/data/etc/android.hardware.wifi.direct.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.wifi.direct.xml \
+
+
+
+
+
+
+
+
+
diff --git a/vendor/redroid_ext/redroid.ext.rc b/vendor/redroid_ext/redroid.ext.rc
new file mode 100644
index 0000000000..acfc960906
--- /dev/null
+++ b/vendor/redroid_ext/redroid.ext.rc
@@ -0,0 +1,74 @@
+
+
+######################
+# for wifi
+######################
+on post-fs-data
+    setprop vold.post_fs_data_done 1
+    mkdir /data/vendor/var 0755 root root
+    mkdir /data/vendor/var/run 0755 root root
+    mkdir /data/vendor/var/run/netns 0755 root root
+    write /data/vendor/var/run/netns/main.pid 1
+
+    setprop wifi.interface wlan0
+    setprop wifi.direct.interface p2p-dev-wlan0
+
+    setprop net.eth0.dns3 8.8.8.8
+    setprop net.eth0.dns4 8.8.4.4
+
+on zygote-start
+    # Create the directories used by the Wireless subsystem
+    mkdir /data/vendor/wifi 0771 wifi wifi
+    mkdir /data/vendor/wifi/wpa 0770 wifi wifi
+    mkdir /data/vendor/wifi/wpa/sockets 0770 wifi wifi
+    mkdir /data/vendor/wifi/hostapd 0770 wifi wifi
+
+on post-fs-data && property:ro.boot.redroid_virtual_wifi=1
+    rm /data/vendor/var/run/netns/router.pid
+    start create_router_ns
+    wait /data/vendor/var/run/netns/router.pid
+    start redroid_wifi
+
+service redroid_wifi /vendor/bin/hw/init.redroid.wifi.sh
+    class late_start
+    user root
+    group root wakelock wifi
+    oneshot
+    disabled    # Started on post-fs-data
+
+service ipv6proxy /vendor/bin/execns2 router /vendor/bin/ipv6proxy2 -o eth0 -i br0,radio0-peer
+    user root
+    group root
+    disabled
+
+service emu_hostapd /vendor/bin/execns2 router /vendor/bin/hostapd_nohidl /data/vendor/wifi/hostapd/redroid_hostapd.conf
+    user root
+    group root wifi net_raw net_admin
+    disabled
+
+service dhcpserver /vendor/bin/execns2 router /vendor/bin/dhcpserver2 --exclude-interface eth0
+    user root
+    group root
+    disabled
+
+service create_router_ns /vendor/bin/createns2 router
+    user root
+    group root
+    disabled
+    oneshot
+
+service wpa_supplicant /vendor/bin/hw/wpa_supplicant -Dnl80211 -iwlan0 -c/vendor/etc/wifi/wpa_supplicant.conf -g@android:wpa_wlan0
+    interface android.hardware.wifi.supplicant@1.0::ISupplicant default
+    interface android.hardware.wifi.supplicant@1.1::ISupplicant default
+    interface android.hardware.wifi.supplicant@1.2::ISupplicant default
+    interface android.hardware.wifi.supplicant@1.3::ISupplicant default
+    socket wpa_wlan0 dgram 660 wifi wifi
+    group system wifi inet
+    oneshot
+    disabled
+
+service adbd_proxy /vendor/bin/execns2 router nc -L -p 5555 /vendor/bin/execns2 main nc 127.0.0.1 5555
+    user root
+    group root
+    disabled
+    oneshot
\ No newline at end of file
diff --git a/vendor/redroid_ext/wifi/Android.mk b/vendor/redroid_ext/wifi/Android.mk
new file mode 100644
index 0000000000..45d3dd5ebe
--- /dev/null
+++ b/vendor/redroid_ext/wifi/Android.mk
@@ -0,0 +1,6 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+include $(call all-makefiles-under,$(LOCAL_PATH))
+
+include device/generic/goldfish/wifi/Android.mk
diff --git a/vendor/redroid_ext/wifi/README.md b/vendor/redroid_ext/wifi/README.md
new file mode 100644
index 0000000000..ef23c134a5
--- /dev/null
+++ b/vendor/redroid_ext/wifi/README.md
@@ -0,0 +1,12 @@
+# 准备工作
+
+宿主机需要开启mac80211_hwsim内核模块
+```
+CONFIG_MAC80211_HWSIM=y
+```
+
+宿主机需切换到iptables-legacy，然后重启
+```
+update-alternatives --set iptables /usr/sbin/iptables-legacy
+update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy
+```
diff --git a/vendor/redroid_ext/wifi/createns/Android.bp b/vendor/redroid_ext/wifi/createns/Android.bp
new file mode 100644
index 0000000000..10e474d601
--- /dev/null
+++ b/vendor/redroid_ext/wifi/createns/Android.bp
@@ -0,0 +1,37 @@
+// Copyright (C) 2020 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// package {
+//     // See: http://go/android-license-faq
+//     // A large-scale-change added 'default_applicable_licenses' to import
+//     // all of the 'license_kinds' from "device_generic_goldfish_license"
+//     // to get the below license kinds:
+//     //   SPDX-license-identifier-Apache-2.0
+//     default_applicable_licenses: ["device_generic_goldfish_license"],
+// }
+
+cc_binary {
+    name: "createns2",
+    srcs: ["createns.cpp"],
+    cflags: [
+        "-Wall",
+        "-Wextra",
+        "-Werror",
+    ],
+    shared_libs: [
+        "libcutils",
+        "liblog",
+    ],
+    proprietary: true,
+}
diff --git a/vendor/redroid_ext/wifi/createns/createns.cpp b/vendor/redroid_ext/wifi/createns/createns.cpp
new file mode 100644
index 0000000000..73e2c63edf
--- /dev/null
+++ b/vendor/redroid_ext/wifi/createns/createns.cpp
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "createns"
+#include <log/log.h>
+
+#include <cutils/properties.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <sched.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <limits>
+#include <string>
+#include <vector>
+
+static const char kNamespacePath[] = "/data/vendor/var/run/netns/";
+static const char kProcNsNet[] = "/proc/self/ns/net";
+
+class Fd {
+public:
+    explicit Fd(int fd) : mFd(fd) { }
+    Fd(const Fd&) = delete;
+    ~Fd() {
+        if (mFd != -1) {
+            ::close(mFd);
+            mFd = -1;
+        }
+    }
+
+    int get() const { return mFd; }
+    Fd& operator=(const Fd&) = delete;
+private:
+    int mFd;
+};
+
+static void usage(const char* program) {
+    ALOGE("%s <namespace>", program);
+}
+
+static bool removeFile(const char* file) {
+    if (::unlink(file) == -1) {
+        ALOGE("Failed to unlink file '%s': %s", file, strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+static std::string getNamespacePath(const char* name) {
+    size_t len = strlen(name);
+    if (len == 0) {
+        ALOGE("Must provide a namespace argument that is not empty");
+        return std::string();
+    }
+
+    if (std::numeric_limits<size_t>::max() - sizeof(kNamespacePath) < len) {
+        // The argument is so big the resulting string can't fit in size_t
+        ALOGE("Namespace argument too long");
+        return std::string();
+    }
+
+    std::vector<char> nsPath(sizeof(kNamespacePath) + len);
+    size_t totalSize = strlcpy(nsPath.data(), kNamespacePath, nsPath.size());
+    if (totalSize >= nsPath.size()) {
+        // The resulting string had to be concatenated to fit, this is a logic
+        // error in the code above that determines the size of the data.
+        ALOGE("Could not create namespace path");
+        return std::string();
+    }
+    totalSize = strlcat(nsPath.data(), name, nsPath.size());
+    if (totalSize >= nsPath.size()) {
+        // The resulting string had to be concatenated to fit, this is a logic
+        // error in the code above that determines the size of the data.
+        ALOGE("Could not append to namespace path");
+        return std::string();
+    }
+    return nsPath.data();
+}
+
+static bool writeNamespacePid(const char* name, pid_t pid) {
+    std::string path = getNamespacePath(name);
+    if (path.empty()) {
+        return false;
+    }
+    path += ".pid";
+
+    Fd fd(::open(path.c_str(),
+                 O_CREAT | O_TRUNC | O_WRONLY | O_CLOEXEC,
+                 S_IRUSR | S_IWUSR | S_IRGRP));
+    if (fd.get() == -1) {
+        ALOGE("Unable to create file '%s': %s", path.c_str(), strerror(errno));
+        return false;
+    }
+
+    // In order to safely print a pid_t we use int64_t with a known format
+    // specifier. Ensure that a pid_t will fit in a pid_t. According to POSIX
+    // pid_t is signed.
+    static_assert(sizeof(pid_t) <= sizeof(int64_t),
+                  "pid_t is larger than int64_t");
+    char pidString[32];
+    int printed = snprintf(pidString,
+                           sizeof(pidString),
+                           "%" PRId64,
+                           static_cast<int64_t>(pid));
+    if (printed <= 0) {
+        ALOGE("Unabled to created PID string for writing");
+        removeFile(path.c_str());
+        return false;
+    }
+
+    const char* toPrint = pidString;
+    int remaining = printed;
+    for (;;) {
+        int result = ::write(fd.get(), toPrint, remaining);
+        if (result < 0) {
+            if (errno == EINTR) {
+                continue;
+            }
+            ALOGE("Unable to write pid to file %s: %s",
+                  path.c_str(), strerror(errno));
+            removeFile(path.c_str());
+            return false;
+        } else if (result < printed) {
+            remaining -= result;
+            toPrint += result;
+        } else {
+            break;
+        }
+    }
+    return true;
+}
+
+int main(int argc, char* argv[]) {
+    if (argc != 2) {
+        usage(argv[0]);
+        return 1;
+    }
+    if (::unshare(CLONE_NEWNET) != 0) {
+        ALOGE("Failed to create network namespace '%s': %s",
+              argv[1],
+              strerror(errno));
+        return 1;
+    }
+
+    std::string path = getNamespacePath(argv[1]);
+    if (path.empty()) {
+        return 1;
+    }
+    {
+        // Open and then immediately close the fd
+        Fd fd(::open(path.c_str(), O_CREAT|O_RDONLY, S_IRUSR | S_IRGRP));
+        if (fd.get() == -1) {
+            ALOGE("Failed to open file %s: %s", path.c_str(), strerror(errno));
+            return 1;
+        }
+    }
+    if (::mount(kProcNsNet, path.c_str(), nullptr, MS_BIND, nullptr) != 0) {
+        ALOGE("Failed to bind %s to %s: %s",
+              kProcNsNet,
+              path.c_str(),
+              strerror(errno));
+        // Clean up on failure
+        removeFile(path.c_str());
+        return 1;
+    }
+
+    if (!writeNamespacePid(argv[1], ::getpid())) {
+        return 1;
+    }
+    property_set("vendor.qemu.networknamespace", "ready");
+
+    for (;;) {
+        pause();
+    }
+
+    return 0;
+}
+
diff --git a/vendor/redroid_ext/wifi/dhcp/Android.mk b/vendor/redroid_ext/wifi/dhcp/Android.mk
new file mode 100644
index 0000000000..fb00329c15
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/Android.mk
@@ -0,0 +1,20 @@
+#
+# Copyright 2017 The Android Open-Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/vendor/redroid_ext/wifi/dhcp/client/Android.bp b/vendor/redroid_ext/wifi/dhcp/client/Android.bp
new file mode 100644
index 0000000000..a664f559ae
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/Android.bp
@@ -0,0 +1,41 @@
+// Copyright (C) 2020 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// package {
+//     // See: http://go/android-license-faq
+//     // A large-scale-change added 'default_applicable_licenses' to import
+//     // all of the 'license_kinds' from "device_generic_goldfish_license"
+//     // to get the below license kinds:
+//     //   SPDX-license-identifier-Apache-2.0
+//     default_applicable_licenses: ["device_generic_goldfish_license"],
+// }
+
+cc_binary {
+    name: "dhcpclient2",
+    srcs: [
+        "dhcpclient.cpp",
+        "interface.cpp",
+        "main.cpp",
+        "router.cpp",
+        "timer.cpp",
+    ],
+    shared_libs: [
+        "libcutils",
+        "liblog",
+    ],
+    static_libs: [
+        "libdhcpclient2",
+    ],
+    proprietary: true,
+}
diff --git a/vendor/redroid_ext/wifi/dhcp/client/dhcpclient.cpp b/vendor/redroid_ext/wifi/dhcp/client/dhcpclient.cpp
new file mode 100644
index 0000000000..7404fad463
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/dhcpclient.cpp
@@ -0,0 +1,546 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dhcpclient.h"
+#include "dhcp.h"
+#include "interface.h"
+#include "log.h"
+
+#include <arpa/inet.h>
+#include <errno.h>
+#include <linux/if_ether.h>
+#include <poll.h>
+#include <unistd.h>
+
+#include <cutils/properties.h>
+
+#include <inttypes.h>
+
+// The initial retry timeout for DHCP is 4000 milliseconds
+static const uint32_t kInitialTimeout = 4000;
+// The maximum retry timeout for DHCP is 64000 milliseconds
+static const uint32_t kMaxTimeout = 64000;
+// A specific value that indicates that no timeout should happen and that
+// the state machine should immediately transition to the next state
+static const uint32_t kNoTimeout = 0;
+
+// Enable debug messages
+static const bool kDebug = false;
+
+// The number of milliseconds that the timeout should vary (up or down) from the
+// base timeout. DHCP requires a -1 to +1 second variation in timeouts.
+static const int kTimeoutSpan = 1000;
+
+static std::string addrToStr(in_addr_t address) {
+    struct in_addr addr = { address };
+    char buffer[64];
+    return inet_ntop(AF_INET, &addr, buffer, sizeof(buffer));
+}
+
+DhcpClient::DhcpClient(uint32_t options)
+    : mOptions(options),
+      mRandomEngine(std::random_device()()),
+      mRandomDistribution(-kTimeoutSpan, kTimeoutSpan),
+      mState(State::Init),
+      mNextTimeout(kInitialTimeout),
+      mFuzzNextTimeout(true) {
+}
+
+Result DhcpClient::init(const char* interfaceName) {
+    Result res = mInterface.init(interfaceName);
+    if (!res) {
+        return res;
+    }
+
+    res = mRouter.init();
+    if (!res) {
+        return res;
+    }
+
+    res = mSocket.open(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));
+    if (!res) {
+        return res;
+    }
+
+    res = mSocket.bindRaw(mInterface.getIndex());
+    if (!res) {
+        return res;
+    }
+    return Result::success();
+}
+
+Result DhcpClient::run() {
+    // Block all signals while we're running. This way we don't have to deal
+    // with things like EINTR. waitAndReceive then uses ppoll to set the
+    // original mask while polling. This way polling can be interrupted but
+    // socket writing, reading and ioctl remain interrupt free. If a signal
+    // arrives while we're blocking it it will be placed in the signal queue
+    // and handled once ppoll sets the original mask. This way no signals are
+    // lost.
+    sigset_t blockMask, originalMask;
+    int status = ::sigfillset(&blockMask);
+    if (status != 0) {
+        return Result::error("Unable to fill signal set: %s", strerror(errno));
+    }
+    status = ::sigprocmask(SIG_SETMASK, &blockMask, &originalMask);
+    if (status != 0) {
+        return Result::error("Unable to set signal mask: %s", strerror(errno));
+    }
+
+    for (;;) {
+        // Before waiting, polling or receiving we check the current state and
+        // see what we should do next. This may result in polling but could
+        // also lead to instant state changes without any polling. The new state
+        // will then be evaluated instead, most likely leading to polling.
+        switch (mState) {
+            case State::Init:
+                // The starting state. This is the state the client is in when
+                // it first starts. It's also the state that the client returns
+                // to when things go wrong in other states.
+                setNextState(State::Selecting);
+                break;
+            case State::Selecting:
+                // In the selecting state the client attempts to find DHCP
+                // servers on the network. The client remains in this state
+                // until a suitable server responds.
+                sendDhcpDiscover();
+                increaseTimeout();
+                break;
+            case State::Requesting:
+                // In the requesting state the client has found a suitable
+                // server. The next step is to send a request directly to that
+                // server.
+                if (mNextTimeout >= kMaxTimeout) {
+                    // We've tried to request a bunch of times, start over
+                    setNextState(State::Init);
+                } else {
+                    sendDhcpRequest(mServerAddress);
+                    increaseTimeout();
+                }
+                break;
+            case State::Bound:
+                // The client enters the bound state when the server has
+                // accepted and acknowledged a request and given us a lease. At
+                // this point the client will wait until the lease is close to
+                // expiring and then it will try to renew the lease.
+                if (mT1.expired()) {
+                    // Lease expired, renew lease
+                    setNextState(State::Renewing);
+                } else {
+                    // Spurious wake-up, continue waiting. Do not fuzz the
+                    // timeout with a random offset. Doing so can cause wakeups
+                    // before the timer has expired causing unnecessary
+                    // processing. Even worse it can cause the timer to expire
+                    // after the lease has ended.
+                    mNextTimeout = mT1.remainingMillis();
+                    mFuzzNextTimeout = false;
+                }
+                break;
+            case State::Renewing:
+                // In the renewing state the client is sending a request for the
+                // same address it had was previously bound to. If the second
+                // timer expires when in this state the client will attempt to
+                // do a full rebind.
+                if (mT2.expired()) {
+                    // Timeout while renewing, move to rebinding
+                    setNextState(State::Rebinding);
+                } else {
+                    sendDhcpRequest(mServerAddress);
+                    increaseTimeout();
+                }
+                break;
+            case State::Rebinding:
+                // The client was unable to renew the lease and moved to the
+                // rebinding state. In this state the client sends a request for
+                // the same address it had before to the broadcast address. This
+                // means that any DHCP server on the network is free to respond.
+                // After attempting this a few times the client will give up and
+                // move to the Init state to try to find a new DHCP server.
+                if (mNextTimeout >= kMaxTimeout) {
+                    // We've tried to rebind a bunch of times, start over
+                    setNextState(State::Init);
+                } else {
+                    // Broadcast a request
+                    sendDhcpRequest(INADDR_BROADCAST);
+                    increaseTimeout();
+                }
+                break;
+            default:
+                break;
+        }
+        // The proper action for the current state has been taken, perform any
+        // polling and/or waiting needed.
+        waitAndReceive(originalMask);
+    }
+
+    return Result::error("Client terminated unexpectedly");
+}
+
+const char* DhcpClient::stateToStr(State state) {
+    switch (state) {
+        case State::Init:
+            return "Init";
+        case State::Selecting:
+            return "Selecting";
+        case State::Requesting:
+            return "Requesting";
+        case State::Bound:
+            return "Bound";
+        case State::Renewing:
+            return "Renewing";
+        case State::Rebinding:
+            return "Rebinding";
+    }
+    return "<unknown>";
+}
+
+void DhcpClient::waitAndReceive(const sigset_t& pollSignalMask) {
+    if (mNextTimeout == kNoTimeout) {
+        // If there is no timeout the state machine has indicated that it wants
+        // an immediate transition to another state. Do nothing.
+        return;
+    }
+
+    struct pollfd fds;
+    fds.fd = mSocket.get();
+    fds.events = POLLIN;
+
+    uint32_t timeout = calculateTimeoutMillis();
+    for (;;) {
+        uint64_t startedAt = now();
+
+        struct timespec ts;
+        ts.tv_sec = timeout / 1000;
+        ts.tv_nsec = (timeout - ts.tv_sec * 1000) * 1000000;
+
+        // Poll for any incoming traffic with the calculated timeout. While
+        // polling the original signal mask is set so that the polling can be
+        // interrupted.
+        int res = ::ppoll(&fds, 1, &ts, &pollSignalMask);
+        if (res == 0) {
+            // Timeout, return to let the caller evaluate
+            return;
+        } else if (res > 0) {
+            // Something to read
+            Message msg;
+            if (receiveDhcpMessage(&msg)) {
+                // We received a DHCP message, check if it's of interest
+                uint8_t msgType = msg.type();
+                switch (mState) {
+                    case State::Selecting:
+                        if (msgType == DHCPOFFER) {
+                            // Received an offer, move to the Requesting state
+                            // to request it.
+                            mServerAddress = msg.serverId();
+                            mRequestAddress = msg.dhcpData.yiaddr;
+                            setNextState(State::Requesting);
+                            return;
+                        }
+                        break;
+                    case State::Requesting:
+                    case State::Renewing:
+                    case State::Rebinding:
+                        // All of these states have sent a DHCP request and are
+                        // now waiting for an ACK so the behavior is the same.
+                        if (msgType == DHCPACK) {
+                            // Request approved
+                            if (configureDhcp(msg)) {
+                                // Successfully configured DHCP, move to Bound
+                                setNextState(State::Bound);
+                                return;
+                            }
+                            // Unable to configure DHCP, keep sending requests.
+                            // This may not fix the issue but eventually it will
+                            // allow for a full timeout which will lead to a
+                            // move to the Init state. This might still not fix
+                            // the issue but at least the client keeps trying.
+                        } else if (msgType == DHCPNAK) {
+                            // Request denied, halt network and start over
+                            haltNetwork();
+                            setNextState(State::Init);
+                            return;
+                        } 
+                        break;
+                    default:
+                        // For the other states the client is not expecting any
+                        // network messages so we ignore those messages.
+                        break;
+                }
+            }
+        } else {
+            // An error occurred in polling, don't do anything here. The client
+            // should keep going anyway to try to acquire a lease in the future
+            // if things start working again.
+        }
+        // If we reach this point we received something that's not a DHCP,
+        // message, we timed out, or an error occurred. Go again with whatever
+        // time remains.
+        uint64_t currentTime = now();
+        uint64_t end = startedAt + timeout;
+        if (currentTime >= end) {
+            // We're done anyway, return and let caller evaluate
+            return;
+        }
+        // Wait whatever the remaining time is
+        timeout = end - currentTime;
+    }
+}
+
+bool DhcpClient::configureDhcp(const Message& msg) {
+    size_t optsSize = msg.optionsSize();
+    if (optsSize < 4) {
+        // Message is too small
+        if (kDebug) ALOGD("Opts size too small %d", static_cast<int>(optsSize));
+        return false;
+    }
+
+    const uint8_t* options = msg.dhcpData.options;
+
+    memset(&mDhcpInfo, 0, sizeof(mDhcpInfo));
+
+    // Inspect all options in the message to try to find the ones we want
+    for (size_t i = 4; i + 1 < optsSize; ) {
+        uint8_t optCode = options[i];
+        uint8_t optLength = options[i + 1];
+        if (optCode == OPT_END) {
+            break;
+        }
+
+        if (options + optLength + i >= msg.end()) {
+            // Invalid option length, drop it
+            if (kDebug) ALOGD("Invalid opt length %d for opt %d",
+                              static_cast<int>(optLength),
+                              static_cast<int>(optCode));
+            return false;
+        }
+        const uint8_t* opt = options + i + 2;
+        switch (optCode) {
+            case OPT_LEASE_TIME:
+                if (optLength == 4) {
+                    mDhcpInfo.leaseTime =
+                        ntohl(*reinterpret_cast<const uint32_t*>(opt));
+                }
+                break;
+            case OPT_T1:
+                if (optLength == 4) {
+                    mDhcpInfo.t1 =
+                        ntohl(*reinterpret_cast<const uint32_t*>(opt));
+                }
+                break;
+            case OPT_T2:
+                if (optLength == 4) {
+                    mDhcpInfo.t2 =
+                        ntohl(*reinterpret_cast<const uint32_t*>(opt));
+                }
+                break;
+            case OPT_SUBNET_MASK:
+                if (optLength == 4) {
+                    mDhcpInfo.subnetMask =
+                        *reinterpret_cast<const in_addr_t*>(opt);
+                }
+                break;
+            case OPT_GATEWAY:
+                if (optLength >= 4) {
+                    mDhcpInfo.gateway =
+                        *reinterpret_cast<const in_addr_t*>(opt);
+                }
+                break;
+            case OPT_MTU:
+                if (optLength == 2) {
+                    mDhcpInfo.mtu =
+                        ntohs(*reinterpret_cast<const uint16_t*>(opt));
+                }
+                break;
+            case OPT_DNS:
+                if (optLength >= 4) {
+                    mDhcpInfo.dns[0] =
+                        *reinterpret_cast<const in_addr_t*>(opt);
+                }
+                if (optLength >= 8) {
+                    mDhcpInfo.dns[1] =
+                        *reinterpret_cast<const in_addr_t*>(opt + 4);
+                }
+                if (optLength >= 12) {
+                    mDhcpInfo.dns[2] =
+                        *reinterpret_cast<const in_addr_t*>(opt + 8);
+                }
+                if (optLength >= 16) {
+                    mDhcpInfo.dns[3] =
+                        *reinterpret_cast<const in_addr_t*>(opt + 12);
+                }
+                break;
+            case OPT_SERVER_ID:
+                if (optLength == 4) {
+                    mDhcpInfo.serverId =
+                        *reinterpret_cast<const in_addr_t*>(opt);
+                }
+                break;
+            default:
+                break;
+        }
+        i += 2 + optLength;
+    }
+    mDhcpInfo.offeredAddress = msg.dhcpData.yiaddr;
+
+    if (mDhcpInfo.leaseTime == 0) {
+        // We didn't get a lease time, ignore this offer
+        return false;
+    }
+    // If there is no T1 or T2 timer given then we create an estimate as
+    // suggested for servers in RFC 2131.
+    uint32_t t1 = mDhcpInfo.t1, t2 = mDhcpInfo.t2;
+    mT1.expireSeconds(t1 > 0 ? t1 : (mDhcpInfo.leaseTime / 2));
+    mT2.expireSeconds(t2 > 0 ? t2 : ((mDhcpInfo.leaseTime * 7) / 8));
+
+    Result res = mInterface.bringUp();
+    if (!res) {
+        ALOGE("Could not configure DHCP: %s", res.c_str());
+        return false;
+    }
+
+    if (mDhcpInfo.mtu != 0) {
+        res = mInterface.setMtu(mDhcpInfo.mtu);
+        if (!res) {
+            // Consider this non-fatal, the system will not perform at its best
+            // but should still work.
+            ALOGE("Could not configure DHCP: %s", res.c_str());
+        }
+    }
+
+    char propName[64];
+    snprintf(propName, sizeof(propName), "vendor.net.%s.gw",
+             mInterface.getName().c_str());
+    if (property_set(propName, addrToStr(mDhcpInfo.gateway).c_str()) != 0) {
+        ALOGE("Failed to set %s: %s", propName, strerror(errno));
+    }
+
+    int numDnsEntries = sizeof(mDhcpInfo.dns) / sizeof(mDhcpInfo.dns[0]);
+    for (int i = 0; i < numDnsEntries; ++i) {
+        snprintf(propName, sizeof(propName), "vendor.net.%s.dns%d",
+                 mInterface.getName().c_str(), i + 1);
+        if (mDhcpInfo.dns[i] != 0) {
+            if (property_set(propName,
+                             addrToStr(mDhcpInfo.dns[i]).c_str()) != 0) {
+                ALOGE("Failed to set %s: %s", propName, strerror(errno));
+            }
+        } else {
+            // Clear out any previous value here in case it was set
+            if (property_set(propName, "") != 0) {
+                ALOGE("Failed to clear %s: %s", propName, strerror(errno));
+            }
+        }
+    }
+
+    res = mInterface.setAddress(mDhcpInfo.offeredAddress,
+                                mDhcpInfo.subnetMask);
+    if (!res) {
+        ALOGE("Could not configure DHCP: %s", res.c_str());
+        return false;
+    }
+
+    if ((mOptions & static_cast<uint32_t>(ClientOption::NoGateway)) == 0) {
+        res = mRouter.setDefaultGateway(mDhcpInfo.gateway,
+                                        mInterface.getIndex());
+        if (!res) {
+            ALOGE("Could not configure DHCP: %s", res.c_str());
+            return false;
+        }
+    }
+    return true;
+}
+
+void DhcpClient::haltNetwork() {
+    Result res = mInterface.setAddress(0, 0);
+    if (!res) {
+        ALOGE("Could not halt network: %s", res.c_str());
+    }
+    res = mInterface.bringDown();
+    if (!res) {
+        ALOGE("Could not halt network: %s", res.c_str());
+    }
+}
+
+bool DhcpClient::receiveDhcpMessage(Message* msg) {
+    bool isValid = false;
+    Result res = mSocket.receiveRawUdp(PORT_BOOTP_CLIENT, msg, &isValid);
+    if (!res) {
+        if (kDebug) ALOGD("Discarding message: %s", res.c_str());
+        return false;
+    }
+
+    return isValid &&
+           msg->isValidDhcpMessage(OP_BOOTREPLY, mLastMsg.dhcpData.xid);
+}
+
+uint32_t DhcpClient::calculateTimeoutMillis() {
+    if (!mFuzzNextTimeout) {
+        return mNextTimeout;
+    }
+    int adjustment = mRandomDistribution(mRandomEngine);
+    if (adjustment < 0 && static_cast<uint32_t>(-adjustment) > mNextTimeout) {
+        // Underflow, return a timeout of zero milliseconds
+        return 0;
+    }
+    return mNextTimeout + adjustment;
+}
+
+void DhcpClient::increaseTimeout() {
+    if (mNextTimeout == kNoTimeout) {
+        mNextTimeout = kInitialTimeout;
+    } else {
+        if (mNextTimeout < kMaxTimeout) {
+            mNextTimeout *= 2;
+        }
+        if (mNextTimeout > kMaxTimeout) {
+            mNextTimeout = kMaxTimeout;
+        }
+    }
+}
+
+void DhcpClient::setNextState(State state) {
+    if (kDebug) ALOGD("Moving from state %s to %s",
+                      stateToStr(mState), stateToStr(state));
+    mState = state;
+    mNextTimeout = kNoTimeout;
+    mFuzzNextTimeout = true;
+}
+
+void DhcpClient::sendDhcpRequest(in_addr_t destination) {
+    if (kDebug) ALOGD("Sending DHCPREQUEST");
+    mLastMsg = Message::request(mInterface.getMacAddress(),
+                                mRequestAddress,
+                                destination);
+    sendMessage(mLastMsg);
+}
+
+void DhcpClient::sendDhcpDiscover() {
+    if (kDebug) ALOGD("Sending DHCPDISCOVER");
+    mLastMsg = Message::discover(mInterface.getMacAddress());
+    sendMessage(mLastMsg);
+}
+
+void DhcpClient::sendMessage(const Message& message) {
+    Result res = mSocket.sendRawUdp(INADDR_ANY,
+                                    PORT_BOOTP_CLIENT,
+                                    INADDR_BROADCAST,
+                                    PORT_BOOTP_SERVER,
+                                    mInterface.getIndex(),
+                                    message);
+    if (!res) {
+        ALOGE("Unable to send message: %s", res.c_str());
+    }
+}
+
diff --git a/vendor/redroid_ext/wifi/dhcp/client/dhcpclient.h b/vendor/redroid_ext/wifi/dhcp/client/dhcpclient.h
new file mode 100644
index 0000000000..128d416f0a
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/dhcpclient.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "interface.h"
+#include "message.h"
+#include "result.h"
+#include "router.h"
+#include "socket.h"
+#include "timer.h"
+
+#include <netinet/in.h>
+#include <stdint.h>
+
+#include <random>
+
+// Options to configure the behavior of the DHCP client.
+enum class ClientOption : uint32_t {
+    NoGateway = (1 << 0),   // Do not configure the system's default gateway
+};
+
+class DhcpClient {
+public:
+    // Create a DHCP client with the given |options|. These options are values
+    // from the ClientOption enum.
+    explicit DhcpClient(uint32_t options);
+
+    // Initialize the DHCP client to listen on |interfaceName|.
+    Result init(const char* interfaceName);
+    Result run();
+private:
+    enum class State {
+        Init,
+        Selecting,
+        Requesting,
+        Bound,
+        Renewing,
+        Rebinding
+    };
+    const char* stateToStr(State state);
+
+    // Wait for any pending timeouts
+    void waitAndReceive(const sigset_t& pollSignalMask);
+    // Create a varying timeout (+- 1 second) based on the next timeout.
+    uint32_t calculateTimeoutMillis();
+    // Increase the next timeout in a manner that's compliant with the DHCP RFC.
+    void increaseTimeout();
+    // Move to |state|, the next poll timeout will be zero and the new
+    // state will be immediately evaluated.
+    void setNextState(State state);
+    // Configure network interface based on the DHCP configuration in |msg|.
+    bool configureDhcp(const Message& msg);
+    // Halt network operations on the network interface for when configuration
+    // is not possible and the protocol demands it.
+    void haltNetwork();
+    // Receive a message on the socket and populate |msg| with the received
+    // data. If the message is a valid DHCP message the method returns true. If
+    // it's not valid false is returned.
+    bool receiveDhcpMessage(Message* msg);
+
+    void sendDhcpDiscover();
+    void sendDhcpRequest(in_addr_t destination);
+    void sendMessage(const Message& message);
+    Result send(in_addr_t source, in_addr_t destination,
+                uint16_t sourcePort, uint16_t destinationPort,
+                const uint8_t* data, size_t size);
+
+    uint32_t mOptions;
+    std::mt19937 mRandomEngine; // Mersenne Twister RNG
+    std::uniform_int_distribution<int> mRandomDistribution;
+
+    struct DhcpInfo {
+        uint32_t t1;
+        uint32_t t2;
+        uint32_t leaseTime;
+        uint16_t mtu;
+        in_addr_t dns[4];
+        in_addr_t gateway;
+        in_addr_t subnetMask;
+        in_addr_t serverId;
+        in_addr_t offeredAddress;
+    } mDhcpInfo;
+
+    Router mRouter;
+    Interface mInterface;
+    Message mLastMsg;
+    Timer mT1, mT2;
+    Socket mSocket;
+    State mState;
+    uint32_t mNextTimeout;
+    bool mFuzzNextTimeout;
+
+    in_addr_t mRequestAddress; // Address we'd like to use in requests
+    in_addr_t mServerAddress;  // Server to send request to
+};
+
diff --git a/vendor/redroid_ext/wifi/dhcp/client/interface.cpp b/vendor/redroid_ext/wifi/dhcp/client/interface.cpp
new file mode 100644
index 0000000000..a13af0843d
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/interface.cpp
@@ -0,0 +1,230 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "interface.h"
+
+#include "netlink.h"
+
+#include <errno.h>
+#include <linux/if.h>
+#include <linux/if_ether.h>
+#include <linux/route.h>
+#include <linux/rtnetlink.h>
+#include <string.h>
+#include <unistd.h>
+
+in_addr_t broadcastFromNetmask(in_addr_t address, in_addr_t netmask) {
+    // The broadcast address is the address with the bits excluded in the
+    // netmask set to 1. For example if address = 10.0.2.15 and netmask is
+    // 255.255.255.0 then the broadcast is 10.0.2.255. If instead netmask was
+    // 255.0.0.0.0 then the broadcast would be 10.255.255.255
+    //
+    // Simply set all the lower bits to 1 and that should do it.
+    return address | (~netmask);
+}
+
+Interface::Interface() : mSocketFd(-1) {
+}
+
+Interface::~Interface() {
+    if (mSocketFd != -1) {
+        close(mSocketFd);
+        mSocketFd = -1;
+    }
+}
+
+Result Interface::init(const char* interfaceName) {
+    mInterfaceName = interfaceName;
+
+    if (mSocketFd != -1) {
+        return Result::error("Interface initialized more than once");
+    }
+
+    mSocketFd = ::socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);
+    if (mSocketFd == -1) {
+        return Result::error("Failed to create interface socket for '%s': %s",
+                             interfaceName, strerror(errno));
+    }
+
+    Result res = populateIndex();
+    if (!res) {
+        return res;
+    }
+
+    res = populateMacAddress();
+    if (!res) {
+        return res;
+    }
+
+    res = bringUp();
+    if (!res) {
+        return res;
+    }
+
+    res = setAddress(0, 0);
+    if (!res) {
+        return res;
+    }
+
+    return Result::success();
+}
+
+Result Interface::bringUp() {
+    return setInterfaceUp(true);
+}
+
+Result Interface::bringDown() {
+    return setInterfaceUp(false);
+}
+
+Result Interface::setMtu(uint16_t mtu) {
+    struct ifreq request = createRequest();
+
+    strncpy(request.ifr_name, mInterfaceName.c_str(), sizeof(request.ifr_name));
+    request.ifr_mtu = mtu;
+    int status = ::ioctl(mSocketFd, SIOCSIFMTU, &request);
+    if (status != 0) {
+        return Result::error("Failed to set interface MTU %u for '%s': %s",
+                             static_cast<unsigned int>(mtu),
+                             mInterfaceName.c_str(),
+                             strerror(errno));
+    }
+
+    return Result::success();
+}
+
+Result Interface::setAddress(in_addr_t address, in_addr_t subnetMask) {
+    struct Request {
+        struct nlmsghdr hdr;
+        struct ifaddrmsg msg;
+        char buf[256];
+    } request;
+
+    memset(&request, 0, sizeof(request));
+
+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(request.msg));
+    request.hdr.nlmsg_type = RTM_NEWADDR;
+    request.hdr.nlmsg_flags = NLM_F_REQUEST |
+                              NLM_F_ACK |
+                              NLM_F_CREATE |
+                              NLM_F_REPLACE;
+
+    request.msg.ifa_family = AF_INET;
+    // Count the number of bits in the subnet mask, this is the length.
+    request.msg.ifa_prefixlen = __builtin_popcount(subnetMask);
+    request.msg.ifa_index = mIndex;
+
+    addRouterAttribute(request, IFA_ADDRESS, &address, sizeof(address));
+    addRouterAttribute(request, IFA_LOCAL, &address, sizeof(address));
+    in_addr_t broadcast = broadcastFromNetmask(address, subnetMask);
+    addRouterAttribute(request, IFA_BROADCAST, &broadcast, sizeof(broadcast));
+
+    struct sockaddr_nl nlAddr;
+    memset(&nlAddr, 0, sizeof(nlAddr));
+    nlAddr.nl_family = AF_NETLINK;
+
+    int status = ::sendto(mSocketFd, &request, request.hdr.nlmsg_len, 0,
+                          reinterpret_cast<sockaddr*>(&nlAddr),
+                          sizeof(nlAddr));
+    if (status == -1) {
+        return Result::error("Unable to set interface address: %s",
+                             strerror(errno));
+    }
+    char buffer[8192];
+    status = ::recv(mSocketFd, buffer, sizeof(buffer), 0);
+    if (status < 0) {
+        return Result::error("Unable to read netlink response: %s",
+                             strerror(errno));
+    }
+    size_t responseSize = static_cast<size_t>(status);
+    if (responseSize < sizeof(nlmsghdr)) {
+        return Result::error("Received incomplete response from netlink");
+    }
+    auto response = reinterpret_cast<const nlmsghdr*>(buffer);
+    if (response->nlmsg_type == NLMSG_ERROR) {
+        if (responseSize < NLMSG_HDRLEN + sizeof(nlmsgerr)) {
+            return Result::error("Recieved an error from netlink but the "
+                                 "response was incomplete");
+        }
+        auto err = reinterpret_cast<const nlmsgerr*>(NLMSG_DATA(response));
+        if (err->error) {
+            return Result::error("Could not set interface address: %s",
+                                 strerror(-err->error));
+        }
+    }
+    return Result::success();
+}
+
+struct ifreq Interface::createRequest() const {
+    struct ifreq request;
+    memset(&request, 0, sizeof(request));
+    strncpy(request.ifr_name, mInterfaceName.c_str(), sizeof(request.ifr_name));
+    request.ifr_name[sizeof(request.ifr_name) - 1] = '\0';
+
+    return request;
+}
+
+Result Interface::populateIndex() {
+    struct ifreq request = createRequest();
+
+    int status = ::ioctl(mSocketFd, SIOCGIFINDEX, &request);
+    if (status != 0) {
+        return Result::error("Failed to get interface index for '%s': %s",
+                             mInterfaceName.c_str(), strerror(errno));
+    }
+    mIndex = request.ifr_ifindex;
+    return Result::success();
+}
+
+Result Interface::populateMacAddress() {
+    struct ifreq request = createRequest();
+
+    int status = ::ioctl(mSocketFd, SIOCGIFHWADDR, &request);
+    if (status != 0) {
+        return Result::error("Failed to get MAC address for '%s': %s",
+                             mInterfaceName.c_str(), strerror(errno));
+    }
+    memcpy(mMacAddress, &request.ifr_hwaddr.sa_data, ETH_ALEN);
+    return Result::success();
+}
+
+Result Interface::setInterfaceUp(bool shouldBeUp) {
+    struct ifreq request = createRequest();
+
+    int status = ::ioctl(mSocketFd, SIOCGIFFLAGS, &request);
+    if (status != 0) {
+        return Result::error("Failed to get interface flags for '%s': %s",
+                             mInterfaceName.c_str(), strerror(errno));
+    }
+
+    bool isUp = (request.ifr_flags & IFF_UP) != 0;
+    if (isUp != shouldBeUp) {
+        // Toggle the up flag
+        request.ifr_flags ^= IFF_UP;
+    } else {
+        // Interface is already in desired state, do nothing
+        return Result::success();
+    }
+
+    status = ::ioctl(mSocketFd, SIOCSIFFLAGS, &request);
+    if (status != 0) {
+        return Result::error("Failed to set interface flags for '%s': %s",
+                             mInterfaceName.c_str(), strerror(errno));
+    }
+
+    return Result::success();
+}
+
diff --git a/vendor/redroid_ext/wifi/dhcp/client/interface.h b/vendor/redroid_ext/wifi/dhcp/client/interface.h
new file mode 100644
index 0000000000..ca9e9e5a0e
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/interface.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "result.h"
+
+#include <linux/if_ether.h>
+#include <netinet/in.h>
+
+#include <string>
+
+// A class representing a network interface. The class provides useful
+// functionality to configure and query the network interface.
+class Interface {
+public:
+    Interface();
+    ~Interface();
+    Result init(const char* interfaceName);
+
+    // Returns the interface index indicated by the system
+    unsigned int getIndex() const { return mIndex; }
+    // Get the MAC address of the interface
+    const uint8_t (&getMacAddress() const)[ETH_ALEN] { return mMacAddress; }
+    // Get the name of the interface
+    const std::string& getName() const { return mInterfaceName; }
+
+    Result bringUp();
+    Result bringDown();
+    Result setMtu(uint16_t mtu);
+    Result setAddress(in_addr_t address, in_addr_t subnetMask);
+
+private:
+    struct ifreq createRequest() const;
+    Result populateIndex();
+    Result populateMacAddress();
+    Result setInterfaceUp(bool shouldBeUp);
+
+    std::string mInterfaceName;
+    int mSocketFd;
+    unsigned int mIndex;
+    uint8_t mMacAddress[ETH_ALEN];
+};
+
diff --git a/vendor/redroid_ext/wifi/dhcp/client/log.h b/vendor/redroid_ext/wifi/dhcp/client/log.h
new file mode 100644
index 0000000000..bf141df77b
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/log.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#define LOG_TAG "dhcpclient"
+#include <log/log.h>
+
diff --git a/vendor/redroid_ext/wifi/dhcp/client/main.cpp b/vendor/redroid_ext/wifi/dhcp/client/main.cpp
new file mode 100644
index 0000000000..70b854f4f3
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/main.cpp
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dhcpclient.h"
+#include "log.h"
+
+static void usage(const char* program) {
+    ALOGE("Usage: %s [--no-gateway] -i <interface>", program);
+    ALOGE("  If the optional parameter --no-gateway is specified the client");
+    ALOGE("  will not configure the default gateway of the system.");
+}
+
+int main(int argc, char* argv[]) {
+    if (argc < 3) {
+        usage(argv[0]);
+        return 1;
+    }
+    const char* interfaceName = nullptr;
+    uint32_t options = 0;
+
+    for (int i = 1; i < argc; ++i) {
+        if (strcmp(argv[i], "-i") == 0) {
+            if (i + 1 < argc) {
+                interfaceName = argv[++i];
+            } else {
+                ALOGE("ERROR: -i parameter needs an argument");
+                usage(argv[0]);
+                return 1;
+            }
+        } else if (strcmp(argv[i], "--no-gateway") == 0) {
+            options |= static_cast<uint32_t>(ClientOption::NoGateway);
+        } else {
+            ALOGE("ERROR: unknown parameters %s", argv[i]);
+            usage(argv[0]);
+            return 1;
+        }
+    }
+    if (interfaceName == nullptr) {
+        ALOGE("ERROR: No interface specified");
+        usage(argv[0]);
+        return 1;
+    }
+
+    DhcpClient client(options);
+    Result res = client.init(interfaceName);
+    if (!res) {
+        ALOGE("Failed to initialize DHCP client: %s\n", res.c_str());
+        return 1;
+    }
+
+    res = client.run();
+    if (!res) {
+        ALOGE("DHCP client failed: %s\n", res.c_str());
+        return 1;
+    }
+    // This is weird and shouldn't happen, the client should run forever.
+    return 0;
+}
+
diff --git a/vendor/redroid_ext/wifi/dhcp/client/netlink.h b/vendor/redroid_ext/wifi/dhcp/client/netlink.h
new file mode 100644
index 0000000000..e0c916f344
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/netlink.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include <linux/rtnetlink.h>
+
+template<class Request>
+inline void addRouterAttribute(Request& r,
+                               int type,
+                               const void* data,
+                               size_t size) {
+    // Calculate the offset into the character buffer where the RTA data lives
+    // We use offsetof on the buffer to get it. This avoids undefined behavior
+    // by casting the buffer (which is safe because it's char) instead of the
+    // Request struct.(which is undefined because of aliasing)
+    size_t offset = NLMSG_ALIGN(r.hdr.nlmsg_len) - offsetof(Request, buf);
+    auto attr = reinterpret_cast<struct rtattr*>(r.buf + offset);
+    attr->rta_type = type;
+    attr->rta_len = RTA_LENGTH(size);
+    memcpy(RTA_DATA(attr), data, size);
+
+    // Update the message length to include the router attribute.
+    r.hdr.nlmsg_len = NLMSG_ALIGN(r.hdr.nlmsg_len) + RTA_ALIGN(attr->rta_len);
+}
diff --git a/vendor/redroid_ext/wifi/dhcp/client/router.cpp b/vendor/redroid_ext/wifi/dhcp/client/router.cpp
new file mode 100644
index 0000000000..7c87e2d9e8
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/router.cpp
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "router.h"
+
+#include "netlink.h"
+
+#include <linux/rtnetlink.h>
+
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+
+Router::Router() : mSocketFd(-1) {
+}
+
+Router::~Router() {
+    if (mSocketFd != -1) {
+        ::close(mSocketFd);
+        mSocketFd = -1;
+    }
+}
+
+Result Router::init() {
+    // Create a netlink socket to the router
+    mSocketFd = ::socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+    if (mSocketFd == -1) {
+        return Result::error(strerror(errno));
+    }
+    return Result::success();
+}
+
+Result Router::setDefaultGateway(in_addr_t gateway, unsigned int ifaceIndex) {
+    struct Request {
+        struct nlmsghdr hdr;
+        struct rtmsg msg;
+        char buf[256];
+    } request;
+
+    memset(&request, 0, sizeof(request));
+
+    // Set up a request to create a new route
+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(request.msg));
+    request.hdr.nlmsg_type = RTM_NEWROUTE;
+    request.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
+
+    request.msg.rtm_family = AF_INET;
+    request.msg.rtm_dst_len = 0;
+    request.msg.rtm_table = RT_TABLE_MAIN;
+    request.msg.rtm_protocol = RTPROT_BOOT;
+    request.msg.rtm_scope = RT_SCOPE_UNIVERSE;
+    request.msg.rtm_type = RTN_UNICAST;
+
+    addRouterAttribute(request, RTA_GATEWAY, &gateway, sizeof(gateway));
+    addRouterAttribute(request, RTA_OIF, &ifaceIndex, sizeof(ifaceIndex));
+
+    return sendNetlinkMessage(&request, request.hdr.nlmsg_len);
+}
+
+Result Router::sendNetlinkMessage(const void* data, size_t size) {
+    struct sockaddr_nl nlAddress;
+    memset(&nlAddress, 0, sizeof(nlAddress));
+    nlAddress.nl_family = AF_NETLINK;
+
+    int res = ::sendto(mSocketFd, data, size, 0,
+                       reinterpret_cast<sockaddr*>(&nlAddress),
+                       sizeof(nlAddress));
+    if (res == -1) {
+        return Result::error("Unable to send on netlink socket: %s",
+                             strerror(errno));
+    }
+    return Result::success();
+}
+
diff --git a/vendor/redroid_ext/wifi/dhcp/client/router.h b/vendor/redroid_ext/wifi/dhcp/client/router.h
new file mode 100644
index 0000000000..1ab6654091
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/router.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <stdint.h>
+
+#include <netinet/in.h>
+
+#include "result.h"
+
+class Router {
+public:
+    Router();
+    ~Router();
+    // Initialize the router, this has to be called before any other methods can
+    // be called. It only needs to be called once.
+    Result init();
+
+    // Set the default route to |gateway| on the interface specified by
+    // |interfaceIndex|. If the default route is already set up with the same
+    // configuration then nothing is done. If another default route exists it
+    // will be removed and replaced by the new one. If no default route exists
+    // a route will be created with the given parameters.
+    Result setDefaultGateway(in_addr_t gateway, unsigned int interfaceIndex);
+private:
+    Result sendNetlinkMessage(const void* data, size_t size);
+
+    // Netlink socket for setting up neighbors and routes
+    int mSocketFd;
+};
+
diff --git a/vendor/redroid_ext/wifi/dhcp/client/timer.cpp b/vendor/redroid_ext/wifi/dhcp/client/timer.cpp
new file mode 100644
index 0000000000..5f81322492
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/timer.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "timer.h"
+
+#include <time.h>
+
+uint64_t now() {
+    struct timespec time = { 0, 0 };
+    clock_gettime(CLOCK_MONOTONIC, &time);
+    return static_cast<uint64_t>(time.tv_sec) * 1000u +
+           static_cast<uint64_t>(time.tv_nsec / 1000000u);
+}
+
+Timer::Timer() : mExpires(0) {
+}
+
+void Timer::expireSeconds(uint64_t seconds) {
+    mExpires = now() + seconds * 1000u;
+}
+
+bool Timer::expired() const {
+    return now() >= mExpires;
+}
+
+uint64_t Timer::remainingMillis() const {
+    uint64_t current = now();
+    if (current > mExpires) {
+        return 0;
+    }
+    return mExpires - current;
+}
+
diff --git a/vendor/redroid_ext/wifi/dhcp/client/timer.h b/vendor/redroid_ext/wifi/dhcp/client/timer.h
new file mode 100644
index 0000000000..7ae01f9d65
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/client/timer.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <stdint.h>
+
+// Return the current timestamp from a monotonic clock in milliseconds.
+uint64_t now();
+
+class Timer {
+public:
+    // Create a timer, initially the timer is already expired.
+    Timer();
+
+    // Set the timer to expire in |seconds| seconds.
+    void expireSeconds(uint64_t seconds);
+
+    // Return true if the timer has expired.
+    bool expired() const;
+    // Get the remaining time on the timer in milliseconds.
+    uint64_t remainingMillis() const;
+
+private:
+    uint64_t mExpires;
+};
+
diff --git a/vendor/redroid_ext/wifi/dhcp/common/Android.bp b/vendor/redroid_ext/wifi/dhcp/common/Android.bp
new file mode 100644
index 0000000000..a049341fcc
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/common/Android.bp
@@ -0,0 +1,38 @@
+// Copyright (C) 2020 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// package {
+//     // See: http://go/android-license-faq
+//     // A large-scale-change added 'default_applicable_licenses' to import
+//     // all of the 'license_kinds' from "device_generic_goldfish_license"
+//     // to get the below license kinds:
+//     //   SPDX-license-identifier-Apache-2.0
+//     default_applicable_licenses: ["device_generic_goldfish_license"],
+// }
+
+cc_library_static {
+    name: "libdhcpclient2",
+    srcs: [
+        "message.cpp",
+        "socket.cpp",
+        "utils.cpp",
+    ],
+    export_include_dirs: ["include"],
+    cflags: [
+        "-Wall",
+        "-Wextra",
+        "-Werror",
+    ],
+    proprietary: true,
+}
diff --git a/vendor/redroid_ext/wifi/dhcp/common/include/dhcp.h b/vendor/redroid_ext/wifi/dhcp/common/include/dhcp.h
new file mode 100644
index 0000000000..beb388fd76
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/common/include/dhcp.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+// Ports
+#define PORT_BOOTP_SERVER 67
+#define PORT_BOOTP_CLIENT 68
+
+// Operations
+#define OP_BOOTREQUEST 1
+#define OP_BOOTREPLY   2
+
+// Flags
+#define FLAGS_BROADCAST 0x8000
+
+// Hardware address types
+#define HTYPE_ETHER    1
+
+// The first four bytes of options are a cookie to indicate that the payload are
+// DHCP options as opposed to some other BOOTP extension.
+#define OPT_COOKIE1          0x63
+#define OPT_COOKIE2          0x82
+#define OPT_COOKIE3          0x53
+#define OPT_COOKIE4          0x63
+
+// BOOTP/DHCP options - see RFC 2132
+#define OPT_PAD              0
+
+#define OPT_SUBNET_MASK      1     // 4 <ipaddr>
+#define OPT_TIME_OFFSET      2     // 4 <seconds>
+#define OPT_GATEWAY          3     // 4*n <ipaddr> * n
+#define OPT_DNS              6     // 4*n <ipaddr> * n
+#define OPT_DOMAIN_NAME      15    // n <domainnamestring>
+#define OPT_MTU              26    // 2 <mtu>
+#define OPT_BROADCAST_ADDR   28    // 4 <ipaddr>
+
+#define OPT_REQUESTED_IP     50    // 4 <ipaddr>
+#define OPT_LEASE_TIME       51    // 4 <seconds>
+#define OPT_MESSAGE_TYPE     53    // 1 <msgtype>
+#define OPT_SERVER_ID        54    // 4 <ipaddr>
+#define OPT_PARAMETER_LIST   55    // n <optcode> * n
+#define OPT_MESSAGE          56    // n <errorstring>
+#define OPT_T1               58    // 4 <renewal time value>
+#define OPT_T2               59    // 4 <rebinding time value>
+#define OPT_CLASS_ID         60    // n <opaque>
+#define OPT_CLIENT_ID        61    // n <opaque>
+#define OPT_END              255
+
+// DHCP message types
+#define DHCPDISCOVER         1
+#define DHCPOFFER            2
+#define DHCPREQUEST          3
+#define DHCPDECLINE          4
+#define DHCPACK              5
+#define DHCPNAK              6
+#define DHCPRELEASE          7
+#define DHCPINFORM           8
+
+
diff --git a/vendor/redroid_ext/wifi/dhcp/common/include/message.h b/vendor/redroid_ext/wifi/dhcp/common/include/message.h
new file mode 100644
index 0000000000..84029cc06e
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/common/include/message.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <linux/if_ether.h>
+#include <netinet/in.h>
+#include <stddef.h>
+#include <string.h>
+
+#include <initializer_list>
+
+class Message {
+public:
+    Message();
+    Message(const uint8_t* data, size_t size);
+    static Message discover(const uint8_t (&sourceMac)[ETH_ALEN]);
+    static Message request(const uint8_t (&sourceMac)[ETH_ALEN],
+                           in_addr_t requestAddress,
+                           in_addr_t serverAddress);
+    static Message offer(const Message& sourceMessage,
+                         in_addr_t serverAddress,
+                         in_addr_t offeredAddress,
+                         in_addr_t offeredNetmask,
+                         in_addr_t offeredGateway,
+                         const in_addr_t* offeredDnsServers,
+                         size_t numOfferedDnsServers);
+    static Message ack(const Message& sourceMessage,
+                       in_addr_t serverAddress,
+                       in_addr_t offeredAddress,
+                       in_addr_t offeredNetmask,
+                       in_addr_t offeredGateway,
+                       const in_addr_t* offeredDnsServers,
+                       size_t numOfferedDnsServers);
+    static Message nack(const Message& sourceMessage, in_addr_t serverAddress);
+
+    // Ensure that the data in the message represent a valid DHCP message
+    bool isValidDhcpMessage(uint8_t expectedOp) const;
+    // Ensure that the data in the message represent a valid DHCP message and
+    // has a xid (transaction ID) that matches |expectedXid|.
+    bool isValidDhcpMessage(uint8_t expectedOp, uint32_t expectedXid) const;
+
+    const uint8_t* data() const {
+        return reinterpret_cast<const uint8_t*>(&dhcpData);
+    }
+    uint8_t* data() {
+        return reinterpret_cast<uint8_t*>(&dhcpData);
+    }
+    const uint8_t* end() const { return data() + mSize; }
+
+    size_t optionsSize() const;
+    size_t size() const { return mSize; }
+    void setSize(size_t size) { mSize = size; }
+    size_t capacity() const { return sizeof(dhcpData); }
+
+    // Get the DHCP message type
+    uint8_t type() const;
+    // Get the DHCP server ID
+    in_addr_t serverId() const;
+    // Get the requested IP
+    in_addr_t requestedIp() const;
+
+    struct Dhcp {
+        uint8_t op;           /* BOOTREQUEST / BOOTREPLY    */
+        uint8_t htype;        /* hw addr type               */
+        uint8_t hlen;         /* hw addr len                */
+        uint8_t hops;         /* client set to 0            */
+
+        uint32_t xid;         /* transaction id             */
+
+        uint16_t secs;        /* seconds since start of acq */
+        uint16_t flags;
+
+        uint32_t ciaddr;      /* client IP addr             */
+        uint32_t yiaddr;      /* your (client) IP addr      */
+        uint32_t siaddr;      /* ip addr of next server     */
+                              /* (DHCPOFFER and DHCPACK)    */
+        uint32_t giaddr;      /* relay agent IP addr        */
+
+        uint8_t chaddr[16];  /* client hw addr             */
+        char sname[64];      /* asciiz server hostname     */
+        char file[128];      /* asciiz boot file name      */
+
+        uint8_t options[1024];  /* optional parameters        */
+    }  dhcpData;
+private:
+    Message(uint8_t operation,
+            const uint8_t (&macAddress)[ETH_ALEN],
+            uint8_t type);
+
+    void addOption(uint8_t type, const void* data, uint8_t size);
+    template<typename T>
+    void addOption(uint8_t type, T data) {
+        static_assert(sizeof(T) <= 255, "The size of data is too large");
+        addOption(type, &data, sizeof(data));
+    }
+    template<typename T, size_t N>
+    void addOption(uint8_t type, T (&items)[N]) {
+        static_assert(sizeof(T) * N <= 255,
+                      "The size of data is too large");
+        uint8_t* opts = nextOption();
+        *opts++ = type;
+        *opts++ = sizeof(T) * N;
+        for (const T& item : items) {
+            memcpy(opts, &item, sizeof(item));
+            opts += sizeof(item);
+        }
+        updateSize(opts);
+    }
+    void endOptions();
+
+    const uint8_t* getOption(uint8_t optCode, uint8_t* length) const;
+    uint8_t* nextOption();
+    void updateSize(uint8_t* optionsEnd);
+    size_t mSize;
+};
+
+static_assert(offsetof(Message::Dhcp, htype) == sizeof(Message::Dhcp::op),
+              "Invalid packing for DHCP message struct");
diff --git a/vendor/redroid_ext/wifi/dhcp/common/include/result.h b/vendor/redroid_ext/wifi/dhcp/common/include/result.h
new file mode 100644
index 0000000000..5087e14631
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/common/include/result.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <stdio.h>
+#include <stdarg.h>
+
+#include <string>
+
+class Result {
+public:
+    static Result success() {
+        return Result(true);
+    }
+    // Construct a result indicating an error.
+    static Result error(std::string message) {
+        return Result(message);
+    }
+    static Result error(const char* format, ...) {
+        char buffer[1024];
+        va_list args;
+        va_start(args, format);
+        vsnprintf(buffer, sizeof(buffer), format, args);
+        va_end(args);
+        buffer[sizeof(buffer) - 1] = '\0';
+        return Result(std::string(buffer));
+    }
+
+    bool isSuccess() const { return mSuccess; }
+    bool operator!() const { return !mSuccess; }
+
+    const char* c_str() const { return mMessage.c_str(); }
+private:
+    explicit Result(bool success) : mSuccess(success) { }
+    explicit Result(std::string message)
+        : mMessage(message), mSuccess(false) {
+    }
+    std::string mMessage;
+    bool mSuccess;
+};
+
diff --git a/vendor/redroid_ext/wifi/dhcp/common/include/socket.h b/vendor/redroid_ext/wifi/dhcp/common/include/socket.h
new file mode 100644
index 0000000000..0c9483c251
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/common/include/socket.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "result.h"
+
+#include <arpa/inet.h>
+
+class Message;
+
+class Socket {
+public:
+    Socket();
+    Socket(const Socket&) = delete;
+    ~Socket();
+
+    Socket& operator=(const Socket&) = delete;
+
+    int get() const { return mSocketFd; }
+    // Open a socket, |domain|, |type| and |protocol| are as described in the
+    // man pages for socket.
+    Result open(int domain, int type, int protocol);
+    // Bind to a generic |sockaddr| of size |sockaddrLength|
+    Result bind(const void* sockaddr, size_t sockaddrLength);
+    // Bind to an IP |address| and |port|
+    Result bindIp(in_addr_t address, uint16_t port);
+    // Bind a raw socket to the interface with index |interfaceIndex|.
+    Result bindRaw(unsigned int interfaceIndex);
+    // Send data in |message| on an IP socket to
+    // |destinationAddress|:|destinationPort|, the message will egress on the
+    // interface specified by |interfaceIndex|
+    Result sendOnInterface(unsigned int interfaceIndex,
+                           in_addr_t destinationAddress,
+                           uint16_t destinationPort,
+                           const Message& message);
+    // Send |message| as a UDP datagram on a raw socket. The source address of
+    // the message will be |source|:|sourcePort| and the destination will be
+    // |destination|:|destinationPort|. The message will be sent on the
+    // interface indicated by |interfaceIndex|.
+    Result sendRawUdp(in_addr_t source,
+                      uint16_t sourcePort,
+                      in_addr_t destination,
+                      uint16_t destinationPort,
+                      unsigned int interfaceIndex,
+                      const Message& message);
+    // Receive data on the socket and indicate which interface the data was
+    // received on in |interfaceIndex|. The received data is placed in |message|
+    Result receiveFromInterface(Message* message, unsigned int* interfaceIndex);
+    // Receive UDP data on a raw socket. Expect that the protocol in the IP
+    // header is UDP and that the port in the UDP header is |expectedPort|. If
+    // the received data is valid then |isValid| will be set to true, otherwise
+    // false. The validity check includes the expected values as well as basic
+    // size requirements to fit the expected protocol headers.  The method will
+    // only return an error result if the actual receiving fails.
+    Result receiveRawUdp(uint16_t expectedPort,
+                         Message* message,
+                         bool* isValid);
+    // Enable |optionName| on option |level|. These values are the same as used
+    // in setsockopt calls.
+    Result enableOption(int level, int optionName);
+private:
+    int mSocketFd;
+};
+
diff --git a/vendor/redroid_ext/wifi/dhcp/common/include/utils.h b/vendor/redroid_ext/wifi/dhcp/common/include/utils.h
new file mode 100644
index 0000000000..5f4b971fdd
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/common/include/utils.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <arpa/inet.h>
+
+#include <string>
+
+std::string addrToStr(in_addr_t address);
+
diff --git a/vendor/redroid_ext/wifi/dhcp/common/message.cpp b/vendor/redroid_ext/wifi/dhcp/common/message.cpp
new file mode 100644
index 0000000000..64a29384eb
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/common/message.cpp
@@ -0,0 +1,312 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "message.h"
+#include "dhcp.h"
+
+#include <string.h>
+
+#include <vector>
+
+static uint32_t sNextTransactionId = 1;
+
+// The default lease time in seconds
+static const uint32_t kDefaultLeaseTime = 10 * 60;
+
+// The parameters that the client would like to receive from the server
+static const uint8_t kRequestParameters[] = { OPT_SUBNET_MASK,
+                                              OPT_GATEWAY,
+                                              OPT_DNS,
+                                              OPT_BROADCAST_ADDR,
+                                              OPT_LEASE_TIME,
+                                              OPT_T1,
+                                              OPT_T2,
+                                              OPT_MTU };
+
+Message::Message() {
+    memset(&dhcpData, 0, sizeof(dhcpData));
+    mSize = 0;
+}
+
+Message::Message(const uint8_t* data, size_t size) {
+    if (size <= sizeof(dhcpData)) {
+        memcpy(&dhcpData, data, size);
+        mSize = size;
+    } else {
+        memset(&dhcpData, 0, sizeof(dhcpData));
+        mSize = 0;
+    }
+}
+
+Message Message::discover(const uint8_t (&sourceMac)[ETH_ALEN]) {
+    Message message(OP_BOOTREQUEST,
+                    sourceMac,
+                    static_cast<uint8_t>(DHCPDISCOVER));
+
+    message.addOption(OPT_PARAMETER_LIST, kRequestParameters);
+    message.endOptions();
+
+    return message;
+}
+
+Message Message::request(const uint8_t (&sourceMac)[ETH_ALEN],
+                         in_addr_t requestAddress,
+                         in_addr_t serverAddress) {
+
+    Message message(OP_BOOTREQUEST,
+                    sourceMac,
+                    static_cast<uint8_t>(DHCPREQUEST));
+
+    message.addOption(OPT_PARAMETER_LIST, kRequestParameters);
+    message.addOption(OPT_REQUESTED_IP, requestAddress);
+    message.addOption(OPT_SERVER_ID, serverAddress);
+    message.endOptions();
+
+    return message;
+}
+
+Message Message::offer(const Message& sourceMessage,
+                       in_addr_t serverAddress,
+                       in_addr_t offeredAddress,
+                       in_addr_t offeredNetmask,
+                       in_addr_t offeredGateway,
+                       const in_addr_t* offeredDnsServers,
+                       size_t numOfferedDnsServers) {
+
+    uint8_t macAddress[ETH_ALEN];
+    memcpy(macAddress, sourceMessage.dhcpData.chaddr, sizeof(macAddress));
+    Message message(OP_BOOTREPLY, macAddress, static_cast<uint8_t>(DHCPOFFER));
+
+    message.dhcpData.xid = sourceMessage.dhcpData.xid;
+    message.dhcpData.flags = sourceMessage.dhcpData.flags;
+    message.dhcpData.yiaddr = offeredAddress;
+    message.dhcpData.giaddr = sourceMessage.dhcpData.giaddr;
+
+    message.addOption(OPT_SERVER_ID, serverAddress);
+    message.addOption(OPT_LEASE_TIME, kDefaultLeaseTime);
+    message.addOption(OPT_SUBNET_MASK, offeredNetmask);
+    message.addOption(OPT_GATEWAY, offeredGateway);
+    message.addOption(OPT_DNS,
+                      offeredDnsServers,
+                      numOfferedDnsServers * sizeof(in_addr_t));
+
+    message.endOptions();
+
+    return message;
+}
+
+Message Message::ack(const Message& sourceMessage,
+                     in_addr_t serverAddress,
+                     in_addr_t offeredAddress,
+                     in_addr_t offeredNetmask,
+                     in_addr_t offeredGateway,
+                     const in_addr_t* offeredDnsServers,
+                     size_t numOfferedDnsServers) {
+    uint8_t macAddress[ETH_ALEN];
+    memcpy(macAddress, sourceMessage.dhcpData.chaddr, sizeof(macAddress));
+    Message message(OP_BOOTREPLY, macAddress, static_cast<uint8_t>(DHCPACK));
+
+    message.dhcpData.xid = sourceMessage.dhcpData.xid;
+    message.dhcpData.flags = sourceMessage.dhcpData.flags;
+    message.dhcpData.yiaddr = offeredAddress;
+    message.dhcpData.giaddr = sourceMessage.dhcpData.giaddr;
+
+    message.addOption(OPT_SERVER_ID, serverAddress);
+    message.addOption(OPT_LEASE_TIME, kDefaultLeaseTime);
+    message.addOption(OPT_SUBNET_MASK, offeredNetmask);
+    message.addOption(OPT_GATEWAY, offeredGateway);
+    message.addOption(OPT_DNS,
+                      offeredDnsServers,
+                      numOfferedDnsServers * sizeof(in_addr_t));
+
+    message.endOptions();
+
+    return message;
+}
+
+Message Message::nack(const Message& sourceMessage, in_addr_t serverAddress) {
+    uint8_t macAddress[ETH_ALEN];
+    memcpy(macAddress, sourceMessage.dhcpData.chaddr, sizeof(macAddress));
+    Message message(OP_BOOTREPLY, macAddress, static_cast<uint8_t>(DHCPNAK));
+
+    message.dhcpData.xid = sourceMessage.dhcpData.xid;
+    message.dhcpData.flags = sourceMessage.dhcpData.flags;
+    message.dhcpData.giaddr = sourceMessage.dhcpData.giaddr;
+
+    message.addOption(OPT_SERVER_ID, serverAddress);
+    message.endOptions();
+
+    return message;
+}
+
+bool Message::isValidDhcpMessage(uint8_t expectedOp,
+                                 uint32_t expectedXid) const {
+    if (!isValidDhcpMessage(expectedOp)) {
+        return false;
+    }
+    // Only look for message with a matching transaction ID
+    if (dhcpData.xid != expectedXid) {
+        return false;
+    }
+    return true;
+}
+
+bool Message::isValidDhcpMessage(uint8_t expectedOp) const {
+    // Require that there is at least enough options for the DHCP cookie
+    if (dhcpData.options + 4 > end()) {
+        return false;
+    }
+
+    if (dhcpData.op != expectedOp) {
+        return false;
+    }
+    if (dhcpData.htype != HTYPE_ETHER) {
+        return false;
+    }
+    if (dhcpData.hlen != ETH_ALEN) {
+        return false;
+    }
+
+    // Need to have the correct cookie in the options
+    if (dhcpData.options[0] != OPT_COOKIE1) {
+        return false;
+    }
+    if (dhcpData.options[1] != OPT_COOKIE2) {
+        return false;
+    }
+    if (dhcpData.options[2] != OPT_COOKIE3) {
+        return false;
+    }
+    if (dhcpData.options[3] != OPT_COOKIE4) {
+        return false;
+    }
+
+    return true;
+}
+
+size_t Message::optionsSize() const {
+    auto options = reinterpret_cast<const uint8_t*>(&dhcpData.options);
+    const uint8_t* msgEnd = end();
+    if (msgEnd <= options) {
+        return 0;
+    }
+    return msgEnd - options;
+}
+
+uint8_t Message::type() const {
+    uint8_t length = 0;
+    const uint8_t* opt = getOption(OPT_MESSAGE_TYPE, &length);
+    if (opt && length == 1) {
+        return *opt;
+    }
+    return 0;
+}
+
+in_addr_t Message::serverId() const {
+    uint8_t length = 0;
+    const uint8_t* opt = getOption(OPT_SERVER_ID, &length);
+    if (opt && length == 4) {
+        return *reinterpret_cast<const in_addr_t*>(opt);
+    }
+    return 0;
+}
+
+in_addr_t Message::requestedIp() const {
+    uint8_t length = 0;
+    const uint8_t* opt = getOption(OPT_REQUESTED_IP, &length);
+    if (opt && length == 4) {
+        return *reinterpret_cast<const in_addr_t*>(opt);
+    }
+    return 0;
+}
+
+Message::Message(uint8_t operation,
+                 const uint8_t (&macAddress)[ETH_ALEN],
+                 uint8_t type) {
+    memset(&dhcpData, 0, sizeof(dhcpData));
+
+    dhcpData.op = operation;
+    dhcpData.htype = HTYPE_ETHER;
+    dhcpData.hlen = ETH_ALEN;
+    dhcpData.hops = 0;
+
+    dhcpData.flags = htons(FLAGS_BROADCAST);
+
+    dhcpData.xid = htonl(sNextTransactionId++);
+
+    memcpy(dhcpData.chaddr, macAddress, ETH_ALEN);
+
+    uint8_t* opts = dhcpData.options;
+
+    *opts++ = OPT_COOKIE1;
+    *opts++ = OPT_COOKIE2;
+    *opts++ = OPT_COOKIE3;
+    *opts++ = OPT_COOKIE4;
+
+    *opts++ = OPT_MESSAGE_TYPE;
+    *opts++ = 1;
+    *opts++ = type;
+
+    updateSize(opts);
+}
+
+void Message::addOption(uint8_t type, const void* data, uint8_t size) {
+    uint8_t* opts = nextOption();
+
+    *opts++ = type;
+    *opts++ = size;
+    memcpy(opts, data, size);
+    opts += size;
+
+    updateSize(opts);
+}
+
+void Message::endOptions() {
+    uint8_t* opts = nextOption();
+
+    *opts++ = OPT_END;
+
+    updateSize(opts);
+}
+
+const uint8_t* Message::getOption(uint8_t expectedOptCode,
+                                  uint8_t* length) const {
+    size_t optsSize = optionsSize();
+    for (size_t i = 4; i + 2 < optsSize; ) {
+        uint8_t optCode = dhcpData.options[i];
+        uint8_t optLen = dhcpData.options[i + 1];
+        const uint8_t* opt = dhcpData.options + i + 2;
+
+        if (optCode == OPT_END) {
+            return nullptr;
+        }
+        if (optCode == expectedOptCode) {
+            *length = optLen;
+            return opt;
+        }
+        i += 2 + optLen;
+    }
+    return nullptr;
+}
+
+uint8_t* Message::nextOption() {
+    return reinterpret_cast<uint8_t*>(&dhcpData) + size();
+}
+
+void Message::updateSize(uint8_t* optionsEnd) {
+    mSize = optionsEnd - reinterpret_cast<uint8_t*>(&dhcpData);
+}
+
diff --git a/vendor/redroid_ext/wifi/dhcp/common/socket.cpp b/vendor/redroid_ext/wifi/dhcp/common/socket.cpp
new file mode 100644
index 0000000000..8fd7b9f369
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/common/socket.cpp
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "socket.h"
+
+#include "message.h"
+#include "utils.h"
+
+#include <errno.h>
+#include <linux/if_packet.h>
+#include <netinet/ip.h>
+#include <netinet/udp.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <unistd.h>
+
+// Combine the checksum of |buffer| with |size| bytes with |checksum|. This is
+// used for checksum calculations for IP and UDP.
+static uint32_t addChecksum(const uint8_t* buffer,
+                            size_t size,
+                            uint32_t checksum) {
+    const uint16_t* data = reinterpret_cast<const uint16_t*>(buffer);
+    while (size > 1) {
+        checksum += *data++;
+        size -= 2;
+    }
+    if (size > 0) {
+        // Odd size, add the last byte
+        checksum += *reinterpret_cast<const uint8_t*>(data);
+    }
+    // msw is the most significant word, the upper 16 bits of the checksum
+    for (uint32_t msw = checksum >> 16; msw != 0; msw = checksum >> 16) {
+        checksum = (checksum & 0xFFFF) + msw;
+    }
+    return checksum;
+}
+
+// Convenienct template function for checksum calculation
+template<typename T>
+static uint32_t addChecksum(const T& data, uint32_t checksum) {
+    return addChecksum(reinterpret_cast<const uint8_t*>(&data), sizeof(T), checksum);
+}
+
+// Finalize the IP or UDP |checksum| by inverting and truncating it.
+static uint32_t finishChecksum(uint32_t checksum) {
+    return ~checksum & 0xFFFF;
+}
+
+Socket::Socket() : mSocketFd(-1) {
+}
+
+Socket::~Socket() {
+    if (mSocketFd != -1) {
+        ::close(mSocketFd);
+        mSocketFd = -1;
+    }
+}
+
+
+Result Socket::open(int domain, int type, int protocol) {
+    if (mSocketFd != -1) {
+        return Result::error("Socket already open");
+    }
+    mSocketFd = ::socket(domain, type, protocol);
+    if (mSocketFd == -1) {
+        return Result::error("Failed to open socket: %s", strerror(errno));
+    }
+    return Result::success();
+}
+
+Result Socket::bind(const void* sockaddr, size_t sockaddrLength) {
+    if (mSocketFd == -1) {
+        return Result::error("Socket not open");
+    }
+
+    int status = ::bind(mSocketFd,
+                        reinterpret_cast<const struct sockaddr*>(sockaddr),
+                        sockaddrLength);
+    if (status != 0) {
+        return Result::error("Unable to bind raw socket: %s", strerror(errno));
+    }
+
+    return Result::success();
+}
+
+Result Socket::bindIp(in_addr_t address, uint16_t port) {
+    struct sockaddr_in sockaddr;
+    memset(&sockaddr, 0, sizeof(sockaddr));
+    sockaddr.sin_family = AF_INET;
+    sockaddr.sin_port = htons(port);
+    sockaddr.sin_addr.s_addr = address;
+
+    return bind(&sockaddr, sizeof(sockaddr));
+}
+
+Result Socket::bindRaw(unsigned int interfaceIndex) {
+    struct sockaddr_ll sockaddr;
+    memset(&sockaddr, 0, sizeof(sockaddr));
+    sockaddr.sll_family = AF_PACKET;
+    sockaddr.sll_protocol = htons(ETH_P_IP);
+    sockaddr.sll_ifindex = interfaceIndex;
+
+    return bind(&sockaddr, sizeof(sockaddr));
+}
+
+Result Socket::sendOnInterface(unsigned int interfaceIndex,
+                               in_addr_t destinationAddress,
+                               uint16_t destinationPort,
+                               const Message& message) {
+    if (mSocketFd == -1) {
+        return Result::error("Socket not open");
+    }
+
+    char controlData[CMSG_SPACE(sizeof(struct in_pktinfo))] = { 0 };
+    struct sockaddr_in addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(destinationPort);
+    addr.sin_addr.s_addr = destinationAddress;
+
+    struct msghdr header;
+    memset(&header, 0, sizeof(header));
+    struct iovec iov;
+    // The struct member is non-const since it's used for receiving but it's
+    // safe to cast away const for sending.
+    iov.iov_base = const_cast<uint8_t*>(message.data());
+    iov.iov_len = message.size();
+    header.msg_name = &addr;
+    header.msg_namelen = sizeof(addr);
+    header.msg_iov = &iov;
+    header.msg_iovlen = 1;
+    header.msg_control = &controlData;
+    header.msg_controllen = sizeof(controlData);
+
+    struct cmsghdr* controlHeader = CMSG_FIRSTHDR(&header);
+    controlHeader->cmsg_level = IPPROTO_IP;
+    controlHeader->cmsg_type = IP_PKTINFO;
+    controlHeader->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
+    auto packetInfo =
+        reinterpret_cast<struct in_pktinfo*>(CMSG_DATA(controlHeader));
+    memset(packetInfo, 0, sizeof(*packetInfo));
+    packetInfo->ipi_ifindex = interfaceIndex;
+
+    ssize_t status = ::sendmsg(mSocketFd, &header, 0);
+    if (status <= 0) {
+        return Result::error("Failed to send packet: %s", strerror(errno));
+    }
+    return Result::success();
+}
+
+Result Socket::sendRawUdp(in_addr_t source,
+                          uint16_t sourcePort,
+                          in_addr_t destination,
+                          uint16_t destinationPort,
+                          unsigned int interfaceIndex,
+                          const Message& message) {
+    struct iphdr ip;
+    struct udphdr udp;
+
+    ip.version = IPVERSION;
+    ip.ihl = sizeof(ip) >> 2;
+    ip.tos = 0;
+    ip.tot_len = htons(sizeof(ip) + sizeof(udp) + message.size());
+    ip.id = 0;
+    ip.frag_off = 0;
+    ip.ttl = IPDEFTTL;
+    ip.protocol = IPPROTO_UDP;
+    ip.check = 0;
+    ip.saddr = source;
+    ip.daddr = destination;
+    ip.check = finishChecksum(addChecksum(ip, 0));
+
+    udp.source = htons(sourcePort);
+    udp.dest = htons(destinationPort);
+    udp.len = htons(sizeof(udp) + message.size());
+    udp.check = 0;
+
+    uint32_t udpChecksum = 0;
+    udpChecksum = addChecksum(ip.saddr, udpChecksum);
+    udpChecksum = addChecksum(ip.daddr, udpChecksum);
+    udpChecksum = addChecksum(htons(IPPROTO_UDP), udpChecksum);
+    udpChecksum = addChecksum(udp.len, udpChecksum);
+    udpChecksum = addChecksum(udp, udpChecksum);
+    udpChecksum = addChecksum(message.data(), message.size(), udpChecksum);
+    udp.check = finishChecksum(udpChecksum);
+
+    struct iovec iov[3];
+
+    iov[0].iov_base = static_cast<void*>(&ip);
+    iov[0].iov_len = sizeof(ip);
+    iov[1].iov_base = static_cast<void*>(&udp);
+    iov[1].iov_len = sizeof(udp);
+    // sendmsg requires these to be non-const but for sending won't modify them
+    iov[2].iov_base = static_cast<void*>(const_cast<uint8_t*>(message.data()));
+    iov[2].iov_len = message.size();
+
+    struct sockaddr_ll dest;
+    memset(&dest, 0, sizeof(dest));
+    dest.sll_family = AF_PACKET;
+    dest.sll_protocol = htons(ETH_P_IP);
+    dest.sll_ifindex = interfaceIndex;
+    dest.sll_halen = ETH_ALEN;
+    memset(dest.sll_addr, 0xFF, ETH_ALEN);
+
+    struct msghdr header;
+    memset(&header, 0, sizeof(header));
+    header.msg_name = &dest;
+    header.msg_namelen = sizeof(dest);
+    header.msg_iov = iov;
+    header.msg_iovlen = sizeof(iov) / sizeof(iov[0]);
+
+    ssize_t res = ::sendmsg(mSocketFd, &header, 0);
+    if (res == -1) {
+        return Result::error("Failed to send message: %s", strerror(errno));
+    }
+    return Result::success();
+}
+
+Result Socket::receiveFromInterface(Message* message,
+                                    unsigned int* interfaceIndex) {
+    char controlData[CMSG_SPACE(sizeof(struct in_pktinfo))];
+    struct msghdr header;
+    memset(&header, 0, sizeof(header));
+    struct iovec iov;
+    iov.iov_base = message->data();
+    iov.iov_len = message->capacity();
+    header.msg_iov = &iov;
+    header.msg_iovlen = 1;
+    header.msg_control = &controlData;
+    header.msg_controllen = sizeof(controlData);
+
+    ssize_t bytesRead = ::recvmsg(mSocketFd, &header, 0);
+    if (bytesRead < 0) {
+        return Result::error("Error receiving on socket: %s", strerror(errno));
+    }
+    message->setSize(static_cast<size_t>(bytesRead));
+    if (header.msg_controllen >= sizeof(struct cmsghdr)) {
+        for (struct cmsghdr* ctrl = CMSG_FIRSTHDR(&header);
+             ctrl;
+             ctrl = CMSG_NXTHDR(&header, ctrl)) {
+            if (ctrl->cmsg_level == SOL_IP &&
+                ctrl->cmsg_type == IP_PKTINFO) {
+                auto packetInfo =
+                    reinterpret_cast<struct in_pktinfo*>(CMSG_DATA(ctrl));
+                *interfaceIndex = packetInfo->ipi_ifindex;
+            }
+        }
+    }
+    return Result::success();
+}
+
+Result Socket::receiveRawUdp(uint16_t expectedPort,
+                             Message* message,
+                             bool* isValid) {
+    struct iphdr ip;
+    struct udphdr udp;
+
+    struct iovec iov[3];
+    iov[0].iov_base = &ip;
+    iov[0].iov_len = sizeof(ip);
+    iov[1].iov_base = &udp;
+    iov[1].iov_len = sizeof(udp);
+    iov[2].iov_base = message->data();
+    iov[2].iov_len = message->capacity();
+
+    ssize_t bytesRead = ::readv(mSocketFd, iov, 3);
+    if (bytesRead < 0) {
+        return Result::error("Unable to read from socket: %s", strerror(errno));
+    }
+    if (static_cast<size_t>(bytesRead) < sizeof(ip) + sizeof(udp)) {
+        // Not enough bytes to even cover IP and UDP headers
+        *isValid = false;
+        return Result::success();
+    }
+    *isValid = ip.version == IPVERSION &&
+               ip.ihl == (sizeof(ip) >> 2) &&
+               ip.protocol == IPPROTO_UDP &&
+               udp.dest == htons(expectedPort);
+
+    message->setSize(bytesRead - sizeof(ip) - sizeof(udp));
+    return Result::success();
+}
+
+Result Socket::enableOption(int level, int optionName) {
+    if (mSocketFd == -1) {
+        return Result::error("Socket not open");
+    }
+
+    int enabled = 1;
+    int status = ::setsockopt(mSocketFd,
+                              level,
+                              optionName,
+                              &enabled,
+                              sizeof(enabled));
+    if (status == -1) {
+        return Result::error("Failed to set socket option: %s",
+                             strerror(errno));
+    }
+    return Result::success();
+}
diff --git a/vendor/redroid_ext/wifi/dhcp/common/utils.cpp b/vendor/redroid_ext/wifi/dhcp/common/utils.cpp
new file mode 100644
index 0000000000..e4a37f326e
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/common/utils.cpp
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "utils.h"
+
+std::string addrToStr(in_addr_t address) {
+    char buffer[INET_ADDRSTRLEN];
+    if (::inet_ntop(AF_INET, &address, buffer, sizeof(buffer)) == nullptr) {
+        return "[unknown]";
+    }
+    return buffer;
+}
+
diff --git a/vendor/redroid_ext/wifi/dhcp/server/Android.mk b/vendor/redroid_ext/wifi/dhcp/server/Android.mk
new file mode 100644
index 0000000000..804a65c41d
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/server/Android.mk
@@ -0,0 +1,22 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	dhcpserver.cpp \
+	main.cpp \
+	../common/message.cpp \
+	../common/socket.cpp \
+	../common/utils.cpp \
+
+
+LOCAL_CPPFLAGS += -Werror
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/../common/include
+LOCAL_SHARED_LIBRARIES := libcutils liblog
+LOCAL_PROPRIETARY_MODULE := true
+LOCAL_MODULE := dhcpserver2
+
+LOCAL_MODULE_CLASS := EXECUTABLES
+
+include $(BUILD_EXECUTABLE)
+
diff --git a/vendor/redroid_ext/wifi/dhcp/server/dhcpserver.cpp b/vendor/redroid_ext/wifi/dhcp/server/dhcpserver.cpp
new file mode 100644
index 0000000000..d6d4a7ba42
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/server/dhcpserver.cpp
@@ -0,0 +1,390 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dhcpserver.h"
+
+#include "dhcp.h"
+#include "log.h"
+#include "message.h"
+
+#include <arpa/inet.h>
+#include <errno.h>
+#include <linux/sockios.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <poll.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+
+#include <cutils/properties.h>
+
+static const int kMaxDnsServers = 4;
+
+DhcpServer::DhcpServer(unsigned int excludeInterface) :
+    mExcludeInterface(excludeInterface)
+{
+}
+
+Result DhcpServer::init() {
+    Result res = mSocket.open(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    if (!res) {
+        return res;
+    }
+    res = mSocket.enableOption(SOL_IP, IP_PKTINFO);
+    if (!res) {
+        return res;
+    }
+    res = mSocket.enableOption(SOL_SOCKET, SO_BROADCAST);
+    if (!res) {
+        return res;
+    }
+
+    res = mSocket.bindIp(INADDR_ANY, PORT_BOOTP_SERVER);
+    if (!res) {
+        return res;
+    }
+
+    return Result::success();
+}
+
+Result DhcpServer::run() {
+    // Block all signals while we're running. This way we don't have to deal
+    // with things like EINTR. We then uses ppoll to set the original mask while
+    // polling. This way polling can be interrupted but socket writing, reading
+    // and ioctl remain interrupt free. If a signal arrives while we're blocking
+    // it it will be placed in the signal queue and handled once ppoll sets the
+    // original mask. This way no signals are lost.
+    sigset_t blockMask, originalMask;
+    int status = ::sigfillset(&blockMask);
+    if (status != 0) {
+        return Result::error("Unable to fill signal set: %s", strerror(errno));
+    }
+    status = ::sigprocmask(SIG_SETMASK, &blockMask, &originalMask);
+    if (status != 0) {
+        return Result::error("Unable to set signal mask: %s", strerror(errno));
+    }
+
+    struct pollfd fds;
+    fds.fd = mSocket.get();
+    fds.events = POLLIN;
+    Message message;
+    while ((status = ::ppoll(&fds, 1, nullptr, &originalMask)) >= 0) {
+        if (status == 0) {
+            // Timeout
+            continue;
+        }
+
+        unsigned int interfaceIndex = 0;
+        Result res = mSocket.receiveFromInterface(&message,
+                                                  &interfaceIndex);
+        if (!res) {
+            ALOGE("Failed to recieve on socket: %s", res.c_str());
+            continue;
+        }
+        if (interfaceIndex == 0 || mExcludeInterface == interfaceIndex) {
+            // Received packet on unknown or unwanted interface, drop it
+            continue;
+        }
+        if (!message.isValidDhcpMessage(OP_BOOTREQUEST)) {
+            // Not a DHCP request, drop it
+            continue;
+        }
+        switch (message.type()) {
+            case DHCPDISCOVER:
+                // Someone is trying to find us, let them know we exist
+                sendDhcpOffer(message, interfaceIndex);
+                break;
+            case DHCPREQUEST:
+                // Someone wants a lease based on an offer
+                if (isValidDhcpRequest(message, interfaceIndex)) {
+                    // The request matches our offer, acknowledge it
+                    sendAck(message, interfaceIndex);
+                } else {
+                    // Request for something other than we offered, denied
+                    sendNack(message, interfaceIndex);
+                }
+                break;
+        }
+    }
+    // Polling failed, exit
+    return Result::error("Polling failed: %s", strerror(errno));
+}
+
+Result DhcpServer::sendMessage(unsigned int interfaceIndex,
+                               in_addr_t /*sourceAddress*/,
+                               const Message& message) {
+    return mSocket.sendOnInterface(interfaceIndex,
+                                   INADDR_BROADCAST,
+                                   PORT_BOOTP_CLIENT,
+                                   message);
+}
+
+void DhcpServer::sendDhcpOffer(const Message& message,
+                               unsigned int interfaceIndex ) {
+    updateDnsServers();
+    in_addr_t offerAddress;
+    in_addr_t netmask;
+    in_addr_t gateway;
+    Result res = getOfferAddress(interfaceIndex,
+                                 message.dhcpData.chaddr,
+                                 &offerAddress,
+                                 &netmask,
+                                 &gateway);
+    if (!res) {
+        ALOGE("Failed to get address for offer: %s", res.c_str());
+        return;
+    }
+    in_addr_t serverAddress;
+    res = getInterfaceAddress(interfaceIndex, &serverAddress);
+    if (!res) {
+        ALOGE("Failed to get address for interface %u: %s",
+              interfaceIndex, res.c_str());
+        return;
+    }
+
+    Message offer = Message::offer(message,
+                                   serverAddress,
+                                   offerAddress,
+                                   netmask,
+                                   gateway,
+                                   mDnsServers.data(),
+                                   mDnsServers.size());
+    res = sendMessage(interfaceIndex, serverAddress, offer);
+    if (!res) {
+        ALOGE("Failed to send DHCP offer: %s", res.c_str());
+    }
+}
+
+void DhcpServer::sendAck(const Message& message, unsigned int interfaceIndex) {
+    updateDnsServers();
+    in_addr_t offerAddress;
+    in_addr_t netmask;
+    in_addr_t gateway;
+    in_addr_t serverAddress;
+    Result res = getOfferAddress(interfaceIndex,
+                                 message.dhcpData.chaddr,
+                                 &offerAddress,
+                                 &netmask,
+                                 &gateway);
+    if (!res) {
+        ALOGE("Failed to get address for offer: %s", res.c_str());
+        return;
+    }
+    res = getInterfaceAddress(interfaceIndex, &serverAddress);
+    if (!res) {
+        ALOGE("Failed to get address for interface %u: %s",
+              interfaceIndex, res.c_str());
+        return;
+    }
+    Message ack = Message::ack(message,
+                               serverAddress,
+                               offerAddress,
+                               netmask,
+                               gateway,
+                               mDnsServers.data(),
+                               mDnsServers.size());
+    res = sendMessage(interfaceIndex, serverAddress, ack);
+    if (!res) {
+        ALOGE("Failed to send DHCP ack: %s", res.c_str());
+    }
+}
+
+void DhcpServer::sendNack(const Message& message, unsigned int interfaceIndex) {
+    in_addr_t serverAddress;
+    Result res = getInterfaceAddress(interfaceIndex, &serverAddress);
+    if (!res) {
+        ALOGE("Failed to get address for interface %u: %s",
+              interfaceIndex, res.c_str());
+        return;
+    }
+    Message nack = Message::nack(message, serverAddress);
+    res = sendMessage(interfaceIndex, serverAddress, nack);
+    if (!res) {
+        ALOGE("Failed to send DHCP nack: %s", res.c_str());
+    }
+}
+
+bool DhcpServer::isValidDhcpRequest(const Message& message,
+                                    unsigned int interfaceIndex) {
+    in_addr_t offerAddress;
+    in_addr_t netmask;
+    in_addr_t gateway;
+    Result res = getOfferAddress(interfaceIndex,
+                                 message.dhcpData.chaddr,
+                                 &offerAddress,
+                                 &netmask,
+                                 &gateway);
+    if (!res) {
+        ALOGE("Failed to get address for offer: %s", res.c_str());
+        return false;
+    }
+    if (message.requestedIp() != offerAddress) {
+        ALOGE("Client requested a different IP address from the offered one");
+        return false;
+    }
+    return true;
+}
+
+void DhcpServer::updateDnsServers() {
+    char key[64];
+    char value[PROPERTY_VALUE_MAX];
+    mDnsServers.clear();
+    for (int i = 1; i <= kMaxDnsServers; ++i) {
+        snprintf(key, sizeof(key), "net.eth0.dns%d", i);
+        if (property_get(key, value, nullptr) > 0) {
+            struct in_addr address;
+            if (::inet_pton(AF_INET, value, &address) > 0) {
+                mDnsServers.push_back(address.s_addr);
+            }
+        }
+    }
+}
+
+Result DhcpServer::getInterfaceData(unsigned int interfaceIndex,
+                                    unsigned long type,
+                                    struct ifreq* response) {
+    char interfaceName[IF_NAMESIZE + 1];
+    if (if_indextoname(interfaceIndex, interfaceName) == nullptr) {
+        return Result::error("Failed to get interface name for index %u: %s",
+                             interfaceIndex, strerror(errno));
+    }
+    memset(response, 0, sizeof(*response));
+    response->ifr_addr.sa_family = AF_INET;
+    strncpy(response->ifr_name, interfaceName, IFNAMSIZ - 1);
+
+    if (::ioctl(mSocket.get(), type, response) == -1) {
+        return Result::error("Failed to get data for interface %s: %s",
+                             interfaceName, strerror(errno));
+    }
+
+    return Result::success();
+}
+
+Result DhcpServer::getInterfaceAddress(unsigned int interfaceIndex,
+                                       in_addr_t* address) {
+    struct ifreq data;
+    Result res = getInterfaceData(interfaceIndex, SIOCGIFADDR, &data);
+    if (res.isSuccess()) {
+        auto inAddr = reinterpret_cast<struct sockaddr_in*>(&data.ifr_addr);
+        *address = inAddr->sin_addr.s_addr;
+    }
+    return res;
+}
+
+Result DhcpServer::getInterfaceNetmask(unsigned int interfaceIndex,
+                                       in_addr_t* address) {
+    struct ifreq data;
+    Result res = getInterfaceData(interfaceIndex, SIOCGIFNETMASK, &data);
+    if (res.isSuccess()) {
+        auto inAddr = reinterpret_cast<struct sockaddr_in*>(&data.ifr_addr);
+        *address = inAddr->sin_addr.s_addr;
+    }
+    return res;
+}
+
+static bool isValidHost(const in_addr_t address,
+                        const in_addr_t interfaceAddress,
+                        const in_addr_t netmask) {
+    // If the bits outside of the netmask are all zero it's a network address,
+    // don't use this.
+    bool isNetworkAddress = (address & ~netmask) == 0;
+    // If all bits outside of the netmask are set then it's a broadcast address,
+    // don't use this either.
+    bool isBroadcastAddress = (address & ~netmask) == ~netmask;
+    // Don't assign the interface address to a host
+    bool isInterfaceAddress = address == interfaceAddress;
+
+    return !isNetworkAddress && !isBroadcastAddress && !isInterfaceAddress;
+}
+
+static bool addressInRange(const in_addr_t address,
+                           const in_addr_t interfaceAddress,
+                           const in_addr_t netmask) {
+    if (address <= (interfaceAddress & netmask)) {
+        return false;
+    }
+    if (address >= (interfaceAddress | ~netmask)) {
+        return false;
+    }
+    return true;
+}
+
+Result DhcpServer::getOfferAddress(unsigned int interfaceIndex,
+                                   const uint8_t* macAddress,
+                                   in_addr_t* address,
+                                   in_addr_t* netmask,
+                                   in_addr_t* gateway) {
+    // The interface address will be the gateway and will be used to determine
+    // the range of valid addresses (along with the netmask) for the client.
+    in_addr_t interfaceAddress = 0;
+    Result res = getInterfaceAddress(interfaceIndex, &interfaceAddress);
+    if (!res) {
+        return res;
+    }
+    // The netmask of the interface will be the netmask for the client as well
+    // as used to determine network range.
+    in_addr_t mask = 0;
+    res = getInterfaceNetmask(interfaceIndex, &mask);
+    if (!res) {
+        return res;
+    }
+
+    // Assign these values now before they are modified below
+    *gateway = interfaceAddress;
+    *netmask = mask;
+
+    Lease key(interfaceIndex, macAddress);
+
+    // Find or create entry, if it's created it will be zero and we update it
+    in_addr_t& value = mLeases[key];
+    if (value == 0) {
+        // Addresses are stored in network byte order so when doing math on them
+        // they have to be converted to host byte order
+        interfaceAddress = ntohl(interfaceAddress);
+        mask = ntohl(mask);
+        // Get a reference to the offset so we can use it and increase it at the
+        // same time. If the entry does not exist it will be created with a
+        // value of zero.
+        in_addr_t& offset = mNextAddressOffsets[interfaceIndex];
+        if (offset == 0) {
+            // Increase if zero to avoid assigning network address
+            ++offset;
+        }
+        // Start out at the first address in the range as determined by netmask
+        in_addr_t nextAddress = (interfaceAddress & mask) + offset;
+
+        // Ensure the address is valid
+        while (!isValidHost(nextAddress, interfaceAddress, mask) &&
+               addressInRange(nextAddress, interfaceAddress, mask)) {
+            ++nextAddress;
+            ++offset;
+        }
+
+        if (addressInRange(nextAddress, interfaceAddress, mask)) {
+            // Convert back to network byte order
+            value = htonl(nextAddress);
+            ++offset;
+        } else {
+            // Ran out of addresses
+            return Result::error("DHCP server is out of addresses");
+        }
+    }
+    *address = value;
+    return Result::success();
+}
+
diff --git a/vendor/redroid_ext/wifi/dhcp/server/dhcpserver.h b/vendor/redroid_ext/wifi/dhcp/server/dhcpserver.h
new file mode 100644
index 0000000000..276cd5b131
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/server/dhcpserver.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "lease.h"
+#include "result.h"
+#include "socket.h"
+
+#include <netinet/in.h>
+#include <stdint.h>
+
+#include <unordered_map>
+#include <vector>
+
+class Message;
+
+class DhcpServer {
+public:
+    // Construct a DHCP server. Ignore any requests and discoveries coming on
+    // the network interface identified by |excludeInterface|.
+    explicit DhcpServer(unsigned int excludeInterface);
+
+    Result init();
+    Result run();
+
+private:
+    Result sendMessage(unsigned int interfaceIndex,
+                       in_addr_t sourceAddress,
+                       const Message& message);
+
+    void sendDhcpOffer(const Message& message, unsigned int interfaceIndex);
+    void sendAck(const Message& message, unsigned int interfaceIndex);
+    void sendNack(const Message& message, unsigned int interfaceIndex);
+
+    bool isValidDhcpRequest(const Message& message,
+                            unsigned int interfaceIndex);
+    void updateDnsServers();
+    Result getInterfaceData(unsigned int interfaceIndex,
+                            unsigned long type,
+                            struct ifreq* response);
+    Result getInterfaceAddress(unsigned int interfaceIndex,
+                               in_addr_t* address);
+    Result getInterfaceNetmask(unsigned int interfaceIndex,
+                               in_addr_t* netmask);
+    Result getOfferAddress(unsigned int interfaceIndex,
+                           const uint8_t* macAddress,
+                           in_addr_t* address,
+                           in_addr_t* netmask,
+                           in_addr_t* gateway);
+
+    Socket mSocket;
+    // This is the next address offset. This will be added to whatever the base
+    // address of the DHCP address range is. For each new MAC address seen this
+    // value will increase by one.
+    std::vector<in_addr_t> mDnsServers;
+    // Map a lease to an IP address for that lease
+    std::unordered_map<Lease, in_addr_t> mLeases;
+    std::unordered_map<unsigned int, in_addr_t> mNextAddressOffsets;
+    unsigned int mExcludeInterface;
+};
+
diff --git a/vendor/redroid_ext/wifi/dhcp/server/lease.h b/vendor/redroid_ext/wifi/dhcp/server/lease.h
new file mode 100644
index 0000000000..bad5614770
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/server/lease.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <linux/if_ether.h>
+#include <stdint.h>
+
+#include <functional>
+
+// A lease consists of both the interface index and the MAC address. This
+// way the server can run on many different interfaces that have the same
+// client MAC address without giving out the same IP address. The reason
+// this is useful is because we might have several virtual interfaces, one
+// for each access point, that all have the same endpoint on the other side.
+// This endpoint would then have the same MAC address and always get the
+// same address. But for routing purposes it's useful to give it different
+// addresses depending on the server side interface. That way the routing
+// table can be set up so that packets are forwarded to the correct access
+// point interface based on IP address.
+struct Lease {
+    Lease(unsigned int interfaceIndex, const uint8_t* macAddress) {
+        InterfaceIndex = interfaceIndex;
+        memcpy(MacAddress, macAddress, sizeof(MacAddress));
+    }
+    unsigned int InterfaceIndex;
+    uint8_t MacAddress[ETH_ALEN];
+};
+
+template<class T>
+inline void hash_combine(size_t& seed, const T& value) {
+    std::hash<T> hasher;
+    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
+}
+
+namespace std {
+template<> struct hash<Lease> {
+    size_t operator()(const Lease& lease) const {
+        size_t seed = 0;
+        hash_combine(seed, lease.InterfaceIndex);
+        // Treat the first 4 bytes as an uint32_t to save some computation
+        hash_combine(seed, *reinterpret_cast<const uint32_t*>(lease.MacAddress));
+        // And the remaining 2 bytes as an uint16_t
+        hash_combine(seed,
+                     *reinterpret_cast<const uint16_t*>(lease.MacAddress + 4));
+        return seed;
+    }
+};
+}
+
+inline bool operator==(const Lease& left, const Lease& right) {
+    return left.InterfaceIndex == right.InterfaceIndex &&
+        memcmp(left.MacAddress, right.MacAddress, sizeof(left.MacAddress)) == 0;
+}
diff --git a/vendor/redroid_ext/wifi/dhcp/server/log.h b/vendor/redroid_ext/wifi/dhcp/server/log.h
new file mode 100644
index 0000000000..a0f21e08a3
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/server/log.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#define LOG_TAG "dhcpserver"
+#include <log/log.h>
+
diff --git a/vendor/redroid_ext/wifi/dhcp/server/main.cpp b/vendor/redroid_ext/wifi/dhcp/server/main.cpp
new file mode 100644
index 0000000000..482ffd6168
--- /dev/null
+++ b/vendor/redroid_ext/wifi/dhcp/server/main.cpp
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2017, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dhcpserver.h"
+
+#include "log.h"
+
+#include <arpa/inet.h>
+#include <net/if.h>
+
+static void usage(const char* program) {
+    ALOGE("Usage: %s -i <interface> -r <", program);
+}
+
+int main(int argc, char* argv[]) {
+    char* excludeInterfaceName = nullptr;
+    unsigned int excludeInterfaceIndex = 0;
+    for (int i = 1; i < argc; ++i) {
+        if (strcmp("--exclude-interface", argv[i]) == 0) {
+            if (i + 1 >= argc) {
+                ALOGE("ERROR: Missing argument to "
+                     "--exclude-interfaces parameter");
+                usage(argv[0]);
+                return 1;
+            }
+            excludeInterfaceName = argv[i + 1];
+            excludeInterfaceIndex = if_nametoindex(excludeInterfaceName);
+            if (excludeInterfaceIndex == 0) {
+                ALOGE("ERROR: Invalid argument '%s' to --exclude-interface",
+                     argv[i + 1]);
+                usage(argv[0]);
+                return 1;
+            }
+        }
+    }
+
+    DhcpServer server(excludeInterfaceIndex);
+    Result res = server.init();
+    if (!res) {
+        ALOGE("Failed to initialize DHCP server: %s\n", res.c_str());
+        return 1;
+    }
+
+    res = server.run();
+    if (!res) {
+        ALOGE("DHCP server failed: %s\n", res.c_str());
+        return 1;
+    }
+    // This is weird and shouldn't happen, the server should run forever.
+    return 0;
+}
+
+
diff --git a/vendor/redroid_ext/wifi/execns/Android.bp b/vendor/redroid_ext/wifi/execns/Android.bp
new file mode 100644
index 0000000000..a3e636e742
--- /dev/null
+++ b/vendor/redroid_ext/wifi/execns/Android.bp
@@ -0,0 +1,37 @@
+// Copyright (C) 2020 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// package {
+//     // See: http://go/android-license-faq
+//     // A large-scale-change added 'default_applicable_licenses' to import
+//     // all of the 'license_kinds' from "device_generic_goldfish_license"
+//     // to get the below license kinds:
+//     //   SPDX-license-identifier-Apache-2.0
+//     default_applicable_licenses: ["device_generic_goldfish_license"],
+// }
+
+cc_binary {
+    name: "execns2",
+    srcs: ["execns.cpp"],
+    cflags: [
+        "-Wall",
+        "-Wextra",
+        "-Werror",
+    ],
+    shared_libs: [
+        "libcutils",
+        "liblog",
+    ],
+    proprietary: true,
+}
diff --git a/vendor/redroid_ext/wifi/execns/execns.cpp b/vendor/redroid_ext/wifi/execns/execns.cpp
new file mode 100644
index 0000000000..770d24992e
--- /dev/null
+++ b/vendor/redroid_ext/wifi/execns/execns.cpp
@@ -0,0 +1,310 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "execns"
+#include <log/log.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <grp.h>
+#include <pwd.h>
+#include <sched.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <string>
+#include <vector>
+
+static bool isTerminal = false;
+// Print errors to stderr if running from a terminal, otherwise print to logcat
+// This is useful for debugging from a terminal
+#define LOGE(...) do { \
+    if (isTerminal) { \
+        fprintf(stderr, __VA_ARGS__); \
+        fprintf(stderr, "\n"); \
+    } else { \
+        ALOGE(__VA_ARGS__); \
+    } \
+} while (0)
+
+static const char kNetNsDir[] = "/data/vendor/var/run/netns";
+
+class FileDescriptor {
+public:
+    explicit FileDescriptor(int fd) : mFd(fd) { }
+    FileDescriptor(const FileDescriptor&) = delete;
+    ~FileDescriptor() {
+        if (mFd != -1) {
+            close(mFd);
+            mFd = -1;
+        }
+    }
+    int get() const { return mFd; }
+    FileDescriptor& operator=(const FileDescriptor&) = delete;
+private:
+    int mFd;
+};
+
+class File {
+public:
+    explicit File(FILE* file) : mFile(file) { }
+    File(const File&) = delete;
+    ~File() {
+        if (mFile) {
+            ::fclose(mFile);
+            mFile = nullptr;
+        }
+    }
+
+    FILE* get() const { return mFile; }
+    File& operator=(const File&) = delete;
+private:
+    FILE* mFile;
+};
+
+static void printUsage(const char* program) {
+    LOGE("%s [-u user] [-g group] <namespace> <program> [options...]", program);
+}
+
+static bool isNumericString(const char* str) {
+    while (isdigit(*str)) {
+        ++str;
+    }
+    return *str == '\0';
+}
+
+static std::string readNamespacePid(const char* ns) {
+    char nsPath[PATH_MAX];
+    snprintf(nsPath, sizeof(nsPath), "%s/%s.pid", kNetNsDir, ns);
+
+    File file(::fopen(nsPath, "r"));
+    if (file.get() == nullptr) {
+        LOGE("Unable to open file %s for namespace %s: %s",
+             nsPath, ns, strerror(errno));
+        return std::string();
+    }
+
+    char buffer[32];
+    size_t bytesRead = ::fread(buffer, 1, sizeof(buffer), file.get());
+    if (bytesRead < sizeof(buffer) && feof(file.get())) {
+        // Reached end-of-file, null-terminate
+        buffer[bytesRead] = '\0';
+        if (isNumericString(buffer)) {
+            // File is valid and contains a number, return it
+            return buffer;
+        }
+        LOGE("File %s does not contain a valid pid '%s'", nsPath, buffer);
+    } else if (ferror(file.get())) {
+        LOGE("Error reading from file %s: %s", nsPath, strerror(errno));
+    } else {
+        LOGE("Invalid contents of pid file %s", nsPath);
+    }
+    return std::string();
+}
+
+static bool setNetworkNamespace(const char* ns) {
+    // There is a file in the net namespace dir (/data/vendor/var/run/netns) with
+    // the name "<namespace>.pid". This file contains the pid of the createns
+    // process that created the namespace.
+    //
+    // To switch network namespace we're going to call setns which requires an
+    // open file descriptor to /proc/<pid>/ns/net where <pid> refers to a
+    // process already running in that namespace. So using the pid from the file
+    // above we can determine which path to use.
+    std::string pid = readNamespacePid(ns);
+    if (pid.empty()) {
+        return false;
+    }
+    char nsPath[PATH_MAX];
+    snprintf(nsPath, sizeof(nsPath), "/proc/%s/ns/net", pid.c_str());
+
+    FileDescriptor nsFd(open(nsPath, O_RDONLY | O_CLOEXEC));
+    if (nsFd.get() == -1) {
+        LOGE("Cannot open network namespace '%s' at '%s': %s",
+             ns, nsPath, strerror(errno));
+        return false;
+    }
+
+    if (setns(nsFd.get(), CLONE_NEWNET) == -1) {
+        LOGE("Cannot set network namespace '%s': %s",
+             ns, strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+static bool changeUser(const char* user) {
+    struct passwd* pwd = ::getpwnam(user);
+    if (pwd == nullptr) {
+        LOGE("Could not find user '%s'", user);
+        return false;
+    }
+
+    if (::setuid(pwd->pw_uid) != 0) {
+        LOGE("Cannot switch to user '%s': %s", user, strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+static bool changeGroup(const char* group) {
+    struct group* grp = ::getgrnam(group);
+    if (grp == nullptr) {
+        LOGE("Could not find group '%s'", group);
+        return false;
+    }
+
+    if (::setgid(grp->gr_gid) != 0) {
+        LOGE("Cannot switch to group '%s': %s", group, strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+// Append a formatted string to the end of |buffer|. The total size in |buffer|
+// is |size|, including any existing string data. The string to append is
+// specified by |fmt| and any additional arguments required by the format
+// string. If the function fails it returns -1, otherwise it returns the number
+// of characters printed (excluding the terminating NULL). On success the
+// string is always null-terminated.
+static int sncatf(char* buffer, size_t size, const char* fmt, ...) {
+    size_t len = strnlen(buffer, size);
+    if (len >= size) {
+        // The length exceeds the available size, if len == size then there is
+        // also a terminating null after len bytes which would then be outside
+        // the provided buffer.
+        return -1;
+    }
+
+    va_list args;
+    va_start(args, fmt);
+    int printed = vsnprintf(buffer + len, size - len, fmt, args);
+    buffer[size - 1] = '\0';
+    va_end(args);
+    return printed;
+}
+
+/**
+ * Execute a given |command| with |argc| number of parameters that are located
+ * in |argv|. The first parameter in |argv| is the command that should be run
+ * followed by its arguments.
+ */
+static int execCommand( int argc, char** argv) {
+    if (argc <= 0 || argv == nullptr || argv[0] == nullptr) {
+        LOGE("No command specified");
+        return 1;
+    }
+
+    std::vector<char*> arguments;
+    // Place all the arguments in the vector and the terminating null
+    arguments.insert(arguments.begin(), argv, argv + argc);
+    arguments.push_back(nullptr);
+
+    char buffer[4096];
+    if (execvp(argv[0], arguments.data()) == -1) {
+        // Save errno in case it gets changed by printing stuff.
+        int error = errno;
+        int printed = snprintf(buffer, sizeof(buffer),
+                               "Could not execute command '%s", argv[0]);
+        if (printed < 0) {
+            LOGE("Could not execute command: %s", strerror(error));
+            return error;
+        }
+        for (int i = 1; i < argc; ++i) {
+            // Be nice to the user and print quotes if there are spaces to
+            // indicate how we saw it. If there are already single quotes in
+            // there confusion will ensue.
+            if (strchr(argv[i], ' ')) {
+                sncatf(buffer, sizeof(buffer), " \"%s\"", argv[i]);
+            } else {
+                sncatf(buffer, sizeof(buffer), " %s", argv[i]);
+            }
+        }
+        sncatf(buffer, sizeof(buffer), "': %s", strerror(error));
+        LOGE("%s", buffer);
+        return error;
+    }
+    // execvp never returns unless it fails so this is just to return something.
+    return 0;
+}
+
+/**
+ * Enter a given network namespace argv[1] and execute command argv[2] with
+ * options argv[3..argc-1] in that namespace.
+ */
+int main(int argc, char* argv[]) {
+    isTerminal = isatty(STDOUT_FILENO) != 0;
+
+    // Parse parameters
+    const char* user = nullptr;
+    const char* group = nullptr;
+    int nsArg = -1;
+    int execArg = -1;
+    for (int i = 1; i < argc; ++i) {
+        if (::strcmp(argv[i], "-u") == 0) {
+            if (user || i + 1 >= argc) {
+                LOGE("Missing argument to option -u");
+                return 1;
+            }
+            user = argv[++i];
+        } else if (::strcmp(argv[i], "-g") == 0) {
+            if (group || i + 1 >= argc) {
+                LOGE("Missing argument to option -g");
+                return 1;
+            }
+            group = argv[++i];
+        } else {
+            // Break on the first non-option and treat it as the namespace name
+            nsArg = i;
+            if (i + 1 < argc) {
+                execArg = i + 1;
+            }
+            break;
+        }
+    }
+
+    if (nsArg < 0 || execArg < 0) {
+        // Missing namespace and/or exec arguments
+        printUsage(argv[0]);
+        return 1;
+    }
+
+    // First set the new network namespace for this process
+    if (!setNetworkNamespace(argv[nsArg])) {
+        return 1;
+    }
+
+    // Changing namespace is the privileged operation, so now we can drop
+    // privileges by changing user and/or group if the user requested it. Note
+    // that it's important to change group first because it must be done as a
+    // privileged user. Otherwise an attacker might be able to restore group
+    // privileges by using the group ID that is saved by setgid when running
+    // as a non-privileged user.
+    if (group && !changeGroup(group)) {
+        return 1;
+    }
+
+    if (user && !changeUser(user)) {
+        return 1;
+    }
+
+    // Now run the command with all the remaining parameters
+    return execCommand(argc - execArg, &argv[execArg]);
+}
+
diff --git a/vendor/redroid_ext/wifi/hostapd.conf b/vendor/redroid_ext/wifi/hostapd.conf
new file mode 100644
index 0000000000..e0d2390817
--- /dev/null
+++ b/vendor/redroid_ext/wifi/hostapd.conf
@@ -0,0 +1,1780 @@
+#
+#* Copyright (C) 2016 The Android Open Source Project
+#*
+#* Licensed under the Apache License, Version 2.0 (the "License");
+#* you may not use this file except in compliance with the License.
+#* You may obtain a copy of the License at
+#*
+#*      http://www.apache.org/licenses/LICENSE-2.0
+#*
+#* Unless required by applicable law or agreed to in writing, software
+#* distributed under the License is distributed on an "AS IS" BASIS,
+#* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#* See the License for the specific language governing permissions and
+#* limitations under the License.
+#
+##### hostapd configuration file ##############################################
+# Empty lines and lines starting with # are ignored
+
+# AP netdevice name (without 'ap' postfix, i.e., wlan0 uses wlan0ap for
+# management frames); ath0 for madwifi
+interface=wlan1
+
+# In case of madwifi, atheros, and nl80211 driver interfaces, an additional
+# configuration parameter, bridge, may be used to notify hostapd if the
+# interface is included in a bridge. This parameter is not used with Host AP
+# driver. If the bridge parameter is not set, the drivers will automatically
+# figure out the bridge interface (assuming sysfs is enabled and mounted to
+# /sys) and this parameter may not be needed.
+#
+# For nl80211, this parameter can be used to request the AP interface to be
+# added to the bridge automatically (brctl may refuse to do this before hostapd
+# has been started to change the interface mode). If needed, the bridge
+# interface is also created.
+bridge=br0
+
+# Driver interface type (hostap/wired/madwifi/test/none/nl80211/bsd);
+# default: hostap). nl80211 is used with all Linux mac80211 drivers.
+# Use driver=none if building hostapd as a standalone RADIUS server that does
+# not control any wireless/wired driver.
+# driver=hostap
+driver=nl80211
+# hostapd event logger configuration
+#
+# Two output method: syslog and stdout (only usable if not forking to
+# background).
+#
+# Module bitfield (ORed bitfield of modules that will be logged; -1 = all
+# modules):
+# bit 0 (1) = IEEE 802.11
+# bit 1 (2) = IEEE 802.1X
+# bit 2 (4) = RADIUS
+# bit 3 (8) = WPA
+# bit 4 (16) = driver interface
+# bit 5 (32) = IAPP
+# bit 6 (64) = MLME
+#
+# Levels (minimum value for logged events):
+#  0 = verbose debugging
+#  1 = debugging
+#  2 = informational messages
+#  3 = notification
+#  4 = warning
+#
+logger_syslog=-1
+logger_syslog_level=2
+logger_stdout=-1
+logger_stdout_level=2
+
+# Interface for separate control program. If this is specified, hostapd
+# will create this directory and a UNIX domain socket for listening to requests
+# from external programs (CLI/GUI, etc.) for status information and
+# configuration. The socket file will be named based on the interface name, so
+# multiple hostapd processes/interfaces can be run at the same time if more
+# than one interface is used.
+# /var/run/hostapd is the recommended directory for sockets and by default,
+# hostapd_cli will use it when trying to connect with hostapd.
+#ctrl_interface=/data/local/wifi/sockets
+
+# Access control for the control interface can be configured by setting the
+# directory to allow only members of a group to use sockets. This way, it is
+# possible to run hostapd as root (since it needs to change network
+# configuration and open raw sockets) and still allow GUI/CLI components to be
+# run as non-root users. However, since the control interface can be used to
+# change the network configuration, this access needs to be protected in many
+# cases. By default, hostapd is configured to use gid 0 (root). If you
+# want to allow non-root users to use the contron interface, add a new group
+# and change this value to match with that group. Add users that should have
+# control interface access to this group.
+#
+# This variable can be a group name or gid.
+#ctrl_interface_group=wheel
+ctrl_interface_group=0
+
+
+##### IEEE 802.11 related configuration #######################################
+
+# SSID to be used in IEEE 802.11 management frames
+ssid=ChinaNet
+# Alternative formats for configuring SSID
+# (double quoted string, hexdump, printf-escaped string)
+#ssid2="test"
+#ssid2=74657374
+#ssid2=P"hello\nthere"
+bssid=<bssid1>
+
+# UTF-8 SSID: Whether the SSID is to be interpreted using UTF-8 encoding
+#utf8_ssid=1
+
+# Country code (ISO/IEC 3166-1). Used to set regulatory domain.
+# Set as needed to indicate country in which device is operating.
+# This can limit available channels and transmit power.
+country_code=US
+
+# Enable IEEE 802.11d. This advertises the country_code and the set of allowed
+# channels and transmit power levels based on the regulatory limits. The
+# country_code setting must be configured with the correct country for
+# IEEE 802.11d functions.
+# (default: 0 = disabled)
+#ieee80211d=1
+
+# Enable IEEE 802.11h. This enables radar detection and DFS support if
+# available. DFS support is required on outdoor 5 GHz channels in most countries
+# of the world. This can be used only with ieee80211d=1.
+# (default: 0 = disabled)
+#ieee80211h=1
+
+# Add Power Constraint element to Beacon and Probe Response frames
+# This config option adds Power Constraint element when applicable and Country
+# element is added. Power Constraint element is required by Transmit Power
+# Control. This can be used only with ieee80211d=1.
+# Valid values are 0..255.
+#local_pwr_constraint=3
+
+# Set Spectrum Management subfield in the Capability Information field.
+# This config option forces the Spectrum Management bit to be set. When this
+# option is not set, the value of the Spectrum Management bit depends on whether
+# DFS or TPC is required by regulatory authorities. This can be used only with
+# ieee80211d=1 and local_pwr_constraint configured.
+#spectrum_mgmt_required=1
+
+# Operation mode (a = IEEE 802.11a, b = IEEE 802.11b, g = IEEE 802.11g,
+# ad = IEEE 802.11ad (60 GHz); a/g options are used with IEEE 802.11n, too, to
+# specify band)
+# Default: IEEE 802.11b
+hw_mode=g
+
+# Channel number (IEEE 802.11)
+# (default: 0, i.e., not set)
+# Please note that some drivers do not use this value from hostapd and the
+# channel will need to be configured separately with iwconfig.
+#
+# If CONFIG_ACS build option is enabled, the channel can be selected
+# automatically at run time by setting channel=acs_survey or channel=0, both of
+# which will enable the ACS survey based algorithm.
+channel=8
+
+# ACS tuning - Automatic Channel Selection
+# See: http://wireless.kernel.org/en/users/Documentation/acs
+#
+# You can customize the ACS survey algorithm with following variables:
+#
+# acs_num_scans requirement is 1..100 - number of scans to be performed that
+# are used to trigger survey data gathering of an underlying device driver.
+# Scans are passive and typically take a little over 100ms (depending on the
+# driver) on each available channel for given hw_mode. Increasing this value
+# means sacrificing startup time and gathering more data wrt channel
+# interference that may help choosing a better channel. This can also help fine
+# tune the ACS scan time in case a driver has different scan dwell times.
+#
+# Defaults:
+#acs_num_scans=5
+
+# Channel list restriction. This option allows hostapd to select one of the
+# provided channels when a channel should be automatically selected. This
+# is currently only used for DFS when the current channels becomes unavailable
+# due to radar interference, and is currently only useful when ieee80211h=1 is
+# set.
+# Default: not set (allow any enabled channel to be selected)
+#chanlist=100 104 108 112 116
+
+# Beacon interval in kus (1.024 ms) (default: 100; range 15..65535)
+beacon_int=100
+
+# DTIM (delivery traffic information message) period (range 1..255):
+# number of beacons between DTIMs (1 = every beacon includes DTIM element)
+# (default: 2)
+dtim_period=2
+
+# Maximum number of stations allowed in station table. New stations will be
+# rejected after the station table is full. IEEE 802.11 has a limit of 2007
+# different association IDs, so this number should not be larger than that.
+# (default: 2007)
+max_num_sta=255
+
+# RTS/CTS threshold; 2347 = disabled (default); range 0..2347
+# If this field is not included in hostapd.conf, hostapd will not control
+# RTS threshold and 'iwconfig wlan# rts <val>' can be used to set it.
+rts_threshold=2347
+
+# Fragmentation threshold; 2346 = disabled (default); range 256..2346
+# If this field is not included in hostapd.conf, hostapd will not control
+# fragmentation threshold and 'iwconfig wlan# frag <val>' can be used to set
+# it.
+fragm_threshold=2346
+
+# Rate configuration
+# Default is to enable all rates supported by the hardware. This configuration
+# item allows this list be filtered so that only the listed rates will be left
+# in the list. If the list is empty, all rates are used. This list can have
+# entries that are not in the list of rates the hardware supports (such entries
+# are ignored). The entries in this list are in 100 kbps, i.e., 11 Mbps = 110.
+# If this item is present, at least one rate have to be matching with the rates
+# hardware supports.
+# default: use the most common supported rate setting for the selected
+# hw_mode (i.e., this line can be removed from configuration file in most
+# cases)
+#supported_rates=10 20 55 110 60 90 120 180 240 360 480 540
+
+# Basic rate set configuration
+# List of rates (in 100 kbps) that are included in the basic rate set.
+# If this item is not included, usually reasonable default set is used.
+#basic_rates=10 20
+#basic_rates=10 20 55 110
+#basic_rates=60 120 240
+
+# Short Preamble
+# This parameter can be used to enable optional use of short preamble for
+# frames sent at 2 Mbps, 5.5 Mbps, and 11 Mbps to improve network performance.
+# This applies only to IEEE 802.11b-compatible networks and this should only be
+# enabled if the local hardware supports use of short preamble. If any of the
+# associated STAs do not support short preamble, use of short preamble will be
+# disabled (and enabled when such STAs disassociate) dynamically.
+# 0 = do not allow use of short preamble (default)
+# 1 = allow use of short preamble
+#preamble=1
+
+# Station MAC address -based authentication
+# Please note that this kind of access control requires a driver that uses
+# hostapd to take care of management frame processing and as such, this can be
+# used with driver=hostap or driver=nl80211, but not with driver=madwifi.
+# 0 = accept unless in deny list
+# 1 = deny unless in accept list
+# 2 = use external RADIUS server (accept/deny lists are searched first)
+macaddr_acl=0
+
+# Accept/deny lists are read from separate files (containing list of
+# MAC addresses, one per line). Use absolute path name to make sure that the
+# files can be read on SIGHUP configuration reloads.
+#accept_mac_file=/etc/hostapd.accept
+#deny_mac_file=/etc/hostapd.deny
+
+# IEEE 802.11 specifies two authentication algorithms. hostapd can be
+# configured to allow both of these or only one. Open system authentication
+# should be used with IEEE 802.1X.
+# Bit fields of allowed authentication algorithms:
+# bit 0 = Open System Authentication
+# bit 1 = Shared Key Authentication (requires WEP)
+auth_algs=3
+
+# Send empty SSID in beacons and ignore probe request frames that do not
+# specify full SSID, i.e., require stations to know SSID.
+# default: disabled (0)
+# 1 = send empty (length=0) SSID in beacon and ignore probe request for
+#     broadcast SSID
+# 2 = clear SSID (ASCII 0), but keep the original length (this may be required
+#     with some clients that do not support empty SSID) and ignore probe
+#     requests for broadcast SSID
+ignore_broadcast_ssid=0
+
+# Additional vendor specfic elements for Beacon and Probe Response frames
+# This parameter can be used to add additional vendor specific element(s) into
+# the end of the Beacon and Probe Response frames. The format for these
+# element(s) is a hexdump of the raw information elements (id+len+payload for
+# one or more elements)
+#vendor_elements=dd0411223301
+
+# TX queue parameters (EDCF / bursting)
+# tx_queue_<queue name>_<param>
+# queues: data0, data1, data2, data3, after_beacon, beacon
+#		(data0 is the highest priority queue)
+# parameters:
+#   aifs: AIFS (default 2)
+#   cwmin: cwMin (1, 3, 7, 15, 31, 63, 127, 255, 511, 1023)
+#   cwmax: cwMax (1, 3, 7, 15, 31, 63, 127, 255, 511, 1023); cwMax >= cwMin
+#   burst: maximum length (in milliseconds with precision of up to 0.1 ms) for
+#          bursting
+#
+# Default WMM parameters (IEEE 802.11 draft; 11-03-0504-03-000e):
+# These parameters are used by the access point when transmitting frames
+# to the clients.
+#
+# Low priority / AC_BK = background
+#tx_queue_data3_aifs=7
+#tx_queue_data3_cwmin=15
+#tx_queue_data3_cwmax=1023
+#tx_queue_data3_burst=0
+# Note: for IEEE 802.11b mode: cWmin=31 cWmax=1023 burst=0
+#
+# Normal priority / AC_BE = best effort
+#tx_queue_data2_aifs=3
+#tx_queue_data2_cwmin=15
+#tx_queue_data2_cwmax=63
+#tx_queue_data2_burst=0
+# Note: for IEEE 802.11b mode: cWmin=31 cWmax=127 burst=0
+#
+# High priority / AC_VI = video
+#tx_queue_data1_aifs=1
+#tx_queue_data1_cwmin=7
+#tx_queue_data1_cwmax=15
+#tx_queue_data1_burst=3.0
+# Note: for IEEE 802.11b mode: cWmin=15 cWmax=31 burst=6.0
+#
+# Highest priority / AC_VO = voice
+#tx_queue_data0_aifs=1
+#tx_queue_data0_cwmin=3
+#tx_queue_data0_cwmax=7
+#tx_queue_data0_burst=1.5
+# Note: for IEEE 802.11b mode: cWmin=7 cWmax=15 burst=3.3
+
+# 802.1D Tag (= UP) to AC mappings
+# WMM specifies following mapping of data frames to different ACs. This mapping
+# can be configured using Linux QoS/tc and sch_pktpri.o module.
+# 802.1D Tag	802.1D Designation	Access Category	WMM Designation
+# 1		BK			AC_BK		Background
+# 2		-			AC_BK		Background
+# 0		BE			AC_BE		Best Effort
+# 3		EE			AC_BE		Best Effort
+# 4		CL			AC_VI		Video
+# 5		VI			AC_VI		Video
+# 6		VO			AC_VO		Voice
+# 7		NC			AC_VO		Voice
+# Data frames with no priority information: AC_BE
+# Management frames: AC_VO
+# PS-Poll frames: AC_BE
+
+# Default WMM parameters (IEEE 802.11 draft; 11-03-0504-03-000e):
+# for 802.11a or 802.11g networks
+# These parameters are sent to WMM clients when they associate.
+# The parameters will be used by WMM clients for frames transmitted to the
+# access point.
+#
+# note - txop_limit is in units of 32microseconds
+# note - acm is admission control mandatory flag. 0 = admission control not
+# required, 1 = mandatory
+# note - here cwMin and cmMax are in exponent form. the actual cw value used
+# will be (2^n)-1 where n is the value given here
+#
+wmm_enabled=1
+#
+# WMM-PS Unscheduled Automatic Power Save Delivery [U-APSD]
+# Enable this flag if U-APSD supported outside hostapd (eg., Firmware/driver)
+#uapsd_advertisement_enabled=1
+#
+# Low priority / AC_BK = background
+wmm_ac_bk_cwmin=4
+wmm_ac_bk_cwmax=10
+wmm_ac_bk_aifs=7
+wmm_ac_bk_txop_limit=0
+wmm_ac_bk_acm=0
+# Note: for IEEE 802.11b mode: cWmin=5 cWmax=10
+#
+# Normal priority / AC_BE = best effort
+wmm_ac_be_aifs=3
+wmm_ac_be_cwmin=4
+wmm_ac_be_cwmax=10
+wmm_ac_be_txop_limit=0
+wmm_ac_be_acm=0
+# Note: for IEEE 802.11b mode: cWmin=5 cWmax=7
+#
+# High priority / AC_VI = video
+wmm_ac_vi_aifs=2
+wmm_ac_vi_cwmin=3
+wmm_ac_vi_cwmax=4
+wmm_ac_vi_txop_limit=94
+wmm_ac_vi_acm=0
+# Note: for IEEE 802.11b mode: cWmin=4 cWmax=5 txop_limit=188
+#
+# Highest priority / AC_VO = voice
+wmm_ac_vo_aifs=2
+wmm_ac_vo_cwmin=2
+wmm_ac_vo_cwmax=3
+wmm_ac_vo_txop_limit=47
+wmm_ac_vo_acm=0
+# Note: for IEEE 802.11b mode: cWmin=3 cWmax=4 burst=102
+
+# Static WEP key configuration
+#
+# The key number to use when transmitting.
+# It must be between 0 and 3, and the corresponding key must be set.
+# default: not set
+#wep_default_key=0
+# The WEP keys to use.
+# A key may be a quoted string or unquoted hexadecimal digits.
+# The key length should be 5, 13, or 16 characters, or 10, 26, or 32
+# digits, depending on whether 40-bit (64-bit), 104-bit (128-bit), or
+# 128-bit (152-bit) WEP is used.
+# Only the default key must be supplied; the others are optional.
+# default: not set
+#wep_key0=123456789a
+#wep_key1="vwxyz"
+#wep_key2=0102030405060708090a0b0c0d
+#wep_key3=".2.4.6.8.0.23"
+
+# Station inactivity limit
+#
+# If a station does not send anything in ap_max_inactivity seconds, an
+# empty data frame is sent to it in order to verify whether it is
+# still in range. If this frame is not ACKed, the station will be
+# disassociated and then deauthenticated. This feature is used to
+# clear station table of old entries when the STAs move out of the
+# range.
+#
+# The station can associate again with the AP if it is still in range;
+# this inactivity poll is just used as a nicer way of verifying
+# inactivity; i.e., client will not report broken connection because
+# disassociation frame is not sent immediately without first polling
+# the STA with a data frame.
+# default: 300 (i.e., 5 minutes)
+#ap_max_inactivity=300
+#
+# The inactivity polling can be disabled to disconnect stations based on
+# inactivity timeout so that idle stations are more likely to be disconnected
+# even if they are still in range of the AP. This can be done by setting
+# skip_inactivity_poll to 1 (default 0).
+#skip_inactivity_poll=0
+
+# Disassociate stations based on excessive transmission failures or other
+# indications of connection loss. This depends on the driver capabilities and
+# may not be available with all drivers.
+#disassoc_low_ack=1
+
+# Maximum allowed Listen Interval (how many Beacon periods STAs are allowed to
+# remain asleep). Default: 65535 (no limit apart from field size)
+#max_listen_interval=100
+
+# WDS (4-address frame) mode with per-station virtual interfaces
+# (only supported with driver=nl80211)
+# This mode allows associated stations to use 4-address frames to allow layer 2
+# bridging to be used.
+#wds_sta=1
+
+# If bridge parameter is set, the WDS STA interface will be added to the same
+# bridge by default. This can be overridden with the wds_bridge parameter to
+# use a separate bridge.
+#wds_bridge=wds-br0
+
+# Start the AP with beaconing disabled by default.
+#start_disabled=0
+
+# Client isolation can be used to prevent low-level bridging of frames between
+# associated stations in the BSS. By default, this bridging is allowed.
+#ap_isolate=1
+
+# Fixed BSS Load value for testing purposes
+# This field can be used to configure hostapd to add a fixed BSS Load element
+# into Beacon and Probe Response frames for testing purposes. The format is
+# <station count>:<channel utilization>:<available admission capacity>
+#bss_load_test=12:80:20000
+
+##### IEEE 802.11n related configuration ######################################
+
+# ieee80211n: Whether IEEE 802.11n (HT) is enabled
+# 0 = disabled (default)
+# 1 = enabled
+# Note: You will also need to enable WMM for full HT functionality.
+ieee80211n=1
+
+# ht_capab: HT capabilities (list of flags)
+# LDPC coding capability: [LDPC] = supported
+# Supported channel width set: [HT40-] = both 20 MHz and 40 MHz with secondary
+#	channel below the primary channel; [HT40+] = both 20 MHz and 40 MHz
+#	with secondary channel above the primary channel
+#	(20 MHz only if neither is set)
+#	Note: There are limits on which channels can be used with HT40- and
+#	HT40+. Following table shows the channels that may be available for
+#	HT40- and HT40+ use per IEEE 802.11n Annex J:
+#	freq		HT40-		HT40+
+#	2.4 GHz		5-13		1-7 (1-9 in Europe/Japan)
+#	5 GHz		40,48,56,64	36,44,52,60
+#	(depending on the location, not all of these channels may be available
+#	for use)
+#	Please note that 40 MHz channels may switch their primary and secondary
+#	channels if needed or creation of 40 MHz channel maybe rejected based
+#	on overlapping BSSes. These changes are done automatically when hostapd
+#	is setting up the 40 MHz channel.
+# Spatial Multiplexing (SM) Power Save: [SMPS-STATIC] or [SMPS-DYNAMIC]
+#	(SMPS disabled if neither is set)
+# HT-greenfield: [GF] (disabled if not set)
+# Short GI for 20 MHz: [SHORT-GI-20] (disabled if not set)
+# Short GI for 40 MHz: [SHORT-GI-40] (disabled if not set)
+# Tx STBC: [TX-STBC] (disabled if not set)
+# Rx STBC: [RX-STBC1] (one spatial stream), [RX-STBC12] (one or two spatial
+#	streams), or [RX-STBC123] (one, two, or three spatial streams); Rx STBC
+#	disabled if none of these set
+# HT-delayed Block Ack: [DELAYED-BA] (disabled if not set)
+# Maximum A-MSDU length: [MAX-AMSDU-7935] for 7935 octets (3839 octets if not
+#	set)
+# DSSS/CCK Mode in 40 MHz: [DSSS_CCK-40] = allowed (not allowed if not set)
+# 40 MHz intolerant [40-INTOLERANT] (not advertised if not set)
+# L-SIG TXOP protection support: [LSIG-TXOP-PROT] (disabled if not set)
+ht_capab=[HT40-][DSSS_CCK-40][SHORT-GI-40]
+
+# Require stations to support HT PHY (reject association if they do not)
+#require_ht=1
+
+# If set non-zero, require stations to perform scans of overlapping
+# channels to test for stations which would be affected by 40 MHz traffic.
+# This parameter sets the interval in seconds between these scans. This
+# is useful only for testing that stations properly set the OBSS interval,
+# since the other parameters in the OBSS scan parameters IE are set to 0.
+#obss_interval=0
+
+##### IEEE 802.11ac related configuration #####################################
+
+# ieee80211ac: Whether IEEE 802.11ac (VHT) is enabled
+# 0 = disabled (default)
+# 1 = enabled
+# Note: You will also need to enable WMM for full VHT functionality.
+#ieee80211ac=1
+
+# vht_capab: VHT capabilities (list of flags)
+#
+# vht_max_mpdu_len: [MAX-MPDU-7991] [MAX-MPDU-11454]
+# Indicates maximum MPDU length
+# 0 = 3895 octets (default)
+# 1 = 7991 octets
+# 2 = 11454 octets
+# 3 = reserved
+#
+# supported_chan_width: [VHT160] [VHT160-80PLUS80]
+# Indicates supported Channel widths
+# 0 = 160 MHz & 80+80 channel widths are not supported (default)
+# 1 = 160 MHz channel width is supported
+# 2 = 160 MHz & 80+80 channel widths are supported
+# 3 = reserved
+#
+# Rx LDPC coding capability: [RXLDPC]
+# Indicates support for receiving LDPC coded pkts
+# 0 = Not supported (default)
+# 1 = Supported
+#
+# Short GI for 80 MHz: [SHORT-GI-80]
+# Indicates short GI support for reception of packets transmitted with TXVECTOR
+# params format equal to VHT and CBW = 80Mhz
+# 0 = Not supported (default)
+# 1 = Supported
+#
+# Short GI for 160 MHz: [SHORT-GI-160]
+# Indicates short GI support for reception of packets transmitted with TXVECTOR
+# params format equal to VHT and CBW = 160Mhz
+# 0 = Not supported (default)
+# 1 = Supported
+#
+# Tx STBC: [TX-STBC-2BY1]
+# Indicates support for the transmission of at least 2x1 STBC
+# 0 = Not supported (default)
+# 1 = Supported
+#
+# Rx STBC: [RX-STBC-1] [RX-STBC-12] [RX-STBC-123] [RX-STBC-1234]
+# Indicates support for the reception of PPDUs using STBC
+# 0 = Not supported (default)
+# 1 = support of one spatial stream
+# 2 = support of one and two spatial streams
+# 3 = support of one, two and three spatial streams
+# 4 = support of one, two, three and four spatial streams
+# 5,6,7 = reserved
+#
+# SU Beamformer Capable: [SU-BEAMFORMER]
+# Indicates support for operation as a single user beamformer
+# 0 = Not supported (default)
+# 1 = Supported
+#
+# SU Beamformee Capable: [SU-BEAMFORMEE]
+# Indicates support for operation as a single user beamformee
+# 0 = Not supported (default)
+# 1 = Supported
+#
+# Compressed Steering Number of Beamformer Antennas Supported: [BF-ANTENNA-2]
+#   Beamformee's capability indicating the maximum number of beamformer
+#   antennas the beamformee can support when sending compressed beamforming
+#   feedback
+# If SU beamformer capable, set to maximum value minus 1
+# else reserved (default)
+#
+# Number of Sounding Dimensions: [SOUNDING-DIMENSION-2]
+# Beamformer's capability indicating the maximum value of the NUM_STS parameter
+# in the TXVECTOR of a VHT NDP
+# If SU beamformer capable, set to maximum value minus 1
+# else reserved (default)
+#
+# MU Beamformer Capable: [MU-BEAMFORMER]
+# Indicates support for operation as an MU beamformer
+# 0 = Not supported or sent by Non-AP STA (default)
+# 1 = Supported
+#
+# MU Beamformee Capable: [MU-BEAMFORMEE]
+# Indicates support for operation as an MU beamformee
+# 0 = Not supported or sent by AP (default)
+# 1 = Supported
+#
+# VHT TXOP PS: [VHT-TXOP-PS]
+# Indicates whether or not the AP supports VHT TXOP Power Save Mode
+#  or whether or not the STA is in VHT TXOP Power Save mode
+# 0 = VHT AP doesnt support VHT TXOP PS mode (OR) VHT Sta not in VHT TXOP PS
+#  mode
+# 1 = VHT AP supports VHT TXOP PS mode (OR) VHT Sta is in VHT TXOP power save
+#  mode
+#
+# +HTC-VHT Capable: [HTC-VHT]
+# Indicates whether or not the STA supports receiving a VHT variant HT Control
+# field.
+# 0 = Not supported (default)
+# 1 = supported
+#
+# Maximum A-MPDU Length Exponent: [MAX-A-MPDU-LEN-EXP0]..[MAX-A-MPDU-LEN-EXP7]
+# Indicates the maximum length of A-MPDU pre-EOF padding that the STA can recv
+# This field is an integer in the range of 0 to 7.
+# The length defined by this field is equal to
+# 2 pow(13 + Maximum A-MPDU Length Exponent) -1 octets
+#
+# VHT Link Adaptation Capable: [VHT-LINK-ADAPT2] [VHT-LINK-ADAPT3]
+# Indicates whether or not the STA supports link adaptation using VHT variant
+# HT Control field
+# If +HTC-VHTcapable is 1
+#  0 = (no feedback) if the STA does not provide VHT MFB (default)
+#  1 = reserved
+#  2 = (Unsolicited) if the STA provides only unsolicited VHT MFB
+#  3 = (Both) if the STA can provide VHT MFB in response to VHT MRQ and if the
+#      STA provides unsolicited VHT MFB
+# Reserved if +HTC-VHTcapable is 0
+#
+# Rx Antenna Pattern Consistency: [RX-ANTENNA-PATTERN]
+# Indicates the possibility of Rx antenna pattern change
+# 0 = Rx antenna pattern might change during the lifetime of an association
+# 1 = Rx antenna pattern does not change during the lifetime of an association
+#
+# Tx Antenna Pattern Consistency: [TX-ANTENNA-PATTERN]
+# Indicates the possibility of Tx antenna pattern change
+# 0 = Tx antenna pattern might change during the lifetime of an association
+# 1 = Tx antenna pattern does not change during the lifetime of an association
+#vht_capab=[SHORT-GI-80][HTC-VHT]
+#
+# Require stations to support VHT PHY (reject association if they do not)
+#require_vht=1
+
+# 0 = 20 or 40 MHz operating Channel width
+# 1 = 80 MHz channel width
+# 2 = 160 MHz channel width
+# 3 = 80+80 MHz channel width
+#vht_oper_chwidth=1
+#
+# center freq = 5 GHz + (5 * index)
+# So index 42 gives center freq 5.210 GHz
+# which is channel 42 in 5G band
+#
+#vht_oper_centr_freq_seg0_idx=42
+#
+# center freq = 5 GHz + (5 * index)
+# So index 159 gives center freq 5.795 GHz
+# which is channel 159 in 5G band
+#
+#vht_oper_centr_freq_seg1_idx=159
+
+##### IEEE 802.1X-2004 related configuration ##################################
+
+# Require IEEE 802.1X authorization
+#ieee8021x=1
+
+# IEEE 802.1X/EAPOL version
+# hostapd is implemented based on IEEE Std 802.1X-2004 which defines EAPOL
+# version 2. However, there are many client implementations that do not handle
+# the new version number correctly (they seem to drop the frames completely).
+# In order to make hostapd interoperate with these clients, the version number
+# can be set to the older version (1) with this configuration value.
+#eapol_version=2
+
+# Optional displayable message sent with EAP Request-Identity. The first \0
+# in this string will be converted to ASCII-0 (nul). This can be used to
+# separate network info (comma separated list of attribute=value pairs); see,
+# e.g., RFC 4284.
+#eap_message=hello
+#eap_message=hello\0networkid=netw,nasid=foo,portid=0,NAIRealms=example.com
+
+# WEP rekeying (disabled if key lengths are not set or are set to 0)
+# Key lengths for default/broadcast and individual/unicast keys:
+# 5 = 40-bit WEP (also known as 64-bit WEP with 40 secret bits)
+# 13 = 104-bit WEP (also known as 128-bit WEP with 104 secret bits)
+#wep_key_len_broadcast=5
+#wep_key_len_unicast=5
+# Rekeying period in seconds. 0 = do not rekey (i.e., set keys only once)
+#wep_rekey_period=300
+
+# EAPOL-Key index workaround (set bit7) for WinXP Supplicant (needed only if
+# only broadcast keys are used)
+eapol_key_index_workaround=0
+
+# EAP reauthentication period in seconds (default: 3600 seconds; 0 = disable
+# reauthentication).
+#eap_reauth_period=3600
+
+# Use PAE group address (01:80:c2:00:00:03) instead of individual target
+# address when sending EAPOL frames with driver=wired. This is the most common
+# mechanism used in wired authentication, but it also requires that the port
+# is only used by one station.
+#use_pae_group_addr=1
+
+##### Integrated EAP server ###################################################
+
+# Optionally, hostapd can be configured to use an integrated EAP server
+# to process EAP authentication locally without need for an external RADIUS
+# server. This functionality can be used both as a local authentication server
+# for IEEE 802.1X/EAPOL and as a RADIUS server for other devices.
+
+# Use integrated EAP server instead of external RADIUS authentication
+# server. This is also needed if hostapd is configured to act as a RADIUS
+# authentication server.
+eap_server=0
+
+# Path for EAP server user database
+# If SQLite support is included, this can be set to "sqlite:/path/to/sqlite.db"
+# to use SQLite database instead of a text file.
+#eap_user_file=/etc/hostapd.eap_user
+
+# CA certificate (PEM or DER file) for EAP-TLS/PEAP/TTLS
+#ca_cert=/etc/hostapd.ca.pem
+
+# Server certificate (PEM or DER file) for EAP-TLS/PEAP/TTLS
+#server_cert=/etc/hostapd.server.pem
+
+# Private key matching with the server certificate for EAP-TLS/PEAP/TTLS
+# This may point to the same file as server_cert if both certificate and key
+# are included in a single file. PKCS#12 (PFX) file (.p12/.pfx) can also be
+# used by commenting out server_cert and specifying the PFX file as the
+# private_key.
+#private_key=/etc/hostapd.server.prv
+
+# Passphrase for private key
+#private_key_passwd=secret passphrase
+
+# Server identity
+# EAP methods that provide mechanism for authenticated server identity delivery
+# use this value. If not set, "hostapd" is used as a default.
+#server_id=server.example.com
+
+# Enable CRL verification.
+# Note: hostapd does not yet support CRL downloading based on CDP. Thus, a
+# valid CRL signed by the CA is required to be included in the ca_cert file.
+# This can be done by using PEM format for CA certificate and CRL and
+# concatenating these into one file. Whenever CRL changes, hostapd needs to be
+# restarted to take the new CRL into use.
+# 0 = do not verify CRLs (default)
+# 1 = check the CRL of the user certificate
+# 2 = check all CRLs in the certificate path
+#check_crl=1
+
+# Cached OCSP stapling response (DER encoded)
+# If set, this file is sent as a certificate status response by the EAP server
+# if the EAP peer requests certificate status in the ClientHello message.
+# This cache file can be updated, e.g., by running following command
+# periodically to get an update from the OCSP responder:
+# openssl ocsp \
+#	-no_nonce \
+#	-CAfile /etc/hostapd.ca.pem \
+#	-issuer /etc/hostapd.ca.pem \
+#	-cert /etc/hostapd.server.pem \
+#	-url http://ocsp.example.com:8888/ \
+#	-respout /tmp/ocsp-cache.der
+#ocsp_stapling_response=/tmp/ocsp-cache.der
+
+# dh_file: File path to DH/DSA parameters file (in PEM format)
+# This is an optional configuration file for setting parameters for an
+# ephemeral DH key exchange. In most cases, the default RSA authentication does
+# not use this configuration. However, it is possible setup RSA to use
+# ephemeral DH key exchange. In addition, ciphers with DSA keys always use
+# ephemeral DH keys. This can be used to achieve forward secrecy. If the file
+# is in DSA parameters format, it will be automatically converted into DH
+# params. This parameter is required if anonymous EAP-FAST is used.
+# You can generate DH parameters file with OpenSSL, e.g.,
+# "openssl dhparam -out /etc/hostapd.dh.pem 1024"
+#dh_file=/etc/hostapd.dh.pem
+
+# Fragment size for EAP methods
+#fragment_size=1400
+
+# Finite cyclic group for EAP-pwd. Number maps to group of domain parameters
+# using the IANA repository for IKE (RFC 2409).
+#pwd_group=19
+
+# Configuration data for EAP-SIM database/authentication gateway interface.
+# This is a text string in implementation specific format. The example
+# implementation in eap_sim_db.c uses this as the UNIX domain socket name for
+# the HLR/AuC gateway (e.g., hlr_auc_gw). In this case, the path uses "unix:"
+# prefix. If hostapd is built with SQLite support (CONFIG_SQLITE=y in .config),
+# database file can be described with an optional db=<path> parameter.
+#eap_sim_db=unix:/tmp/hlr_auc_gw.sock
+#eap_sim_db=unix:/tmp/hlr_auc_gw.sock db=/tmp/hostapd.db
+
+# Encryption key for EAP-FAST PAC-Opaque values. This key must be a secret,
+# random value. It is configured as a 16-octet value in hex format. It can be
+# generated, e.g., with the following command:
+# od -tx1 -v -N16 /dev/random | colrm 1 8 | tr -d ' '
+#pac_opaque_encr_key=000102030405060708090a0b0c0d0e0f
+
+# EAP-FAST authority identity (A-ID)
+# A-ID indicates the identity of the authority that issues PACs. The A-ID
+# should be unique across all issuing servers. In theory, this is a variable
+# length field, but due to some existing implementations requiring A-ID to be
+# 16 octets in length, it is strongly recommended to use that length for the
+# field to provid interoperability with deployed peer implementations. This
+# field is configured in hex format.
+#eap_fast_a_id=101112131415161718191a1b1c1d1e1f
+
+# EAP-FAST authority identifier information (A-ID-Info)
+# This is a user-friendly name for the A-ID. For example, the enterprise name
+# and server name in a human-readable format. This field is encoded as UTF-8.
+#eap_fast_a_id_info=test server
+
+# Enable/disable different EAP-FAST provisioning modes:
+#0 = provisioning disabled
+#1 = only anonymous provisioning allowed
+#2 = only authenticated provisioning allowed
+#3 = both provisioning modes allowed (default)
+#eap_fast_prov=3
+
+# EAP-FAST PAC-Key lifetime in seconds (hard limit)
+#pac_key_lifetime=604800
+
+# EAP-FAST PAC-Key refresh time in seconds (soft limit on remaining hard
+# limit). The server will generate a new PAC-Key when this number of seconds
+# (or fewer) of the lifetime remains.
+#pac_key_refresh_time=86400
+
+# EAP-SIM and EAP-AKA protected success/failure indication using AT_RESULT_IND
+# (default: 0 = disabled).
+#eap_sim_aka_result_ind=1
+
+# Trusted Network Connect (TNC)
+# If enabled, TNC validation will be required before the peer is allowed to
+# connect. Note: This is only used with EAP-TTLS and EAP-FAST. If any other
+# EAP method is enabled, the peer will be allowed to connect without TNC.
+#tnc=1
+
+
+##### IEEE 802.11f - Inter-Access Point Protocol (IAPP) #######################
+
+# Interface to be used for IAPP broadcast packets
+#iapp_interface=eth0
+
+
+##### RADIUS client configuration #############################################
+# for IEEE 802.1X with external Authentication Server, IEEE 802.11
+# authentication with external ACL for MAC addresses, and accounting
+
+# The own IP address of the access point (used as NAS-IP-Address)
+own_ip_addr=192.168.100.1
+
+# Optional NAS-Identifier string for RADIUS messages. When used, this should be
+# a unique to the NAS within the scope of the RADIUS server. For example, a
+# fully qualified domain name can be used here.
+# When using IEEE 802.11r, nas_identifier must be set and must be between 1 and
+# 48 octets long.
+#nas_identifier=ap.example.com
+
+# RADIUS authentication server
+#auth_server_addr=127.0.0.1
+#auth_server_port=1812
+#auth_server_shared_secret=secret
+
+# RADIUS accounting server
+#acct_server_addr=127.0.0.1
+#acct_server_port=1813
+#acct_server_shared_secret=secret
+
+# Secondary RADIUS servers; to be used if primary one does not reply to
+# RADIUS packets. These are optional and there can be more than one secondary
+# server listed.
+#auth_server_addr=127.0.0.2
+#auth_server_port=1812
+#auth_server_shared_secret=secret2
+#
+#acct_server_addr=127.0.0.2
+#acct_server_port=1813
+#acct_server_shared_secret=secret2
+
+# Retry interval for trying to return to the primary RADIUS server (in
+# seconds). RADIUS client code will automatically try to use the next server
+# when the current server is not replying to requests. If this interval is set,
+# primary server will be retried after configured amount of time even if the
+# currently used secondary server is still working.
+#radius_retry_primary_interval=600
+
+
+# Interim accounting update interval
+# If this is set (larger than 0) and acct_server is configured, hostapd will
+# send interim accounting updates every N seconds. Note: if set, this overrides
+# possible Acct-Interim-Interval attribute in Access-Accept message. Thus, this
+# value should not be configured in hostapd.conf, if RADIUS server is used to
+# control the interim interval.
+# This value should not be less 600 (10 minutes) and must not be less than
+# 60 (1 minute).
+#radius_acct_interim_interval=600
+
+# Request Chargeable-User-Identity (RFC 4372)
+# This parameter can be used to configure hostapd to request CUI from the
+# RADIUS server by including Chargeable-User-Identity attribute into
+# Access-Request packets.
+#radius_request_cui=1
+
+# Dynamic VLAN mode; allow RADIUS authentication server to decide which VLAN
+# is used for the stations. This information is parsed from following RADIUS
+# attributes based on RFC 3580 and RFC 2868: Tunnel-Type (value 13 = VLAN),
+# Tunnel-Medium-Type (value 6 = IEEE 802), Tunnel-Private-Group-ID (value
+# VLANID as a string). Optionally, the local MAC ACL list (accept_mac_file) can
+# be used to set static client MAC address to VLAN ID mapping.
+# 0 = disabled (default)
+# 1 = option; use default interface if RADIUS server does not include VLAN ID
+# 2 = required; reject authentication if RADIUS server does not include VLAN ID
+#dynamic_vlan=0
+
+# VLAN interface list for dynamic VLAN mode is read from a separate text file.
+# This list is used to map VLAN ID from the RADIUS server to a network
+# interface. Each station is bound to one interface in the same way as with
+# multiple BSSIDs or SSIDs. Each line in this text file is defining a new
+# interface and the line must include VLAN ID and interface name separated by
+# white space (space or tab).
+# If no entries are provided by this file, the station is statically mapped
+# to <bss-iface>.<vlan-id> interfaces.
+#vlan_file=/etc/hostapd.vlan
+
+# Interface where 802.1q tagged packets should appear when a RADIUS server is
+# used to determine which VLAN a station is on.  hostapd creates a bridge for
+# each VLAN.  Then hostapd adds a VLAN interface (associated with the interface
+# indicated by 'vlan_tagged_interface') and the appropriate wireless interface
+# to the bridge.
+#vlan_tagged_interface=eth0
+
+# Bridge (prefix) to add the wifi and the tagged interface to. This gets the
+# VLAN ID appended. It defaults to brvlan%d if no tagged interface is given
+# and br%s.%d if a tagged interface is given, provided %s = tagged interface
+# and %d = VLAN ID.
+#vlan_bridge=brvlan
+
+# When hostapd creates a VLAN interface on vlan_tagged_interfaces, it needs
+# to know how to name it.
+# 0 = vlan<XXX>, e.g., vlan1
+# 1 = <vlan_tagged_interface>.<XXX>, e.g. eth0.1
+#vlan_naming=0
+
+# Arbitrary RADIUS attributes can be added into Access-Request and
+# Accounting-Request packets by specifying the contents of the attributes with
+# the following configuration parameters. There can be multiple of these to
+# add multiple attributes. These parameters can also be used to override some
+# of the attributes added automatically by hostapd.
+# Format: <attr_id>[:<syntax:value>]
+# attr_id: RADIUS attribute type (e.g., 26 = Vendor-Specific)
+# syntax: s = string (UTF-8), d = integer, x = octet string
+# value: attribute value in format indicated by the syntax
+# If syntax and value parts are omitted, a null value (single 0x00 octet) is
+# used.
+#
+# Additional Access-Request attributes
+# radius_auth_req_attr=<attr_id>[:<syntax:value>]
+# Examples:
+# Operator-Name = "Operator"
+#radius_auth_req_attr=126:s:Operator
+# Service-Type = Framed (2)
+#radius_auth_req_attr=6:d:2
+# Connect-Info = "testing" (this overrides the automatically generated value)
+#radius_auth_req_attr=77:s:testing
+# Same Connect-Info value set as a hexdump
+#radius_auth_req_attr=77:x:74657374696e67
+
+#
+# Additional Accounting-Request attributes
+# radius_acct_req_attr=<attr_id>[:<syntax:value>]
+# Examples:
+# Operator-Name = "Operator"
+#radius_acct_req_attr=126:s:Operator
+
+# Dynamic Authorization Extensions (RFC 5176)
+# This mechanism can be used to allow dynamic changes to user session based on
+# commands from a RADIUS server (or some other disconnect client that has the
+# needed session information). For example, Disconnect message can be used to
+# request an associated station to be disconnected.
+#
+# This is disabled by default. Set radius_das_port to non-zero UDP port
+# number to enable.
+#radius_das_port=3799
+#
+# DAS client (the host that can send Disconnect/CoA requests) and shared secret
+#radius_das_client=192.168.1.123 shared secret here
+#
+# DAS Event-Timestamp time window in seconds
+#radius_das_time_window=300
+#
+# DAS require Event-Timestamp
+#radius_das_require_event_timestamp=1
+
+##### RADIUS authentication server configuration ##############################
+
+# hostapd can be used as a RADIUS authentication server for other hosts. This
+# requires that the integrated EAP server is also enabled and both
+# authentication services are sharing the same configuration.
+
+# File name of the RADIUS clients configuration for the RADIUS server. If this
+# commented out, RADIUS server is disabled.
+#radius_server_clients=/etc/hostapd.radius_clients
+
+# The UDP port number for the RADIUS authentication server
+#radius_server_auth_port=1812
+
+# The UDP port number for the RADIUS accounting server
+# Commenting this out or setting this to 0 can be used to disable RADIUS
+# accounting while still enabling RADIUS authentication.
+#radius_server_acct_port=1813
+
+# Use IPv6 with RADIUS server (IPv4 will also be supported using IPv6 API)
+#radius_server_ipv6=1
+
+
+##### WPA/IEEE 802.11i configuration ##########################################
+
+# Enable WPA. Setting this variable configures the AP to require WPA (either
+# WPA-PSK or WPA-RADIUS/EAP based on other configuration). For WPA-PSK, either
+# wpa_psk or wpa_passphrase must be set and wpa_key_mgmt must include WPA-PSK.
+# Instead of wpa_psk / wpa_passphrase, wpa_psk_radius might suffice.
+# For WPA-RADIUS/EAP, ieee8021x must be set (but without dynamic WEP keys),
+# RADIUS authentication server must be configured, and WPA-EAP must be included
+# in wpa_key_mgmt.
+# This field is a bit field that can be used to enable WPA (IEEE 802.11i/D3.0)
+# and/or WPA2 (full IEEE 802.11i/RSN):
+# bit0 = WPA
+# bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled)
+#wpa=1
+
+# WPA pre-shared keys for WPA-PSK. This can be either entered as a 256-bit
+# secret in hex format (64 hex digits), wpa_psk, or as an ASCII passphrase
+# (8..63 characters) that will be converted to PSK. This conversion uses SSID
+# so the PSK changes when ASCII passphrase is used and the SSID is changed.
+# wpa_psk (dot11RSNAConfigPSKValue)
+# wpa_passphrase (dot11RSNAConfigPSKPassPhrase)
+#wpa_psk=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
+#wpa_passphrase=secret passphrase
+
+# Optionally, WPA PSKs can be read from a separate text file (containing list
+# of (PSK,MAC address) pairs. This allows more than one PSK to be configured.
+# Use absolute path name to make sure that the files can be read on SIGHUP
+# configuration reloads.
+#wpa_psk_file=/etc/hostapd.wpa_psk
+
+# Optionally, WPA passphrase can be received from RADIUS authentication server
+# This requires macaddr_acl to be set to 2 (RADIUS)
+# 0 = disabled (default)
+# 1 = optional; use default passphrase/psk if RADIUS server does not include
+#	Tunnel-Password
+# 2 = required; reject authentication if RADIUS server does not include
+#	Tunnel-Password
+#wpa_psk_radius=0
+
+# Set of accepted key management algorithms (WPA-PSK, WPA-EAP, or both). The
+# entries are separated with a space. WPA-PSK-SHA256 and WPA-EAP-SHA256 can be
+# added to enable SHA256-based stronger algorithms.
+# (dot11RSNAConfigAuthenticationSuitesTable)
+#wpa_key_mgmt=WPA-PSK WPA-EAP
+
+# Set of accepted cipher suites (encryption algorithms) for pairwise keys
+# (unicast packets). This is a space separated list of algorithms:
+# CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
+# TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
+# Group cipher suite (encryption algorithm for broadcast and multicast frames)
+# is automatically selected based on this configuration. If only CCMP is
+# allowed as the pairwise cipher, group cipher will also be CCMP. Otherwise,
+# TKIP will be used as the group cipher.
+# (dot11RSNAConfigPairwiseCiphersTable)
+# Pairwise cipher for WPA (v1) (default: TKIP)
+#wpa_pairwise=TKIP CCMP
+# Pairwise cipher for RSN/WPA2 (default: use wpa_pairwise value)
+#rsn_pairwise=CCMP
+
+# Time interval for rekeying GTK (broadcast/multicast encryption keys) in
+# seconds. (dot11RSNAConfigGroupRekeyTime)
+#wpa_group_rekey=600
+
+# Rekey GTK when any STA that possesses the current GTK is leaving the BSS.
+# (dot11RSNAConfigGroupRekeyStrict)
+#wpa_strict_rekey=1
+
+# Time interval for rekeying GMK (master key used internally to generate GTKs
+# (in seconds).
+#wpa_gmk_rekey=86400
+
+# Maximum lifetime for PTK in seconds. This can be used to enforce rekeying of
+# PTK to mitigate some attacks against TKIP deficiencies.
+#wpa_ptk_rekey=600
+
+# Enable IEEE 802.11i/RSN/WPA2 pre-authentication. This is used to speed up
+# roaming be pre-authenticating IEEE 802.1X/EAP part of the full RSN
+# authentication and key handshake before actually associating with a new AP.
+# (dot11RSNAPreauthenticationEnabled)
+#rsn_preauth=1
+#
+# Space separated list of interfaces from which pre-authentication frames are
+# accepted (e.g., 'eth0' or 'eth0 wlan0wds0'. This list should include all
+# interface that are used for connections to other APs. This could include
+# wired interfaces and WDS links. The normal wireless data interface towards
+# associated stations (e.g., wlan0) should not be added, since
+# pre-authentication is only used with APs other than the currently associated
+# one.
+#rsn_preauth_interfaces=eth0
+
+# peerkey: Whether PeerKey negotiation for direct links (IEEE 802.11e) is
+# allowed. This is only used with RSN/WPA2.
+# 0 = disabled (default)
+# 1 = enabled
+#peerkey=1
+
+# ieee80211w: Whether management frame protection (MFP) is enabled
+# 0 = disabled (default)
+# 1 = optional
+# 2 = required
+#ieee80211w=0
+
+# Group management cipher suite
+# Default: AES-128-CMAC (BIP)
+# Other options (depending on driver support):
+# BIP-GMAC-128
+# BIP-GMAC-256
+# BIP-CMAC-256
+# Note: All the stations connecting to the BSS will also need to support the
+# selected cipher. The default AES-128-CMAC is the only option that is commonly
+# available in deployed devices.
+#group_mgmt_cipher=AES-128-CMAC
+
+# Association SA Query maximum timeout (in TU = 1.024 ms; for MFP)
+# (maximum time to wait for a SA Query response)
+# dot11AssociationSAQueryMaximumTimeout, 1...4294967295
+#assoc_sa_query_max_timeout=1000
+
+# Association SA Query retry timeout (in TU = 1.024 ms; for MFP)
+# (time between two subsequent SA Query requests)
+# dot11AssociationSAQueryRetryTimeout, 1...4294967295
+#assoc_sa_query_retry_timeout=201
+
+# disable_pmksa_caching: Disable PMKSA caching
+# This parameter can be used to disable caching of PMKSA created through EAP
+# authentication. RSN preauthentication may still end up using PMKSA caching if
+# it is enabled (rsn_preauth=1).
+# 0 = PMKSA caching enabled (default)
+# 1 = PMKSA caching disabled
+#disable_pmksa_caching=0
+
+# okc: Opportunistic Key Caching (aka Proactive Key Caching)
+# Allow PMK cache to be shared opportunistically among configured interfaces
+# and BSSes (i.e., all configurations within a single hostapd process).
+# 0 = disabled (default)
+# 1 = enabled
+#okc=1
+
+# SAE threshold for anti-clogging mechanism (dot11RSNASAEAntiCloggingThreshold)
+# This parameter defines how many open SAE instances can be in progress at the
+# same time before the anti-clogging mechanism is taken into use.
+#sae_anti_clogging_threshold=5
+
+# Enabled SAE finite cyclic groups
+# SAE implementation are required to support group 19 (ECC group defined over a
+# 256-bit prime order field). All groups that are supported by the
+# implementation are enabled by default. This configuration parameter can be
+# used to specify a limited set of allowed groups. The group values are listed
+# in the IANA registry:
+# http://www.iana.org/assignments/ipsec-registry/ipsec-registry.xml#ipsec-registry-9
+#sae_groups=19 20 21 25 26
+
+##### IEEE 802.11r configuration ##############################################
+
+# Mobility Domain identifier (dot11FTMobilityDomainID, MDID)
+# MDID is used to indicate a group of APs (within an ESS, i.e., sharing the
+# same SSID) between which a STA can use Fast BSS Transition.
+# 2-octet identifier as a hex string.
+#mobility_domain=a1b2
+
+# PMK-R0 Key Holder identifier (dot11FTR0KeyHolderID)
+# 1 to 48 octet identifier.
+# This is configured with nas_identifier (see RADIUS client section above).
+
+# Default lifetime of the PMK-RO in minutes; range 1..65535
+# (dot11FTR0KeyLifetime)
+#r0_key_lifetime=10000
+
+# PMK-R1 Key Holder identifier (dot11FTR1KeyHolderID)
+# 6-octet identifier as a hex string.
+#r1_key_holder=000102030405
+
+# Reassociation deadline in time units (TUs / 1.024 ms; range 1000..65535)
+# (dot11FTReassociationDeadline)
+#reassociation_deadline=1000
+
+# List of R0KHs in the same Mobility Domain
+# format: <MAC address> <NAS Identifier> <128-bit key as hex string>
+# This list is used to map R0KH-ID (NAS Identifier) to a destination MAC
+# address when requesting PMK-R1 key from the R0KH that the STA used during the
+# Initial Mobility Domain Association.
+#r0kh=02:01:02:03:04:05 r0kh-1.example.com 000102030405060708090a0b0c0d0e0f
+#r0kh=02:01:02:03:04:06 r0kh-2.example.com 00112233445566778899aabbccddeeff
+# And so on.. One line per R0KH.
+
+# List of R1KHs in the same Mobility Domain
+# format: <MAC address> <R1KH-ID> <128-bit key as hex string>
+# This list is used to map R1KH-ID to a destination MAC address when sending
+# PMK-R1 key from the R0KH. This is also the list of authorized R1KHs in the MD
+# that can request PMK-R1 keys.
+#r1kh=02:01:02:03:04:05 02:11:22:33:44:55 000102030405060708090a0b0c0d0e0f
+#r1kh=02:01:02:03:04:06 02:11:22:33:44:66 00112233445566778899aabbccddeeff
+# And so on.. One line per R1KH.
+
+# Whether PMK-R1 push is enabled at R0KH
+# 0 = do not push PMK-R1 to all configured R1KHs (default)
+# 1 = push PMK-R1 to all configured R1KHs whenever a new PMK-R0 is derived
+#pmk_r1_push=1
+
+##### Neighbor table ##########################################################
+# Maximum number of entries kept in AP table (either for neigbor table or for
+# detecting Overlapping Legacy BSS Condition). The oldest entry will be
+# removed when adding a new entry that would make the list grow over this
+# limit. Note! WFA certification for IEEE 802.11g requires that OLBC is
+# enabled, so this field should not be set to 0 when using IEEE 802.11g.
+# default: 255
+#ap_table_max_size=255
+
+# Number of seconds of no frames received after which entries may be deleted
+# from the AP table. Since passive scanning is not usually performed frequently
+# this should not be set to very small value. In addition, there is no
+# guarantee that every scan cycle will receive beacon frames from the
+# neighboring APs.
+# default: 60
+#ap_table_expiration_time=3600
+
+
+##### Wi-Fi Protected Setup (WPS) #############################################
+
+# WPS state
+# 0 = WPS disabled (default)
+# 1 = WPS enabled, not configured
+# 2 = WPS enabled, configured
+#wps_state=2
+
+# Whether to manage this interface independently from other WPS interfaces
+# By default, a single hostapd process applies WPS operations to all configured
+# interfaces. This parameter can be used to disable that behavior for a subset
+# of interfaces. If this is set to non-zero for an interface, WPS commands
+# issued on that interface do not apply to other interfaces and WPS operations
+# performed on other interfaces do not affect this interface.
+#wps_independent=0
+
+# AP can be configured into a locked state where new WPS Registrar are not
+# accepted, but previously authorized Registrars (including the internal one)
+# can continue to add new Enrollees.
+#ap_setup_locked=1
+
+# Universally Unique IDentifier (UUID; see RFC 4122) of the device
+# This value is used as the UUID for the internal WPS Registrar. If the AP
+# is also using UPnP, this value should be set to the device's UPnP UUID.
+# If not configured, UUID will be generated based on the local MAC address.
+#uuid=12345678-9abc-def0-1234-56789abcdef0
+
+# Note: If wpa_psk_file is set, WPS is used to generate random, per-device PSKs
+# that will be appended to the wpa_psk_file. If wpa_psk_file is not set, the
+# default PSK (wpa_psk/wpa_passphrase) will be delivered to Enrollees. Use of
+# per-device PSKs is recommended as the more secure option (i.e., make sure to
+# set wpa_psk_file when using WPS with WPA-PSK).
+
+# When an Enrollee requests access to the network with PIN method, the Enrollee
+# PIN will need to be entered for the Registrar. PIN request notifications are
+# sent to hostapd ctrl_iface monitor. In addition, they can be written to a
+# text file that could be used, e.g., to populate the AP administration UI with
+# pending PIN requests. If the following variable is set, the PIN requests will
+# be written to the configured file.
+#wps_pin_requests=/var/run/hostapd_wps_pin_requests
+
+# Device Name
+# User-friendly description of device; up to 32 octets encoded in UTF-8
+#device_name=Wireless AP
+
+# Manufacturer
+# The manufacturer of the device (up to 64 ASCII characters)
+#manufacturer=Company
+
+# Model Name
+# Model of the device (up to 32 ASCII characters)
+#model_name=WAP
+
+# Model Number
+# Additional device description (up to 32 ASCII characters)
+#model_number=123
+
+# Serial Number
+# Serial number of the device (up to 32 characters)
+#serial_number=12345
+
+# Primary Device Type
+# Used format: <categ>-<OUI>-<subcateg>
+# categ = Category as an integer value
+# OUI = OUI and type octet as a 4-octet hex-encoded value; 0050F204 for
+#       default WPS OUI
+# subcateg = OUI-specific Sub Category as an integer value
+# Examples:
+#   1-0050F204-1 (Computer / PC)
+#   1-0050F204-2 (Computer / Server)
+#   5-0050F204-1 (Storage / NAS)
+#   6-0050F204-1 (Network Infrastructure / AP)
+#device_type=6-0050F204-1
+
+# OS Version
+# 4-octet operating system version number (hex string)
+#os_version=01020300
+
+# Config Methods
+# List of the supported configuration methods
+# Available methods: usba ethernet label display ext_nfc_token int_nfc_token
+#	nfc_interface push_button keypad virtual_display physical_display
+#	virtual_push_button physical_push_button
+#config_methods=label virtual_display virtual_push_button keypad
+
+# WPS capability discovery workaround for PBC with Windows 7
+# Windows 7 uses incorrect way of figuring out AP's WPS capabilities by acting
+# as a Registrar and using M1 from the AP. The config methods attribute in that
+# message is supposed to indicate only the configuration method supported by
+# the AP in Enrollee role, i.e., to add an external Registrar. For that case,
+# PBC shall not be used and as such, the PushButton config method is removed
+# from M1 by default. If pbc_in_m1=1 is included in the configuration file,
+# the PushButton config method is left in M1 (if included in config_methods
+# parameter) to allow Windows 7 to use PBC instead of PIN (e.g., from a label
+# in the AP).
+#pbc_in_m1=1
+
+# Static access point PIN for initial configuration and adding Registrars
+# If not set, hostapd will not allow external WPS Registrars to control the
+# access point. The AP PIN can also be set at runtime with hostapd_cli
+# wps_ap_pin command. Use of temporary (enabled by user action) and random
+# AP PIN is much more secure than configuring a static AP PIN here. As such,
+# use of the ap_pin parameter is not recommended if the AP device has means for
+# displaying a random PIN.
+#ap_pin=12345670
+
+# Skip building of automatic WPS credential
+# This can be used to allow the automatically generated Credential attribute to
+# be replaced with pre-configured Credential(s).
+#skip_cred_build=1
+
+# Additional Credential attribute(s)
+# This option can be used to add pre-configured Credential attributes into M8
+# message when acting as a Registrar. If skip_cred_build=1, this data will also
+# be able to override the Credential attribute that would have otherwise been
+# automatically generated based on network configuration. This configuration
+# option points to an external file that much contain the WPS Credential
+# attribute(s) as binary data.
+#extra_cred=hostapd.cred
+
+# Credential processing
+#   0 = process received credentials internally (default)
+#   1 = do not process received credentials; just pass them over ctrl_iface to
+#	external program(s)
+#   2 = process received credentials internally and pass them over ctrl_iface
+#	to external program(s)
+# Note: With wps_cred_processing=1, skip_cred_build should be set to 1 and
+# extra_cred be used to provide the Credential data for Enrollees.
+#
+# wps_cred_processing=1 will disabled automatic updates of hostapd.conf file
+# both for Credential processing and for marking AP Setup Locked based on
+# validation failures of AP PIN. An external program is responsible on updating
+# the configuration appropriately in this case.
+#wps_cred_processing=0
+
+# AP Settings Attributes for M7
+# By default, hostapd generates the AP Settings Attributes for M7 based on the
+# current configuration. It is possible to override this by providing a file
+# with pre-configured attributes. This is similar to extra_cred file format,
+# but the AP Settings attributes are not encapsulated in a Credential
+# attribute.
+#ap_settings=hostapd.ap_settings
+
+# WPS UPnP interface
+# If set, support for external Registrars is enabled.
+#upnp_iface=br0
+
+# Friendly Name (required for UPnP)
+# Short description for end use. Should be less than 64 characters.
+#friendly_name=WPS Access Point
+
+# Manufacturer URL (optional for UPnP)
+#manufacturer_url=http://www.example.com/
+
+# Model Description (recommended for UPnP)
+# Long description for end user. Should be less than 128 characters.
+#model_description=Wireless Access Point
+
+# Model URL (optional for UPnP)
+#model_url=http://www.example.com/model/
+
+# Universal Product Code (optional for UPnP)
+# 12-digit, all-numeric code that identifies the consumer package.
+#upc=123456789012
+
+# WPS RF Bands (a = 5G, b = 2.4G, g = 2.4G, ag = dual band)
+# This value should be set according to RF band(s) supported by the AP if
+# hw_mode is not set. For dual band dual concurrent devices, this needs to be
+# set to ag to allow both RF bands to be advertized.
+#wps_rf_bands=ag
+
+# NFC password token for WPS
+# These parameters can be used to configure a fixed NFC password token for the
+# AP. This can be generated, e.g., with nfc_pw_token from wpa_supplicant. When
+# these parameters are used, the AP is assumed to be deployed with a NFC tag
+# that includes the matching NFC password token (e.g., written based on the
+# NDEF record from nfc_pw_token).
+#
+#wps_nfc_dev_pw_id: Device Password ID (16..65535)
+#wps_nfc_dh_pubkey: Hexdump of DH Public Key
+#wps_nfc_dh_privkey: Hexdump of DH Private Key
+#wps_nfc_dev_pw: Hexdump of Device Password
+
+##### Wi-Fi Direct (P2P) ######################################################
+
+# Enable P2P Device management
+#manage_p2p=1
+
+# Allow cross connection
+#allow_cross_connection=1
+
+#### TDLS (IEEE 802.11z-2010) #################################################
+
+# Prohibit use of TDLS in this BSS
+#tdls_prohibit=1
+
+# Prohibit use of TDLS Channel Switching in this BSS
+#tdls_prohibit_chan_switch=1
+
+##### IEEE 802.11v-2011 #######################################################
+
+# Time advertisement
+# 0 = disabled (default)
+# 2 = UTC time at which the TSF timer is 0
+#time_advertisement=2
+
+# Local time zone as specified in 8.3 of IEEE Std 1003.1-2004:
+# stdoffset[dst[offset][,start[/time],end[/time]]]
+#time_zone=EST5
+
+# WNM-Sleep Mode (extended sleep mode for stations)
+# 0 = disabled (default)
+# 1 = enabled (allow stations to use WNM-Sleep Mode)
+#wnm_sleep_mode=1
+
+# BSS Transition Management
+# 0 = disabled (default)
+# 1 = enabled
+#bss_transition=1
+
+##### IEEE 802.11u-2011 #######################################################
+
+# Enable Interworking service
+#interworking=1
+
+# Access Network Type
+# 0 = Private network
+# 1 = Private network with guest access
+# 2 = Chargeable public network
+# 3 = Free public network
+# 4 = Personal device network
+# 5 = Emergency services only network
+# 14 = Test or experimental
+# 15 = Wildcard
+#access_network_type=0
+
+# Whether the network provides connectivity to the Internet
+# 0 = Unspecified
+# 1 = Network provides connectivity to the Internet
+#internet=1
+
+# Additional Step Required for Access
+# Note: This is only used with open network, i.e., ASRA shall ne set to 0 if
+# RSN is used.
+#asra=0
+
+# Emergency services reachable
+#esr=0
+
+# Unauthenticated emergency service accessible
+#uesa=0
+
+# Venue Info (optional)
+# The available values are defined in IEEE Std 802.11u-2011, 7.3.1.34.
+# Example values (group,type):
+# 0,0 = Unspecified
+# 1,7 = Convention Center
+# 1,13 = Coffee Shop
+# 2,0 = Unspecified Business
+# 7,1  Private Residence
+#venue_group=7
+#venue_type=1
+
+# Homogeneous ESS identifier (optional; dot11HESSID)
+# If set, this shall be identifical to one of the BSSIDs in the homogeneous
+# ESS and this shall be set to the same value across all BSSs in homogeneous
+# ESS.
+#hessid=02:03:04:05:06:07
+
+# Roaming Consortium List
+# Arbitrary number of Roaming Consortium OIs can be configured with each line
+# adding a new OI to the list. The first three entries are available through
+# Beacon and Probe Response frames. Any additional entry will be available only
+# through ANQP queries. Each OI is between 3 and 15 octets and is configured as
+# a hexstring.
+#roaming_consortium=021122
+#roaming_consortium=2233445566
+
+# Venue Name information
+# This parameter can be used to configure one or more Venue Name Duples for
+# Venue Name ANQP information. Each entry has a two or three character language
+# code (ISO-639) separated by colon from the venue name string.
+# Note that venue_group and venue_type have to be set for Venue Name
+# information to be complete.
+#venue_name=eng:Example venue
+#venue_name=fin:Esimerkkipaikka
+# Alternative format for language:value strings:
+# (double quoted string, printf-escaped string)
+#venue_name=P"eng:Example\nvenue"
+
+# Network Authentication Type
+# This parameter indicates what type of network authentication is used in the
+# network.
+# format: <network auth type indicator (1-octet hex str)> [redirect URL]
+# Network Authentication Type Indicator values:
+# 00 = Acceptance of terms and conditions
+# 01 = On-line enrollment supported
+# 02 = http/https redirection
+# 03 = DNS redirection
+#network_auth_type=00
+#network_auth_type=02http://www.example.com/redirect/me/here/
+
+# IP Address Type Availability
+# format: <1-octet encoded value as hex str>
+# (ipv4_type & 0x3f) << 2 | (ipv6_type & 0x3)
+# ipv4_type:
+# 0 = Address type not available
+# 1 = Public IPv4 address available
+# 2 = Port-restricted IPv4 address available
+# 3 = Single NATed private IPv4 address available
+# 4 = Double NATed private IPv4 address available
+# 5 = Port-restricted IPv4 address and single NATed IPv4 address available
+# 6 = Port-restricted IPv4 address and double NATed IPv4 address available
+# 7 = Availability of the address type is not known
+# ipv6_type:
+# 0 = Address type not available
+# 1 = Address type available
+# 2 = Availability of the address type not known
+#ipaddr_type_availability=14
+
+# Domain Name
+# format: <variable-octet str>[,<variable-octet str>]
+#domain_name=example.com,another.example.com,yet-another.example.com
+
+# 3GPP Cellular Network information
+# format: <MCC1,MNC1>[;<MCC2,MNC2>][;...]
+#anqp_3gpp_cell_net=244,91;310,026;234,56
+
+# NAI Realm information
+# One or more realm can be advertised. Each nai_realm line adds a new realm to
+# the set. These parameters provide information for stations using Interworking
+# network selection to allow automatic connection to a network based on
+# credentials.
+# format: <encoding>,<NAI Realm(s)>[,<EAP Method 1>][,<EAP Method 2>][,...]
+# encoding:
+#	0 = Realm formatted in accordance with IETF RFC 4282
+#	1 = UTF-8 formatted character string that is not formatted in
+#	    accordance with IETF RFC 4282
+# NAI Realm(s): Semi-colon delimited NAI Realm(s)
+# EAP Method: <EAP Method>[:<[AuthParam1:Val1]>][<[AuthParam2:Val2]>][...]
+# EAP Method types, see:
+# http://www.iana.org/assignments/eap-numbers/eap-numbers.xhtml#eap-numbers-4
+# AuthParam (Table 8-188 in IEEE Std 802.11-2012):
+# ID 2 = Non-EAP Inner Authentication Type
+#	1 = PAP, 2 = CHAP, 3 = MSCHAP, 4 = MSCHAPV2
+# ID 3 = Inner authentication EAP Method Type
+# ID 5 = Credential Type
+#	1 = SIM, 2 = USIM, 3 = NFC Secure Element, 4 = Hardware Token,
+#	5 = Softoken, 6 = Certificate, 7 = username/password, 9 = Anonymous,
+#	10 = Vendor Specific
+#nai_realm=0,example.com;example.net
+# EAP methods EAP-TLS with certificate and EAP-TTLS/MSCHAPv2 with
+# username/password
+#nai_realm=0,example.org,13[5:6],21[2:4][5:7]
+
+# QoS Map Set configuration
+#
+# Comma delimited QoS Map Set in decimal values
+# (see IEEE Std 802.11-2012, 8.4.2.97)
+#
+# format:
+# [<DSCP Exceptions[DSCP,UP]>,]<UP 0 range[low,high]>,...<UP 7 range[low,high]>
+#
+# There can be up to 21 optional DSCP Exceptions which are pairs of DSCP Value
+# (0..63 or 255) and User Priority (0..7). This is followed by eight DSCP Range
+# descriptions with DSCP Low Value and DSCP High Value pairs (0..63 or 255) for
+# each UP starting from 0. If both low and high value are set to 255, the
+# corresponding UP is not used.
+#
+# default: not set
+#qos_map_set=53,2,22,6,8,15,0,7,255,255,16,31,32,39,255,255,40,47,255,255
+
+##### Hotspot 2.0 #############################################################
+
+# Enable Hotspot 2.0 support
+#hs20=1
+
+# Disable Downstream Group-Addressed Forwarding (DGAF)
+# This can be used to configure a network where no group-addressed frames are
+# allowed. The AP will not forward any group-address frames to the stations and
+# random GTKs are issued for each station to prevent associated stations from
+# forging such frames to other stations in the BSS.
+#disable_dgaf=1
+
+# OSU Server-Only Authenticated L2 Encryption Network
+#osen=1
+
+# ANQP Domain ID (0..65535)
+# An identifier for a set of APs in an ESS that share the same common ANQP
+# information. 0 = Some of the ANQP information is unique to this AP (default).
+#anqp_domain_id=1234
+
+# Deauthentication request timeout
+# If the RADIUS server indicates that the station is not allowed to connect to
+# the BSS/ESS, the AP can allow the station some time to download a
+# notification page (URL included in the message). This parameter sets that
+# timeout in seconds.
+#hs20_deauth_req_timeout=60
+
+# Operator Friendly Name
+# This parameter can be used to configure one or more Operator Friendly Name
+# Duples. Each entry has a two or three character language code (ISO-639)
+# separated by colon from the operator friendly name string.
+#hs20_oper_friendly_name=eng:Example operator
+#hs20_oper_friendly_name=fin:Esimerkkioperaattori
+
+# Connection Capability
+# This can be used to advertise what type of IP traffic can be sent through the
+# hotspot (e.g., due to firewall allowing/blocking protocols/ports).
+# format: <IP Protocol>:<Port Number>:<Status>
+# IP Protocol: 1 = ICMP, 6 = TCP, 17 = UDP
+# Port Number: 0..65535
+# Status: 0 = Closed, 1 = Open, 2 = Unknown
+# Each hs20_conn_capab line is added to the list of advertised tuples.
+#hs20_conn_capab=1:0:2
+#hs20_conn_capab=6:22:1
+#hs20_conn_capab=17:5060:0
+
+# WAN Metrics
+# format: <WAN Info>:<DL Speed>:<UL Speed>:<DL Load>:<UL Load>:<LMD>
+# WAN Info: B0-B1: Link Status, B2: Symmetric Link, B3: At Capabity
+#    (encoded as two hex digits)
+#    Link Status: 1 = Link up, 2 = Link down, 3 = Link in test state
+# Downlink Speed: Estimate of WAN backhaul link current downlink speed in kbps;
+#	1..4294967295; 0 = unknown
+# Uplink Speed: Estimate of WAN backhaul link current uplink speed in kbps
+#	1..4294967295; 0 = unknown
+# Downlink Load: Current load of downlink WAN connection (scaled to 255 = 100%)
+# Uplink Load: Current load of uplink WAN connection (scaled to 255 = 100%)
+# Load Measurement Duration: Duration for measuring downlink/uplink load in
+# tenths of a second (1..65535); 0 if load cannot be determined
+#hs20_wan_metrics=01:8000:1000:80:240:3000
+
+# Operating Class Indication
+# List of operating classes the BSSes in this ESS use. The Global operating
+# classes in Table E-4 of IEEE Std 802.11-2012 Annex E define the values that
+# can be used in this.
+# format: hexdump of operating class octets
+# for example, operating classes 81 (2.4 GHz channels 1-13) and 115 (5 GHz
+# channels 36-48):
+#hs20_operating_class=5173
+
+# OSU icons
+# <Icon Width>:<Icon Height>:<Language code>:<Icon Type>:<Name>:<file path>
+#hs20_icon=32:32:eng:image/png:icon32:/tmp/icon32.png
+#hs20_icon=64:64:eng:image/png:icon64:/tmp/icon64.png
+
+# OSU SSID (see ssid2 for format description)
+# This is the SSID used for all OSU connections to all the listed OSU Providers.
+#osu_ssid="example"
+
+# OSU Providers
+# One or more sets of following parameter. Each OSU provider is started by the
+# mandatory osu_server_uri item. The other parameters add information for the
+# last added OSU provider.
+#
+#osu_server_uri=https://example.com/osu/
+#osu_friendly_name=eng:Example operator
+#osu_friendly_name=fin:Esimerkkipalveluntarjoaja
+#osu_nai=anonymous@example.com
+#osu_method_list=1 0
+#osu_icon=icon32
+#osu_icon=icon64
+#osu_service_desc=eng:Example services
+#osu_service_desc=fin:Esimerkkipalveluja
+#
+#osu_server_uri=...
+
+##### TESTING OPTIONS #########################################################
+#
+# The options in this section are only available when the build configuration
+# option CONFIG_TESTING_OPTIONS is set while compiling hostapd. They allow
+# testing some scenarios that are otherwise difficult to reproduce.
+#
+# Ignore probe requests sent to hostapd with the given probability, must be a
+# floating point number in the range [0, 1).
+#ignore_probe_probability=0.0
+#
+# Ignore authentication frames with the given probability
+#ignore_auth_probability=0.0
+#
+# Ignore association requests with the given probability
+#ignore_assoc_probability=0.0
+#
+# Ignore reassociation requests with the given probability
+#ignore_reassoc_probability=0.0
+#
+# Corrupt Key MIC in GTK rekey EAPOL-Key frames with the given probability
+#corrupt_gtk_rekey_mic_probability=0.0
+
+##### Multiple BSSID support ##################################################
+#
+# Above configuration is using the default interface (wlan#, or multi-SSID VLAN
+# interfaces). Other BSSIDs can be added by using separator 'bss' with
+# default interface name to be allocated for the data packets of the new BSS.
+#
+# hostapd will generate BSSID mask based on the BSSIDs that are
+# configured. hostapd will verify that dev_addr & MASK == dev_addr. If this is
+# not the case, the MAC address of the radio must be changed before starting
+# hostapd (ifconfig wlan0 hw ether <MAC addr>). If a BSSID is configured for
+# every secondary BSS, this limitation is not applied at hostapd and other
+# masks may be used if the driver supports them (e.g., swap the locally
+# administered bit)
+#
+# BSSIDs are assigned in order to each BSS, unless an explicit BSSID is
+# specified using the 'bssid' parameter.
+# If an explicit BSSID is specified, it must be chosen such that it:
+# - results in a valid MASK that covers it and the dev_addr
+# - is not the same as the MAC address of the radio
+# - is not the same as any other explicitly specified BSSID
+#
+# Not all drivers support multiple BSSes. The exact mechanism for determining
+# the driver capabilities is driver specific. With the current (i.e., a recent
+# kernel) drivers using nl80211, this information can be checked with "iw list"
+# (search for "valid interface combinations").
+#
+# Please note that hostapd uses some of the values configured for the first BSS
+# as the defaults for the following BSSes. However, it is recommended that all
+# BSSes include explicit configuration of all relevant configuration items.
+#
+#bss=wlan0_0
+#ssid=test2
+# most of the above items can be used here (apart from radio interface specific
+# items, like channel)
+
+#bss=wlan0_1
+#bssid=00:13:10:95:fe:0b
+# ...
+
+bss=wlan2
+ssid=CMCC
+bridge=br0
+bssid=<bssid2>
+
+bss=wlan3
+ssid=CMCC_EDU
+bridge=br0
+bssid=<bssid3>
+
+bss=wlan4
+ssid=Starbucks WiFi
+bridge=br0
+bssid=<bssid4>
diff --git a/vendor/redroid_ext/wifi/init.redroid.wifi.sh b/vendor/redroid_ext/wifi/init.redroid.wifi.sh
new file mode 100755
index 0000000000..ec4d093304
--- /dev/null
+++ b/vendor/redroid_ext/wifi/init.redroid.wifi.sh
@@ -0,0 +1,106 @@
+#!/vendor/bin/sh
+
+# Do all the setup required for WiFi.
+# The kernel driver mac80211_hwsim has already created two virtual wifi devices
+# us. These devices are connected so that everything that's sent on one device
+# is recieved on the other and vice versa. This allows us to create a fake
+# WiFi network with an access point running inside the guest. Here is the setup
+# for that and the basics of how it works.
+#
+# Create a namespace named router and move eth0 to it. Create a virtual ethernet
+# pair of devices and move both one virtual ethernet interface and one virtual
+# wifi interface into the router namespace. Then set up NAT networking for those
+# interfaces so that traffic flowing through them reach eth0 and eventually the
+# host and the internet. The main network namespace will now only see the other
+# ends of those pipes and send traffic on them depending on if WiFi or radio is
+# used.  Finally run hostapd in the network namespace to create an access point
+# for the guest to connect to and dnsmasq to serve as a DHCP server for the WiFi
+# connection.
+#
+#          main namespace                     router namespace
+#       -------       ----------   |    ---------------
+#       | ril |<----->| radio0 |<--+--->| radio0-peer |<-------+
+#       -------       ----------   |    ---------------        |
+#                                  |            ^              |
+#                                  |            |              |
+#                                  |            v              v
+#                                  |      *************     --------
+#                                  |      * ipv6proxy *<--->| eth0 |<--+
+#                                  |      *************     --------   |
+#                                  |            ^              ^       |
+#                                  |            |              |       |
+#                                  |            v              |       |
+# ------------------   ---------   |        ---------          |       |
+# | wpa_supplicant |<->| wlan0 |<--+------->| wlan1 |<---------+       |
+# ------------------   ---------   |        ---------                  |
+#                                  |         ^     ^                   |
+#                                  |         |     |                   v
+#                                  |         v     v                --------
+#                                  | ***********  ***********       | host |
+#                                  | * hostapd *  * dnsmasq *       --------
+#                                  | ***********  ***********
+#
+
+NAMESPACE="router"
+
+# createns will have created a file that contains the process id (pid) of a
+# process running in the network namespace. This pid is needed for some commands
+# to access the namespace.
+PID=$(</data/vendor/var/run/netns/${NAMESPACE}.pid)
+
+WIFI_MAC_PREFIX=`getprop ro.boot.redroid_wifi_mac_prefix`
+if [ ! -n "$WIFI_MAC_PREFIX" ]; then WIFI_MAC_PREFIX=`expr $RANDOM % 65535`; fi
+/vendor/bin/create_radios2 2 $WIFI_MAC_PREFIX || exit 1
+
+ETH0_ADDR=$(/system/bin/ip addr show dev eth0 | grep 'inet ' | awk '{print $2,$3,$4}')
+ETH0_GW=$(/system/bin/ip route get 8.8.8.8 | head -n 1 | awk '{print $3}')
+/system/bin/ip link set eth0 netns ${PID}
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip link set eth0 up
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip addr add ${ETH0_ADDR} dev eth0
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip route add default via ${ETH0_GW} dev eth0
+
+/system/bin/ip link add radio0 type veth peer name radio0-peer netns ${PID}
+
+# Enable privacy addresses for radio0, this is done by the framework for wlan0
+sysctl -wq net.ipv6.conf.radio0.use_tempaddr=2
+
+/system/bin/ip addr add 192.168.200.2/24 broadcast 192.168.200.255 dev radio0
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip addr add 192.168.200.1/24 dev radio0-peer
+/vendor/bin/execns2 ${NAMESPACE} sysctl -wq net.ipv6.conf.all.forwarding=1
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip link set radio0-peer up
+
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip link set eth0 up
+
+# Start the ADB daemon in the router namespace
+setprop ctl.start adbd_proxy
+
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/iptables -w -W 50000 -t nat -A POSTROUTING -s 192.168.0.0/17 -o eth0 -j MASQUERADE
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/iptables -w -W 50000 -t nat -A POSTROUTING -s 192.168.200.0/24 -o eth0 -j MASQUERADE
+/system/bin/ip link set radio0 up
+
+/vendor/bin/iw phy phy$(/vendor/bin/iw dev wlan1 info | awk -F 'wiphy +' '{print $2}' | awk NF) set netns ${PID}
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip link set wlan1 up
+
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip link add name br0 type bridge
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip addr add 192.168.1.1/24 dev br0
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip link set br0 mtu 1400
+/vendor/bin/execns2 ${NAMESPACE} /system/bin/ip link set br0 up
+
+# Start the IPv6 proxy that will enable use of IPv6 in the main namespace
+setprop ctl.start ipv6proxy
+
+# Copy the hostapd configuration file to the data partition
+SED_ARGS=""
+for i in $(seq 1 10)
+    do SED_ARGS="$SED_ARGS -e 's/<bssid$i>/00:$(echo $RANDOM | md5sum | sed 's/../&:/g' | cut -c 1-14)/'"
+done
+echo sed $SED_ARGS /vendor/etc/hostapd.conf | sh > /data/vendor/wifi/hostapd/redroid_hostapd.conf
+chown wifi:wifi /data/vendor/wifi/hostapd/redroid_hostapd.conf
+chmod 660 /data/vendor/wifi/hostapd/redroid_hostapd.conf
+
+# Start hostapd, the access point software
+setprop ctl.start emu_hostapd
+
+setprop ctl.start dhcpserver
+
+ifconfig radio0 -multicast
\ No newline at end of file
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/Android.mk b/vendor/redroid_ext/wifi/ipv6proxy/Android.mk
new file mode 100644
index 0000000000..173491e50a
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/Android.mk
@@ -0,0 +1,24 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	address.cpp \
+	interface.cpp \
+	log.cpp \
+	main.cpp \
+	namespace.cpp \
+	packet.cpp \
+	proxy.cpp \
+	router.cpp \
+	socket.cpp \
+
+
+LOCAL_CPPFLAGS += -Werror
+LOCAL_SHARED_LIBRARIES := libcutils liblog
+LOCAL_PROPRIETARY_MODULE := true
+LOCAL_MODULE := ipv6proxy2
+
+LOCAL_MODULE_CLASS := EXECUTABLES
+
+include $(BUILD_EXECUTABLE)
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/address.cpp b/vendor/redroid_ext/wifi/ipv6proxy/address.cpp
new file mode 100644
index 0000000000..def9c7b8ad
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/address.cpp
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "address.h"
+
+#include <arpa/inet.h>
+#include <errno.h>
+#include <linux/if_ether.h>
+#include <linux/if_packet.h>
+#include <netdb.h>
+#include <net/if.h>
+#include <string.h>
+#include <sys/ioctl.h>
+
+#include "socket.h"
+
+std::string addrToStr(const struct in6_addr& addr) {
+    char buf[INET6_ADDRSTRLEN];
+    if (inet_ntop(AF_INET6, &addr, buf, sizeof(buf)) == nullptr) {
+        return "[unknown]";
+    }
+    return buf;
+}
+
+Address::Address() {
+    mStorage.reserve(sizeof(struct sockaddr_storage));
+}
+
+Address::Address(const struct sockaddr_nl& address)
+        : mStorage(sizeof(address)) {
+    memcpy(mStorage.data(), &address, sizeof(address));
+}
+Address::Address(const struct sockaddr_in6& address)
+        : mStorage(sizeof(address)) {
+    memcpy(mStorage.data(), &address, sizeof(address));
+}
+
+Address::Address(struct in6_addr address)
+        : mStorage(sizeof(struct sockaddr_in6)) {
+    auto sockaddr = reinterpret_cast<struct sockaddr_in6*>(mStorage.data());
+    sockaddr->sin6_family = AF_INET6;
+    sockaddr->sin6_addr = address;
+}
+
+void Address::reset() {
+    mStorage.resize(sizeof(struct sockaddr_storage));
+}
+
+Result Address::resolveInet(const std::string& address) {
+    struct addrinfo hints;
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = AF_INET6;
+    hints.ai_socktype = SOCK_RAW;
+    struct addrinfo* addrinfo;
+    int res = ::getaddrinfo(address.c_str(), nullptr, &hints, &addrinfo);
+    if (res != 0) {
+        return Result::error(gai_strerror(res));
+    }
+    mStorage.resize(addrinfo->ai_addrlen);
+    memcpy(mStorage.data(), addrinfo->ai_addr, mStorage.size());
+    freeaddrinfo(addrinfo);
+
+    return Result::success();
+}
+
+Result Address::resolveEth(const std::string& interfaceName) {
+    mStorage.resize(sizeof(struct sockaddr_ll));
+    memset(mStorage.data(), 0, mStorage.size());
+    auto addr = reinterpret_cast<struct sockaddr_ll*>(mStorage.data());
+    addr->sll_family = AF_PACKET;
+    addr->sll_protocol = htons(ETH_P_IPV6);
+
+    unsigned int index = if_nametoindex(interfaceName.c_str());
+    if (index == 0) {
+        return Result::error(strerror(errno));
+    }
+    addr->sll_ifindex = index;
+
+    struct ifreq request;
+    memset(&request, 0, sizeof(request));
+    strncpy(request.ifr_name, interfaceName.c_str(), sizeof(request.ifr_name));
+    request.ifr_name[sizeof(request.ifr_name) - 1] = '\0';
+
+    Socket socket;
+    Result res = socket.open(AF_INET, SOCK_DGRAM, IPPROTO_IP);
+    if (!res) {
+        return res;
+    }
+    int status = ::ioctl(socket.get(), SIOCGIFHWADDR, &request);
+    if (status != 0) {
+        return Result::error(strerror(errno));
+    }
+    memcpy(addr->sll_addr, request.ifr_addr.sa_data, 6);
+
+    return Result::success();
+}
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/address.h b/vendor/redroid_ext/wifi/ipv6proxy/address.h
new file mode 100644
index 0000000000..f9cec0bd3b
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/address.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "result.h"
+
+#include <linux/netlink.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <string>
+#include <vector>
+
+// Convert an IPv6 address struct to a string for debugging purposes
+std::string addrToStr(const struct in6_addr& addr);
+
+// Represents any kind of address in a struct sockaddr.
+class Address {
+public:
+    Address();
+    explicit Address(const struct sockaddr_nl& address);
+    explicit Address(const struct sockaddr_in6& address);
+    explicit Address(struct in6_addr address);
+
+    template<typename T>
+    const T* get() const {
+        return reinterpret_cast<const T*>(mStorage.data());
+    }
+
+    template<typename T>
+    T* get() {
+        return reinterpret_cast<T*>(mStorage.data());
+    }
+
+    ssize_t size() const { return mStorage.size(); }
+
+    // Reset the address to be the max size possible for an address
+    void reset();
+
+    // Resolve |address| into an IPv6 address. |address| may be either a domain
+    // name or just a string containing a numeric address.
+    Result resolveInet(const std::string& address);
+    // Resolve |interfaceName| into a link layer address. This can be used to
+    // create a struct sockaddr_nl that can be used to listen on the given
+    // interface at the link layer.
+    Result resolveEth(const std::string& interfaceName);
+private:
+    std::vector<char> mStorage;
+};
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/interface.cpp b/vendor/redroid_ext/wifi/ipv6proxy/interface.cpp
new file mode 100644
index 0000000000..e9597ab569
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/interface.cpp
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "interface.h"
+
+#include <errno.h>
+#include <linux/if_ether.h>
+#include <net/if.h>
+#include <string.h>
+#include <sys/ioctl.h>
+
+#include "log.h"
+
+Interface::Interface(const std::string& name) : mName(name) {
+}
+
+bool Interface::init() {
+    // setAllMulti will set the ALLMULTI flag for the interface, this allows us
+    // to capture all the traffic needed to perform proxying.
+    return setAllMulti() &&
+           resolveAddresses() &&
+           configureIpSocket() &&
+           configureIcmpSocket();
+}
+
+bool Interface::setAllMulti() {
+    struct ifreq request;
+    memset(&request, 0, sizeof(request));
+    strncpy(request.ifr_name, mName.c_str(), sizeof(request.ifr_name));
+    request.ifr_name[sizeof(request.ifr_name) - 1] = '\0';
+
+    Socket socket;
+    Result res = socket.open(AF_INET, SOCK_DGRAM, IPPROTO_IP);
+    if (!res) {
+        loge("Failed to open IP socket for interface %s: %s\n",
+             mName.c_str(), strerror(errno));
+        return false;
+    }
+    int status = ::ioctl(socket.get(), SIOCGIFFLAGS, &request);
+    if (status != 0) {
+        loge("Failed to get interface flags for %s: %s\n",
+             mName.c_str(), strerror(errno));
+        return false;
+    }
+
+    if ((request.ifr_flags & IFF_ALLMULTI) != 0) {
+        // AllMulti is already enabled, nothing to do
+        return true;
+    }
+
+    request.ifr_flags |= IFF_ALLMULTI;
+
+    status = ::ioctl(socket.get(), SIOCSIFFLAGS, &request);
+    if (status != 0) {
+        loge("Failed to enable AllMulti flag for %s: %s\n",
+             mName.c_str(), strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+bool Interface::resolveAddresses() {
+    Result res = mLinkAddr.resolveEth(mName);
+    if (!res) {
+        loge("Unable to resolve interface %s: %s\n",
+             mName.c_str(), res.c_str());
+        return false;
+    }
+    mIndex = if_nametoindex(mName.c_str());
+    if (mIndex == 0) {
+        loge("Unable to get interface index for '%s': %s\n",
+             mName.c_str(), strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+bool Interface::configureIcmpSocket() {
+    Result res = mIcmpSocket.open(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
+    if (!res) {
+        loge("Error opening socket: %s\n", res.c_str());
+        return false;
+    }
+
+    // The ICMP messages we are going to send need a hop limit of 255 to be
+    // accepted.
+    res = mIcmpSocket.setMulticastHopLimit(255);
+    if (!res) {
+        loge("Error setting socket hop limit: %s\n", res.c_str());
+        return false;
+    }
+    res = mIcmpSocket.setUnicastHopLimit(255);
+    if (!res) {
+        loge("Error setting socket hop limit: %s\n", res.c_str());
+        return false;
+    }
+
+    // We only care about one specific interface
+    res = mIcmpSocket.setInterface(mName);
+    if (!res) {
+        loge("Error socket interface: %s\n", res.c_str());
+        return false;
+    }
+
+    // Make sure the socket allows transparent proxying, this allows sending of
+    // packets with a source address that is different from the interface.
+    res = mIcmpSocket.setTransparent(true);
+    if (!res) {
+        loge("Error socket interface: %s\n", res.c_str());
+        return false;
+    }
+
+    return true;
+}
+
+bool Interface::configureIpSocket() {
+    Result res = mIpSocket.open(AF_PACKET, SOCK_DGRAM, ETH_P_IPV6);
+    if (!res) {
+        loge("Error opening socket: %s\n", res.c_str());
+        return false;
+    }
+
+    res = mIpSocket.bind(mLinkAddr);
+    if (!res) {
+        loge("Error binding socket: %s\n", res.c_str());
+        return false;
+    }
+    return true;
+}
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/interface.h b/vendor/redroid_ext/wifi/ipv6proxy/interface.h
new file mode 100644
index 0000000000..e6e5d78a22
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/interface.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <stdint.h>
+#include <string>
+
+#include "address.h"
+#include "socket.h"
+
+// A class that contains the information used by the proxy that is specific to a
+// single interface. This includes the name and index of the interface as well
+// as the sockets used to send and receive data on the interface.
+//
+// The class also contains the functionality needed to initialized and configure
+// the interface, sockets and addresses.
+class Interface {
+public:
+    explicit Interface(const std::string& name);
+
+    bool init();
+
+    const std::string& name() const { return mName; }
+    uint32_t index() const { return mIndex; }
+    Socket& ipSocket() { return mIpSocket; }
+    Socket& icmpSocket() { return mIcmpSocket; }
+    const Address& linkAddr() const { return mLinkAddr; }
+
+private:
+    bool setAllMulti();
+    bool resolveAddresses();
+    bool configureIcmpSocket();
+    bool configureIpSocket();
+
+    std::string mName;
+    uint32_t mIndex;
+    Socket mIpSocket;
+    Socket mIcmpSocket;
+    Address mLinkAddr;
+};
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/log.cpp b/vendor/redroid_ext/wifi/ipv6proxy/log.cpp
new file mode 100644
index 0000000000..a23b06210c
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/log.cpp
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "log.h"
+
+#ifndef ANDROID
+#include <stdarg.h>
+#ifdef USE_LOG_TIMESTAMPS
+#include <time.h>
+#endif  // USE_LOG_TIMESTAMPS
+
+static void vlogf(FILE* stream, const char* fmt, va_list args) {
+#ifdef USE_LOG_TIMESTAMPS
+    struct timespec ts;
+    struct tm localTime;
+    static bool newLine = true;
+    if (newLine && clock_gettime(CLOCK_REALTIME, &ts) == 0) {
+        time_t now = ts.tv_sec;
+        if (localtime_r(&now, &localTime)) {
+            char format[32];
+            char timestamp[1024];
+            snprintf(format, sizeof(format), "[%%T.%03lld] ", (long long)(ts.tv_nsec) / 1000000);
+            strftime(timestamp, sizeof(timestamp), format, &localTime);
+            fprintf(stream, "%s ", timestamp);
+        }
+    }
+    newLine = (fmt[strlen(fmt) - 1] == '\n');
+#endif  // USE_LOG_TIMESTAMPS
+    vfprintf(stream, fmt, args);
+}
+
+static void logf(FILE* stream, const char* fmt, ...) {
+    va_list args;
+    va_start(args, fmt);
+    vlogf(stream, fmt, args);
+    va_end(args);
+}
+
+void loge(const char* fmt, ...) {
+    va_list args;
+    va_start(args, fmt);
+    vlogf(stderr, fmt, args);
+    va_end(args);
+}
+
+void logd(const char* fmt, ...) {
+    va_list args;
+    va_start(args, fmt);
+    vlogf(stdout, fmt, args);
+    va_end(args);
+}
+#endif  // !ANDROID
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/log.h b/vendor/redroid_ext/wifi/ipv6proxy/log.h
new file mode 100644
index 0000000000..53e89350a8
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/log.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#ifdef ANDROID
+
+#define LOG_TAG "ipv6proxy"
+#include <log/log.h>
+
+#define loge(...) ALOGE(__VA_ARGS__)
+#define logd(...) ALOGD(__VA_ARGS__)
+
+#else
+#include <stdio.h>
+
+void loge(const char* fmt, ...);
+void logd(const char* fmt, ...);
+
+#endif
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/main.cpp b/vendor/redroid_ext/wifi/ipv6proxy/main.cpp
new file mode 100644
index 0000000000..91445caf07
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/main.cpp
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <vector>
+
+#include <string.h>
+
+#include "log.h"
+#include "namespace.h"
+#include "proxy.h"
+
+void usage(const char* program) {
+    loge("Usage: %s -n [namespace|pid] -o <outer if> -i <inner ifs>\n",
+         program);
+    loge("  -o   Outer interface that connects to an existing IPv6 network.\n"
+         "  -i   Comma separated list of inner interfaces that would like\n"
+         "       to access the IPv6 network available on the outer interface.\n"
+         "  -n   Optional parameter that causes the proxy to run in the given\n"
+         "       network namespace. If a name is given instead of a PID the\n"
+         "       namespace is expected to be set up by iproute2 or with a\n"
+         "       similar approach where the namespace is linked in\n"
+         "       /var/run/netns. A PID is assumed if the argument is numeric.\n"
+         "       If providing a PID the same namespace that the PID is\n"
+         "       running in will be used. In this scenario there is no\n"
+         "       requirement for a file in /var/run/netns.\n"
+         "\n"
+         "       The proxy will ensure that router solicitations from inner\n"
+         "       interfaces are forwarded to the outer interface and that\n"
+         "       router advertisements from the outer interface are forwarded\n"
+         "       to the inner interfaces. In addition to this neighbor\n"
+         "       solicitations and advertisements will also be forwarded in a\n"
+         "       way that enables IPv6 connectivity and routes will be set up\n"
+         "       for source addresses on the inner interfaces so that replies\n"
+         "       can reach those sources as expected.\n"
+    );
+}
+
+static std::vector<const char*> splitString(char* str, char delimiter) {
+    std::vector<const char*> parts;
+    char* part = nullptr;
+    do {
+        parts.push_back(str);
+        part = strchr(str, delimiter);
+        if (part != nullptr) {
+            *part = '\0';
+            str = part + 1;
+        }
+    } while (part != nullptr);
+    return parts;
+}
+
+int main(int argc, char* argv[]) {
+    char* inner = nullptr;
+    const char* outer = nullptr;
+    const char* netNamespace = nullptr;
+    for (int i = 1; i < argc; ++i) {
+        if (strcmp(argv[i], "-o") == 0) {
+            outer = argv[++i];
+        } else if (strcmp(argv[i], "-i") == 0) {
+            inner = argv[++i];
+        } else if (strcmp(argv[i], "-h") == 0 ||
+                   strcmp(argv[i], "--help") == 0) {
+            usage(argv[0]);
+            return 1;
+        } else if (strcmp(argv[i], "-n") == 0) {
+            netNamespace = argv[++i];
+        } else {
+            loge("ERROR: Unknown argument '%s'\n\n", argv[i]);
+            usage(argv[0]);
+            return 1;
+        }
+    }
+    bool error = false;
+    if (inner == nullptr) {
+        loge("ERROR: Missing inner interface\n");
+        error = true;
+    }
+    if (outer == nullptr) {
+        loge("ERROR: Missing outer interface\n");
+        error = true;
+    }
+    if (netNamespace) {
+        if (!setNetworkNamespace(netNamespace)) {
+            error = true;
+        }
+    }
+    if (error) {
+        usage(argv[0]);
+        return 1;
+    }
+
+    std::vector<const char*> innerInterfaces = splitString(inner, ',');
+
+    Proxy proxy(outer, innerInterfaces.begin(), innerInterfaces.end());
+
+    return proxy.run();
+}
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/message.h b/vendor/redroid_ext/wifi/ipv6proxy/message.h
new file mode 100644
index 0000000000..9b35daebb0
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/message.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+class Message {
+public:
+
+    size_t size() const { return mSize; }
+    size_t capacity() const { return sizeof(mData); }
+    const char* data() const { return mData; }
+    char* data() { return mData; }
+
+    void setSize(size_t size) { mSize = size; }
+
+protected:
+    char mData[8192];
+    size_t mSize;
+};
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/namespace.cpp b/vendor/redroid_ext/wifi/ipv6proxy/namespace.cpp
new file mode 100644
index 0000000000..04841c291d
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/namespace.cpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "namespace.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/limits.h>
+#include <sched.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "log.h"
+
+static const char kNetNsDir[] = "/data/vendor/var/run/netns";
+
+// Set the current namespace to that of the /proc/<pid>/ns/net provided in
+// |path|. This may be a link or mount point for that same file, anything that
+// when opened will be an fd usable by setns is fine.
+static bool setNamespaceFromPath(const char* path) {
+    int nsFd = open(path, O_RDONLY | O_CLOEXEC);
+    if (nsFd == -1) {
+        loge("Cannot open network namespace at '%s': %s\n",
+             path, strerror(errno));
+        return false;
+    }
+
+    if (setns(nsFd, CLONE_NEWNET) == -1) {
+        loge("Cannot set network namespace at '%s': %s\n",
+             path, strerror(errno));
+        close(nsFd);
+        return false;
+    }
+    close(nsFd);
+    return true;
+}
+
+bool setNetworkNamespace(const char* ns) {
+    // There is a file in the net namespace dir (usually /var/run/netns) with
+    // the same name as the namespace. This file is bound to /proc/<pid>/ns/net
+    // by the 'ip' command when the namespace is created. This allows us to
+    // access the file of a process running in that network namespace without
+    // knowing its pid, knowing the namespace name is enough.
+    //
+    // We are going to call setns which requires a file descriptor to that proc
+    // file in /proc/<pid>/net. The process has to already be running in that
+    // namespace. Since the file in the net namespace dir has been bound to
+    // such a file already we just have to open /var/run/netns/<namespace> and
+    // we have the required file descriptor.
+    char nsPath[PATH_MAX];
+    snprintf(nsPath, sizeof(nsPath), "%s/%s", kNetNsDir, ns);
+    return setNamespaceFromPath(nsPath);
+}
+
+bool setNetworkNamespace(pid_t pid) {
+    // If we know the pid we can create the path to the /proc file right away
+    // and use that when we call setns.
+    char nsPath[PATH_MAX];
+    static_assert(sizeof(pid_t) <= sizeof(unsigned long long),
+                  "Cast requires sizeof(pid_t) <= sizeof(unsigned long long)");
+    snprintf(nsPath, sizeof(nsPath), "/proc/%llu/ns/net/",
+             static_cast<unsigned long long>(pid));
+    return setNamespaceFromPath(nsPath);
+}
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/namespace.h b/vendor/redroid_ext/wifi/ipv6proxy/namespace.h
new file mode 100644
index 0000000000..8a70374148
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/namespace.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <sys/types.h>
+
+// Move the process into the namespace |ns|
+bool setNetworkNamespace(const char* ns);
+
+// Move the process into the same namespace as the process |pid| is in.
+bool setNetworkNamespace(pid_t pid);
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/packet.cpp b/vendor/redroid_ext/wifi/ipv6proxy/packet.cpp
new file mode 100644
index 0000000000..fa15a7581f
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/packet.cpp
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "packet.h"
+
+#include "address.h"
+
+Packet::Packet(Message& message)
+    : mMessage(message),
+      mType(Type::Other),
+      mIp(nullptr),
+      mIcmp(nullptr),
+      mFirstOpt(nullptr) {
+    if (message.size() < sizeof(ip6_hdr) + sizeof(icmp6_hdr)) {
+        mType = Type::Other;
+        return;
+    }
+    mIp = reinterpret_cast<const ip6_hdr*>(message.data());
+    uint8_t version = (mIp->ip6_vfc & 0xF0) >> 4;
+    if (version != 6 || mIp->ip6_nxt != IPPROTO_ICMPV6) {
+        mType = Type::Other;
+        return;
+    }
+
+    size_t size = message.size() - sizeof(ip6_hdr);
+    char* data = message.data() + sizeof(ip6_hdr);
+    mIcmp = reinterpret_cast<const icmp6_hdr*>(data);
+    if (mIcmp->icmp6_code != 0) {
+        // All messages we care about have a code of zero
+        mType = Type::Other;
+        return;
+    }
+
+    size_t headerSize = 0;
+    switch (mIcmp->icmp6_type) {
+    case ND_ROUTER_SOLICIT:
+        headerSize = sizeof(nd_router_solicit);
+        mType = Type::RouterSolicitation;
+        break;
+    case ND_ROUTER_ADVERT:
+        headerSize = sizeof(nd_router_advert);
+        mType = Type::RouterAdvertisement;
+        break;
+    case ND_NEIGHBOR_SOLICIT:
+        headerSize = sizeof(nd_neighbor_solicit);
+        mType = Type::NeighborSolicitation;
+        break;
+    case ND_NEIGHBOR_ADVERT:
+        headerSize = sizeof(nd_neighbor_advert);
+        mType = Type::NeighborAdvertisement;
+        break;
+    default:
+        mType = Type::Other;
+        return;
+    }
+    if (size < headerSize) {
+        mType = Type::Other;
+        return;
+    }
+
+    // We might have options
+    char* options = data + headerSize;
+    if (options + sizeof(nd_opt_hdr) < data + size) {
+        nd_opt_hdr* option = reinterpret_cast<nd_opt_hdr*>(options);
+        // Option length is in units of 8 bytes, multiply by 8 to get bytes
+        if (options + option->nd_opt_len * 8u <= data + size) {
+            mFirstOpt = option;
+        }
+    }
+}
+
+std::string Packet::description() const {
+    char buffer[256];
+    switch (mType) {
+        case Type::NeighborSolicitation: {
+                auto ns = reinterpret_cast<const nd_neighbor_solicit*>(icmp());
+                snprintf(buffer, sizeof(buffer), "Neighbor Solicitation for %s",
+                         addrToStr(ns->nd_ns_target).c_str());
+                return buffer;
+            }
+        case Type::NeighborAdvertisement: {
+                auto na = reinterpret_cast<const nd_neighbor_advert*>(icmp());
+                snprintf(buffer, sizeof(buffer),
+                         "Neighbor Advertisement for %s",
+                         addrToStr(na->nd_na_target).c_str());
+                return buffer;
+            }
+        case Type::RouterSolicitation:
+            return "Router Solicitation";
+        case Type::RouterAdvertisement:
+            return "Router Advertisement";
+        default:
+            break;
+    }
+    return "[unknown]";
+}
+
+nd_opt_hdr* Packet::firstOpt() {
+    return mFirstOpt;
+}
+
+nd_opt_hdr* Packet::nextOpt(nd_opt_hdr* currentHeader) {
+    char* end = mMessage.data() + mMessage.size();
+    char* current = reinterpret_cast<char*>(currentHeader);
+    if (currentHeader < mFirstOpt || current >= end) {
+        // The provided header does not belong to this packet info.
+        return nullptr;
+    }
+    char* next = current + currentHeader->nd_opt_len * 8u;
+    if (next >= end) {
+        // The next header points passed the message data
+        return nullptr;
+    }
+    nd_opt_hdr* nextHeader = reinterpret_cast<nd_opt_hdr*>(next);
+    if (next + nextHeader->nd_opt_len * 8u > end) {
+        // The next option extends beyond the message data
+        return nullptr;
+    }
+    return nextHeader;
+}
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/packet.h b/vendor/redroid_ext/wifi/ipv6proxy/packet.h
new file mode 100644
index 0000000000..49e69d4c16
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/packet.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <netinet/icmp6.h>
+#include <netinet/ip6.h>
+
+#include <string>
+#include <vector>
+
+#include "message.h"
+
+class Packet {
+public:
+    enum class Type {
+        NeighborSolicitation,
+        NeighborAdvertisement,
+        RouterSolicitation,
+        RouterAdvertisement,
+        Other
+    };
+
+    explicit Packet(Message& message);
+
+    // Create a string that can be used for debug purposes to describe
+    // what type of packet and potentially its target for certain types.
+    std::string description() const;
+
+    // Full size including IP header
+    size_t fullSize() const {
+        return mMessage.size();
+    }
+    // Remaining size including ICMPv6 header but excluding IP header
+    size_t icmpSize() const {
+        return mMessage.size() - sizeof(ip6_hdr);
+    }
+
+    Type type() const {
+        return mType;
+    }
+    const ip6_hdr* ip() const {
+        return mIp;
+    }
+    const icmp6_hdr* icmp() const {
+        return mIcmp;
+    }
+
+    nd_opt_hdr* firstOpt();
+    nd_opt_hdr* nextOpt(nd_opt_hdr* currentHeader);
+
+private:
+    Message& mMessage;
+    Type mType;
+
+    const ip6_hdr* mIp;
+    const icmp6_hdr* mIcmp;
+    nd_opt_hdr* mFirstOpt;
+};
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/proxy.cpp b/vendor/redroid_ext/wifi/ipv6proxy/proxy.cpp
new file mode 100644
index 0000000000..cb19ff7d43
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/proxy.cpp
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "proxy.h"
+
+#include <arpa/inet.h>
+#include <errno.h>
+#include <linux/if_packet.h>
+#include <poll.h>
+#include <signal.h>
+
+#include <cutils/properties.h>
+
+#include "log.h"
+#include "message.h"
+#include "packet.h"
+#include "result.h"
+
+// The prefix length for an address of a single unique node
+static const uint8_t kNodePrefixLength = 128;
+static const size_t kLinkAddressSize = 6;
+static const size_t kRecursiveDnsOptHeaderSize = 8;
+
+// Rewrite the link address of a neighbor discovery option to the link address
+// of |interface|. This can be either a source or target link address as
+// specified by |optionType|. The valid values are ND_OPT_TARGET_LINKADDR and
+// ND_OPT_SOURCE_LINKADDR. This will modify the message data inside |packet|.
+static void rewriteLinkAddressOption(Packet& packet,
+                                     const Interface& interface,
+                                     int optionType) {
+    for (nd_opt_hdr* opt = packet.firstOpt(); opt; opt = packet.nextOpt(opt)) {
+        if (opt->nd_opt_type == optionType) {
+            auto src = interface.linkAddr().get<sockaddr_ll>();
+            auto dest = reinterpret_cast<char*>(opt) + sizeof(nd_opt_hdr);
+            memcpy(dest, src->sll_addr, kLinkAddressSize);
+        }
+    }
+}
+
+static void extractRecursiveDnsServers(Packet& packet) {
+    for (nd_opt_hdr* opt = packet.firstOpt(); opt; opt = packet.nextOpt(opt)) {
+        if (opt->nd_opt_type != 25 || opt->nd_opt_len < 1) {
+            // Not a RNDSS option, skip it
+            continue;
+        }
+        size_t numEntries = (opt->nd_opt_len - 1) / 2;
+        //Found number of entries, dump  each address
+        const char* option = reinterpret_cast<const char*>(opt);
+        option += kRecursiveDnsOptHeaderSize;
+        auto dnsServers = reinterpret_cast<const struct in6_addr*>(option);
+
+        std::vector<std::string> validServers;
+        for (size_t i = 0; i < numEntries; ++i) {
+            char buffer[INET6_ADDRSTRLEN];
+            if (inet_ntop(AF_INET6, &dnsServers[i], buffer, sizeof(buffer))) {
+                validServers.push_back(buffer);
+            } else {
+                loge("Failed to convert RDNSS to string\n");
+            }
+        }
+
+        auto server = validServers.begin();
+        char propName[PROP_NAME_MAX];
+        char propValue[PROP_VALUE_MAX];
+        for (int i = 1; i <= 4; ++i) {
+            snprintf(propName, sizeof(propName), "net.eth0.ipv6dns%d", i);
+            if (server != validServers.end()) {
+                property_set(propName, server->c_str());
+                ++server;
+            } else {
+                // Clear the property if it's no longer a valid server, don't
+                // want to leave old servers around
+                property_set(propName, "");
+            }
+        }
+    }
+}
+
+int Proxy::run() {
+    sigset_t blockMask, originalMask;
+    int status = ::sigfillset(&blockMask);
+    if (status != 0) {
+        loge("Unable to fill signal set: %s\n", strerror(errno));
+        return 1;
+    }
+    status = ::sigprocmask(SIG_SETMASK, &blockMask, &originalMask);
+    if (status != 0) {
+        loge("Unable to set signal mask: %s\n", strerror(errno));
+        return 1;
+    }
+    // Init outer interface and router
+    if (!mOuterIf.init() || !mRouter.init()) {
+        return 1;
+    }
+    // Init all inner interfaces
+    for (size_t i = 0; i < mInnerIfs.size(); ++i) {
+        if (!mInnerIfs[i].init()) {
+            return 1;
+        }
+    }
+
+    // Create list of FDs to poll, we're only looking for input (POLLIN)
+    std::vector<pollfd> fds(mInnerIfs.size() + 1);
+    fds[0].fd = mOuterIf.ipSocket().get();
+    fds[0].events = POLLIN;
+    for (size_t i = 0; i < mInnerIfs.size(); ++i) {
+        fds[i + 1].fd = mInnerIfs[i].ipSocket().get();
+        fds[i + 1].events = POLLIN;
+    }
+
+    Message message;
+    while (status >= 0) {
+        status = ::ppoll(fds.data(), fds.size(), nullptr, &originalMask);
+        if (status > 0) {
+            // Something available to read
+            for (const struct pollfd& fd : fds) {
+                if (receiveIfPossible(fd, mOuterIf.ipSocket(), &message)) {
+                    // Received a message on the outer interface
+                    handleOuterMessage(message);
+                } else {
+                    for (auto& inner : mInnerIfs) {
+                        if (receiveIfPossible(fd, inner.ipSocket(), &message)) {
+                            // Received a message on the inner interface
+                            handleInnerMessage(inner, message);
+                        }
+                    }
+                }
+            }
+        }
+    }
+    loge("Polling failed: %s\n", strerror(errno));
+    return 1;
+}
+
+bool Proxy::receiveIfPossible(const pollfd& fd,
+                              Socket& socket,
+                              Message* message) {
+    // Check if it's actually the socket we're interested in
+    if (fd.fd != socket.get()) {
+        return false;
+    }
+    // Check if there is something to read on this socket
+    if ((fd.revents & POLLIN) == 0) {
+        return false;
+    }
+
+    // Receive the message and place the data in the message parameter
+    Result res = socket.receive(message);
+    if (!res) {
+        loge("Error receiving on socket: %s\n", res.c_str());
+        return false;
+    }
+    return true;
+}
+
+void Proxy::handleOuterMessage(Message& message) {
+    Packet packet(message);
+    uint32_t options = kForwardOnly;
+    switch (packet.type()) {
+        case Packet::Type::RouterAdvertisement:
+            extractRecursiveDnsServers(packet);
+            options = kRewriteSourceLink | kSetDefaultGateway;
+            break;
+        case Packet::Type::NeighborSolicitation:
+            options = kSpoofSource;
+            break;
+        case Packet::Type::NeighborAdvertisement:
+            options = kRewriteTargetLink;
+            break;
+        default:
+            return;
+    }
+    for (auto& inner : mInnerIfs) {
+        forward(mOuterIf, inner, packet, options);
+    }
+}
+
+void Proxy::handleInnerMessage(const Interface& inner, Message& message) {
+    Packet packet(message);
+    uint32_t options = kForwardOnly;
+    switch (packet.type()) {
+        case Packet::Type::RouterSolicitation:
+            options = kSpoofSource;
+            break;
+        case Packet::Type::NeighborSolicitation:
+            options = kSpoofSource | kAddRoute;
+            break;
+        case Packet::Type::NeighborAdvertisement:
+            options = kRewriteTargetLink | kSpoofSource | kAddRoute;
+            break;
+        default:
+            return;
+    }
+    forward(inner, mOuterIf, packet, options);
+}
+
+void Proxy::forward(const Interface& from,
+                    Interface& to,
+                    Packet& packet,
+                    uint32_t options) {
+    if (mLogDebug) {
+        logd("Forwarding %s from %s/%s to %s/%s\n",
+             packet.description().c_str(),
+             from.name().c_str(), addrToStr(packet.ip()->ip6_src).c_str(),
+             to.name().c_str(), addrToStr(packet.ip()->ip6_dst).c_str());
+    }
+
+    if (options & kRewriteTargetLink) {
+        rewriteLinkAddressOption(packet, to, ND_OPT_TARGET_LINKADDR);
+    }
+    if (options & kRewriteSourceLink) {
+        rewriteLinkAddressOption(packet, to, ND_OPT_SOURCE_LINKADDR);
+    }
+
+    Result res = Result::success();
+    if (options & kSpoofSource) {
+        // Spoof the source of the packet so that it appears to originate from
+        // the same source that we see.
+        res = to.icmpSocket().sendFrom(packet.ip()->ip6_src,
+                                       packet.ip()->ip6_dst,
+                                       packet.icmp(),
+                                       packet.icmpSize());
+    } else {
+        res = to.icmpSocket().sendTo(packet.ip()->ip6_dst,
+                                     packet.icmp(),
+                                     packet.icmpSize());
+    }
+    if (!res) {
+        loge("Failed to forward %s from %s to %s: %s\n",
+             packet.description().c_str(),
+             from.name().c_str(), to.name().c_str(),
+             res.c_str());
+    }
+
+    if (options & kAddRoute) {
+        mRouter.addRoute(packet.ip()->ip6_src, kNodePrefixLength, from.index());
+    }
+    if (packet.type() == Packet::Type::RouterAdvertisement &&
+        options & kSetDefaultGateway) {
+        // Set the default gateway from this router advertisement. This is
+        // needed so that packets that are forwarded as a result of proxying
+        // actually have somewhere to go.
+        if (!mRouter.setDefaultGateway(packet.ip()->ip6_src, from.index())) {
+            loge("Failed to set default gateway %s\n",
+                 addrToStr(packet.ip()->ip6_src).c_str());
+        }
+    }
+}
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/proxy.h b/vendor/redroid_ext/wifi/ipv6proxy/proxy.h
new file mode 100644
index 0000000000..517913734e
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/proxy.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <string>
+#include <vector>
+
+#include "interface.h"
+#include "router.h"
+
+struct pollfd;
+class Message;
+class Packet;
+class Socket;
+
+class Proxy {
+public:
+    template<typename Iter>
+    Proxy(std::string outerInterfaceName,
+          Iter innerInterfacesBegin, Iter innerInterfacesEnd)
+        : mOuterIf(outerInterfaceName),
+          mLogDebug(false) {
+
+        for (Iter i = innerInterfacesBegin; i != innerInterfacesEnd; ++i) {
+            mInnerIfs.emplace_back(*i);
+        }
+    }
+
+    int run();
+
+private:
+    enum ForwardOpt {
+        kForwardOnly = 0,
+        kRewriteTargetLink = (1 << 0),
+        kRewriteSourceLink = (1 << 1),
+        kSpoofSource = (1 << 2),
+        kAddRoute = (1 << 3),
+        kSetDefaultGateway = (1 << 4)
+    };
+
+    bool receiveIfPossible(const pollfd&, Socket& socket, Message* message);
+
+    void handleOuterMessage(Message& message);
+    void handleInnerMessage(const Interface& inner, Message& message);
+    void forward(const Interface& from, Interface& to,
+                 Packet& packet, uint32_t options);
+
+    std::vector<Interface> mInnerIfs;
+    Interface mOuterIf;
+
+    Router mRouter;
+    bool mLogDebug;
+};
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/result.h b/vendor/redroid_ext/wifi/ipv6proxy/result.h
new file mode 100644
index 0000000000..5cd2b035cc
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/result.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+class Result {
+public:
+    static Result success() {
+        return Result(true);
+    }
+    // Construct a result indicating an error. NOTE: the data in |message| will
+    // NOT be copied. It must be kept alive for as long as its intended to be
+    // used. This way the object is kept light-weight.
+    static Result error(const char* message) {
+        return Result(message);
+    }
+
+    bool isSuccess() const { return mSuccess; }
+    bool operator!() const { return !mSuccess; }
+
+    const char* c_str() const { return mMessage; }
+private:
+    explicit Result(bool success) : mSuccess(success) { }
+    explicit Result(const char* message)
+        : mMessage(message), mSuccess(false) {
+    }
+    const char* mMessage;
+    bool mSuccess;
+};
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/router.cpp b/vendor/redroid_ext/wifi/ipv6proxy/router.cpp
new file mode 100644
index 0000000000..be505c92bd
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/router.cpp
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "router.h"
+
+#include <linux/rtnetlink.h>
+#include <stddef.h>
+#include <string.h>
+
+#include "address.h"
+#include "log.h"
+
+template<class Request>
+static void addRouterAttribute(Request& r,
+                               int type,
+                               const void* data,
+                               size_t size) {
+    // Calculate the offset into the character buffer where the RTA data lives
+    // We use offsetof on the buffer to get it. This avoids undefined behavior
+    // by casting the buffer (which is safe because it's char) instead of the
+    // Request struct.(which is undefined because of aliasing)
+    size_t offset = NLMSG_ALIGN(r.hdr.nlmsg_len) - offsetof(Request, buf);
+    auto attr = reinterpret_cast<struct rtattr*>(r.buf + offset);
+    attr->rta_type = type;
+    attr->rta_len = RTA_LENGTH(size);
+    memcpy(RTA_DATA(attr), data, size);
+
+    // Update the message length to include the router attribute.
+    r.hdr.nlmsg_len = NLMSG_ALIGN(r.hdr.nlmsg_len) + RTA_ALIGN(attr->rta_len);
+}
+
+bool Router::init() {
+    // Create a netlink socket to the router
+    Result res = mSocket.open(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+    if (!res) {
+        loge("Unable to open netlink socket: %s\n", res.c_str());
+        return false;
+    }
+    return true;
+}
+
+bool Router::addNeighbor(const struct in6_addr& address,
+                         unsigned int interfaceIndex) {
+    struct Request {
+        struct nlmsghdr hdr;
+        struct ndmsg msg;
+        char buf[256];
+    } request;
+
+    memset(&request, 0, sizeof(request));
+
+    unsigned short msgLen = NLMSG_LENGTH(sizeof(request.msg));
+    // Set up a request to create a new neighbor
+    request.hdr.nlmsg_len = msgLen;
+    request.hdr.nlmsg_type = RTM_NEWNEIGH;
+    request.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
+
+    // The neighbor is a permanent IPv6 proxy
+    request.msg.ndm_family = AF_INET6;
+    request.msg.ndm_state = NUD_PERMANENT;
+    request.msg.ndm_flags = NTF_PROXY;
+    request.msg.ndm_ifindex = interfaceIndex;
+
+    addRouterAttribute(request, NDA_DST, &address, sizeof(address));
+
+    return sendNetlinkMessage(&request, request.hdr.nlmsg_len);
+}
+
+bool Router::addRoute(const struct in6_addr& address,
+                      uint8_t bits,
+                      uint32_t ifaceIndex) {
+    struct Request {
+        struct nlmsghdr hdr;
+        struct rtmsg msg;
+        char buf[256];
+    } request;
+
+    memset(&request, 0, sizeof(request));
+
+    // Set up a request to create a new route
+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(request.msg));
+    request.hdr.nlmsg_type = RTM_NEWROUTE;
+    request.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
+
+    request.msg.rtm_family = AF_INET6;
+    request.msg.rtm_dst_len = bits;
+    request.msg.rtm_table = RT_TABLE_MAIN;
+    request.msg.rtm_protocol = RTPROT_RA;
+    request.msg.rtm_scope = RT_SCOPE_UNIVERSE;
+    request.msg.rtm_type = RTN_UNICAST;
+
+    addRouterAttribute(request, RTA_DST, &address, sizeof(address));
+    addRouterAttribute(request, RTA_OIF, &ifaceIndex, sizeof(ifaceIndex));
+
+    return sendNetlinkMessage(&request, request.hdr.nlmsg_len);
+}
+
+bool Router::setDefaultGateway(const struct in6_addr& address,
+                               unsigned int ifaceIndex) {
+    struct Request {
+        struct nlmsghdr hdr;
+        struct rtmsg msg;
+        char buf[256];
+    } request;
+
+    memset(&request, 0, sizeof(request));
+
+    // Set up a request to create a new route
+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(request.msg));
+    request.hdr.nlmsg_type = RTM_NEWROUTE;
+    request.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
+
+    request.msg.rtm_family = AF_INET6;
+    request.msg.rtm_dst_len = 0;
+    request.msg.rtm_src_len = 0;
+    request.msg.rtm_table = RT_TABLE_MAIN;
+    request.msg.rtm_protocol = RTPROT_RA;
+    request.msg.rtm_scope = RT_SCOPE_UNIVERSE;
+    request.msg.rtm_type = RTN_UNICAST;
+
+    struct in6_addr anyAddress;
+    memset(&anyAddress, 0, sizeof(anyAddress));
+    addRouterAttribute(request, RTA_GATEWAY, &address, sizeof(address));
+    addRouterAttribute(request, RTA_OIF, &ifaceIndex, sizeof(ifaceIndex));
+    addRouterAttribute(request, RTA_SRC, &anyAddress, sizeof(anyAddress));
+
+    return sendNetlinkMessage(&request, request.hdr.nlmsg_len);
+}
+
+bool Router::sendNetlinkMessage(const void* data, size_t size) {
+    struct sockaddr_nl netlinkAddress;
+    memset(&netlinkAddress, 0, sizeof(netlinkAddress));
+    netlinkAddress.nl_family = AF_NETLINK;
+    Result res = mSocket.sendTo(netlinkAddress, data, size);
+    if (!res) {
+        loge("Unable to send on netlink socket: %s\n", res.c_str());
+        return false;
+    }
+    return true;
+}
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/router.h b/vendor/redroid_ext/wifi/ipv6proxy/router.h
new file mode 100644
index 0000000000..66e896ff24
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/router.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <stdint.h>
+
+#include <netinet/in.h>
+
+#include "socket.h"
+
+class Router {
+public:
+    // Initialize the router, this has to be called before any other methods can
+    // be called. It only needs to be called once.
+    bool init();
+
+    // Indicate that |address| is a neighbor to this node and that it is
+    // accessible on the interface with index |interfaceIndex|.
+    bool addNeighbor(const struct in6_addr& address, uint32_t interfaceIndex);
+
+    // Add a route to |address|/|bits| on interface |interfaceIndex|. The
+    // |bits| parameter indicates the bitmask of the address, for example in
+    // the routing entry 2001:db8::/32 the |bits| parameter would be 32.
+    bool addRoute(const struct in6_addr& address,
+                  uint8_t bits,
+                  uint32_t interfaceIndex);
+
+    // Set the default gateway route to |address| on interface with index
+    // |interfaceIndex|. Overwrites any existing default gateway with the same
+    // address.
+    bool setDefaultGateway(const struct in6_addr& address,
+                           unsigned int interfaceIndex);
+private:
+    bool sendNetlinkMessage(const void* data, size_t size);
+
+    // Netlink socket for setting up neighbors and routes
+    Socket mSocket;
+};
+
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/socket.cpp b/vendor/redroid_ext/wifi/ipv6proxy/socket.cpp
new file mode 100644
index 0000000000..3b6781618b
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/socket.cpp
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "socket.h"
+
+#include <errno.h>
+#include <string.h>
+
+#include <linux/in6.h>
+#include <net/ethernet.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+
+#include "address.h"
+#include "message.h"
+
+Socket::Socket() : mState(State::New), mSocket(-1) {
+}
+
+Socket::Socket(Socket&& other) noexcept : mState(other.mState), mSocket(other.mSocket) {
+    other.mSocket = -1;
+    other.mState = State::Moved;
+}
+
+Socket::~Socket() {
+    if (mSocket != -1) {
+        close(mSocket);
+        mSocket = -1;
+    }
+    mState = State::Destructed;
+}
+
+Socket& Socket::operator=(Socket&& other) noexcept {
+    if (mSocket != -1) {
+        close(mSocket);
+    }
+    mSocket = other.mSocket;
+    mState = other.mState;
+    other.mSocket = -1;
+    other.mState = State::Moved;
+
+    return *this;
+}
+
+Result Socket::open(int domain, int type, int protocol) {
+    if (mState != State::New) {
+        return Result::error("open called on socket in invalid state");
+    }
+    mSocket = ::socket(domain, type | SOCK_CLOEXEC, protocol);
+    if (mSocket == -1) {
+        return Result::error(strerror(errno));
+    }
+    mState = State::Open;
+    return Result::success();
+}
+
+Result Socket::setInterface(const std::string& interface) {
+    if (mState != State::Open) {
+        return Result::error("attempting to set option in invalid state");
+    }
+    int res = ::setsockopt(mSocket, SOL_SOCKET, SO_BINDTODEVICE,
+                           interface.c_str(), interface.size());
+
+    return res == -1 ? Result::error(strerror(errno)) : Result::success();
+}
+
+Result Socket::setMulticastHopLimit(int hopLimit) {
+    if (mState != State::Open) {
+        return Result::error("attempting to set option in invalid state");
+    }
+    int res = ::setsockopt(mSocket, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
+                           &hopLimit, sizeof(hopLimit));
+
+    return res == -1 ? Result::error(strerror(errno)) : Result::success();
+}
+
+Result Socket::setUnicastHopLimit(int hopLimit) {
+    if (mState != State::Open) {
+        return Result::error("attempting to set option in invalid state");
+    }
+    int res = ::setsockopt(mSocket, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
+                           &hopLimit, sizeof(hopLimit));
+
+    return res == -1 ? Result::error(strerror(errno)) : Result::success();
+}
+
+Result Socket::setTransparent(bool transparent) {
+    if (mState != State::Open) {
+        return Result::error("attempting to set option in invalid state");
+    }
+    int v = transparent ? 1 : 0;
+    int res = ::setsockopt(mSocket, IPPROTO_IPV6, IPV6_TRANSPARENT,
+                           &v, sizeof(v));
+
+    return res == -1 ? Result::error(strerror(errno)) : Result::success();
+}
+
+Result Socket::bind(const Address& address) {
+    if (mState != State::Open) {
+        return Result::error("bind called on socket in invalid state");
+    }
+
+    int res = ::bind(mSocket, address.get<sockaddr>(), address.size());
+    if (res == -1) {
+        return Result::error(strerror(errno));
+    }
+
+    mState = State::Bound;
+    return Result::success();
+}
+
+Result Socket::receive(Message* receivingMessage) {
+    if (receivingMessage == nullptr) {
+        return Result::error("No receivingMessage provided");
+    }
+    if (mState != State::Bound) {
+        return Result::error("Attempt to receive on a socket that isn't bound");
+    }
+
+    ssize_t rxBytes = ::recv(mSocket,
+                             receivingMessage->data(),
+                             receivingMessage->capacity(),
+                             0);
+    if (rxBytes < 0) {
+        return Result::error(strerror(errno));
+    }
+
+    receivingMessage->setSize(static_cast<size_t>(rxBytes));
+    return Result::success();
+}
+
+Result Socket::receiveFrom(Message* receivingMessage, Address* from) {
+    if (receivingMessage == nullptr) {
+        return Result::error("No receivingMessage provided");
+    }
+    if (from == nullptr) {
+        return Result::error("No from address provided");
+    }
+    if (mState != State::Bound) {
+        return Result::error("Attempt to receive on a socket that isn't bound");
+    }
+
+    from->reset();
+    sockaddr* source = from->get<sockaddr>();
+    socklen_t sourceLen = from->size();
+    ssize_t rxBytes = ::recvfrom(mSocket,
+                                 receivingMessage->data(),
+                                 receivingMessage->capacity(),
+                                 0,
+                                 source,
+                                 &sourceLen);
+    if (rxBytes < 0) {
+        return Result::error(strerror(errno));
+    }
+
+    receivingMessage->setSize(static_cast<size_t>(rxBytes));
+    return Result::success();
+}
+
+Result Socket::send(const void* data, size_t size) {
+    if (mState != State::Bound && mState != State::Open) {
+        return Result::error("Attempt to send on a socket in invalid state");
+    }
+
+    int res = ::send(mSocket, data, size, 0);
+    if (res == -1) {
+        return Result::error(strerror(errno));
+    }
+    return Result::success();
+}
+
+Result Socket::sendTo(const sockaddr& destination,
+                      size_t destinationSize,
+                      const void* data,
+                      size_t size) {
+    if (mState != State::Bound && mState != State::Open) {
+        return Result::error("Attempt to send on a socket in invalid state");
+    }
+
+    int res = ::sendto(mSocket, data, size, 0, &destination, destinationSize);
+    if (res == -1) {
+        return Result::error(strerror(errno));
+    }
+    return Result::success();
+}
+
+Result Socket::sendTo(const in6_addr& destination,
+                      const void* data,
+                      size_t size) {
+    sockaddr_in6 addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.sin6_family = AF_INET6;
+    addr.sin6_addr = destination;
+    return sendTo(*reinterpret_cast<sockaddr*>(&addr),
+                  sizeof(addr),
+                  data,
+                  size);
+}
+
+Result Socket::sendFrom(const struct in6_addr& fromAddress,
+                        const sockaddr& destination,
+                        size_t destinationSize,
+                        const void* data,
+                        size_t size) {
+    struct msghdr messageHeader;
+    memset(&messageHeader, 0, sizeof(messageHeader));
+    // Even when sending this struct requires a non-const pointer, even when
+    // it's only going to be read. Do a const_cast instead of creating a
+    // method signature with illogical const-behavior.
+    messageHeader.msg_name = const_cast<struct sockaddr*>(&destination);
+    messageHeader.msg_namelen = destinationSize;
+
+    struct iovec iov;
+    messageHeader.msg_iov = &iov;
+    messageHeader.msg_iovlen = 1;
+
+    memset(&iov, 0, sizeof(iov));
+    iov.iov_base = const_cast<void*>(data);
+    iov.iov_len = size;
+
+    char control[CMSG_SPACE(sizeof(struct in6_pktinfo))] = { 0 };
+    messageHeader.msg_control = control;
+    messageHeader.msg_controllen = sizeof(control);
+
+    struct cmsghdr* controlHeader = CMSG_FIRSTHDR(&messageHeader);
+    controlHeader->cmsg_level = IPPROTO_IPV6;
+    controlHeader->cmsg_type = IPV6_PKTINFO;
+    controlHeader->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+
+    auto packetInfoData = CMSG_DATA(controlHeader);
+    auto packetInfo = reinterpret_cast<struct in6_pktinfo*>(packetInfoData);
+    packetInfo->ipi6_addr = fromAddress;
+
+    int res = ::sendmsg(mSocket, &messageHeader, 0);
+    if (res == -1) {
+        int error = errno;
+        printf("sendmsg failed: %d\n", error);
+        return Result::error(strerror(error));
+    }
+    return Result::success();
+}
+
+Result Socket::sendFrom(const in6_addr& fromAddress,
+                        const in6_addr& destination,
+                        const void* data,
+                        size_t size) {
+    sockaddr_in6 addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.sin6_family = AF_INET6;
+    addr.sin6_addr = destination;
+
+    return sendFrom(fromAddress,
+                    *reinterpret_cast<sockaddr*>(&addr),
+                    sizeof(addr),
+                    data,
+                    size);
+}
diff --git a/vendor/redroid_ext/wifi/ipv6proxy/socket.h b/vendor/redroid_ext/wifi/ipv6proxy/socket.h
new file mode 100644
index 0000000000..9cbdda3194
--- /dev/null
+++ b/vendor/redroid_ext/wifi/ipv6proxy/socket.h
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "result.h"
+
+#include <netinet/in.h>
+
+#include <stdint.h>
+#include <string>
+
+class Address;
+class Message;
+
+class Socket {
+public:
+    enum class Domain {
+        IpV4,
+        IpV6,
+        Packet,
+    };
+
+    enum class Type {
+        Stream,   // A streaming protocol, use this with Infer for TCP
+        Datagram, // A datagram protocol, use this with Infer for UDP
+        Raw,      // A raw socket
+    };
+    enum class Protocol {
+        Infer,    // Infer the protocol from the type, such as TCP for Stream
+        Ip,       // Internet Protocol for raw sockets
+        IcmpV6,   // ICMPv6 control protocol for Raw sockets
+        EthIpV6,  // Ethernet packets containing IPV6, for packet sockets
+    };
+
+    // Construct an empty socket object, next use open() to start using it
+    Socket();
+    // Move construct a socket, The constructed socket will be in the same state
+    // that |other| is. After this |other| will be in an undefined state and
+    // should no longer be used.
+    Socket(Socket&& other) noexcept;
+    ~Socket();
+
+    // Move the |other| socket object into this one. If this object has an open
+    // socket it will be closed first. After that this object will have the
+    // same state that |other| did. |other| will be left in an undefined state
+    // and should not be used.
+    Socket& operator=(Socket&& other) noexcept;
+
+    int get() const { return mSocket; }
+
+    Result open(int domain, int type, int protocol);
+
+    /** Options, these must be called between open and bind **/
+
+    // Bind to a specific interface regardless of the address that the socket
+    // is going to bind to.
+    Result setInterface(const std::string& interface);
+
+    // Set the hop limit for multicast traffic on the socket. Each router hop
+    // decreases this value by one, when it reaches zero the packet is
+    // discarded.
+    Result setMulticastHopLimit(int hopLimit);
+
+    // Set the hop limit for unicast traffic on the socket. Each router hop
+    // decreases this value by one, when it reaches zero the packet is
+    // discarded.
+    Result setUnicastHopLimit(int hopLimit);
+
+    // Configure the socket to be transparent. This allows packets sent to have
+    // a source address that is different from the network interface's source
+    // address.
+    Result setTransparent(bool transparent);
+
+    /** Binding **/
+
+    Result bind(const Address& address);
+
+    /** Sending and receiving **/
+
+    Result receive(Message* receivingMessage);
+    Result receiveFrom(Message* receivingMessage, Address* from);
+
+    Result send(const void* data, size_t size);
+
+    // Send a packet to a specific |destination| of any address type.
+    Result sendTo(const sockaddr& destination,
+                  size_t destinationSize,
+                  const void* data,
+                  size_t size);
+    // Convenience function to send to a specific IPv6 address.
+    Result sendTo(const in6_addr& destination, const void* data, size_t size);
+    // Convenience method to use sendTo with a more specific sockaddr struct
+    // without having to specify the size or do the casting.
+    template<typename T>
+    Result sendTo(const T& destination, const void* data, size_t size) {
+        return sendTo(*reinterpret_cast<const sockaddr*>(&destination),
+                      sizeof(destination),
+                      data,
+                      size);
+    }
+
+    // Send a packet with a specific source IPv6 address to a given
+    // |destination|. Rewriting the source in this manner usually requires root.
+    Result sendFrom(const in6_addr& fromAddress,
+                    const sockaddr& destination,
+                    size_t destinationSize,
+                    const void* data,
+                    size_t size);
+    Result sendFrom(const in6_addr& fromAddress,
+                    const in6_addr& destination,
+                    const void* data,
+                    size_t size);
+    // Convenience method to use sendFrom with a more specific sockaddr struct
+    // without having to specify the size or do the casting.
+    template<typename T>
+    Result sendFrom(const in6_addr& fromAddress,
+                    const T& destination,
+                    const void* data,
+                    size_t size) {
+        return sendFrom(fromAddress,
+                        *reinterpret_cast<const sockaddr*>(&destination),
+                        sizeof(destination),
+                        data,
+                        size);
+    }
+
+private:
+    // No copy construction or assignment allowed, support move semantics only
+    Socket(const Socket&);
+    Socket& operator=(const Socket&);
+
+    enum class State {
+        New,
+        Open,
+        Bound,
+        Moved,
+        Destructed,
+    };
+
+    State mState;
+    int mSocket;
+};
+
diff --git a/vendor/redroid_ext/wifi/mac80211_create_radios/Android.bp b/vendor/redroid_ext/wifi/mac80211_create_radios/Android.bp
new file mode 100644
index 0000000000..fc9cbb4790
--- /dev/null
+++ b/vendor/redroid_ext/wifi/mac80211_create_radios/Android.bp
@@ -0,0 +1,24 @@
+// package {
+//     // See: http://go/android-license-faq
+//     // A large-scale-change added 'default_applicable_licenses' to import
+//     // all of the 'license_kinds' from "device_generic_goldfish_license"
+//     // to get the below license kinds:
+//     //   SPDX-license-identifier-Apache-2.0
+//     default_applicable_licenses: ["device_generic_goldfish_license"],
+// }
+
+cc_binary {
+    name: "create_radios2",
+    vendor: true,
+    cppflags: [
+             "-Wall",
+             "-Werror",
+             "--std=c++17",
+            ],
+    srcs: ["main.cpp",],
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "libnl",
+    ],
+}
diff --git a/vendor/redroid_ext/wifi/mac80211_create_radios/main.cpp b/vendor/redroid_ext/wifi/mac80211_create_radios/main.cpp
new file mode 100644
index 0000000000..3b9f1493c4
--- /dev/null
+++ b/vendor/redroid_ext/wifi/mac80211_create_radios/main.cpp
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "mac80211_create_radios"
+
+#include <memory>
+#include <log/log.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/genl/genl.h>
+#include <netlink/netlink.h>
+#include <net/ethernet.h>
+
+enum {
+    HWSIM_CMD_UNSPEC,
+    HWSIM_CMD_REGISTER,
+    HWSIM_CMD_FRAME,
+    HWSIM_CMD_TX_INFO_FRAME,
+    HWSIM_CMD_NEW_RADIO,
+    HWSIM_CMD_DEL_RADIO,
+    HWSIM_CMD_GET_RADIO,
+};
+
+enum {
+    HWSIM_ATTR_UNSPEC,
+    HWSIM_ATTR_ADDR_RECEIVER,
+    HWSIM_ATTR_ADDR_TRANSMITTER,
+    HWSIM_ATTR_FRAME,
+    HWSIM_ATTR_FLAGS,
+    HWSIM_ATTR_RX_RATE,
+    HWSIM_ATTR_SIGNAL,
+    HWSIM_ATTR_TX_INFO,
+    HWSIM_ATTR_COOKIE,
+    HWSIM_ATTR_CHANNELS,
+    HWSIM_ATTR_RADIO_ID,
+    HWSIM_ATTR_REG_HINT_ALPHA2,
+    HWSIM_ATTR_REG_CUSTOM_REG,
+    HWSIM_ATTR_REG_STRICT_REG,
+    HWSIM_ATTR_SUPPORT_P2P_DEVICE,
+    HWSIM_ATTR_USE_CHANCTX,
+    HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE,
+    HWSIM_ATTR_RADIO_NAME,
+    HWSIM_ATTR_NO_VIF,
+    HWSIM_ATTR_FREQ,
+    HWSIM_ATTR_PAD,
+    HWSIM_ATTR_TX_INFO_FLAGS,
+    HWSIM_ATTR_PERM_ADDR,
+    HWSIM_ATTR_IFTYPE_SUPPORT,
+    HWSIM_ATTR_CIPHER_SUPPORT,
+};
+
+struct nl_sock_deleter {
+    void operator()(struct nl_sock* x) const { nl_socket_free(x); }
+};
+
+struct nl_msg_deleter {
+    void operator()(struct nl_msg* x) const { nlmsg_free(x); }
+};
+
+constexpr char kHwSimFamilyName[] = "MAC80211_HWSIM";
+constexpr int kHwSimVersion = 1;
+constexpr int kChannels = 2;
+
+const char* nlErrStr(const int e) { return (e < 0) ? nl_geterror(e) : ""; }
+
+#define RETURN(R) return (R);
+#define RETURN_ERROR(C, R) \
+    do { \
+        ALOGE("%s:%d '%s' failed", __func__, __LINE__, C); \
+        return (R); \
+    } while (false);
+#define RETURN_NL_ERROR(C, NLR, R) \
+    do { \
+        ALOGE("%s:%d '%s' failed with '%s'", __func__, __LINE__, C, nlErrStr((NLR))); \
+        return (R); \
+    } while (false);
+
+int parseInt(const char* str, int* result) { return sscanf(str, "%d", result); }
+
+std::unique_ptr<struct nl_msg, nl_msg_deleter> createNlMessage(
+        const int family,
+        const int cmd) {
+    std::unique_ptr<struct nl_msg, nl_msg_deleter> msg(nlmsg_alloc());
+    if (!msg) { RETURN_ERROR("nlmsg_alloc", nullptr); }
+
+    void* user = genlmsg_put(msg.get(), NL_AUTO_PORT, NL_AUTO_SEQ, family, 0,
+                       NLM_F_REQUEST, cmd, kHwSimVersion);
+    if (!user) { RETURN_ERROR("genlmsg_put", nullptr); }
+
+    RETURN(msg);
+}
+
+std::unique_ptr<struct nl_msg, nl_msg_deleter>
+buildCreateRadioMessage(const int family, const uint8_t mac[ETH_ALEN]) {
+    std::unique_ptr<struct nl_msg, nl_msg_deleter> msg =
+        createNlMessage(family, HWSIM_CMD_NEW_RADIO);
+    if (!msg) { RETURN(nullptr); }
+
+    int ret;
+    ret = nla_put(msg.get(), HWSIM_ATTR_PERM_ADDR, ETH_ALEN, mac);
+    if (ret) { RETURN_NL_ERROR("nla_put(HWSIM_ATTR_PERM_ADDR)", ret, nullptr); }
+
+    ret = nla_put_flag(msg.get(), HWSIM_ATTR_SUPPORT_P2P_DEVICE);
+    if (ret) { RETURN_NL_ERROR("nla_put(HWSIM_ATTR_SUPPORT_P2P_DEVICE)", ret, nullptr); }
+
+    ret = nla_put_u32(msg.get(), HWSIM_ATTR_CHANNELS, kChannels);
+    if (ret) { RETURN_NL_ERROR("nla_put(HWSIM_ATTR_CHANNELS)", ret, nullptr); }
+
+    RETURN(msg);
+}
+
+int createRadios(struct nl_sock* socket, const int netlinkFamily,
+                 const int nRadios, const int macPrefix) {
+    uint8_t mac[ETH_ALEN] = {};
+    mac[0] = 0x02;
+    mac[1] = (macPrefix >> CHAR_BIT) & 0xFF;
+    mac[2] = macPrefix & 0xFF;
+
+    for (int idx = 0; idx < nRadios; ++idx) {
+        mac[4] = idx;
+
+        std::unique_ptr<struct nl_msg, nl_msg_deleter> msg =
+            buildCreateRadioMessage(netlinkFamily, mac);
+        if (msg) {
+            int ret = nl_send_auto(socket, msg.get());
+            if (ret < 0) { RETURN_NL_ERROR("nl_send_auto", ret, 1); }
+        } else {
+            RETURN(1);
+        }
+    }
+
+    RETURN(0);
+}
+
+int manageRadios(const int nRadios, const int macPrefix) {
+    std::unique_ptr<struct nl_sock, nl_sock_deleter> socket(nl_socket_alloc());
+    if (!socket) { RETURN_ERROR("nl_socket_alloc", 1); }
+
+    int ret;
+    ret = genl_connect(socket.get());
+    if (ret) { RETURN_NL_ERROR("genl_connect", ret, 1); }
+
+    const int netlinkFamily = genl_ctrl_resolve(socket.get(), kHwSimFamilyName);
+    if (netlinkFamily < 0) { RETURN_NL_ERROR("genl_ctrl_resolve", ret, 1); }
+
+    ret = createRadios(socket.get(), netlinkFamily, nRadios, macPrefix);
+    if (ret) { RETURN(ret); }
+
+    RETURN(0);
+}
+
+int printUsage(FILE* dst, const int ret) {
+    fprintf(dst, "%s",
+    "Usage:\n"
+    "   mac80211_create_radios n_radios mac_prefix\n"
+    "   where\n"
+    "       n_radios - int, [1,100], e.g. 2;\n"
+    "       mac_prefix - int, [0, 65535], e.g. 5555.\n\n"
+    "   mac80211_create_radios will delete all existing radios and\n"
+    "   create n_radios with MAC addresses\n"
+    "   02:pp:pp:00:nn:00, where nn is incremented (from zero)\n");
+
+    return ret;
+}
+
+int main(int argc, char* argv[]) {
+    if (argc != 3) { return printUsage(stdout, 0); }
+
+    int nRadios;
+    if (!parseInt(argv[1], &nRadios)) { return printUsage(stderr, 1); }
+    if (nRadios < 1) { return printUsage(stderr, 1); }
+    if (nRadios > 100) { return printUsage(stderr, 1); }
+
+    int macPrefix;
+    if (!parseInt(argv[2], &macPrefix)) { return printUsage(stderr, 1); }
+    if (macPrefix < 0) { return printUsage(stderr, 1); }
+    if (macPrefix > UINT16_MAX) { return printUsage(stderr, 1); }
+
+    return manageRadios(nRadios, macPrefix);
+}
diff --git a/vendor/redroid_ext/wifi/wpa_supplicant.conf b/vendor/redroid_ext/wifi/wpa_supplicant.conf
new file mode 100644
index 0000000000..5f1eb7b21e
--- /dev/null
+++ b/vendor/redroid_ext/wifi/wpa_supplicant.conf
@@ -0,0 +1,3 @@
+disable_scan_offload=1
+wowlan_triggers=any
+ap_scan=1
