From 0bddc9d2bf09470f8905416412e053a25b07246c Mon Sep 17 00:00:00 2001
From: ntimesrepo <973731820@qq.com>
Date: Thu, 30 May 2024 08:39:23 +0000
Subject: [PATCH] Fix game animation blank screen

---
 hardware/rockchip/audio/Android.mk            |   69 +-
 hardware/rockchip/audio/hdmi_hal/Android.mk   |  102 +
 hardware/rockchip/audio/hdmi_hal/alsa_audio.h |  132 +
 hardware/rockchip/audio/hdmi_hal/alsa_mixer.c |  789 ++++
 hardware/rockchip/audio/hdmi_hal/alsa_route.c |  736 +++
 hardware/rockchip/audio/hdmi_hal/amix.c       |  119 +
 hardware/rockchip/audio/hdmi_hal/asound.h     |  844 ++++
 hardware/rockchip/audio/hdmi_hal/asoundlib.h  |  325 ++
 hardware/rockchip/audio/hdmi_hal/audio_hw.c   | 3177 +++++++++++++
 hardware/rockchip/audio/hdmi_hal/audio_hw.h   |  572 +++
 .../rockchip/audio/hdmi_hal/audio_hw_hdmi.c   |  648 +++
 .../rockchip/audio/hdmi_hal/audio_hw_hdmi.h   |   96 +
 .../rockchip/audio/hdmi_hal/audio_setting.h   |   15 +
 .../hdmi_hal/bitstream/audio_bitstream.c      |  326 ++
 .../hdmi_hal/bitstream/audio_bitstream.h      |   32 +
 .../bitstream/audio_bitstream_manager.c       |  109 +
 .../bitstream/audio_bitstream_manager.h       |   39 +
 .../audio/hdmi_hal/bitstream/audio_iec958.c   |  336 ++
 .../audio/hdmi_hal/bitstream/audio_iec958.h   |  145 +
 .../audio/hdmi_hal/codec_config/config.h      |   88 +
 .../audio/hdmi_hal/codec_config/config_list.h |  113 +
 .../hdmi_hal/codec_config/cx2072_config.h     |  332 ++
 .../hdmi_hal/codec_config/default_config.h    |  455 ++
 .../hdmi_hal/codec_config/es8316_config.h     |  363 ++
 .../hdmi_hal/codec_config/es8388_config.h     |  428 ++
 .../hdmi_hal/codec_config/es8396_config.h     |  377 ++
 .../codec_config/hdmi_analog_config.h         |  324 ++
 .../hdmi_hal/codec_config/mixer_paths.xml     |  110 +
 .../hdmi_hal/codec_config/rk616_config.h      | 1607 +++++++
 .../audio/hdmi_hal/codec_config/rk_audio.mk   |    3 +
 .../hdmi_hal/codec_config/rt3224_config.h     | 3969 +++++++++++++++++
 .../hdmi_hal/codec_config/rt3261_config.h     | 3758 ++++++++++++++++
 .../hdmi_hal/codec_config/rt5616_config.h     |  890 ++++
 .../hdmi_hal/codec_config/rt5640_config.h     | 1468 ++++++
 .../hdmi_hal/codec_config/rt5651_config.h     | 1234 +++++
 .../hdmi_hal/codec_config/rt5678_config.h     |  308 ++
 .../hdmi_hal/codec_config/wm8960_config.h     |  869 ++++
 .../audio/hdmi_hal/denoise/rkdenoise.c        |  322 ++
 .../audio/hdmi_hal/denoise/rkdenoise.h        |   32 +
 .../audio/hdmi_hal/denoise/skv/libanr.so      |  Bin 0 -> 60320 bytes
 .../audio/hdmi_hal/denoise/skv/skv_anr.h      |   21 +
 .../audio/hdmi_hal/voice_preprocess.c         |  686 +++
 .../audio/hdmi_hal/voice_preprocess.h         |   26 +
 43 files changed, 26344 insertions(+), 50 deletions(-)
 create mode 100644 hardware/rockchip/audio/hdmi_hal/Android.mk
 create mode 100644 hardware/rockchip/audio/hdmi_hal/alsa_audio.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/alsa_mixer.c
 create mode 100644 hardware/rockchip/audio/hdmi_hal/alsa_route.c
 create mode 100755 hardware/rockchip/audio/hdmi_hal/amix.c
 create mode 100755 hardware/rockchip/audio/hdmi_hal/asound.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/asoundlib.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/audio_hw.c
 create mode 100755 hardware/rockchip/audio/hdmi_hal/audio_hw.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/audio_hw_hdmi.c
 create mode 100755 hardware/rockchip/audio/hdmi_hal/audio_hw_hdmi.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/audio_setting.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream.c
 create mode 100755 hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream_manager.c
 create mode 100755 hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream_manager.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/bitstream/audio_iec958.c
 create mode 100755 hardware/rockchip/audio/hdmi_hal/bitstream/audio_iec958.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/config.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/codec_config/config_list.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/codec_config/cx2072_config.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/default_config.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/codec_config/es8316_config.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/codec_config/es8388_config.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/codec_config/es8396_config.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/hdmi_analog_config.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/mixer_paths.xml
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/rk616_config.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/rk_audio.mk
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/rt3224_config.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/rt3261_config.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/rt5616_config.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/codec_config/rt5640_config.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/codec_config/rt5651_config.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/codec_config/rt5678_config.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/codec_config/wm8960_config.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/denoise/rkdenoise.c
 create mode 100644 hardware/rockchip/audio/hdmi_hal/denoise/rkdenoise.h
 create mode 100755 hardware/rockchip/audio/hdmi_hal/denoise/skv/libanr.so
 create mode 100644 hardware/rockchip/audio/hdmi_hal/denoise/skv/skv_anr.h
 create mode 100644 hardware/rockchip/audio/hdmi_hal/voice_preprocess.c
 create mode 100644 hardware/rockchip/audio/hdmi_hal/voice_preprocess.h

diff --git a/hardware/rockchip/audio/Android.mk b/hardware/rockchip/audio/Android.mk
index 0e35e074d0..72c64a0209 100644
--- a/hardware/rockchip/audio/Android.mk
+++ b/hardware/rockchip/audio/Android.mk
@@ -1,51 +1,20 @@
-# Copyright (C) 2011 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
+#legacy audio hal is just for debuging, and we use tinyalsa in all rk product
+#use AUDIO_FORCE_LEGACY to choose which you need.
+
+MY_LOCAL_PATH := $(call my-dir)
+
+AUDIO_FORCE_LEGACY=false
+include $(MY_LOCAL_PATH)/hdmi_hal/Android.mk
+
+# ifeq ($(strip $(AUDIO_FORCE_LEGACY)), true)
+#     include $(MY_LOCAL_PATH)/legacy_hal/Android.mk
+# else
+#     include $(MY_LOCAL_PATH)/tinyalsa_hal/Android.mk
+# ifeq ($(strip $(BOARD_SUPPORT_MULTIAUDIO)), true)
+#     include $(MY_LOCAL_PATH)/hdmi_hal/Android.mk
+#     include $(MY_LOCAL_PATH)/hdmi_1_hal/Android.mk
+#     include $(MY_LOCAL_PATH)/spdif_hal/Android.mk
+#     include $(MY_LOCAL_PATH)/spdif_1_hal/Android.mk
+# endif
+# endif
 
-LOCAL_PATH := $(call my-dir)
-
-# The default audio HAL module, which is a stub, that is loaded if no other
-# device specific modules are present. The exact load order can be seen in
-# libhardware/hardware.c
-#
-# The format of the name is audio.<type>.<hardware/etc>.so where the only
-# required type is 'primary'. Other possibilites are 'a2dp', 'usb', etc.
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := audio.primary.$(TARGET_BOARD_HARDWARE)
-LOCAL_MODULE_RELATIVE_PATH := hw
-LOCAL_PROPRIETARY_MODULE := true
-LOCAL_SRC_FILES := audio_hw.c lwrb.c
-LOCAL_SHARED_LIBRARIES := liblog libcutils
-LOCAL_MODULE_TAGS := optional
-LOCAL_CFLAGS := -Wno-unused-parameter 
-LOCAL_HEADER_LIBRARIES := libhardware_headers
-
-include $(BUILD_SHARED_LIBRARY)
-
-# The stub audio policy HAL module that can be used as a skeleton for
-# new implementations.
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := audio_policy.$(TARGET_BOARD_HARDWARE)
-LOCAL_MODULE_RELATIVE_PATH := hw
-# installed into a vendor partition
-LOCAL_PROPRIETARY_MODULE := true
-
-LOCAL_SRC_FILES := audio_policy.c
-LOCAL_SHARED_LIBRARIES := liblog libcutils
-LOCAL_MODULE_TAGS := optional
-LOCAL_CFLAGS := -Wno-unused-parameter
-LOCAL_HEADER_LIBRARIES := libhardware_headers
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/hardware/rockchip/audio/hdmi_hal/Android.mk b/hardware/rockchip/audio/hdmi_hal/Android.mk
new file mode 100644
index 0000000000..3f8aede539
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/Android.mk
@@ -0,0 +1,102 @@
+# Copyright (C) 2012 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := audio.hdmi.$(TARGET_BOARD_HARDWARE)
+LOCAL_PROPRIETARY_MODULE := true
+LOCAL_MODULE_RELATIVE_PATH := hw
+LOCAL_SRC_FILES := \
+	bitstream/audio_iec958.c \
+	bitstream/audio_bitstream.c \
+	bitstream/audio_bitstream_manager.c \
+	audio_hw.c \
+	alsa_route.c \
+	alsa_mixer.c \
+	voice_preprocess.c \
+	audio_hw_hdmi.c \
+	denoise/rkdenoise.c
+
+LOCAL_C_INCLUDES += \
+	$(call include-path-for, audio-utils) \
+	$(call include-path-for, audio-route) \
+	$(call include-path-for, speex)
+
+
+LOCAL_HEADER_LIBRARIES += libhardware_headers
+LOCAL_CFLAGS := -Wno-unused-parameter
+LOCAL_CFLAGS += -DLIBTINYALSA_ENABLE_VNDK_EXT
+ifneq ($(filter box atv, $(strip $(TARGET_BOARD_PLATFORM_PRODUCT))), )
+LOCAL_CFLAGS += -DBOX_HAL
+endif
+ifeq ($(strip $(BOARD_USE_DRM)),true)
+LOCAL_CFLAGS += -DUSE_DRM
+endif
+ifeq ($(strip $(BOARD_USE_AUDIO_3A)),true)
+LOCAL_CFLAGS += -DAUDIO_3A
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk3368)
+LOCAL_CFLAGS += -DRK3368
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk3228h)
+        LOCAL_CFLAGS += -DRK3228
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk3328)
+        LOCAL_CFLAGS += -DRK3228
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk3228)
+        LOCAL_CFLAGS += -DRK3228
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk322x)
+	LOCAL_CFLAGS += -DRK3228
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk3128h)
+        LOCAL_CFLAGS += -DRK3228
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk3399)
+    LOCAL_CFLAGS += -DRK3399
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk3399pro)
+    LOCAL_CFLAGS += -DRK3399
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk3128)
+    LOCAL_CFLAGS += -DRK3128
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM)),rk3588)
+    LOCAL_CFLAGS += -DRK3588
+    LOCAL_CFLAGS += -DIEC958_FORAMT
+endif
+ifeq ($(strip $(TARGET_BOARD_PLATFORM_PRODUCT)), laptop)
+LOCAL_CFLAGS += -DRK3399_LAPTOP
+LOCAL_CFLAGS += -DBT_AP_SCO
+endif
+ifeq ($(AUD_VOICE_CONFIG),voice_support)
+LOCAL_CFLAGS += -DVOICE_SUPPORT
+endif
+LOCAL_CFLAGS += -Wno-error
+
+LOCAL_SHARED_LIBRARIES := liblog libcutils libaudioutils libaudioroute libhardware_legacy libspeexresampler
+
+#API 31 -> Android 12.0, Android 12.0 link libtinyalsa_iec958
+ifneq (1, $(strip $(shell expr $(PLATFORM_SDK_VERSION) \< 31)))
+LOCAL_SHARED_LIBRARIES += libtinyalsa_iec958
+else
+LOCAL_SHARED_LIBRARIES += libtinyalsa
+endif
+
+LOCAL_STATIC_LIBRARIES := libspeex
+LOCAL_MODULE_TAGS := optional
+include $(BUILD_SHARED_LIBRARY)
diff --git a/hardware/rockchip/audio/hdmi_hal/alsa_audio.h b/hardware/rockchip/audio/hdmi_hal/alsa_audio.h
new file mode 100644
index 0000000000..43f5841bf3
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/alsa_audio.h
@@ -0,0 +1,132 @@
+/*
+** Copyright 2010, The Android Open-Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+/**
+ * @file alsa_audio.h
+ * @brief
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _AUDIO_H_
+#define _AUDIO_H_
+
+typedef enum _AudioRoute {
+    SPEAKER_NORMAL_ROUTE = 0,
+    SPEAKER_INCALL_ROUTE, // 1
+    SPEAKER_RINGTONE_ROUTE,
+    SPEAKER_VOIP_ROUTE,
+
+    EARPIECE_NORMAL_ROUTE, // 4
+    EARPIECE_INCALL_ROUTE,
+    EARPIECE_RINGTONE_ROUTE,
+    EARPIECE_VOIP_ROUTE,
+
+    HEADPHONE_NORMAL_ROUTE, // 8
+    HEADPHONE_INCALL_ROUTE,
+    HEADPHONE_RINGTONE_ROUTE,
+    SPEAKER_HEADPHONE_NORMAL_ROUTE,
+    SPEAKER_HEADPHONE_RINGTONE_ROUTE,
+    HEADPHONE_VOIP_ROUTE,
+
+    HEADSET_NORMAL_ROUTE, // 14
+    HEADSET_INCALL_ROUTE,
+    HEADSET_RINGTONE_ROUTE,
+    HEADSET_VOIP_ROUTE,
+
+    BLUETOOTH_NORMAL_ROUTE, // 18
+    BLUETOOTH_INCALL_ROUTE,
+    BLUETOOTH_VOIP_ROUTE,
+
+    MAIN_MIC_CAPTURE_ROUTE, // 21
+    HANDS_FREE_MIC_CAPTURE_ROUTE,
+    BLUETOOTH_SOC_MIC_CAPTURE_ROUTE,
+
+    PLAYBACK_OFF_ROUTE, // 24
+    CAPTURE_OFF_ROUTE,
+    INCALL_OFF_ROUTE,
+    VOIP_OFF_ROUTE,
+
+    HDMI_NORMAL_ROUTE, // 28
+
+    SPDIF_NORMAL_ROUTE,
+
+    USB_NORMAL_ROUTE, // 30
+    USB_CAPTURE_ROUTE,
+
+    HDMI_IN_NORMAL_ROUTE,
+    HDMI_IN_OFF_ROUTE,
+    HDMI_IN_CAPTURE_ROUTE,
+    HDMI_IN_CAPTURE_OFF_ROUTE,
+
+    MAX_ROUTE, //36
+} AudioRoute;
+
+#define PCM_ERROR_MAX 128
+
+struct pcm {
+    int fd;
+    unsigned flags;
+    int running:1;
+    int underruns;
+    unsigned buffer_size;
+    char error[PCM_ERROR_MAX];
+};
+
+struct mixer_ctl {
+    struct mixer *mixer;
+    struct snd_ctl_elem_info *info;
+    struct snd_ctl_tlv *tlv;
+    char **ename;
+};
+
+struct mixer {
+    int fd;
+    struct snd_ctl_elem_info *info;
+    struct mixer_ctl *ctl;
+    unsigned count;
+};
+
+struct mixer *mixer_open_legacy(unsigned card);
+void mixer_close_legacy(struct mixer *mixer);
+void mixer_dump(struct mixer *mixer);
+
+struct mixer_ctl *mixer_get_control(struct mixer *mixer,
+                                    const char *name, unsigned index);
+struct mixer_ctl *mixer_get_nth_control(struct mixer *mixer, unsigned n);
+
+int mixer_ctl_set_val(struct mixer_ctl *ctl,int value);
+int mixer_ctl_set(struct mixer_ctl *ctl, unsigned percent);
+int mixer_ctl_select(struct mixer_ctl *ctl, const char *value);
+void mixer_ctl_print(struct mixer_ctl *ctl);
+int mixer_ctl_set_int_double(struct mixer_ctl *ctl, long long left, long long right);
+int mixer_ctl_set_int(struct mixer_ctl *ctl, long long value);
+int mixer_tlv_get_dB_range(unsigned int *tlv, long rangemin, long rangemax,
+                           long *min, long *max);
+int mixer_get_ctl_minmax(struct mixer_ctl *ctl, long long *min, long long *max);
+int mixer_get_dB_range(struct mixer_ctl *ctl, long rangemin, long rangemax,
+                       float *dB_min, float *dB_max, float *dB_step);
+
+int route_init(void);
+void route_uninit(void);
+int route_set_input_source(const char *source);
+int route_set_voice_volume(const char *ctlName, float volume);
+int route_set_controls(unsigned route);
+void route_pcm_open(unsigned route);
+void route_pcm_card_open(int card, unsigned route);
+int route_pcm_close(unsigned route);
+#endif
diff --git a/hardware/rockchip/audio/hdmi_hal/alsa_mixer.c b/hardware/rockchip/audio/hdmi_hal/alsa_mixer.c
new file mode 100644
index 0000000000..245bac8fb2
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/alsa_mixer.c
@@ -0,0 +1,789 @@
+/*
+** Copyright 2010, The Android Open-Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+/**
+ * @file alsa_mixer.c
+ * @brief
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+
+#include <linux/ioctl.h>
+#define __force
+#define __bitwise
+#define __user
+#include "asound.h"
+#define LOG_TAG "alsa_mixer"
+
+//#define LOG_NDEBUG 0
+
+#include "alsa_audio.h"
+#include <cutils/log.h>
+
+#define MAX_SOUND_CARDS     10
+#define VOLUME_PERCENTS     90
+#define SOUND_CTL_PREFIX    "/dev/snd/controlC%d"
+
+/* convert to index of integer array */
+#define int_index(size)	(((size) + sizeof(int) - 1) / sizeof(int))
+/* max size of a TLV entry for dB information (including compound one) */
+#define MAX_TLV_RANGE_SIZE	256
+
+char *volume_controls_name_table[] = {
+    "Earpiece Playback Volume",
+    "Speaker Playback Volume",
+    "Headphone Playback Volume",
+    "PCM Playback Volume",
+    "Mic Capture Volume",
+};
+
+/**
+ * @brief elem_iface_name
+ *
+ * @param n
+ *
+ * @returns
+ */
+static const char *elem_iface_name(snd_ctl_elem_iface_t n)
+{
+    switch (n) {
+    case SNDRV_CTL_ELEM_IFACE_CARD:
+        return "CARD";
+    case SNDRV_CTL_ELEM_IFACE_HWDEP:
+        return "HWDEP";
+    case SNDRV_CTL_ELEM_IFACE_MIXER:
+        return "MIXER";
+    case SNDRV_CTL_ELEM_IFACE_PCM:
+        return "PCM";
+    case SNDRV_CTL_ELEM_IFACE_RAWMIDI:
+        return "MIDI";
+    case SNDRV_CTL_ELEM_IFACE_TIMER:
+        return "TIMER";
+    case SNDRV_CTL_ELEM_IFACE_SEQUENCER:
+        return "SEQ";
+    default:
+        return "???";
+    }
+}
+
+/**
+ * @brief elem_type_name
+ *
+ * @param n
+ *
+ * @returns
+ */
+static const char *elem_type_name(snd_ctl_elem_type_t n)
+{
+    switch (n) {
+    case SNDRV_CTL_ELEM_TYPE_NONE:
+        return "NONE";
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        return "BOOL";
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        return "INT32";
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        return "ENUM";
+    case SNDRV_CTL_ELEM_TYPE_BYTES:
+        return "BYTES";
+    case SNDRV_CTL_ELEM_TYPE_IEC958:
+        return "IEC958";
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        return "INT64";
+    default:
+        return "???";
+    }
+}
+
+/**
+ * @brief mixer_close_legacy
+ *
+ * @param mixer
+ */
+void mixer_close_legacy(struct mixer *mixer)
+{
+    unsigned n,m;
+
+    if (!mixer)
+        return;
+
+    if (mixer->fd >= 0)
+        close(mixer->fd);
+
+    if (mixer->ctl) {
+        for (n = 0; n < mixer->count; n++) {
+            if (mixer->ctl[n].tlv)
+                free(mixer->ctl[n].tlv);
+            if (mixer->ctl[n].ename) {
+                unsigned max = mixer->ctl[n].info->value.enumerated.items;
+                for (m = 0; m < max; m++)
+                    if(mixer->ctl[n].ename[m])
+                        free(mixer->ctl[n].ename[m]);
+                if(mixer->ctl[n].ename)
+                    free(mixer->ctl[n].ename);
+            }
+        }
+        free(mixer->ctl);
+    }
+
+    if (mixer->info)
+        free(mixer->info);
+
+    free(mixer);
+}
+
+/**
+ * @brief mixer_open_legacy
+ *
+ * @param card
+ *
+ * @returns
+ */
+struct mixer *mixer_open_legacy(unsigned card)
+{
+    char dname[sizeof(SOUND_CTL_PREFIX) + 20];
+    struct snd_ctl_elem_list elist;
+    struct snd_ctl_elem_info tmp;
+    struct snd_ctl_elem_id *eid = NULL;
+    struct mixer *mixer = NULL;
+    unsigned n, m, i, max = sizeof(volume_controls_name_table) / sizeof(char *);
+    int fd;
+    sprintf(dname, SOUND_CTL_PREFIX, card);
+
+    fd = open(dname, O_RDWR);
+
+    if (fd < 0) {
+        ALOGE("mixer_open() Can not open %s for card %d", dname, card);
+        return 0;
+    }
+
+    memset(&elist, 0, sizeof(elist));
+    if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_LIST, &elist) < 0)
+        goto fail;
+
+    mixer = calloc(1, sizeof(*mixer));
+    if (!mixer)
+        goto fail;
+
+    mixer->ctl = calloc(elist.count, sizeof(struct mixer_ctl));
+    mixer->info = calloc(elist.count, sizeof(struct snd_ctl_elem_info));
+    if (!mixer->ctl || !mixer->info)
+        goto fail;
+
+    eid = calloc(elist.count, sizeof(struct snd_ctl_elem_id));
+    if (!eid)
+        goto fail;
+
+    mixer->count = elist.count;
+    mixer->fd = fd;
+    elist.space = mixer->count;
+    elist.pids = eid;
+    if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_LIST, &elist) < 0)
+        goto fail;
+
+    for (n = 0; n < mixer->count; n++) {
+        struct snd_ctl_elem_info *ei = mixer->info + n;
+        ei->id.numid = eid[n].numid;
+        if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_INFO, ei) < 0)
+            goto fail;
+        mixer->ctl[n].info = ei;
+        mixer->ctl[n].mixer = mixer;
+        if (ei->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+            char **enames = calloc(ei->value.enumerated.items, sizeof(char*));
+            if (!enames)
+                goto fail;
+            mixer->ctl[n].ename = enames;
+            for (m = 0; m < ei->value.enumerated.items; m++) {
+                memset(&tmp, 0, sizeof(tmp));
+                tmp.id.numid = ei->id.numid;
+                tmp.value.enumerated.item = m;
+                if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_INFO, &tmp) < 0)
+                    goto fail;
+                enames[m] = strdup(tmp.value.enumerated.name);
+                if (!enames[m])
+                    goto fail;
+            }
+        }
+
+        //add for incall volume by Jear.Chen. get tlv.
+        for (i = 0; i < max; i++) {
+            if (!strcmp((char*) mixer->ctl[n].info->id.name, volume_controls_name_table[i]))
+                break;
+        }
+
+        if (i >= max) {
+            mixer->ctl[n].tlv = NULL;
+            continue;
+        }
+
+        if ((mixer->ctl[n].info->access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) == 0) {
+            ALOGV("mixer_open() type of control %s is not TLVT_DB", mixer->ctl[n].info->id.name);
+            mixer->ctl[n].tlv = NULL;
+            continue;
+        }
+
+        unsigned int tlv_size = 2 * sizeof(unsigned int) + 2 * sizeof(unsigned int);
+        struct snd_ctl_tlv *tlv = malloc(sizeof(struct sndrv_ctl_tlv) + tlv_size);
+
+        //tlv->numid < (info->id.numid + info->count) and
+        //tlv->numid >= info->id.numid
+        tlv->numid = mixer->ctl[n].info->id.numid;
+        //length >= tlv.p[1] + 2 * sizeof(unsigned int);
+        //tlv.p is DECLARE_TLV_DB_SCALE defined in kernel
+        tlv->length = tlv_size;
+
+        if (ioctl(fd, SNDRV_CTL_IOCTL_TLV_READ, tlv) < 0) {
+            ALOGE("mixer_open() get tlv for control %s fail", mixer->ctl[n].info->id.name);
+            free(tlv);
+            mixer->ctl[n].tlv = tlv = NULL;
+            continue;
+        }
+
+        ALOGV("mixer_open() get tlv for control %s", mixer->ctl[n].info->id.name);
+        mixer->ctl[n].tlv = tlv;
+        //add for incall volume end
+    }
+
+    free(eid);
+    return mixer;
+
+fail:
+    if (eid)
+        free(eid);
+    if (mixer)
+        mixer_close_legacy(mixer);
+    else if (fd >= 0)
+        close(fd);
+    return 0;
+}
+
+/**
+ * @brief mixer_ctl_print
+ *
+ * @param ctl
+ */
+void mixer_ctl_print(struct mixer_ctl *ctl)
+{
+    struct snd_ctl_elem_value ev;
+    struct snd_ctl_elem_info *ei = ctl->info;
+    unsigned m;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    if (ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_READ, &ev))
+        return;
+    printf("%s:", ctl->info->id.name);
+
+    switch (ei->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        for (m = 0; m < ei->count; m++)
+            printf(" %s", ev.value.integer.value[m] ? "ON" : "OFF");
+
+        printf(" { OFF=0, ON=1 }");
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        for (m = 0; m < ei->count; m++)
+            printf(" %ld", ev.value.integer.value[m]);
+
+        printf(ei->value.integer.step ?
+               " { %ld-%ld, %ld }\n" : " { %ld-%ld }",
+               ei->value.integer.min,
+               ei->value.integer.max,
+               ei->value.integer.step);
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        for (m = 0; m < ei->count; m++)
+            printf(" %lld", ev.value.integer64.value[m]);
+
+        printf(ei->value.integer64.step ?
+               " { %lld-%lld, %lld }\n" : " { %lld-%lld }",
+               ei->value.integer64.min,
+               ei->value.integer64.max,
+               ei->value.integer64.step);
+        break;
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED: {
+        for (m = 0; m < ei->count; m++) {
+            unsigned v = ev.value.enumerated.item[m];
+            printf(" (%d %s)", v,
+                   (v < ei->value.enumerated.items) ? ctl->ename[v] : "???");
+        }
+
+        printf(" { %s=0", ctl->ename[0]);
+        for (m = 1; m < ei->value.enumerated.items; m++)
+            printf(", %s=%d", ctl->ename[m],m);
+        printf(" }");
+        break;
+    }
+    default:
+        printf(" ???");
+    }
+    printf("\n");
+}
+
+/**
+ * @brief mixer_dump
+ *
+ * @param mixer
+ */
+void mixer_dump(struct mixer *mixer)
+{
+    unsigned n;
+
+    printf("  id iface dev sub idx num perms     type   name\n");
+    for (n = 0; n < mixer->count; n++) {
+        struct snd_ctl_elem_info *ei = mixer->info + n;
+
+        printf("%4d %5s %3d %3d %3d %3d %c%c%c%c%c%c%c%c%c %-6s ",
+               ei->id.numid, elem_iface_name(ei->id.iface),
+               ei->id.device, ei->id.subdevice, ei->id.index,
+               ei->count,
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_READ) ? 'r' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ? 'w' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_VOLATILE) ? 'V' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TIMESTAMP) ? 'T' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) ? 'R' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) ? 'W' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) ? 'C' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE) ? 'I' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_LOCK) ? 'L' : ' ',
+               elem_type_name(ei->type));
+
+        mixer_ctl_print(mixer->ctl + n);
+    }
+}
+
+/**
+ * @brief mixer_get_control
+ *
+ * @param mixer
+ * @param name
+ * @param index
+ *
+ * @returns
+ */
+struct mixer_ctl *mixer_get_control(struct mixer *mixer,
+                                    const char *name, unsigned index)
+{
+    unsigned n;
+    for (n = 0; n < mixer->count; n++) {
+        if (mixer->info[n].id.index == index) {
+            if (!strcmp(name, (char*) mixer->info[n].id.name)) {
+                ALOGV("mixer_get_control() %s access 0x%08x",mixer->info[n].id.name,mixer->info[n].access);
+                return mixer->ctl + n;
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * @brief mixer_get_nth_control
+ *
+ * @param mixer
+ * @param n
+ *
+ * @returns
+ */
+struct mixer_ctl *mixer_get_nth_control(struct mixer *mixer, unsigned n)
+{
+    if (n < mixer->count)
+        return mixer->ctl + n;
+    return 0;
+}
+
+/**
+ * @brief scale_int
+ *
+ * @param ei
+ * @param _percent
+ *
+ * @returns
+ */
+static long scale_int(struct snd_ctl_elem_info *ei, unsigned _percent)
+{
+    long percent;
+    long range;
+
+    if (_percent > 100)
+        percent = 100;
+    else
+        percent = (long) _percent;
+
+    range = (ei->value.integer.max - ei->value.integer.min);
+
+    return ei->value.integer.min + (range * percent) / 100LL;
+}
+
+/**
+ * @brief scale_int64
+ *
+ * @param ei
+ * @param _percent
+ *
+ * @returns
+ */
+static long long scale_int64(struct snd_ctl_elem_info *ei, unsigned _percent)
+{
+    long long percent;
+    long long range;
+
+    if (_percent > 100)
+        percent = 100;
+    else
+        percent = (long) _percent;
+
+    range = (ei->value.integer.max - ei->value.integer.min) * 100LL;
+
+    return ei->value.integer.min + (range / percent);
+}
+/**
+ * @brief mixer_ctl_set_val
+ *
+ * @param ctl
+ * @param value
+ *
+ * @returns
+ */
+
+
+int mixer_ctl_set_val(struct mixer_ctl *ctl, int value)
+{
+    struct snd_ctl_elem_value ev;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        ev.value.integer.value[0] = !!value;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        ev.value.integer.value[0] = value;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        ev.value.integer64.value[0] = value;
+        break;
+defalut:
+        errno = EINVAL;
+        return -1;
+    }
+    return ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+}
+
+/**
+ * @brief mixer_ctl_set
+ *
+ * @param ctl
+ * @param percent
+ *
+ * @returns
+ */
+int mixer_ctl_set(struct mixer_ctl *ctl, unsigned percent)
+{
+    struct snd_ctl_elem_value ev;
+    unsigned n;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        for (n = 0; n < ctl->info->count; n++)
+            ev.value.integer.value[n] = !!percent;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER: {
+        long value = scale_int(ctl->info, percent);
+        for (n = 0; n < ctl->info->count; n++)
+            ev.value.integer.value[n] = value;
+        break;
+    }
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64: {
+        long long value = scale_int64(ctl->info, percent);
+        for (n = 0; n < ctl->info->count; n++)
+            ev.value.integer64.value[n] = value;
+        break;
+    }
+    default:
+        errno = EINVAL;
+        return -1;
+    }
+
+    return ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+}
+
+/**
+ * @brief mixer_ctl_select
+ *
+ * @param ctl
+ * @param value
+ *
+ * @returns
+ */
+int mixer_ctl_select(struct mixer_ctl *ctl, const char *value)
+{
+    unsigned n, max;
+    struct snd_ctl_elem_value ev;
+
+    if (ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    max = ctl->info->value.enumerated.items;
+    for (n = 0; n < max; n++) {
+        if (!strcmp(value, ctl->ename[n])) {
+            memset(&ev, 0, sizeof(ev));
+            ev.value.enumerated.item[0] = n;
+            ev.id.numid = ctl->info->id.numid;
+            if (ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev) < 0)
+                return -1;
+            return 0;
+        }
+    }
+
+    errno = EINVAL;
+    return -1;
+}
+
+/**
+ * @brief mixer_ctl_set_int_double
+ *
+ * @param ctl
+ * @param left
+ * @param right
+ *
+ * @returns
+ */
+int mixer_ctl_set_int_double(struct mixer_ctl *ctl, long long left, long long right)
+{
+    struct snd_ctl_elem_value ev;
+    unsigned n;
+    long long max, min, value = left;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        for (n = 0; n < ctl->info->count; n++) {
+            ev.value.integer.value[n] = !!value;
+            value = right;
+        }
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER: {
+        max = ctl->info->value.integer.max;
+        min = ctl->info->value.integer.min;
+
+        left = left > max ? max : left;
+        left = left < min ? min : left;
+        right = right > max ? max : right;
+        right = right < min ? min : right;
+
+        value = left;
+
+        for (n = 0; n < ctl->info->count; n++) {
+            ev.value.integer.value[n] = (long)value;
+            value = right;
+        }
+        break;
+    }
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64: {
+        max = ctl->info->value.integer64.max;
+        min = ctl->info->value.integer64.min;
+
+        left = left > max ? max : left;
+        left = left < min ? min : left;
+        right = right > max ? max : right;
+        right = right < min ? min : right;
+
+        value = left;
+
+        for (n = 0; n < ctl->info->count; n++) {
+            ev.value.integer64.value[n] = value;
+            value = right;
+        }
+        break;
+    }
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        max = ctl->info->value.enumerated.items;
+        return mixer_ctl_select(ctl, ctl->ename[value > max ? max : value]);
+    default:
+        errno = EINVAL;
+        return -1;
+    }
+
+    return ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+}
+
+/**
+ * @brief mixer_ctl_set_int
+ *
+ * @param ctl
+ * @param value
+ *
+ * @returns
+ */
+int mixer_ctl_set_int(struct mixer_ctl *ctl, long long value)
+{
+    return mixer_ctl_set_int_double(ctl, value, value);
+}
+
+/**
+ * @brief mixer_get_ctl_minmax
+ *
+ * @param ctl
+ * @param min
+ * @param max
+ *
+ * @returns
+ */
+int mixer_get_ctl_minmax(struct mixer_ctl *ctl, long long *min, long long *max)
+{
+    struct snd_ctl_elem_info *ei = ctl->info;
+
+    switch (ei->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        *min = ei->value.integer.min;
+        *max = ei->value.integer.max;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        *min = ei->value.integer64.min;
+        *max = ei->value.integer64.max;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        *min = 0;
+        *max = ei->value.enumerated.items;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+/**
+ * @brief mixer_tlv_get_dB_range
+ * Get dB range from tlv[] which is obtained from control
+ *
+ * @param tlv
+ * @param rangemin
+ * @param rangemax
+ * @param min
+ * @param max
+ *
+ * @returns
+ */
+int mixer_tlv_get_dB_range(unsigned int *tlv, long rangemin, long rangemax,
+                           long *min, long *max)
+{
+    int err;
+
+    switch (tlv[0]) {
+    case SND_CTL_TLVT_DB_RANGE: {
+        unsigned int pos, len;
+        len = int_index(tlv[1]);
+        if (len > MAX_TLV_RANGE_SIZE)
+            return -EINVAL;
+        pos = 2;
+        while (pos + 4 <= len) {
+            long rmin, rmax;
+            rangemin = (int)tlv[pos];
+            rangemax = (int)tlv[pos + 1];
+            err = mixer_tlv_get_dB_range(tlv + pos + 2,
+                                         rangemin, rangemax,
+                                         &rmin, &rmax);
+            if (err < 0)
+                return err;
+            if (pos > 2) {
+                if (rmin < *min)
+                    *min = rmin;
+                if (rmax > *max)
+                    *max = rmax;
+            } else {
+                *min = rmin;
+                *max = rmax;
+            }
+            pos += int_index(tlv[pos + 3]) + 4;
+        }
+        return 0;
+    }
+    case SND_CTL_TLVT_DB_SCALE: {
+        long step;
+        *min = (int)tlv[2];
+        step = (tlv[3] & 0xffff);
+        *max = *min + (long)(step * (rangemax - rangemin));
+        return 0;
+    }
+    case SND_CTL_TLVT_DB_MINMAX:
+    case SND_CTL_TLVT_DB_MINMAX_MUTE:
+    case SND_CTL_TLVT_DB_LINEAR:
+        *min = (int)tlv[2];
+        *max = (int)tlv[3];
+        return 0;
+    }
+    return -EINVAL;
+}
+
+/**
+ * @brief mixer_get_dB_range
+ * Get dB range of control
+ *
+ * @param ctl
+ * @param rangemin
+ * @param rangemax
+ * @param dB_min
+ * @param dB_max
+ * @param dB_step
+ *
+ * @returns
+ */
+int mixer_get_dB_range(struct mixer_ctl *ctl, long rangemin, long rangemax,
+                       float *dB_min, float *dB_max, float *dB_step)
+{
+    unsigned int *tlv;
+    long min, max;
+
+    if (ctl->tlv == NULL) {
+        ALOGE("mixer_get_dB_range() tlv of control %s is NULL", ctl->info->id.name);
+        return -EINVAL;
+    }
+
+    if (mixer_tlv_get_dB_range(ctl->tlv->tlv, rangemin, rangemax,
+                               &min, &max) < 0) {
+        ALOGE("mixer_get_dB_range() get control dB range fail");
+        return -EINVAL;
+    }
+
+    *dB_min = min * 1.0 / 100;
+    *dB_max = max * 1.0 / 100;
+    *dB_step = (max - min) * 1.0 / (rangemax - rangemin) / 100;
+
+    ALOGV("control %s : dB min = %f, dB max = %f, dB step = %f",
+          ctl->info->id.name,
+          *dB_min,
+          *dB_max,
+          *dB_step);
+
+    return 0;
+}
diff --git a/hardware/rockchip/audio/hdmi_hal/alsa_route.c b/hardware/rockchip/audio/hdmi_hal/alsa_route.c
new file mode 100644
index 0000000000..5d04b20c91
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/alsa_route.c
@@ -0,0 +1,736 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+ */
+
+/*
+ * @file alsa_route.c
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#define LOG_TAG "modules.hdmi.alsa_route"
+
+//#define LOG_NDEBUG 0
+
+#include <cutils/log.h>
+#include <cutils/config_utils.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <math.h>
+
+#include <linux/ioctl.h>
+#include "alsa_audio.h"
+
+#define __force
+#define __bitwise
+#define __user
+#include "asound.h"
+
+#include "codec_config/config_list.h"
+
+#define PCM_DEVICE0_PLAYBACK 0
+#define PCM_DEVICE0_CAPTURE 1
+#define PCM_DEVICE1_PLAYBACK 2
+#define PCM_DEVICE1_CAPTURE 3
+#define PCM_DEVICE2_PLAYBACK 4
+#define PCM_DEVICE2_CAPTURE 5
+
+#define PCM_MAX PCM_DEVICE2_CAPTURE
+
+static const struct config_route_table *route_table = NULL;
+static int route_card = -1;
+
+struct pcm* mPcm[PCM_MAX + 1];
+struct mixer* mMixerPlayback;
+struct mixer* mMixerCapture;
+
+/**
+ * @brief route_init 
+ *
+ * @returns 
+ */
+int route_init(void)
+{
+    char soundCardID[20] = "";
+    static FILE * fp;
+    unsigned i, config_count = sizeof(sound_card_config_list) / sizeof(struct alsa_sound_card_config);
+    size_t read_size;
+
+    ALOGV("route_init()");
+
+    fp = fopen("/proc/asound/card0/id", "rt");
+    if (!fp) {
+        ALOGE("Open sound card0 id error!");
+    } else {
+        read_size = fread(soundCardID, sizeof(char), sizeof(soundCardID), fp);
+        fclose(fp);
+
+        if (soundCardID[read_size - 1] == '\n') {
+            read_size--;
+            soundCardID[read_size] = '\0';
+        }
+
+        ALOGV("Sound card0 is %s", soundCardID);
+
+        for (i = 0; i < config_count; i++) {
+            if (!(sound_card_config_list + i) || !sound_card_config_list[i].sound_card_name ||
+                !sound_card_config_list[i].route_table)
+                continue;
+
+            if (strncmp(sound_card_config_list[i].sound_card_name, soundCardID, 
+                read_size) == 0) {
+                route_table = sound_card_config_list[i].route_table;
+                ALOGD("Get route table for sound card0 %s", soundCardID);
+            }
+        }
+    }
+
+    if (!route_table) {
+        route_table = &default_config_table;
+        ALOGD("Can not get config table for sound card0 %s, so get default config table.", soundCardID);
+    }
+
+    for (i = PCM_DEVICE0_PLAYBACK; i < PCM_MAX; i++)
+         mPcm[i] = NULL;
+
+    return 0;
+}
+
+/**
+ * @brief route_init
+ *
+ * @returns
+ */
+int route_card_init(int card)
+{
+    char soundcard[32];
+    char soundCardID[20] = "";
+    static FILE * fp;
+    unsigned i, config_count = sizeof(sound_card_config_list) / sizeof(struct alsa_sound_card_config);
+    size_t read_size;
+
+    ALOGV("route_card_init(card %d)", card);
+    sprintf(soundcard, "/proc/asound/card%d/id", card);
+    fp = fopen(soundcard, "rt");
+    if (!fp) {
+        ALOGE("Open %s error!", soundcard);
+    } else {
+        read_size = fread(soundCardID, sizeof(char), sizeof(soundCardID), fp);
+        fclose(fp);
+
+        if (soundCardID[read_size - 1] == '\n') {
+            read_size--;
+            soundCardID[read_size] = '\0';
+        }
+
+        ALOGV("Sound card%d is %s", card, soundCardID);
+
+        for (i = 0; i < config_count; i++) {
+            if (!(sound_card_config_list + i) || !sound_card_config_list[i].sound_card_name ||
+                !sound_card_config_list[i].route_table)
+                continue;
+
+            if (strncmp(sound_card_config_list[i].sound_card_name, soundCardID,
+                read_size) == 0) {
+                route_table = sound_card_config_list[i].route_table;
+                ALOGD("Get route table for sound card0 %s", soundCardID);
+            }
+        }
+    }
+
+    if (!route_table) {
+        route_table = &default_config_table;
+        ALOGD("Can not get config table for sound card0 %s, so get default config table.", soundCardID);
+    }
+
+    for (i = PCM_DEVICE0_PLAYBACK; i < PCM_MAX; i++)
+         mPcm[i] = NULL;
+
+    return 0;
+}
+
+/**
+ * @brief route_uninit 
+ */
+void route_uninit(void)
+{
+    ALOGV("route_uninit()");
+    route_pcm_close(PLAYBACK_OFF_ROUTE);
+
+	route_pcm_close(CAPTURE_OFF_ROUTE);
+}
+
+/**
+ * @brief is_playback_route 
+ *
+ * @param route
+ *
+ * @returns 
+ */
+int is_playback_route(unsigned route)
+{
+    switch (route) {
+    case MAIN_MIC_CAPTURE_ROUTE:
+    case HANDS_FREE_MIC_CAPTURE_ROUTE:
+    case BLUETOOTH_SOC_MIC_CAPTURE_ROUTE:
+    case CAPTURE_OFF_ROUTE:
+    case USB_CAPTURE_ROUTE:
+    case HDMI_IN_NORMAL_ROUTE:
+    case HDMI_IN_OFF_ROUTE:
+    case HDMI_IN_CAPTURE_ROUTE:
+    case HDMI_IN_CAPTURE_OFF_ROUTE:
+        return 0;
+    case SPEAKER_NORMAL_ROUTE:
+    case SPEAKER_INCALL_ROUTE:
+    case SPEAKER_RINGTONE_ROUTE:
+    case SPEAKER_VOIP_ROUTE:
+    case EARPIECE_NORMAL_ROUTE:
+    case EARPIECE_INCALL_ROUTE:
+    case EARPIECE_RINGTONE_ROUTE:
+    case EARPIECE_VOIP_ROUTE:
+    case HEADPHONE_NORMAL_ROUTE:
+    case HEADPHONE_INCALL_ROUTE:
+    case HEADPHONE_RINGTONE_ROUTE:
+    case SPEAKER_HEADPHONE_NORMAL_ROUTE:
+    case SPEAKER_HEADPHONE_RINGTONE_ROUTE:
+    case HEADPHONE_VOIP_ROUTE:
+    case HEADSET_NORMAL_ROUTE:
+    case HEADSET_INCALL_ROUTE:
+    case HEADSET_RINGTONE_ROUTE:
+    case HEADSET_VOIP_ROUTE:
+    case BLUETOOTH_NORMAL_ROUTE:
+    case BLUETOOTH_INCALL_ROUTE:
+    case BLUETOOTH_VOIP_ROUTE:
+    case PLAYBACK_OFF_ROUTE:
+    case INCALL_OFF_ROUTE:
+    case VOIP_OFF_ROUTE:
+    case HDMI_NORMAL_ROUTE:
+    case USB_NORMAL_ROUTE:
+    case SPDIF_NORMAL_ROUTE:
+        return 1;
+    default:
+        ALOGE("is_playback_route() Error route %d", route);
+        return -EINVAL;
+    }
+}
+
+/**
+ * @brief route_set_input_source 
+ *
+ * @param source
+ *
+ * @returns 
+ */
+int route_set_input_source(const char *source)
+{
+    struct mixer* mMixer = mMixerCapture;
+
+    if (mMixer == NULL || source[0] == '\0') return 0;
+
+    struct mixer_ctl *ctl= mixer_get_control(mMixer, "Input Source", 0);
+
+    if (ctl == NULL)
+        return 0;
+
+    ALOGV("mixer_ctl_select, Input Source, (%s)", source);
+    return mixer_ctl_select(ctl, source);
+}
+
+/**
+ * @brief route_set_voice_volume 
+ *
+ * @param ctlName
+ * @param volume
+ *
+ * @returns 
+ */
+int route_set_voice_volume(const char *ctlName, float volume)
+{
+    struct mixer* mMixer = mMixerPlayback;
+
+    if (mMixer == NULL || ctlName[0] == '\0')
+        return 0;
+
+    struct mixer_ctl *ctl = mixer_get_control(mMixer, ctlName, 0);
+    if (ctl == NULL)
+        return 0;
+
+    long long vol, vol_min, vol_max;
+    unsigned int Nmax = 6, N = volume * 5 + 1;
+    float e = 2.71828, dB_min, dB_max, dB_vol, dB_step, volFloat;
+
+    ALOGD("route_set_voice_volume() set incall voice volume %f to control %s", volume, ctlName);
+
+    if (mixer_get_ctl_minmax(ctl, &vol_min, &vol_max) < 0) {
+        ALOGE("mixer_get_dB_range() get control min max value fail");
+        return 0;
+    }
+
+    mixer_get_dB_range(ctl, (long)vol_min, (long)vol_max, &dB_min, &dB_max, &dB_step);
+
+    dB_vol = 20 * log((Nmax * pow(e, dB_min / 20) + N * (pow(e, dB_max / 20) - pow(e, dB_min / 20))) / Nmax);
+
+    volFloat = vol_min + (dB_vol - dB_min) / dB_step;
+    vol = (long long)volFloat;
+
+    if (((unsigned)(volFloat * 10) % 10) >= 5)
+        vol++;
+
+    ALOGV("dB_min = %f, dB_step = %f, dB_max = %f, dB_vol = %f",
+        dB_min,
+        dB_step,
+        dB_max,
+        dB_vol);
+
+    ALOGV("N = %u, volFloat = %f, vol = %lld", N, volFloat, vol);
+
+    return mixer_ctl_set_int(ctl, vol);
+}
+
+/**
+ * @brief get_route_config 
+ *
+ * @param route
+ *
+ * @returns 
+ */
+const struct config_route *get_route_config(unsigned route)
+{
+    ALOGV("get_route_config() route %d", route);
+
+    if (!route_table) {
+        ALOGE("get_route_config() route_table is NULL!");
+        return NULL;
+    }
+    switch (route) {
+    case SPEAKER_NORMAL_ROUTE:
+        return &(route_table->speaker_normal);
+    case SPEAKER_INCALL_ROUTE:
+        return &(route_table->speaker_incall);
+    case SPEAKER_RINGTONE_ROUTE:
+        return &(route_table->speaker_ringtone);
+    case SPEAKER_VOIP_ROUTE:
+        return &(route_table->speaker_voip);
+    case EARPIECE_NORMAL_ROUTE:
+        return &(route_table->earpiece_normal);
+    case EARPIECE_INCALL_ROUTE:
+        return &(route_table->earpiece_incall);
+    case EARPIECE_RINGTONE_ROUTE:
+        return &(route_table->earpiece_ringtone);
+    case EARPIECE_VOIP_ROUTE:
+        return &(route_table->earpiece_voip);
+    case HEADPHONE_NORMAL_ROUTE:
+        return &(route_table->headphone_normal);
+    case HEADPHONE_INCALL_ROUTE:
+        return &(route_table->headphone_incall);
+    case HEADPHONE_RINGTONE_ROUTE:
+        return &(route_table->headphone_ringtone);
+    case SPEAKER_HEADPHONE_NORMAL_ROUTE:
+        return &(route_table->speaker_headphone_normal);
+    case SPEAKER_HEADPHONE_RINGTONE_ROUTE:
+        return &(route_table->speaker_headphone_ringtone);
+    case HEADPHONE_VOIP_ROUTE:
+        return &(route_table->headphone_voip);
+    case HEADSET_NORMAL_ROUTE:
+        return &(route_table->headset_normal);
+    case HEADSET_INCALL_ROUTE:
+        return &(route_table->headset_incall);
+    case HEADSET_RINGTONE_ROUTE:
+        return &(route_table->headset_ringtone);
+    case HEADSET_VOIP_ROUTE:
+        return &(route_table->headset_voip);
+    case BLUETOOTH_NORMAL_ROUTE:
+        return &(route_table->bluetooth_normal);
+    case BLUETOOTH_INCALL_ROUTE:
+        return &(route_table->bluetooth_incall);
+    case BLUETOOTH_VOIP_ROUTE:
+        return &(route_table->bluetooth_voip);
+    case MAIN_MIC_CAPTURE_ROUTE:
+        return &(route_table->main_mic_capture);
+    case HANDS_FREE_MIC_CAPTURE_ROUTE:
+        return &(route_table->hands_free_mic_capture);
+    case BLUETOOTH_SOC_MIC_CAPTURE_ROUTE:
+        return &(route_table->bluetooth_sco_mic_capture);
+    case PLAYBACK_OFF_ROUTE:
+        return &(route_table->playback_off);
+    case CAPTURE_OFF_ROUTE:
+        return &(route_table->capture_off);
+    case INCALL_OFF_ROUTE:
+        return &(route_table->incall_off);
+    case VOIP_OFF_ROUTE:
+        return &(route_table->voip_off);
+    case HDMI_NORMAL_ROUTE:
+        return &(route_table->hdmi_normal);
+    case USB_NORMAL_ROUTE:
+        return &(route_table->usb_normal);
+    case USB_CAPTURE_ROUTE:
+        return &(route_table->usb_capture);
+    case SPDIF_NORMAL_ROUTE:
+        return &(route_table->spdif_normal);
+    case HDMI_IN_NORMAL_ROUTE:
+        return &(route_table->hdmiin_normal);
+    case HDMI_IN_OFF_ROUTE:
+        return &(route_table->hdmiin_off);
+    case HDMI_IN_CAPTURE_ROUTE:
+        return &(route_table->hdmiin_captrue);
+    case HDMI_IN_CAPTURE_OFF_ROUTE:
+        return &(route_table->hdmiin_captrue_off);
+    default:
+        ALOGE("get_route_config() Error route %d", route);
+        return NULL;
+    }
+}
+
+/**
+ * @brief set_controls 
+ *
+ * @param mixer
+ * @param ctls
+ * @param ctls_count
+ *
+ * @returns 
+ */
+int set_controls(struct mixer *mixer, const struct config_control *ctls, const unsigned ctls_count)
+{
+    struct mixer_ctl *ctl;
+    unsigned i;
+
+    ALOGV("set_controls() ctls_count %d", ctls_count);
+
+    if (!ctls || ctls_count <= 0) {
+        ALOGV("set_controls() ctls is NULL");
+        return 0;
+    }
+
+    for (i = 0; i < ctls_count; i++) {
+        ctl = mixer_get_control(mixer, ctls[i].ctl_name, 0);
+        if (!ctl) {
+            ALOGE_IF(route_table != &default_config_table, "set_controls() Can not get ctl : %s", ctls[i].ctl_name);
+            ALOGV_IF(route_table == &default_config_table, "set_controls() Can not get ctl : %s", ctls[i].ctl_name);
+            return -EINVAL;
+        }
+
+        if (ctl->info->type != SNDRV_CTL_ELEM_TYPE_BOOLEAN &&
+            ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER &&
+            ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER64 &&
+            ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+            ALOGE("set_controls() ctl %s is not a type of INT or ENUMERATED", ctls[i].ctl_name);
+            return -EINVAL;
+        }
+
+        if (ctls[i].str_val) {
+            if (ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+                ALOGE("set_controls() ctl %s is not a type of ENUMERATED", ctls[i].ctl_name);
+                return -EINVAL;
+            }
+            if (mixer_ctl_select(ctl, ctls[i].str_val) != 0) {
+                ALOGE("set_controls() Can not set ctl %s to %s", ctls[i].ctl_name, ctls[i].str_val);
+                return -EINVAL;
+            }
+            ALOGV("set_controls() set ctl %s to %s", ctls[i].ctl_name, ctls[i].str_val);
+        } else {
+            if (mixer_ctl_set_int_double(ctl, ctls[i].int_val[0], ctls[i].int_val[1]) != 0) {
+                ALOGE("set_controls() can not set ctl %s to %d", ctls[i].ctl_name, ctls[i].int_val[0]);
+                return -EINVAL;
+            }
+            ALOGV("set_controls() set ctl %s to %d", ctls[i].ctl_name, ctls[i].int_val[0]);
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * @brief route_set_controls 
+ *
+ * @param route
+ *
+ * @returns 
+ */
+int route_set_controls(unsigned route)
+{
+    struct mixer* mMixer;
+
+    if (route >= MAX_ROUTE) {
+        ALOGE("route_set_controls() route %d error!", route);
+        return -EINVAL;
+    }
+
+#ifdef SUPPORT_USB //usb input maybe used for primary
+    if (route != USB_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != MAIN_MIC_CAPTURE_ROUTE &&
+        route != HANDS_FREE_MIC_CAPTURE_ROUTE &&
+        route != BLUETOOTH_SOC_MIC_CAPTURE_ROUTE) {
+        ALOGV("route %d error for usb sound card!", route);
+        return -EINVAL;
+    }
+#else //primary input maybe used for usb
+    if (route > SPDIF_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != HDMI_IN_NORMAL_ROUTE &&
+        route != HDMI_IN_OFF_ROUTE &&
+        route != HDMI_IN_CAPTURE_ROUTE &&
+        route != HDMI_IN_CAPTURE_OFF_ROUTE) {
+        ALOGV("route %d error for codec or hdmi!", route);
+        return -EINVAL;
+    }
+#endif
+
+    ALOGD("route_set_controls() set route %d", route);
+
+    mMixer = is_playback_route(route) ? mMixerPlayback : mMixerCapture;
+
+    if (!mMixer) {
+        ALOGE("route_set_controls() mMixer is NULL!");
+        return -EINVAL;
+    }
+
+    const struct config_route *route_info = get_route_config(route);
+    if (!route_info) {
+        ALOGE("route_set_controls() Can not get config of route");
+        return -EINVAL;
+    }
+
+    if (route_info->controls_count > 0)
+        set_controls(mMixer, route_info->controls, route_info->controls_count);
+
+    return 0;
+}
+
+/**
+ * @brief route_pcm_open 
+ *
+ * @param route
+ */
+void route_pcm_open(uint32_t route)
+{
+    int is_playback;
+
+    if (route >= MAX_ROUTE) {
+        ALOGE("route_pcm_open() route %d error!", route);
+        goto __exit;
+    }
+
+#ifdef SUPPORT_USB //usb input maybe used for primary
+	
+	if (route != USB_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != MAIN_MIC_CAPTURE_ROUTE &&
+        route != HANDS_FREE_MIC_CAPTURE_ROUTE &&
+        route != BLUETOOTH_SOC_MIC_CAPTURE_ROUTE) {
+        ALOGV("route %d error for usb sound card!", route);
+        goto __exit;
+    }
+#else //primary input maybe used for usb
+    if (route > BLUETOOTH_SOC_MIC_CAPTURE_ROUTE &&
+        route != HDMI_NORMAL_ROUTE &&
+        route != SPDIF_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != HDMI_IN_NORMAL_ROUTE &&
+        route != HDMI_IN_OFF_ROUTE &&
+        route != PLAYBACK_OFF_ROUTE &&
+        route != HDMI_IN_CAPTURE_ROUTE &&
+        route != HDMI_IN_CAPTURE_OFF_ROUTE) {
+        ALOGV("route %d error for codec or hdmi!", route);
+        goto __exit;
+    }
+#endif
+
+    ALOGV("route_pcm_open() route %d", route);
+
+    is_playback = is_playback_route(route);
+
+    if (!route_table) {
+        route_init();
+    }
+
+    const struct config_route *route_info = get_route_config(route);
+    if (!route_info) {
+        ALOGE("route_pcm_open() Can not get config of route");
+        goto __exit;
+    }
+
+    ALOGD("route_info->sound_card %d, route_info->devices 0 %s %s",
+        route_info->sound_card,
+        (route_info->devices == DEVICES_0_1 || route_info->devices == DEVICES_0_2 ||
+        route_info->devices == DEVICES_0_1_2) ? (route_info->devices == DEVICES_0_2 ? "2" : "1") : "",
+        route_info->devices == DEVICES_0_1_2 ? "2" : "");
+
+   
+
+    if (is_playback) {
+        //close all route and pcm
+        if (mMixerPlayback) {
+            route_set_controls(INCALL_OFF_ROUTE);
+            route_set_controls(VOIP_OFF_ROUTE);
+        }
+        route_pcm_close(PLAYBACK_OFF_ROUTE);
+
+        //Open playback and capture of device 2
+        
+    } else {
+        route_pcm_close(CAPTURE_OFF_ROUTE);
+    }
+
+    //update mMixer
+    if (is_playback) {
+        if (mMixerPlayback == NULL)
+            mMixerPlayback = mixer_open_legacy(route_info->sound_card == 1 ? 0 : route_info->sound_card);
+    } else {
+        if (mMixerCapture == NULL)
+            mMixerCapture = mixer_open_legacy(route_info->sound_card == 1 ? 0 : route_info->sound_card);
+    }
+
+    //set controls
+    if (route_info->controls_count > 0)
+        route_set_controls(route);
+__exit:
+	ALOGV("route_pcm_open exit");
+}
+
+/**
+ * @brief route_pcm_open
+ *
+ * @param route
+ */
+void route_pcm_card_open(int card, uint32_t route)
+{
+    int is_playback;
+
+    if (route >= MAX_ROUTE) {
+        ALOGE("route_pcm_card_open() route %d error!", route);
+        goto __exit;
+    }
+    if (card < 0) {
+        ALOGE("route_pcm_card_open() card %d error!", card);
+        goto __exit;
+    }
+#ifdef SUPPORT_USB //usb input maybe used for primary
+
+	if (route != USB_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != MAIN_MIC_CAPTURE_ROUTE &&
+        route != HANDS_FREE_MIC_CAPTURE_ROUTE &&
+        route != BLUETOOTH_SOC_MIC_CAPTURE_ROUTE) {
+        ALOGV("route %d error for usb sound card!", route);
+        goto __exit;
+    }
+#else //primary input maybe used for usb
+    if (route > BLUETOOTH_SOC_MIC_CAPTURE_ROUTE &&
+        route != HDMI_NORMAL_ROUTE &&
+        route != SPDIF_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != HDMI_IN_NORMAL_ROUTE &&
+        route != HDMI_IN_OFF_ROUTE &&
+        route != PLAYBACK_OFF_ROUTE) {
+        ALOGV("route %d error for codec or hdmi!", route);
+        goto __exit;
+    }
+#endif
+
+    ALOGV("route_pcm_card_open(card %d, route %d)", card, route);
+
+    is_playback = is_playback_route(route);
+
+    if (!route_table || route_card != card) {
+        route_card_init(card);
+        route_card = card;
+    }
+
+    const struct config_route *route_info = get_route_config(route);
+    if (!route_info) {
+        ALOGE("route_pcm_open() Can not get config of route");
+        goto __exit;
+    }
+
+    ALOGD("route_info->sound_card %d, route_info->devices 0 %s %s",
+        route_info->sound_card,
+        (route_info->devices == DEVICES_0_1 || route_info->devices == DEVICES_0_2 ||
+        route_info->devices == DEVICES_0_1_2) ? (route_info->devices == DEVICES_0_2 ? "2" : "1") : "",
+        route_info->devices == DEVICES_0_1_2 ? "2" : "");
+
+    if (is_playback) {
+        //close all route and pcm
+        if (mMixerPlayback) {
+            route_set_controls(INCALL_OFF_ROUTE);
+            route_set_controls(VOIP_OFF_ROUTE);
+        }
+        route_pcm_close(PLAYBACK_OFF_ROUTE);
+
+        //Open playback and capture of device 2
+
+    } else {
+        route_pcm_close(CAPTURE_OFF_ROUTE);
+    }
+
+    //update mMixer
+    if (is_playback) {
+        if (mMixerPlayback == NULL)
+            mMixerPlayback = mixer_open_legacy(card);
+    } else {
+        if (mMixerCapture == NULL)
+            mMixerCapture = mixer_open_legacy(card);
+    }
+
+    //set controls
+    if (route_info->controls_count > 0)
+        route_set_controls(route);
+__exit:
+	ALOGV("route_pcm_open exit");
+
+}
+
+/**
+ * @brief route_pcm_close 
+ *
+ * @param route
+ *
+ * @returns 
+ */
+int route_pcm_close(unsigned route)
+{
+    unsigned i;
+
+    if (route != PLAYBACK_OFF_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != INCALL_OFF_ROUTE &&
+        route != VOIP_OFF_ROUTE &&
+        route != HDMI_IN_CAPTURE_OFF_ROUTE) {
+        ALOGE("route_pcm_close() is not a off route");
+        return 0;
+    }
+
+    ALOGV("route_pcm_close() route %d", route);
+
+	//set controls
+    if (is_playback_route(route) ? mMixerPlayback : mMixerCapture)
+        route_set_controls(route);
+
+    //close mixer
+    if (route == PLAYBACK_OFF_ROUTE) {
+        if (mMixerPlayback) {
+            mixer_close_legacy(mMixerPlayback);
+            mMixerPlayback = NULL;
+        }
+    } else if (route == CAPTURE_OFF_ROUTE) {
+        if (mMixerCapture) {
+            mixer_close_legacy(mMixerCapture);
+            mMixerCapture = NULL;
+        }
+    }
+
+    return 0;
+}
+
diff --git a/hardware/rockchip/audio/hdmi_hal/amix.c b/hardware/rockchip/audio/hdmi_hal/amix.c
new file mode 100755
index 0000000000..a71b403a9c
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/amix.c
@@ -0,0 +1,119 @@
+/*
+** Copyright 2010, The Android Open-Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+/**
+ * @file amix.c
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+#include "alsa_audio.h"
+
+
+/**
+ * @brief get_ctl 
+ *
+ * @param mixer
+ * @param name
+ *
+ * @returns 
+ */
+struct mixer_ctl *get_ctl(struct mixer *mixer, char *name)
+{
+    char *p;
+    unsigned idx = 0;
+
+    if (isdigit(name[0]))
+        return mixer_get_nth_control(mixer, atoi(name) - 1);
+
+    p = strrchr(name, '#');
+    if (p) {
+        *p++ = 0;
+        idx = atoi(p);
+    }
+
+    return mixer_get_control(mixer, name, idx);
+}
+
+int main(int argc, char **argv)
+{
+    struct mixer *mixer;
+    struct mixer_ctl *ctl;
+    int card = 0;
+    int r, i, c;
+	//struct audio_route *ar;
+    for (i = 0; i < argc; i++) {
+        if ((strncmp(argv[i], "-c", sizeof(argv[i])) == 0) ||
+            (strncmp(argv[i], "-card", sizeof(argv[i])) == 0)) {
+
+            i++;
+            if (i >= argc) {
+                argc -= 1;
+                argv += 1;
+                break;
+            }
+
+            card = atoi(argv[i]);
+            argc -= 2;
+            argv += 2;
+            break;
+        }
+    }
+
+    printf("Card:%i\n", card);
+
+    
+	mixer = mixer_open_legacy(card);
+
+    if (!mixer)
+        return -1;
+
+    if (argc == 1) {
+        mixer_dump(mixer);
+        return 0;
+    }
+
+    ctl = get_ctl(mixer, argv[1]);
+    argc -= 2;
+    argv += 2;
+
+    if (!ctl) {
+        printf("can't find control\n");
+        return -1;
+    }
+
+    if (argc) {
+        if (isdigit(argv[0][0]))
+            r = mixer_ctl_set_int(ctl, atoi(argv[0]));
+        else
+            r = mixer_ctl_select(ctl, argv[0]);
+        if (r)
+            printf("oops: %s\n", strerror(errno));
+    }
+
+    mixer_ctl_print(ctl);
+
+    mixer_close_legacy(mixer);
+
+    return 0;
+}
diff --git a/hardware/rockchip/audio/hdmi_hal/asound.h b/hardware/rockchip/audio/hdmi_hal/asound.h
new file mode 100755
index 0000000000..76abac5a38
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/asound.h
@@ -0,0 +1,844 @@
+/****************************************************************************
+ ****************************************************************************
+ ***
+ ***   This header was automatically generated from a Linux kernel header
+ ***   of the same name, to make information necessary for userspace to
+ ***   call into the kernel available to libc.  It contains only constants,
+ ***   structures, and macros generated from the original header, and thus,
+ ***   contains no copyrightable information.
+ ***
+ ****************************************************************************
+ ****************************************************************************/
+/**
+ * @file asound.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef __SOUND_ASOUND_H
+#define __SOUND_ASOUND_H
+
+#include <linux/types.h>
+
+#define SNDRV_PROTOCOL_VERSION(major, minor, subminor) (((major)<<16)|((minor)<<8)|(subminor))
+#define SNDRV_PROTOCOL_MAJOR(version) (((version)>>16)&0xffff)
+#define SNDRV_PROTOCOL_MINOR(version) (((version)>>8)&0xff)
+#define SNDRV_PROTOCOL_MICRO(version) ((version)&0xff)
+#define SNDRV_PROTOCOL_INCOMPATIBLE(kversion, uversion)   (SNDRV_PROTOCOL_MAJOR(kversion) != SNDRV_PROTOCOL_MAJOR(uversion) ||   (SNDRV_PROTOCOL_MAJOR(kversion) == SNDRV_PROTOCOL_MAJOR(uversion) &&   SNDRV_PROTOCOL_MINOR(kversion) != SNDRV_PROTOCOL_MINOR(uversion)))
+
+struct snd_aes_iec958 {
+ unsigned char status[24];
+ unsigned char subcode[147];
+ unsigned char pad;
+ unsigned char dig_subframe[4];
+};
+
+#define SNDRV_HWDEP_VERSION SNDRV_PROTOCOL_VERSION(1, 0, 1)
+
+enum {
+ SNDRV_HWDEP_IFACE_OPL2 = 0,
+ SNDRV_HWDEP_IFACE_OPL3,
+ SNDRV_HWDEP_IFACE_OPL4,
+ SNDRV_HWDEP_IFACE_SB16CSP,
+ SNDRV_HWDEP_IFACE_EMU10K1,
+ SNDRV_HWDEP_IFACE_YSS225,
+ SNDRV_HWDEP_IFACE_ICS2115,
+ SNDRV_HWDEP_IFACE_SSCAPE,
+ SNDRV_HWDEP_IFACE_VX,
+ SNDRV_HWDEP_IFACE_MIXART,
+ SNDRV_HWDEP_IFACE_USX2Y,
+ SNDRV_HWDEP_IFACE_EMUX_WAVETABLE,
+ SNDRV_HWDEP_IFACE_BLUETOOTH,
+ SNDRV_HWDEP_IFACE_USX2Y_PCM,
+ SNDRV_HWDEP_IFACE_PCXHR,
+ SNDRV_HWDEP_IFACE_SB_RC,
+ SNDRV_HWDEP_IFACE_HDA,
+ SNDRV_HWDEP_IFACE_USB_STREAM,
+
+ SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_USB_STREAM
+};
+
+struct snd_hwdep_info {
+ unsigned int device;
+ int card;
+ unsigned char id[64];
+ unsigned char name[80];
+ int iface;
+ unsigned char reserved[64];
+};
+
+struct snd_hwdep_dsp_status {
+ unsigned int version;
+ unsigned char id[32];
+ unsigned int num_dsps;
+ unsigned int dsp_loaded;
+ unsigned int chip_ready;
+ unsigned char reserved[16];
+};
+
+struct snd_hwdep_dsp_image {
+ unsigned int index;
+ unsigned char name[64];
+ unsigned char __user *image;
+ size_t length;
+ unsigned long driver_data;
+};
+
+#define SNDRV_HWDEP_IOCTL_PVERSION _IOR ('H', 0x00, int)
+#define SNDRV_HWDEP_IOCTL_INFO _IOR ('H', 0x01, struct snd_hwdep_info)
+#define SNDRV_HWDEP_IOCTL_DSP_STATUS _IOR('H', 0x02, struct snd_hwdep_dsp_status)
+#define SNDRV_HWDEP_IOCTL_DSP_LOAD _IOW('H', 0x03, struct snd_hwdep_dsp_image)
+
+#define SNDRV_PCM_VERSION SNDRV_PROTOCOL_VERSION(2, 0, 10)
+
+typedef unsigned long snd_pcm_uframes_t;
+typedef signed long snd_pcm_sframes_t;
+
+enum {
+ SNDRV_PCM_CLASS_GENERIC = 0,
+ SNDRV_PCM_CLASS_MULTI,
+ SNDRV_PCM_CLASS_MODEM,
+ SNDRV_PCM_CLASS_DIGITIZER,
+
+ SNDRV_PCM_CLASS_LAST = SNDRV_PCM_CLASS_DIGITIZER,
+};
+
+enum {
+ SNDRV_PCM_SUBCLASS_GENERIC_MIX = 0,
+ SNDRV_PCM_SUBCLASS_MULTI_MIX,
+
+ SNDRV_PCM_SUBCLASS_LAST = SNDRV_PCM_SUBCLASS_MULTI_MIX,
+};
+
+enum {
+ SNDRV_PCM_STREAM_PLAYBACK = 0,
+ SNDRV_PCM_STREAM_CAPTURE,
+ SNDRV_PCM_STREAM_LAST = SNDRV_PCM_STREAM_CAPTURE,
+};
+
+typedef int __bitwise snd_pcm_access_t;
+#define SNDRV_PCM_ACCESS_MMAP_INTERLEAVED ((__force snd_pcm_access_t) 0)  
+#define SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED ((__force snd_pcm_access_t) 1)  
+#define SNDRV_PCM_ACCESS_MMAP_COMPLEX ((__force snd_pcm_access_t) 2)  
+#define SNDRV_PCM_ACCESS_RW_INTERLEAVED ((__force snd_pcm_access_t) 3)  
+#define SNDRV_PCM_ACCESS_RW_NONINTERLEAVED ((__force snd_pcm_access_t) 4)  
+#define SNDRV_PCM_ACCESS_LAST SNDRV_PCM_ACCESS_RW_NONINTERLEAVED
+
+typedef int __bitwise snd_pcm_format_t;
+#define SNDRV_PCM_FORMAT_S8 ((__force snd_pcm_format_t) 0)
+#define SNDRV_PCM_FORMAT_U8 ((__force snd_pcm_format_t) 1)
+#define SNDRV_PCM_FORMAT_S16_LE ((__force snd_pcm_format_t) 2)
+#define SNDRV_PCM_FORMAT_S16_BE ((__force snd_pcm_format_t) 3)
+#define SNDRV_PCM_FORMAT_U16_LE ((__force snd_pcm_format_t) 4)
+#define SNDRV_PCM_FORMAT_U16_BE ((__force snd_pcm_format_t) 5)
+#define SNDRV_PCM_FORMAT_S24_LE ((__force snd_pcm_format_t) 6)  
+#define SNDRV_PCM_FORMAT_S24_BE ((__force snd_pcm_format_t) 7)  
+#define SNDRV_PCM_FORMAT_U24_LE ((__force snd_pcm_format_t) 8)  
+#define SNDRV_PCM_FORMAT_U24_BE ((__force snd_pcm_format_t) 9)  
+#define SNDRV_PCM_FORMAT_S32_LE ((__force snd_pcm_format_t) 10)
+#define SNDRV_PCM_FORMAT_S32_BE ((__force snd_pcm_format_t) 11)
+#define SNDRV_PCM_FORMAT_U32_LE ((__force snd_pcm_format_t) 12)
+#define SNDRV_PCM_FORMAT_U32_BE ((__force snd_pcm_format_t) 13)
+#define SNDRV_PCM_FORMAT_FLOAT_LE ((__force snd_pcm_format_t) 14)  
+#define SNDRV_PCM_FORMAT_FLOAT_BE ((__force snd_pcm_format_t) 15)  
+#define SNDRV_PCM_FORMAT_FLOAT64_LE ((__force snd_pcm_format_t) 16)  
+#define SNDRV_PCM_FORMAT_FLOAT64_BE ((__force snd_pcm_format_t) 17)  
+#define SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE ((__force snd_pcm_format_t) 18)  
+#define SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE ((__force snd_pcm_format_t) 19)  
+#define SNDRV_PCM_FORMAT_MU_LAW ((__force snd_pcm_format_t) 20)
+#define SNDRV_PCM_FORMAT_A_LAW ((__force snd_pcm_format_t) 21)
+#define SNDRV_PCM_FORMAT_IMA_ADPCM ((__force snd_pcm_format_t) 22)
+#define SNDRV_PCM_FORMAT_MPEG ((__force snd_pcm_format_t) 23)
+#define SNDRV_PCM_FORMAT_GSM ((__force snd_pcm_format_t) 24)
+#define SNDRV_PCM_FORMAT_SPECIAL ((__force snd_pcm_format_t) 31)
+#define SNDRV_PCM_FORMAT_S24_3LE ((__force snd_pcm_format_t) 32)  
+#define SNDRV_PCM_FORMAT_S24_3BE ((__force snd_pcm_format_t) 33)  
+#define SNDRV_PCM_FORMAT_U24_3LE ((__force snd_pcm_format_t) 34)  
+#define SNDRV_PCM_FORMAT_U24_3BE ((__force snd_pcm_format_t) 35)  
+#define SNDRV_PCM_FORMAT_S20_3LE ((__force snd_pcm_format_t) 36)  
+#define SNDRV_PCM_FORMAT_S20_3BE ((__force snd_pcm_format_t) 37)  
+#define SNDRV_PCM_FORMAT_U20_3LE ((__force snd_pcm_format_t) 38)  
+#define SNDRV_PCM_FORMAT_U20_3BE ((__force snd_pcm_format_t) 39)  
+#define SNDRV_PCM_FORMAT_S18_3LE ((__force snd_pcm_format_t) 40)  
+#define SNDRV_PCM_FORMAT_S18_3BE ((__force snd_pcm_format_t) 41)  
+#define SNDRV_PCM_FORMAT_U18_3LE ((__force snd_pcm_format_t) 42)  
+#define SNDRV_PCM_FORMAT_U18_3BE ((__force snd_pcm_format_t) 43)  
+#define SNDRV_PCM_FORMAT_LAST SNDRV_PCM_FORMAT_U18_3BE
+
+#ifdef SNDRV_LITTLE_ENDIAN
+#define SNDRV_PCM_FORMAT_S16 SNDRV_PCM_FORMAT_S16_LE
+#define SNDRV_PCM_FORMAT_U16 SNDRV_PCM_FORMAT_U16_LE
+#define SNDRV_PCM_FORMAT_S24 SNDRV_PCM_FORMAT_S24_LE
+#define SNDRV_PCM_FORMAT_U24 SNDRV_PCM_FORMAT_U24_LE
+#define SNDRV_PCM_FORMAT_S32 SNDRV_PCM_FORMAT_S32_LE
+#define SNDRV_PCM_FORMAT_U32 SNDRV_PCM_FORMAT_U32_LE
+#define SNDRV_PCM_FORMAT_FLOAT SNDRV_PCM_FORMAT_FLOAT_LE
+#define SNDRV_PCM_FORMAT_FLOAT64 SNDRV_PCM_FORMAT_FLOAT64_LE
+#define SNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE
+#endif
+#ifdef SNDRV_BIG_ENDIAN
+#define SNDRV_PCM_FORMAT_S16 SNDRV_PCM_FORMAT_S16_BE
+#define SNDRV_PCM_FORMAT_U16 SNDRV_PCM_FORMAT_U16_BE
+#define SNDRV_PCM_FORMAT_S24 SNDRV_PCM_FORMAT_S24_BE
+#define SNDRV_PCM_FORMAT_U24 SNDRV_PCM_FORMAT_U24_BE
+#define SNDRV_PCM_FORMAT_S32 SNDRV_PCM_FORMAT_S32_BE
+#define SNDRV_PCM_FORMAT_U32 SNDRV_PCM_FORMAT_U32_BE
+#define SNDRV_PCM_FORMAT_FLOAT SNDRV_PCM_FORMAT_FLOAT_BE
+#define SNDRV_PCM_FORMAT_FLOAT64 SNDRV_PCM_FORMAT_FLOAT64_BE
+#define SNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE
+#endif
+
+typedef int __bitwise snd_pcm_subformat_t;
+#define SNDRV_PCM_SUBFORMAT_STD ((__force snd_pcm_subformat_t) 0)
+#define SNDRV_PCM_SUBFORMAT_LAST SNDRV_PCM_SUBFORMAT_STD
+
+#define SNDRV_PCM_INFO_MMAP 0x00000001  
+#define SNDRV_PCM_INFO_MMAP_VALID 0x00000002  
+#define SNDRV_PCM_INFO_DOUBLE 0x00000004  
+#define SNDRV_PCM_INFO_BATCH 0x00000010  
+#define SNDRV_PCM_INFO_INTERLEAVED 0x00000100  
+#define SNDRV_PCM_INFO_NONINTERLEAVED 0x00000200  
+#define SNDRV_PCM_INFO_COMPLEX 0x00000400  
+#define SNDRV_PCM_INFO_BLOCK_TRANSFER 0x00010000  
+#define SNDRV_PCM_INFO_OVERRANGE 0x00020000  
+#define SNDRV_PCM_INFO_RESUME 0x00040000  
+#define SNDRV_PCM_INFO_PAUSE 0x00080000  
+#define SNDRV_PCM_INFO_HALF_DUPLEX 0x00100000  
+#define SNDRV_PCM_INFO_JOINT_DUPLEX 0x00200000  
+#define SNDRV_PCM_INFO_SYNC_START 0x00400000  
+#define SNDRV_PCM_INFO_FIFO_IN_FRAMES 0x80000000  
+
+typedef int __bitwise snd_pcm_state_t;
+#define SNDRV_PCM_STATE_OPEN ((__force snd_pcm_state_t) 0)  
+#define SNDRV_PCM_STATE_SETUP ((__force snd_pcm_state_t) 1)  
+#define SNDRV_PCM_STATE_PREPARED ((__force snd_pcm_state_t) 2)  
+#define SNDRV_PCM_STATE_RUNNING ((__force snd_pcm_state_t) 3)  
+#define SNDRV_PCM_STATE_XRUN ((__force snd_pcm_state_t) 4)  
+#define SNDRV_PCM_STATE_DRAINING ((__force snd_pcm_state_t) 5)  
+#define SNDRV_PCM_STATE_PAUSED ((__force snd_pcm_state_t) 6)  
+#define SNDRV_PCM_STATE_SUSPENDED ((__force snd_pcm_state_t) 7)  
+#define SNDRV_PCM_STATE_DISCONNECTED ((__force snd_pcm_state_t) 8)  
+#define SNDRV_PCM_STATE_LAST SNDRV_PCM_STATE_DISCONNECTED
+
+enum {
+ SNDRV_PCM_MMAP_OFFSET_DATA = 0x00000000,
+ SNDRV_PCM_MMAP_OFFSET_STATUS = 0x80000000,
+ SNDRV_PCM_MMAP_OFFSET_CONTROL = 0x81000000,
+};
+
+union snd_pcm_sync_id {
+ unsigned char id[16];
+ unsigned short id16[8];
+ unsigned int id32[4];
+};
+
+struct snd_pcm_info {
+ unsigned int device;
+ unsigned int subdevice;
+ int stream;
+ int card;
+ unsigned char id[64];
+ unsigned char name[80];
+ unsigned char subname[32];
+ int dev_class;
+ int dev_subclass;
+ unsigned int subdevices_count;
+ unsigned int subdevices_avail;
+ union snd_pcm_sync_id sync;
+ unsigned char reserved[64];
+};
+
+typedef int snd_pcm_hw_param_t;
+#define SNDRV_PCM_HW_PARAM_ACCESS 0  
+#define SNDRV_PCM_HW_PARAM_FORMAT 1  
+#define SNDRV_PCM_HW_PARAM_SUBFORMAT 2  
+#define SNDRV_PCM_HW_PARAM_FIRST_MASK SNDRV_PCM_HW_PARAM_ACCESS
+#define SNDRV_PCM_HW_PARAM_LAST_MASK SNDRV_PCM_HW_PARAM_SUBFORMAT
+
+#define SNDRV_PCM_HW_PARAM_SAMPLE_BITS 8  
+#define SNDRV_PCM_HW_PARAM_FRAME_BITS 9  
+#define SNDRV_PCM_HW_PARAM_CHANNELS 10  
+#define SNDRV_PCM_HW_PARAM_RATE 11  
+#define SNDRV_PCM_HW_PARAM_PERIOD_TIME 12  
+#define SNDRV_PCM_HW_PARAM_PERIOD_SIZE 13  
+#define SNDRV_PCM_HW_PARAM_PERIOD_BYTES 14  
+#define SNDRV_PCM_HW_PARAM_PERIODS 15  
+#define SNDRV_PCM_HW_PARAM_BUFFER_TIME 16  
+#define SNDRV_PCM_HW_PARAM_BUFFER_SIZE 17  
+#define SNDRV_PCM_HW_PARAM_BUFFER_BYTES 18  
+#define SNDRV_PCM_HW_PARAM_TICK_TIME 19  
+#define SNDRV_PCM_HW_PARAM_FIRST_INTERVAL SNDRV_PCM_HW_PARAM_SAMPLE_BITS
+#define SNDRV_PCM_HW_PARAM_LAST_INTERVAL SNDRV_PCM_HW_PARAM_TICK_TIME
+
+#define SNDRV_PCM_HW_PARAMS_NORESAMPLE (1<<0)  
+
+struct snd_interval {
+ unsigned int min, max;
+ unsigned int openmin:1,
+ openmax:1,
+ integer:1,
+ empty:1;
+};
+
+#define SNDRV_MASK_MAX 256
+
+struct snd_mask {
+ __u32 bits[(SNDRV_MASK_MAX+31)/32];
+};
+
+struct snd_pcm_hw_params {
+ unsigned int flags;
+ struct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK -
+ SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];
+ struct snd_mask mres[5];
+ struct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -
+ SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
+ struct snd_interval ires[9];
+ unsigned int rmask;
+ unsigned int cmask;
+ unsigned int info;
+ unsigned int msbits;
+ unsigned int rate_num;
+ unsigned int rate_den;
+ snd_pcm_uframes_t fifo_size;
+ unsigned char reserved[64];
+};
+
+enum {
+ SNDRV_PCM_TSTAMP_NONE = 0,
+ SNDRV_PCM_TSTAMP_ENABLE,
+ SNDRV_PCM_TSTAMP_LAST = SNDRV_PCM_TSTAMP_ENABLE,
+};
+
+struct snd_pcm_sw_params {
+ int tstamp_mode;
+ unsigned int period_step;
+ unsigned int sleep_min;
+ snd_pcm_uframes_t avail_min;
+ snd_pcm_uframes_t xfer_align;
+ snd_pcm_uframes_t start_threshold;
+ snd_pcm_uframes_t stop_threshold;
+ snd_pcm_uframes_t silence_threshold;
+ snd_pcm_uframes_t silence_size;
+ snd_pcm_uframes_t boundary;
+ unsigned char reserved[64];
+};
+
+struct snd_pcm_channel_info {
+ unsigned int channel;
+ __kernel_off_t offset;
+ unsigned int first;
+ unsigned int step;
+};
+
+struct snd_pcm_status {
+ snd_pcm_state_t state;
+ struct timespec trigger_tstamp;
+ struct timespec tstamp;
+ snd_pcm_uframes_t appl_ptr;
+ snd_pcm_uframes_t hw_ptr;
+ snd_pcm_sframes_t delay;
+ snd_pcm_uframes_t avail;
+ snd_pcm_uframes_t avail_max;
+ snd_pcm_uframes_t overrange;
+ snd_pcm_state_t suspended_state;
+ unsigned char reserved[60];
+};
+
+struct snd_pcm_mmap_status {
+ snd_pcm_state_t state;
+ int pad1;
+ snd_pcm_uframes_t hw_ptr;
+ struct timespec tstamp;
+ snd_pcm_state_t suspended_state;
+};
+
+struct snd_pcm_mmap_control {
+ snd_pcm_uframes_t appl_ptr;
+ snd_pcm_uframes_t avail_min;
+};
+
+#define SNDRV_PCM_SYNC_PTR_HWSYNC (1<<0)  
+#define SNDRV_PCM_SYNC_PTR_APPL (1<<1)  
+#define SNDRV_PCM_SYNC_PTR_AVAIL_MIN (1<<2)  
+
+struct snd_pcm_sync_ptr {
+ unsigned int flags;
+ union {
+ struct snd_pcm_mmap_status status;
+ unsigned char reserved[64];
+ } s;
+ union {
+ struct snd_pcm_mmap_control control;
+ unsigned char reserved[64];
+ } c;
+};
+
+struct snd_xferi {
+ snd_pcm_sframes_t result;
+ void __user *buf;
+ snd_pcm_uframes_t frames;
+};
+
+struct snd_xfern {
+ snd_pcm_sframes_t result;
+ void __user * __user *bufs;
+ snd_pcm_uframes_t frames;
+};
+
+enum {
+ SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,
+ SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,
+ SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,
+};
+
+#define SNDRV_PCM_IOCTL_PVERSION _IOR('A', 0x00, int)
+#define SNDRV_PCM_IOCTL_INFO _IOR('A', 0x01, struct snd_pcm_info)
+#define SNDRV_PCM_IOCTL_TSTAMP _IOW('A', 0x02, int)
+#define SNDRV_PCM_IOCTL_TTSTAMP _IOW('A', 0x03, int)
+#define SNDRV_PCM_IOCTL_HW_REFINE _IOWR('A', 0x10, struct snd_pcm_hw_params)
+#define SNDRV_PCM_IOCTL_HW_PARAMS _IOWR('A', 0x11, struct snd_pcm_hw_params)
+#define SNDRV_PCM_IOCTL_HW_FREE _IO('A', 0x12)
+#define SNDRV_PCM_IOCTL_SW_PARAMS _IOWR('A', 0x13, struct snd_pcm_sw_params)
+#define SNDRV_PCM_IOCTL_STATUS _IOR('A', 0x20, struct snd_pcm_status)
+#define SNDRV_PCM_IOCTL_DELAY _IOR('A', 0x21, snd_pcm_sframes_t)
+#define SNDRV_PCM_IOCTL_HWSYNC _IO('A', 0x22)
+#define SNDRV_PCM_IOCTL_SYNC_PTR _IOWR('A', 0x23, struct snd_pcm_sync_ptr)
+#define SNDRV_PCM_IOCTL_CHANNEL_INFO _IOR('A', 0x32, struct snd_pcm_channel_info)
+#define SNDRV_PCM_IOCTL_PREPARE _IO('A', 0x40)
+#define SNDRV_PCM_IOCTL_RESET _IO('A', 0x41)
+#define SNDRV_PCM_IOCTL_START _IO('A', 0x42)
+#define SNDRV_PCM_IOCTL_DROP _IO('A', 0x43)
+#define SNDRV_PCM_IOCTL_DRAIN _IO('A', 0x44)
+#define SNDRV_PCM_IOCTL_PAUSE _IOW('A', 0x45, int)
+#define SNDRV_PCM_IOCTL_REWIND _IOW('A', 0x46, snd_pcm_uframes_t)
+#define SNDRV_PCM_IOCTL_RESUME _IO('A', 0x47)
+#define SNDRV_PCM_IOCTL_XRUN _IO('A', 0x48)
+#define SNDRV_PCM_IOCTL_FORWARD _IOW('A', 0x49, snd_pcm_uframes_t)
+#define SNDRV_PCM_IOCTL_WRITEI_FRAMES _IOW('A', 0x50, struct snd_xferi)
+#define SNDRV_PCM_IOCTL_READI_FRAMES _IOR('A', 0x51, struct snd_xferi)
+#define SNDRV_PCM_IOCTL_WRITEN_FRAMES _IOW('A', 0x52, struct snd_xfern)
+#define SNDRV_PCM_IOCTL_READN_FRAMES _IOR('A', 0x53, struct snd_xfern)
+#define SNDRV_PCM_IOCTL_LINK _IOW('A', 0x60, int)
+#define SNDRV_PCM_IOCTL_UNLINK _IO('A', 0x61)
+
+#define SNDRV_RAWMIDI_VERSION SNDRV_PROTOCOL_VERSION(2, 0, 0)
+
+enum {
+ SNDRV_RAWMIDI_STREAM_OUTPUT = 0,
+ SNDRV_RAWMIDI_STREAM_INPUT,
+ SNDRV_RAWMIDI_STREAM_LAST = SNDRV_RAWMIDI_STREAM_INPUT,
+};
+
+#define SNDRV_RAWMIDI_INFO_OUTPUT 0x00000001
+#define SNDRV_RAWMIDI_INFO_INPUT 0x00000002
+#define SNDRV_RAWMIDI_INFO_DUPLEX 0x00000004
+
+struct snd_rawmidi_info {
+ unsigned int device;
+ unsigned int subdevice;
+ int stream;
+ int card;
+ unsigned int flags;
+ unsigned char id[64];
+ unsigned char name[80];
+ unsigned char subname[32];
+ unsigned int subdevices_count;
+ unsigned int subdevices_avail;
+ unsigned char reserved[64];
+};
+
+struct snd_rawmidi_params {
+ int stream;
+ size_t buffer_size;
+ size_t avail_min;
+ unsigned int no_active_sensing: 1;
+ unsigned char reserved[16];
+};
+
+struct snd_rawmidi_status {
+ int stream;
+ struct timespec tstamp;
+ size_t avail;
+ size_t xruns;
+ unsigned char reserved[16];
+};
+
+#define SNDRV_RAWMIDI_IOCTL_PVERSION _IOR('W', 0x00, int)
+#define SNDRV_RAWMIDI_IOCTL_INFO _IOR('W', 0x01, struct snd_rawmidi_info)
+#define SNDRV_RAWMIDI_IOCTL_PARAMS _IOWR('W', 0x10, struct snd_rawmidi_params)
+#define SNDRV_RAWMIDI_IOCTL_STATUS _IOWR('W', 0x20, struct snd_rawmidi_status)
+#define SNDRV_RAWMIDI_IOCTL_DROP _IOW('W', 0x30, int)
+#define SNDRV_RAWMIDI_IOCTL_DRAIN _IOW('W', 0x31, int)
+
+#define SNDRV_TIMER_VERSION SNDRV_PROTOCOL_VERSION(2, 0, 6)
+
+enum {
+ SNDRV_TIMER_CLASS_NONE = -1,
+ SNDRV_TIMER_CLASS_SLAVE = 0,
+ SNDRV_TIMER_CLASS_GLOBAL,
+ SNDRV_TIMER_CLASS_CARD,
+ SNDRV_TIMER_CLASS_PCM,
+ SNDRV_TIMER_CLASS_LAST = SNDRV_TIMER_CLASS_PCM,
+};
+
+enum {
+ SNDRV_TIMER_SCLASS_NONE = 0,
+ SNDRV_TIMER_SCLASS_APPLICATION,
+ SNDRV_TIMER_SCLASS_SEQUENCER,
+ SNDRV_TIMER_SCLASS_OSS_SEQUENCER,
+ SNDRV_TIMER_SCLASS_LAST = SNDRV_TIMER_SCLASS_OSS_SEQUENCER,
+};
+
+#define SNDRV_TIMER_GLOBAL_SYSTEM 0
+#define SNDRV_TIMER_GLOBAL_RTC 1
+#define SNDRV_TIMER_GLOBAL_HPET 2
+#define SNDRV_TIMER_GLOBAL_HRTIMER 3
+
+#define SNDRV_TIMER_FLG_SLAVE (1<<0)  
+
+struct snd_timer_id {
+ int dev_class;
+ int dev_sclass;
+ int card;
+ int device;
+ int subdevice;
+};
+
+struct snd_timer_ginfo {
+ struct snd_timer_id tid;
+ unsigned int flags;
+ int card;
+ unsigned char id[64];
+ unsigned char name[80];
+ unsigned long reserved0;
+ unsigned long resolution;
+ unsigned long resolution_min;
+ unsigned long resolution_max;
+ unsigned int clients;
+ unsigned char reserved[32];
+};
+
+struct snd_timer_gparams {
+ struct snd_timer_id tid;
+ unsigned long period_num;
+ unsigned long period_den;
+ unsigned char reserved[32];
+};
+
+struct snd_timer_gstatus {
+ struct snd_timer_id tid;
+ unsigned long resolution;
+ unsigned long resolution_num;
+ unsigned long resolution_den;
+ unsigned char reserved[32];
+};
+
+struct snd_timer_select {
+ struct snd_timer_id id;
+ unsigned char reserved[32];
+};
+
+struct snd_timer_info {
+ unsigned int flags;
+ int card;
+ unsigned char id[64];
+ unsigned char name[80];
+ unsigned long reserved0;
+ unsigned long resolution;
+ unsigned char reserved[64];
+};
+
+#define SNDRV_TIMER_PSFLG_AUTO (1<<0)  
+#define SNDRV_TIMER_PSFLG_EXCLUSIVE (1<<1)  
+#define SNDRV_TIMER_PSFLG_EARLY_EVENT (1<<2)  
+
+struct snd_timer_params {
+ unsigned int flags;
+ unsigned int ticks;
+ unsigned int queue_size;
+ unsigned int reserved0;
+ unsigned int filter;
+ unsigned char reserved[60];
+};
+
+struct snd_timer_status {
+ struct timespec tstamp;
+ unsigned int resolution;
+ unsigned int lost;
+ unsigned int overrun;
+ unsigned int queue;
+ unsigned char reserved[64];
+};
+
+#define SNDRV_TIMER_IOCTL_PVERSION _IOR('T', 0x00, int)
+#define SNDRV_TIMER_IOCTL_NEXT_DEVICE _IOWR('T', 0x01, struct snd_timer_id)
+#define SNDRV_TIMER_IOCTL_TREAD _IOW('T', 0x02, int)
+#define SNDRV_TIMER_IOCTL_GINFO _IOWR('T', 0x03, struct snd_timer_ginfo)
+#define SNDRV_TIMER_IOCTL_GPARAMS _IOW('T', 0x04, struct snd_timer_gparams)
+#define SNDRV_TIMER_IOCTL_GSTATUS _IOWR('T', 0x05, struct snd_timer_gstatus)
+#define SNDRV_TIMER_IOCTL_SELECT _IOW('T', 0x10, struct snd_timer_select)
+#define SNDRV_TIMER_IOCTL_INFO _IOR('T', 0x11, struct snd_timer_info)
+#define SNDRV_TIMER_IOCTL_PARAMS _IOW('T', 0x12, struct snd_timer_params)
+#define SNDRV_TIMER_IOCTL_STATUS _IOR('T', 0x14, struct snd_timer_status)
+
+#define SNDRV_TIMER_IOCTL_START _IO('T', 0xa0)
+#define SNDRV_TIMER_IOCTL_STOP _IO('T', 0xa1)
+#define SNDRV_TIMER_IOCTL_CONTINUE _IO('T', 0xa2)
+#define SNDRV_TIMER_IOCTL_PAUSE _IO('T', 0xa3)
+
+struct snd_timer_read {
+ unsigned int resolution;
+ unsigned int ticks;
+};
+
+enum {
+ SNDRV_TIMER_EVENT_RESOLUTION = 0,
+ SNDRV_TIMER_EVENT_TICK,
+ SNDRV_TIMER_EVENT_START,
+ SNDRV_TIMER_EVENT_STOP,
+ SNDRV_TIMER_EVENT_CONTINUE,
+ SNDRV_TIMER_EVENT_PAUSE,
+ SNDRV_TIMER_EVENT_EARLY,
+ SNDRV_TIMER_EVENT_SUSPEND,
+ SNDRV_TIMER_EVENT_RESUME,
+
+ SNDRV_TIMER_EVENT_MSTART = SNDRV_TIMER_EVENT_START + 10,
+ SNDRV_TIMER_EVENT_MSTOP = SNDRV_TIMER_EVENT_STOP + 10,
+ SNDRV_TIMER_EVENT_MCONTINUE = SNDRV_TIMER_EVENT_CONTINUE + 10,
+ SNDRV_TIMER_EVENT_MPAUSE = SNDRV_TIMER_EVENT_PAUSE + 10,
+ SNDRV_TIMER_EVENT_MSUSPEND = SNDRV_TIMER_EVENT_SUSPEND + 10,
+ SNDRV_TIMER_EVENT_MRESUME = SNDRV_TIMER_EVENT_RESUME + 10,
+};
+
+struct snd_timer_tread {
+ int event;
+ struct timespec tstamp;
+ unsigned int val;
+};
+
+#define SNDRV_CTL_VERSION SNDRV_PROTOCOL_VERSION(2, 0, 6)
+
+struct snd_ctl_card_info {
+ int card;
+ int pad;
+ unsigned char id[16];
+ unsigned char driver[16];
+ unsigned char name[32];
+ unsigned char longname[80];
+ unsigned char reserved_[16];
+ unsigned char mixername[80];
+ unsigned char components[128];
+};
+
+typedef int __bitwise snd_ctl_elem_type_t;
+#define SNDRV_CTL_ELEM_TYPE_NONE ((__force snd_ctl_elem_type_t) 0)  
+#define SNDRV_CTL_ELEM_TYPE_BOOLEAN ((__force snd_ctl_elem_type_t) 1)  
+#define SNDRV_CTL_ELEM_TYPE_INTEGER ((__force snd_ctl_elem_type_t) 2)  
+#define SNDRV_CTL_ELEM_TYPE_ENUMERATED ((__force snd_ctl_elem_type_t) 3)  
+#define SNDRV_CTL_ELEM_TYPE_BYTES ((__force snd_ctl_elem_type_t) 4)  
+#define SNDRV_CTL_ELEM_TYPE_IEC958 ((__force snd_ctl_elem_type_t) 5)  
+#define SNDRV_CTL_ELEM_TYPE_INTEGER64 ((__force snd_ctl_elem_type_t) 6)  
+#define SNDRV_CTL_ELEM_TYPE_LAST SNDRV_CTL_ELEM_TYPE_INTEGER64
+
+typedef int __bitwise snd_ctl_elem_iface_t;
+#define SNDRV_CTL_ELEM_IFACE_CARD ((__force snd_ctl_elem_iface_t) 0)  
+#define SNDRV_CTL_ELEM_IFACE_HWDEP ((__force snd_ctl_elem_iface_t) 1)  
+#define SNDRV_CTL_ELEM_IFACE_MIXER ((__force snd_ctl_elem_iface_t) 2)  
+#define SNDRV_CTL_ELEM_IFACE_PCM ((__force snd_ctl_elem_iface_t) 3)  
+#define SNDRV_CTL_ELEM_IFACE_RAWMIDI ((__force snd_ctl_elem_iface_t) 4)  
+#define SNDRV_CTL_ELEM_IFACE_TIMER ((__force snd_ctl_elem_iface_t) 5)  
+#define SNDRV_CTL_ELEM_IFACE_SEQUENCER ((__force snd_ctl_elem_iface_t) 6)  
+#define SNDRV_CTL_ELEM_IFACE_LAST SNDRV_CTL_ELEM_IFACE_SEQUENCER
+
+#define SNDRV_CTL_ELEM_ACCESS_READ (1<<0)
+#define SNDRV_CTL_ELEM_ACCESS_WRITE (1<<1)
+#define SNDRV_CTL_ELEM_ACCESS_READWRITE (SNDRV_CTL_ELEM_ACCESS_READ|SNDRV_CTL_ELEM_ACCESS_WRITE)
+#define SNDRV_CTL_ELEM_ACCESS_VOLATILE (1<<2)  
+#define SNDRV_CTL_ELEM_ACCESS_TIMESTAMP (1<<3)  
+#define SNDRV_CTL_ELEM_ACCESS_TLV_READ (1<<4)  
+#define SNDRV_CTL_ELEM_ACCESS_TLV_WRITE (1<<5)  
+#define SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE (SNDRV_CTL_ELEM_ACCESS_TLV_READ|SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)
+#define SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND (1<<6)  
+#define SNDRV_CTL_ELEM_ACCESS_INACTIVE (1<<8)  
+#define SNDRV_CTL_ELEM_ACCESS_LOCK (1<<9)  
+#define SNDRV_CTL_ELEM_ACCESS_OWNER (1<<10)  
+#define SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK (1<<28)   
+#define SNDRV_CTL_ELEM_ACCESS_USER (1<<29)  
+
+#define SNDRV_CTL_POWER_D0 0x0000  
+#define SNDRV_CTL_POWER_D1 0x0100  
+#define SNDRV_CTL_POWER_D2 0x0200  
+#define SNDRV_CTL_POWER_D3 0x0300  
+#define SNDRV_CTL_POWER_D3hot (SNDRV_CTL_POWER_D3|0x0000)  
+#define SNDRV_CTL_POWER_D3cold (SNDRV_CTL_POWER_D3|0x0001)  
+
+/** TLV type - Container */
+#define SND_CTL_TLVT_CONTAINER		0x0000
+/** TLV type - basic dB scale */
+#define SND_CTL_TLVT_DB_SCALE		0x0001
+/** TLV type - linear volume */
+#define SND_CTL_TLVT_DB_LINEAR		0x0002
+/** TLV type - dB range container */
+#define SND_CTL_TLVT_DB_RANGE		0x0003
+/** TLV type - dB scale specified by min/max values */
+#define SND_CTL_TLVT_DB_MINMAX		0x0004
+/** TLV type - dB scale specified by min/max values (with mute) */
+#define SND_CTL_TLVT_DB_MINMAX_MUTE	0x0005
+
+/** Mute state */
+#define SND_CTL_TLV_DB_GAIN_MUTE	-9999999
+
+struct sndrv_ctl_tlv {
+ unsigned int numid;     /* control element numeric identification */
+ unsigned int length;    /* in bytes aligned to 4 */
+ unsigned int tlv[0];    /* first TLV */
+};
+
+struct snd_ctl_elem_id {
+ unsigned int numid;
+ snd_ctl_elem_iface_t iface;
+ unsigned int device;
+ unsigned int subdevice;
+ unsigned char name[44];
+ unsigned int index;
+};
+
+struct snd_ctl_elem_list {
+ unsigned int offset;
+ unsigned int space;
+ unsigned int used;
+ unsigned int count;
+ struct snd_ctl_elem_id __user *pids;
+ unsigned char reserved[50];
+};
+
+struct snd_ctl_elem_info {
+ struct snd_ctl_elem_id id;
+ snd_ctl_elem_type_t type;
+ unsigned int access;
+ unsigned int count;
+ __kernel_pid_t owner;
+ union {
+ struct {
+ long min;
+ long max;
+ long step;
+ } integer;
+ struct {
+ long long min;
+ long long max;
+ long long step;
+ } integer64;
+ struct {
+ unsigned int items;
+ unsigned int item;
+ char name[64];
+ } enumerated;
+ unsigned char reserved[128];
+ } value;
+ union {
+ unsigned short d[4];
+ unsigned short *d_ptr;
+ } dimen;
+ unsigned char reserved[64-4*sizeof(unsigned short)];
+};
+
+struct snd_ctl_elem_value {
+ struct snd_ctl_elem_id id;
+ unsigned int indirect: 1;
+ union {
+ union {
+ long value[128];
+ long *value_ptr;
+ } integer;
+ union {
+ long long value[64];
+ long long *value_ptr;
+ } integer64;
+ union {
+ unsigned int item[128];
+ unsigned int *item_ptr;
+ } enumerated;
+ union {
+ unsigned char data[512];
+ unsigned char *data_ptr;
+ } bytes;
+ struct snd_aes_iec958 iec958;
+ } value;
+ struct timespec tstamp;
+ unsigned char reserved[128-sizeof(struct timespec)];
+};
+
+struct snd_ctl_tlv {
+ unsigned int numid;
+ unsigned int length;
+ unsigned int tlv[0];
+};
+
+#define SNDRV_CTL_IOCTL_PVERSION _IOR('U', 0x00, int)
+#define SNDRV_CTL_IOCTL_CARD_INFO _IOR('U', 0x01, struct snd_ctl_card_info)
+#define SNDRV_CTL_IOCTL_ELEM_LIST _IOWR('U', 0x10, struct snd_ctl_elem_list)
+#define SNDRV_CTL_IOCTL_ELEM_INFO _IOWR('U', 0x11, struct snd_ctl_elem_info)
+#define SNDRV_CTL_IOCTL_ELEM_READ _IOWR('U', 0x12, struct snd_ctl_elem_value)
+#define SNDRV_CTL_IOCTL_ELEM_WRITE _IOWR('U', 0x13, struct snd_ctl_elem_value)
+#define SNDRV_CTL_IOCTL_ELEM_LOCK _IOW('U', 0x14, struct snd_ctl_elem_id)
+#define SNDRV_CTL_IOCTL_ELEM_UNLOCK _IOW('U', 0x15, struct snd_ctl_elem_id)
+#define SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS _IOWR('U', 0x16, int)
+#define SNDRV_CTL_IOCTL_ELEM_ADD _IOWR('U', 0x17, struct snd_ctl_elem_info)
+#define SNDRV_CTL_IOCTL_ELEM_REPLACE _IOWR('U', 0x18, struct snd_ctl_elem_info)
+#define SNDRV_CTL_IOCTL_ELEM_REMOVE _IOWR('U', 0x19, struct snd_ctl_elem_id)
+#define SNDRV_CTL_IOCTL_TLV_READ _IOWR('U', 0x1a, struct snd_ctl_tlv)
+#define SNDRV_CTL_IOCTL_TLV_WRITE _IOWR('U', 0x1b, struct snd_ctl_tlv)
+#define SNDRV_CTL_IOCTL_TLV_COMMAND _IOWR('U', 0x1c, struct snd_ctl_tlv)
+#define SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE _IOWR('U', 0x20, int)
+#define SNDRV_CTL_IOCTL_HWDEP_INFO _IOR('U', 0x21, struct snd_hwdep_info)
+#define SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE _IOR('U', 0x30, int)
+#define SNDRV_CTL_IOCTL_PCM_INFO _IOWR('U', 0x31, struct snd_pcm_info)
+#define SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE _IOW('U', 0x32, int)
+#define SNDRV_CTL_IOCTL_RAWMIDI_NEXT_DEVICE _IOWR('U', 0x40, int)
+#define SNDRV_CTL_IOCTL_RAWMIDI_INFO _IOWR('U', 0x41, struct snd_rawmidi_info)
+#define SNDRV_CTL_IOCTL_RAWMIDI_PREFER_SUBDEVICE _IOW('U', 0x42, int)
+#define SNDRV_CTL_IOCTL_POWER _IOWR('U', 0xd0, int)
+#define SNDRV_CTL_IOCTL_POWER_STATE _IOR('U', 0xd1, int)
+
+enum sndrv_ctl_event_type {
+ SNDRV_CTL_EVENT_ELEM = 0,
+ SNDRV_CTL_EVENT_LAST = SNDRV_CTL_EVENT_ELEM,
+};
+
+#define SNDRV_CTL_EVENT_MASK_VALUE (1<<0)  
+#define SNDRV_CTL_EVENT_MASK_INFO (1<<1)  
+#define SNDRV_CTL_EVENT_MASK_ADD (1<<2)  
+#define SNDRV_CTL_EVENT_MASK_TLV (1<<3)  
+#define SNDRV_CTL_EVENT_MASK_REMOVE (~0U)  
+
+struct snd_ctl_event {
+ int type;
+ union {
+ struct {
+ unsigned int mask;
+ struct snd_ctl_elem_id id;
+ } elem;
+ unsigned char data8[60];
+ } data;
+};
+
+#define SNDRV_CTL_NAME_NONE ""
+#define SNDRV_CTL_NAME_PLAYBACK "Playback "
+#define SNDRV_CTL_NAME_CAPTURE "Capture "
+
+#define SNDRV_CTL_NAME_IEC958_NONE ""
+#define SNDRV_CTL_NAME_IEC958_SWITCH "Switch"
+#define SNDRV_CTL_NAME_IEC958_VOLUME "Volume"
+#define SNDRV_CTL_NAME_IEC958_DEFAULT "Default"
+#define SNDRV_CTL_NAME_IEC958_MASK "Mask"
+#define SNDRV_CTL_NAME_IEC958_CON_MASK "Con Mask"
+#define SNDRV_CTL_NAME_IEC958_PRO_MASK "Pro Mask"
+#define SNDRV_CTL_NAME_IEC958_PCM_STREAM "PCM Stream"
+#define SNDRV_CTL_NAME_IEC958(expl,direction,what) "IEC958 " expl SNDRV_CTL_NAME_##direction SNDRV_CTL_NAME_IEC958_##what
+
+#endif
+
diff --git a/hardware/rockchip/audio/hdmi_hal/asoundlib.h b/hardware/rockchip/audio/hdmi_hal/asoundlib.h
new file mode 100755
index 0000000000..1be60167f3
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/asoundlib.h
@@ -0,0 +1,325 @@
+/* asoundlib.h
+**
+** Copyright 2011, The Android Open Source Project
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**     * Redistributions of source code must retain the above copyright
+**       notice, this list of conditions and the following disclaimer.
+**     * Redistributions in binary form must reproduce the above copyright
+**       notice, this list of conditions and the following disclaimer in the
+**       documentation and/or other materials provided with the distribution.
+**     * Neither the name of The Android Open Source Project nor the names of
+**       its contributors may be used to endorse or promote products derived
+**       from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY The Android Open Source Project ``AS IS'' AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL The Android Open Source Project BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+** DAMAGE.
+*/
+
+#ifndef ASOUNDLIB_H
+#define ASOUNDLIB_H
+
+#include <sys/time.h>
+#include <stddef.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/*
+ * PCM API
+ */
+
+struct pcm;
+
+#define PCM_OUT        0x00000000
+#define PCM_IN         0x10000000
+#define PCM_MMAP       0x00000001
+#define PCM_NOIRQ      0x00000002
+#define PCM_NORESTART  0x00000004 /* PCM_NORESTART - when set, calls to
+                                   * pcm_write for a playback stream will not
+                                   * attempt to restart the stream in the case
+                                   * of an underflow, but will return -EPIPE
+                                   * instead.  After the first -EPIPE error, the
+                                   * stream is considered to be stopped, and a
+                                   * second call to pcm_write will attempt to
+                                   * restart the stream.
+                                   */
+#define PCM_MONOTONIC  0x00000008 /* see pcm_get_htimestamp */
+
+/* PCM runtime states */
+#define	PCM_STATE_OPEN		0
+#define	PCM_STATE_SETUP		1
+#define	PCM_STATE_PREPARED	2
+#define	PCM_STATE_RUNNING		3
+#define	PCM_STATE_XRUN		4
+#define	PCM_STATE_DRAINING	5
+#define	PCM_STATE_PAUSED		6
+#define	PCM_STATE_SUSPENDED	7
+#define	PCM_STATE_DISCONNECTED	8
+
+/* TLV header size*/
+#define TLV_HEADER_SIZE (2 * sizeof(unsigned int))
+
+/* Bit formats */
+enum pcm_format {
+    PCM_FORMAT_INVALID = -1,
+    PCM_FORMAT_S16_LE = 0,  /* 16-bit signed */
+    PCM_FORMAT_S32_LE,      /* 32-bit signed */
+    PCM_FORMAT_S8,          /* 8-bit signed */
+    PCM_FORMAT_S24_LE,      /* 24-bits in 4-bytes */
+    PCM_FORMAT_S24_3LE,     /* 24-bits in 3-bytes */
+    PCM_FORMAT_IEC958_SUBFRAME_LE = 18,  /* 32bit for IEC-958 */
+    PCM_FORMAT_MAX,
+};
+
+/* Bitmask has 256 bits (32 bytes) in asound.h */
+struct pcm_mask {
+    unsigned int bits[32 / sizeof(unsigned int)];
+};
+
+/* Configuration for a stream */
+struct pcm_config {
+    unsigned int channels;
+    unsigned int rate;
+    unsigned int period_size;
+    unsigned int period_count;
+    enum pcm_format format;
+
+    /* Values to use for the ALSA start, stop and silence thresholds, and
+     * silence size.  Setting any one of these values to 0 will cause the
+     * default tinyalsa values to be used instead.
+     * Tinyalsa defaults are as follows.
+     *
+     * start_threshold   : period_count * period_size
+     * stop_threshold    : period_count * period_size
+     * silence_threshold : 0
+     * silence_size      : 0
+     */
+    unsigned int start_threshold;
+    unsigned int stop_threshold;
+    unsigned int silence_threshold;
+    unsigned int silence_size;
+
+    /* Minimum number of frames available before pcm_mmap_write() will actually
+     * write into the kernel buffer. Only used if the stream is opened in mmap mode
+     * (pcm_open() called with PCM_MMAP flag set).   Use 0 for default.
+     */
+    int avail_min;
+};
+
+/* PCM parameters */
+enum pcm_param
+{
+    /* mask parameters */
+    PCM_PARAM_ACCESS,
+    PCM_PARAM_FORMAT,
+    PCM_PARAM_SUBFORMAT,
+    /* interval parameters */
+    PCM_PARAM_SAMPLE_BITS,
+    PCM_PARAM_FRAME_BITS,
+    PCM_PARAM_CHANNELS,
+    PCM_PARAM_RATE,
+    PCM_PARAM_PERIOD_TIME,
+    PCM_PARAM_PERIOD_SIZE,
+    PCM_PARAM_PERIOD_BYTES,
+    PCM_PARAM_PERIODS,
+    PCM_PARAM_BUFFER_TIME,
+    PCM_PARAM_BUFFER_SIZE,
+    PCM_PARAM_BUFFER_BYTES,
+    PCM_PARAM_TICK_TIME,
+};
+
+/* Mixer control types */
+enum mixer_ctl_type {
+    MIXER_CTL_TYPE_BOOL,
+    MIXER_CTL_TYPE_INT,
+    MIXER_CTL_TYPE_ENUM,
+    MIXER_CTL_TYPE_BYTE,
+    MIXER_CTL_TYPE_IEC958,
+    MIXER_CTL_TYPE_INT64,
+    MIXER_CTL_TYPE_UNKNOWN,
+
+    MIXER_CTL_TYPE_MAX,
+};
+
+/* Open and close a stream */
+struct pcm *pcm_open(unsigned int card, unsigned int device,
+                     unsigned int flags, struct pcm_config *config);
+int pcm_close(struct pcm *pcm);
+int pcm_is_ready(struct pcm *pcm);
+
+/* Obtain the parameters for a PCM */
+struct pcm_params *pcm_params_get(unsigned int card, unsigned int device,
+                                  unsigned int flags);
+void pcm_params_free(struct pcm_params *pcm_params);
+
+struct pcm_mask *pcm_params_get_mask(struct pcm_params *pcm_params,
+                                     enum pcm_param param);
+unsigned int pcm_params_get_min(struct pcm_params *pcm_params,
+                                enum pcm_param param);
+void pcm_params_set_min(struct pcm_params *pcm_params,
+                                enum pcm_param param, unsigned int val);
+unsigned int pcm_params_get_max(struct pcm_params *pcm_params,
+                                enum pcm_param param);
+void pcm_params_set_max(struct pcm_params *pcm_params,
+                                enum pcm_param param, unsigned int val);
+
+/* Converts the pcm parameters to a human readable string.
+ * The string parameter is a caller allocated buffer of size bytes,
+ * which is then filled up to size - 1 and null terminated,
+ * if size is greater than zero.
+ * The return value is the number of bytes copied to string
+ * (not including null termination) if less than size; otherwise,
+ * the number of bytes required for the buffer.
+ */
+int pcm_params_to_string(struct pcm_params *params, char *string, unsigned int size);
+
+/* Returns 1 if the pcm_format is present (format bit set) in
+ * the pcm_params structure; 0 otherwise, or upon unrecognized format.
+ */
+int pcm_params_format_test(struct pcm_params *params, enum pcm_format format);
+
+/* Set and get config */
+int pcm_get_config(struct pcm *pcm, struct pcm_config *config);
+int pcm_set_config(struct pcm *pcm, struct pcm_config *config);
+
+/* Returns a human readable reason for the last error */
+const char *pcm_get_error(struct pcm *pcm);
+
+/* Returns the sample size in bits for a PCM format.
+ * As with ALSA formats, this is the storage size for the format, whereas the
+ * format represents the number of significant bits. For example,
+ * PCM_FORMAT_S24_LE uses 32 bits of storage.
+ */
+unsigned int pcm_format_to_bits(enum pcm_format format);
+
+/* Returns the buffer size (int frames) that should be used for pcm_write. */
+unsigned int pcm_get_buffer_size(struct pcm *pcm);
+unsigned int pcm_frames_to_bytes(struct pcm *pcm, unsigned int frames);
+unsigned int pcm_bytes_to_frames(struct pcm *pcm, unsigned int bytes);
+
+/* Returns the pcm latency in ms */
+unsigned int pcm_get_latency(struct pcm *pcm);
+
+/* Returns available frames in pcm buffer and corresponding time stamp.
+ * The clock is CLOCK_MONOTONIC if flag PCM_MONOTONIC was specified in pcm_open,
+ * otherwise the clock is CLOCK_REALTIME.
+ * For an input stream, frames available are frames ready for the
+ * application to read.
+ * For an output stream, frames available are the number of empty frames available
+ * for the application to write.
+ */
+int pcm_get_htimestamp(struct pcm *pcm, unsigned int *avail,
+                       struct timespec *tstamp);
+
+/* Returns the subdevice on which the pcm has been opened */
+unsigned int pcm_get_subdevice(struct pcm *pcm);
+
+/* Write data to the fifo.
+ * Will start playback on the first write or on a write that
+ * occurs after a fifo underrun.
+ */
+int pcm_write(struct pcm *pcm, const void *data, unsigned int count);
+int pcm_read(struct pcm *pcm, void *data, unsigned int count);
+
+/*
+ * mmap() support.
+ */
+int pcm_mmap_write(struct pcm *pcm, const void *data, unsigned int count);
+int pcm_mmap_read(struct pcm *pcm, void *data, unsigned int count);
+int pcm_mmap_begin(struct pcm *pcm, void **areas, unsigned int *offset,
+                   unsigned int *frames);
+int pcm_mmap_commit(struct pcm *pcm, unsigned int offset, unsigned int frames);
+int pcm_mmap_avail(struct pcm *pcm);
+
+/* Returns current read/write position in the mmap buffer with associated time stamp.
+ */
+int pcm_mmap_get_hw_ptr(struct pcm* pcm, unsigned int *hw_ptr, struct timespec *tstamp);
+
+/* Prepare the PCM substream to be triggerable */
+int pcm_prepare(struct pcm *pcm);
+/* Start and stop a PCM channel that doesn't transfer data */
+int pcm_start(struct pcm *pcm);
+int pcm_stop(struct pcm *pcm);
+
+/* ioctl function for PCM driver */
+int pcm_ioctl(struct pcm *pcm, int request, ...);
+
+/* Interrupt driven API */
+int pcm_wait(struct pcm *pcm, int timeout);
+int pcm_get_poll_fd(struct pcm *pcm);
+
+/* Change avail_min after the stream has been opened with no need to stop the stream.
+ * Only accepted if opened with PCM_MMAP and PCM_NOIRQ flags
+ */
+int pcm_set_avail_min(struct pcm *pcm, int avail_min);
+
+/*
+ * MIXER API
+ */
+
+struct mixer;
+struct mixer_ctl;
+
+/* Open and close a mixer */
+struct mixer *mixer_open(unsigned int card);
+void mixer_close(struct mixer *mixer);
+
+/* Get info about a mixer */
+const char *mixer_get_name(struct mixer *mixer);
+
+/* Obtain mixer controls */
+unsigned int mixer_get_num_ctls(struct mixer *mixer);
+struct mixer_ctl *mixer_get_ctl(struct mixer *mixer, unsigned int id);
+struct mixer_ctl *mixer_get_ctl_by_name(struct mixer *mixer, const char *name);
+
+/* Get info about mixer controls */
+const char *mixer_ctl_get_name(struct mixer_ctl *ctl);
+enum mixer_ctl_type mixer_ctl_get_type(struct mixer_ctl *ctl);
+const char *mixer_ctl_get_type_string(struct mixer_ctl *ctl);
+unsigned int mixer_ctl_get_num_values(struct mixer_ctl *ctl);
+unsigned int mixer_ctl_get_num_enums(struct mixer_ctl *ctl);
+const char *mixer_ctl_get_enum_string(struct mixer_ctl *ctl,
+                                      unsigned int enum_id);
+
+/* Some sound cards update their controls due to external events,
+ * such as HDMI EDID byte data changing when an HDMI cable is
+ * connected. This API allows the count of elements to be updated.
+ */
+void mixer_ctl_update(struct mixer_ctl *ctl);
+
+/* Set and get mixer controls */
+int mixer_ctl_get_percent(struct mixer_ctl *ctl, unsigned int id);
+int mixer_ctl_set_percent(struct mixer_ctl *ctl, unsigned int id, int percent);
+
+int mixer_ctl_get_value(struct mixer_ctl *ctl, unsigned int id);
+int mixer_ctl_is_access_tlv_rw(struct mixer_ctl *ctl);
+int mixer_ctl_get_array(struct mixer_ctl *ctl, void *array, size_t count);
+int mixer_ctl_set_value(struct mixer_ctl *ctl, unsigned int id, int value);
+int mixer_ctl_set_array(struct mixer_ctl *ctl, const void *array, size_t count);
+int mixer_ctl_set_enum_by_string(struct mixer_ctl *ctl, const char *string);
+
+/* Determine range of integer mixer controls */
+int mixer_ctl_get_range_min(struct mixer_ctl *ctl);
+int mixer_ctl_get_range_max(struct mixer_ctl *ctl);
+
+int mixer_subscribe_events(struct mixer *mixer, int subscribe);
+int mixer_wait_event(struct mixer *mixer, int timeout);
+int mixer_consume_event(struct mixer *mixer);
+
+#if defined(__cplusplus)
+}  /* extern "C" */
+#endif
+
+#endif
diff --git a/hardware/rockchip/audio/hdmi_hal/audio_hw.c b/hardware/rockchip/audio/hdmi_hal/audio_hw.c
new file mode 100644
index 0000000000..cba4d34756
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/audio_hw.c
@@ -0,0 +1,3177 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file    audio_hw.c
+ * @brief
+ *                 ALSA Audio Git Log
+ * - V0.1.0:add alsa audio hal,just support 312x now.
+ * - V0.2.0:remove unused variable.
+ * - V0.3.0:turn off device when do_standby.
+ * - V0.4.0:turn off device before open pcm.
+ * - V0.4.1:Need to re-open the control to fix no sound when suspend.
+ * - V0.5.0:Merge the mixer operation from legacy_alsa.
+ * - V0.6.0:Merge speex denoise from legacy_alsa.
+ * - V0.7.0:add copyright.
+ * - V0.7.1:add support for box audio
+ * - V0.7.2:add support for dircet output
+ * - V0.8.0:update the direct output for box, add the DVI mode
+ * - V1.0.0:stable version
+ *
+ * @author  RkAudio
+ * @version 1.0.5
+ * @date    2015-08-24
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "modules.hdmi.audio_hal"
+
+#include "alsa_audio.h"
+#include "audio_hw.h"
+#include <system/audio.h>
+#include "codec_config/config.h"
+
+#include "audio_setting.h"
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+#define SNDRV_CARDS 8
+#define SNDRV_DEVICES 8
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+#define SND_CARDS_NODE          "/proc/asound/cards"
+#define SAMPLECOUNT 441*5*2*2
+
+#define CHR_VALID (1 << 1)
+#define CHL_VALID (1 << 0)
+#define CH_CHECK (1 << 2)
+
+struct SurroundFormat {
+    audio_format_t format;
+    const char *value;
+};
+
+const struct SurroundFormat sSurroundFormat[] = {
+    {AUDIO_FORMAT_AC3,"AUDIO_FORMAT_AC3"},
+    {AUDIO_FORMAT_E_AC3,"AUDIO_FORMAT_E_AC3"},
+    {AUDIO_FORMAT_DTS,"AUDIO_FORMAT_DTS"},
+    {AUDIO_FORMAT_DTS_HD,"AUDIO_FORMAT_DTS_HD"},
+    {AUDIO_FORMAT_AAC_LC,"AUDIO_FORMAT_AAC_LC"},
+    {AUDIO_FORMAT_DOLBY_TRUEHD,"AUDIO_FORMAT_DOLBY_TRUEHD"},
+    {AUDIO_FORMAT_AC4,"AUDIO_FORMAT_E_AC3_JOC"}
+};
+
+/*
+ * mute audio datas when screen off or standby
+ * The MediaPlayer no stop/pause when screen off, they may be just play in background,
+ * so they still send audio datas to audio hal.
+ * HDMI may disconnet and enter stanby status, this means no voice output on HDMI
+ * but speaker/av and spdif still work, and voice may output on them.
+ * Some customer need to mute the audio datas in this condition.
+ * If need mute datas when screen off, define this marco.
+ */
+//#define MUTE_WHEN_SCREEN_OFF
+
+/*
+ * if current audio stream bitstream over hdmi,
+ * and hdmi is removed and reconnected later,
+ * the driver of hdmi may config it with pcm mode automatically,
+ * which is according the implement of hdmi driver.
+ * If hdmi driver implement in this way, in order to output audio
+ * bitstream stream after hdmi reconnected,
+ * we must close sound card of hdmi and reopen/config
+ * it in bitstream mode. If need this, define this macro.
+ */
+#define AUDIO_BITSTREAM_REOPEN_HDMI
+
+//#define ALSA_DEBUG
+#ifdef ALSA_IN_DEBUG
+FILE *in_debug;
+#endif
+
+int in_dump(const struct audio_stream *stream, int fd);
+int out_dump(const struct audio_stream *stream, int fd);
+
+int get_output_device_id(audio_devices_t device)
+{
+    if (device == AUDIO_DEVICE_NONE)
+        return OUT_DEVICE_NONE;
+
+    if (popcount(device) == 2) {
+        if ((device == (AUDIO_DEVICE_OUT_SPEAKER |
+                        AUDIO_DEVICE_OUT_WIRED_HEADSET)) ||
+                (device == (AUDIO_DEVICE_OUT_SPEAKER |
+                            AUDIO_DEVICE_OUT_WIRED_HEADPHONE)))
+            return OUT_DEVICE_SPEAKER_AND_HEADSET;
+        else
+            return OUT_DEVICE_NONE;
+    }
+
+    if (popcount(device) != 1)
+        return OUT_DEVICE_NONE;
+
+    switch (device) {
+    case AUDIO_DEVICE_OUT_SPEAKER:
+        return OUT_DEVICE_SPEAKER;
+    case AUDIO_DEVICE_OUT_WIRED_HEADSET:
+        return OUT_DEVICE_HEADSET;
+    case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:
+        return OUT_DEVICE_HEADPHONES;
+    case AUDIO_DEVICE_OUT_BLUETOOTH_SCO:
+    case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
+    case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT:
+        return OUT_DEVICE_BT_SCO;
+    default:
+        return OUT_DEVICE_NONE;
+    }
+}
+
+int get_input_source_id(audio_source_t source)
+{
+    switch (source) {
+    case AUDIO_SOURCE_DEFAULT:
+        return IN_SOURCE_NONE;
+    case AUDIO_SOURCE_MIC:
+        return IN_SOURCE_MIC;
+    case AUDIO_SOURCE_CAMCORDER:
+        return IN_SOURCE_CAMCORDER;
+    case AUDIO_SOURCE_VOICE_RECOGNITION:
+        return IN_SOURCE_VOICE_RECOGNITION;
+    case AUDIO_SOURCE_VOICE_COMMUNICATION:
+        return IN_SOURCE_VOICE_COMMUNICATION;
+    default:
+        return IN_SOURCE_NONE;
+    }
+}
+
+/**
+ * @brief force_non_hdmi_out_standby
+ * must be called with hw device outputs list, all out streams, and hw device mutexes locked
+ *
+ * @param adev
+ */
+static void force_non_hdmi_out_standby(struct audio_device *adev)
+{
+    enum output_type type;
+    struct stream_out *out;
+    for (type = 0; type < OUTPUT_TOTAL; ++type) {
+        out = adev->outputs[type];
+        if (type == OUTPUT_HDMI_MULTI|| !out)
+            continue;
+        /* This will never recurse more than 2 levels deep. */
+        do_out_standby(out);
+    }
+}
+
+unsigned getOutputRouteFromDevice(uint32_t device)
+{
+    switch (device) {
+    case AUDIO_DEVICE_OUT_SPEAKER:
+        return SPEAKER_NORMAL_ROUTE;
+    case AUDIO_DEVICE_OUT_WIRED_HEADSET:
+        return HEADSET_NORMAL_ROUTE;
+    case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:
+        return HEADPHONE_NORMAL_ROUTE;
+    case (AUDIO_DEVICE_OUT_SPEAKER|AUDIO_DEVICE_OUT_WIRED_HEADPHONE):
+    case (AUDIO_DEVICE_OUT_SPEAKER|AUDIO_DEVICE_OUT_WIRED_HEADSET):
+        return SPEAKER_HEADPHONE_NORMAL_ROUTE;
+    case AUDIO_DEVICE_OUT_BLUETOOTH_SCO:
+    case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
+    case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT:
+        return BLUETOOTH_NORMAL_ROUTE;
+    case AUDIO_DEVICE_OUT_AUX_DIGITAL:
+        return HDMI_NORMAL_ROUTE;
+    default:
+        return PLAYBACK_OFF_ROUTE;
+    }
+}
+
+uint32_t getVoiceRouteFromDevice(uint32_t device)
+{
+    ALOGE("not support now");
+    return 0;
+}
+
+uint32_t getInputRouteFromDevice(uint32_t device)
+{
+    ALOGE("%s:device:%x",__FUNCTION__,device);
+    switch (device) {
+    case AUDIO_DEVICE_IN_BUILTIN_MIC:
+        return MAIN_MIC_CAPTURE_ROUTE;
+    case AUDIO_DEVICE_IN_WIRED_HEADSET:
+        return HANDS_FREE_MIC_CAPTURE_ROUTE;
+    case AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET:
+        return BLUETOOTH_SOC_MIC_CAPTURE_ROUTE;
+    case AUDIO_DEVICE_IN_ANLG_DOCK_HEADSET:
+        return USB_CAPTURE_ROUTE;
+    case AUDIO_DEVICE_IN_HDMI:
+        return HDMI_IN_CAPTURE_ROUTE;
+    default:
+        return CAPTURE_OFF_ROUTE;
+    }
+}
+
+uint32_t getRouteFromDevice(uint32_t device)
+{
+    if (device & AUDIO_DEVICE_BIT_IN)
+        return getInputRouteFromDevice(device);
+    else
+        return getOutputRouteFromDevice(device);
+}
+
+struct dev_proc_info HDMI_OUT_NAME[] =
+{
+    {"realtekrt5651co", "i2s-hifi",},
+    {"realtekrt5670co", "i2s-hifi",},
+    {"rkhdmidpsound", NULL,},
+    {"hdmisound", NULL},
+    {"rockchiphdmi0", NULL,},
+    {"rockchiprt5640c", "i2s-hifi",},
+    {NULL, NULL}, /* Note! Must end with NULL, else will cause crash */
+};
+
+struct dev_proc_info HDMI_IN_NAME[] =
+{
+    {"realtekrt5651co", "tc358749x-audio"},
+    {"hdmiin", NULL},
+    {"rockchiphdmirx", NULL},
+    {NULL, NULL}, /* Note! Must end with NULL, else will cause crash */
+};
+
+static int name_match(const char* dst, const char* src)
+{
+    int score = 0;
+    // total equal
+    if (!strcmp(dst, src)) {
+        score = 100;
+    } else  if (strstr(dst, src)) {
+        // part equal
+        score = 50;
+    }
+
+    return score;
+}
+
+static bool is_specified_out_sound_card(char *id, struct dev_proc_info *match)
+{
+    int i = 0;
+
+    if (!match)
+        return true; /* match any */
+
+    while (match[i].cid) {
+        if (!strcmp(id, match[i].cid)) {
+            return true;
+    }
+        i++;
+    }
+    return false;
+}
+
+static bool dev_id_match(const char *info, const char *did)
+{
+    const char *deli = "id:";
+    char *id;
+    int idx = 0;
+
+    if (!did)
+        return true;
+    if (!info)
+        return false;
+    /* find str like-> id: ff880000.i2s-rt5651-aif1 rt5651-aif1-0 */
+    id = strstr(info, deli);
+    if (!id)
+        return false;
+    id += strlen(deli);
+    while(id[idx] != '\0') {
+        if (id[idx] == '\r' ||id[idx] == '\n') {
+            id[idx] = '\0';
+            break;
+    }
+        idx ++;
+    }
+    if (strstr(id, did)) {
+        ALOGE("match dai!!!: %s %s", id, did);
+        return true;
+    }
+    return false;
+}
+
+static bool get_specified_out_dev(struct dev_info *devinfo,
+                                  int card,
+                                  const char *id,
+                                  struct dev_proc_info *match)
+{
+    int i = 0;
+    int device;
+    char str_device[32];
+    char info[256];
+    size_t len;
+    FILE* file = NULL;
+    int score  = 0;
+    int better = devinfo->score;
+    int index = -1;
+
+    /* parse card id */
+    if (!match)
+        return true; /* match any */
+    while (match[i].cid) {
+        score = name_match(id, match[i].cid);
+        if (score > better) {
+            better = score;
+            index = i;
+        }
+        i++;
+    }
+
+    if (index < 0)
+        return false;
+
+    if (!match[index].cid)
+        return false;
+
+    if (!match[index].did) { /* no exist dai info, exit */
+        devinfo->card = card;
+        devinfo->device = 0;
+        devinfo->score  = better;
+        ALOGD("%s card, got card=%d,device=%d", devinfo->id,
+              devinfo->card, devinfo->device);
+        return true;
+    }
+
+    /* parse device id */
+    for (device = 0; device < SNDRV_DEVICES; device++) {
+        sprintf(str_device, "proc/asound/card%d/pcm%dp/info", card, device);
+        if (access(str_device, 0)) {
+            ALOGD("No exist %s, break and finish parsing", str_device);
+            break;
+        }
+        file = fopen(str_device, "r");
+        if (!file) {
+            ALOGD("Could reading %s property", str_device);
+            continue;
+        }
+        len = fread(info, sizeof(char), sizeof(info)/sizeof(char), file);
+        fclose(file);
+        if (len == 0 || len > sizeof(info)/sizeof(char))
+            continue;
+        if (info[len - 1] == '\n') {
+            len--;
+            info[len] = '\0';
+        }
+        /* parse device dai */
+        if (dev_id_match(info, match[index].did)) {
+            devinfo->card = card;
+            devinfo->device = device;
+            devinfo->score  = better;
+            ALOGD("%s card, got card=%d,device=%d", devinfo->id,
+                  devinfo->card, devinfo->device);
+        return true;
+    }
+    }
+    return false;
+}
+
+static bool get_specified_in_dev(struct dev_info *devinfo,
+                                 int card,
+                                 const char *id,
+                                 struct dev_proc_info *match)
+{
+    int i = 0;
+    int device;
+    char str_device[32];
+    char info[256];
+    size_t len;
+    FILE* file = NULL;
+    int score  = 0;
+    int better = devinfo->score;
+    int index = -1;
+
+    /* parse card id */
+    if (!match)
+        return true; /* match any */
+
+    while (match[i].cid) {
+        score = name_match(id, match[i].cid);
+        if (score > better) {
+            better = score;
+            index = i;
+        }
+        i++;
+    }
+
+    if (index < 0)
+        return false;
+
+    if (!match[index].cid)
+        return false;
+
+    if (!match[index].did) { /* no exist dai info, exit */
+        devinfo->card = card;
+        devinfo->device = 0;
+        devinfo->score = better;
+        ALOGD("%s card, got card=%d,device=%d", devinfo->id,
+              devinfo->card, devinfo->device);
+        return true;
+    }
+
+    /* parse device id */
+    for (device = 0; device < SNDRV_DEVICES; device++) {
+        sprintf(str_device, "proc/asound/card%d/pcm%dc/info", card, device);
+        if (access(str_device, 0)) {
+            ALOGD("No exist %s, break and finish parsing", str_device);
+            break;
+        }
+        file = fopen(str_device, "r");
+        if (!file) {
+            ALOGD("Could reading %s property", str_device);
+            continue;
+        }
+        len = fread(info, sizeof(char), sizeof(info)/sizeof(char), file);
+        fclose(file);
+        if (len == 0 || len > sizeof(info)/sizeof(char))
+            continue;
+        if (info[len - 1] == '\n') {
+            len--;
+            info[len] = '\0';
+        }
+        /* parse device dai */
+        if (dev_id_match(info, match[i].did)) {
+            devinfo->card = card;
+            devinfo->device = device;
+            devinfo->score = better;
+            ALOGD("%s card, got card=%d,device=%d", devinfo->id,
+                  devinfo->card, devinfo->device);
+            return true;
+        }
+    }
+    return false;
+}
+
+static bool is_specified_in_sound_card(char *id, struct dev_proc_info *match)
+{
+    int i = 0;
+
+    /*
+     * mic: diffrent product may have diffrent card name,modify codes here
+     * for example: 0 [rockchiprk3328 ]: rockchip-rk3328 - rockchip-rk3328
+     */
+    if (!match)
+        return true;/* match any */
+    while (match[i].cid) {
+        if (!strcmp(id, match[i].cid)) {
+            return true;
+  }
+        i++;
+    }
+    return false;
+}
+
+static void set_default_dev_info( struct dev_info *info, int rid)
+{
+    if (rid) {
+        info->id = NULL;
+    }
+    info->card = (int)SND_OUT_SOUND_CARD_UNKNOWN;
+    info->score = 0;
+}
+
+static void dumpdev_info(const char *tag, struct dev_info  *devinfo, int count)
+{
+    ALOGD("dump %s device info", tag);
+    for(int i = 0; i < count; i++) {
+        if (devinfo[i].id && devinfo[i].card != SND_OUT_SOUND_CARD_UNKNOWN)
+            ALOGD("dev_info %s  card=%d, device:%d", devinfo[i].id,
+                  devinfo[i].card,
+                  devinfo[i].device);
+    }
+}
+
+/*
+ * get sound card infor by parser node: /proc/asound/cards
+ * the sound card number is not always the same value
+ */
+static void read_out_sound_card(struct stream_out *out)
+{
+
+    struct audio_device *device = NULL;
+    int card = 0;
+    char str[32];
+    char id[20];
+    size_t len;
+    FILE* file = NULL;
+
+    if((out == NULL) || (out->dev == NULL)) {
+        return ;
+    }
+    device = out->dev;
+    set_default_dev_info(&device->dev_out, 0);
+    for (card = 0; card < SNDRV_CARDS; card++) {
+        sprintf(str, "proc/asound/card%d/id", card);
+        if (access(str, 0)) {
+            ALOGD("No exist %s, break and finish parsing", str);
+            break;
+        }
+        file = fopen(str, "r");
+        if (!file) {
+            ALOGD("Could reading %s property", str);
+            continue;
+        }
+        len = fread(id, sizeof(char), sizeof(id)/sizeof(char), file);
+        fclose(file);
+        if (len == 0 || len > sizeof(id)/sizeof(char))
+            continue;
+        if (id[len - 1] == '\n') {
+            len--;
+            id[len] = '\0';
+        }
+        ALOGD("card%d id:%s", card, id);
+        get_specified_out_dev(&device->dev_out, card, id, HDMI_OUT_NAME);
+    }
+    dumpdev_info("out", &device->dev_out, 1);
+    return ;
+}
+
+/*
+ * get sound card infor by parser node: /proc/asound/cards
+ * the sound card number is not always the same value
+ */
+static void read_in_sound_card(struct stream_in *in)
+{
+    struct audio_device *device = NULL;
+    int card = 0;
+    char str[32];
+    char id[20];
+    size_t len;
+    FILE* file = NULL;
+
+    if((in == NULL) || (in->dev == NULL)){
+        return ;
+    }
+    device = in->dev;
+    set_default_dev_info(&device->dev_in, 0);
+    for (card = 0; card < SNDRV_CARDS; card++) {
+        sprintf(str, "proc/asound/card%d/id", card);
+        if(access(str, 0)) {
+            ALOGD("No exist %s, break and finish parsing", str);
+                break;
+        }
+        file = fopen(str, "r");
+        if (!file) {
+            ALOGD("Could reading %s property", str);
+            continue;
+        }
+        len = fread(id, sizeof(char), sizeof(id)/sizeof(char), file);
+        fclose(file);
+        if (len == 0 || len > sizeof(id)/sizeof(char))
+            continue;
+        if (id[len - 1] == '\n') {
+            len--;
+           id[len] = '\0';
+        }
+        /* set HDMI audio input info if need hdmi audio input */
+        get_specified_in_dev(&device->dev_in, card, id, HDMI_IN_NAME);
+    }
+    dumpdev_info("in", &device->dev_in, 1);
+    return ;
+}
+
+static uint32_t channel_check(void *data, unsigned int len)
+{
+    short *pcmLeftChannel = (short*)data;
+    short *pcmRightChannel = pcmLeftChannel + 1;
+    unsigned int index = 0;
+    int leftValid = 0x0;
+    int rightValid = 0x0;
+    short valuel = 0;
+    short valuer = 0;
+    uint32_t validflag = 0;
+
+    valuel = *pcmLeftChannel;
+    valuer = *pcmRightChannel;
+    for (index = 0; index < len; index += 2) {
+        if ((pcmLeftChannel[index] >= valuel + 50) ||
+            (pcmLeftChannel[index] <= valuel - 50))
+            leftValid++;
+        if ((pcmRightChannel[index] >= valuer + 50) ||
+            (pcmRightChannel[index] <= valuer - 50))
+            rightValid++;
+    }
+    if (leftValid > 20)
+        validflag |= CHL_VALID;
+    if (rightValid > 20)
+        validflag |= CHR_VALID;
+    return validflag;
+}
+
+static void channel_fixed(void *data, unsigned len, uint32_t chFlag)
+{
+    short *ch0 ,*ch1, *pcmValid, *pcmInvalid;
+
+    if ((chFlag&(CHL_VALID | CHR_VALID)) == 0 ||
+        (chFlag&(CHL_VALID | CHR_VALID)) == (CHL_VALID | CHR_VALID))
+        return;
+    ch0 = (short*)data;
+    ch1 = ch0 + 1;
+    pcmValid = ch0;
+    pcmInvalid = ch0;
+    if (chFlag & CHL_VALID)
+        pcmInvalid  = ch1;
+    else if (chFlag & CHR_VALID)
+        pcmValid = ch1;
+    for (unsigned index = 0; index < len; index += 2) {
+        pcmInvalid[index] = pcmValid[index];
+    }
+    return;
+}
+
+static void channel_check_start(struct stream_in *in)
+{
+    in->channel_flag = CH_CHECK;
+    in->start_checkcount = 0;
+}
+
+static bool is_bitstream(struct stream_out *out)
+{
+    if (out == NULL) {
+        return false;
+    }
+
+    if (out->config.format == PCM_FORMAT_IEC958_SUBFRAME_LE)
+        return true;
+
+    bool bitstream = false;
+    if (out->output_direct) {
+        switch(out->output_direct_mode) {
+            case HBR:
+            case NLPCM:
+                bitstream = true;
+                break;
+            case LPCM:
+            default:
+                bitstream = false;
+                break;
+        }
+    } else {
+        if(out->output_direct_mode != LPCM) {
+            ALOGD("%s: %d: error output_direct = false, but output_direct_mode != LPCM, this is error config",__FUNCTION__,__LINE__);
+        }
+    }
+
+    return bitstream;
+}
+
+static bool is_multi_pcm(struct stream_out *out)
+{
+    if (out == NULL) {
+        return false;
+    }
+
+    bool multi = false;
+    if (out->output_direct && (out->output_direct_mode == LPCM) && (out->config.channels > 2)) {
+        multi = true;
+    }
+
+    return multi;
+}
+
+static int mixer_mode_set(struct stream_out *out)
+{
+    int ret = 0;
+    struct mixer *pMixer = NULL;
+    struct mixer_ctl *pctl;
+    struct audio_device *adev = out->dev;
+
+    /*
+     * set audio mode for hdmi
+     * The driver of hdmi read the audio mode to identify
+     * the type of audio stream according to audio mode.
+     * 1) LPCM: the stream is pcm format
+     * 2) NLPCM: the stream is bitstream format, AC3/EAC3/DTS use this format
+     * 3) HDR: the stream is bitstream format, TrueHD/Atoms/DTS-HD/DTS-X use this format.
+     */
+    if (out->device & AUDIO_DEVICE_OUT_AUX_DIGITAL) {
+        pMixer = mixer_open_legacy(adev->dev_out.card);
+        if (!pMixer) {
+            ALOGE("mMixer is a null point %s %d,CARD = %d",__func__, __LINE__,adev->dev_out.card);
+            return ret;
+        }
+        pctl = mixer_get_control(pMixer,"AUDIO MODE",0 );
+        if (pctl != NULL) {
+            ALOGD("Now set mixer audio_mode is %d for drm",out->output_direct_mode);
+            switch (out->output_direct_mode) {
+            case HBR:
+                ret = mixer_ctl_set_val(pctl , out->output_direct_mode);
+                break;
+            case NLPCM:
+                ret = mixer_ctl_set_val(pctl , out->output_direct_mode);
+                break;
+            default:
+                ret = mixer_ctl_set_val(pctl , out->output_direct_mode);
+                break;
+            }
+
+            if (ret != 0) {
+                ALOGE("set_controls() can not set ctl!");
+                mixer_close_legacy(pMixer);
+                return -EINVAL;
+            }
+        }
+        mixer_close_legacy(pMixer);
+    }
+
+    return ret;
+}
+
+static void open_sound_card_policy(struct stream_out *out)
+{
+    if (out == NULL) {
+        return ;
+    }
+
+    if (is_bitstream(out) || (is_multi_pcm(out))) {
+        return ;
+    }
+
+    /*
+     * In Box Product, ouput 2 channles pcm datas over hdmi,speaker and spdif simultaneous.
+     * speaker can only support 44.1k or 48k
+     */
+    bool support = ((out->config.rate == 44100) || (out->config.rate == 48000));
+    struct audio_device *adev = out->dev;
+    if (support) {
+        if(adev->dev_out.card != SND_OUT_SOUND_CARD_UNKNOWN) {
+            /*
+             * hdmi is taken by direct/mulit pcm output
+             */
+            if(adev->outputs[OUTPUT_HDMI_MULTI] != NULL) {
+                out->device &= ~AUDIO_DEVICE_OUT_AUX_DIGITAL;
+            } else {
+                out->device |= AUDIO_DEVICE_OUT_AUX_DIGITAL;
+            }
+        }
+    }
+
+    // some specail config for chips
+#ifdef RK3288
+    /*3288's hdmi & codec use the same i2s,so only config the codec card*/
+    audio_devices_t devices = (AUDIO_DEVICE_OUT_AUX_DIGITAL|AUDIO_DEVICE_OUT_SPEAKER);
+    if ((out->device & devices) == devices) {
+        out->device &= ~AUDIO_DEVICE_OUT_AUX_DIGITAL;
+    }
+#endif
+}
+
+/**
+ * @brief start_output_stream
+ * must be called with hw device outputs list, output stream, and hw device mutexes locked
+ *
+ * @param out
+ *
+ * @returns
+ */
+static int start_output_stream(struct stream_out *out)
+{
+    struct audio_device *adev = out->dev;
+    int ret = 0;
+    int card = (int)SND_OUT_SOUND_CARD_UNKNOWN;
+    int device = 0;
+
+    ALOGD("%s:%d out = %p,device = 0x%x,outputs[OUTPUT_HDMI_MULTI] = %p",__FUNCTION__,__LINE__,out,out->device,adev->outputs[OUTPUT_HDMI_MULTI]);
+    if (out == adev->outputs[OUTPUT_HDMI_MULTI]) {
+        force_non_hdmi_out_standby(adev);
+    } else if (adev->outputs[OUTPUT_HDMI_MULTI] &&
+            !adev->outputs[OUTPUT_HDMI_MULTI]->standby) {
+        out->disabled = true;
+        return 0;
+    }
+
+    out->disabled = false;
+    read_out_sound_card(out);
+
+#ifdef BOX_HAL
+    open_sound_card_policy(out);
+#endif
+
+    out_dump(out, 0);
+
+    if (out->device & AUDIO_DEVICE_OUT_AUX_DIGITAL) {
+        audio_devices_t route_device = out->device & AUDIO_DEVICE_OUT_AUX_DIGITAL;
+        route_pcm_card_open(adev->dev_out.card, getRouteFromDevice(route_device));
+
+        if (adev->owner == NULL) {
+            card = adev->dev_out.card;
+            device =adev->dev_out.device;
+            if (card != (int)SND_OUT_SOUND_CARD_UNKNOWN) {
+
+#ifndef IEC958_FORAMT         
+#ifdef  USE_DRM
+                // set audio mode
+                ret = mixer_mode_set(out);
+                if (ret != 0) {
+                    ALOGE("mixer mode set error,ret=%d!",ret);
+                }
+#endif
+#endif
+
+                out->pcm = pcm_open(card, device, PCM_OUT | PCM_MONOTONIC, &out->config);
+                if (out->pcm && !pcm_is_ready(out->pcm)) {
+                    ALOGE("pcm_open(PCM_CARD_HDMI) failed: %s, card number = %d",
+                          pcm_get_error(out->pcm),card);
+                    pcm_close(out->pcm);
+                    return -ENOMEM;
+                }
+
+                if (is_bitstream(out) && ((out->config.format == PCM_FORMAT_S24_LE)
+                    || (out->config.format == PCM_FORMAT_IEC958_SUBFRAME_LE))) {
+                    out->bistream = bitstream_init(out->config.format,
+                        out->config.rate, out->config.channels);
+                }
+
+                if (is_multi_pcm(out) || is_bitstream(out)){
+                    adev->owner = (int*)out;
+                }
+            }
+        }
+    }
+
+    adev->out_device |= out->device;
+    ALOGD("%s:%d, out = %p",__FUNCTION__,__LINE__,out);
+    return 0;
+}
+
+static int get_next_buffer(struct resampler_buffer_provider *buffer_provider,
+                           struct resampler_buffer* buffer)
+{
+    struct stream_in *in;
+    size_t i,size;
+
+    if (buffer_provider == NULL || buffer == NULL)
+        return -EINVAL;
+
+    in = (struct stream_in *)((char *)buffer_provider -
+                              offsetof(struct stream_in, buf_provider));
+
+    if (in->pcm == NULL) {
+        buffer->raw = NULL;
+        buffer->frame_count = 0;
+        in->read_status = -ENODEV;
+        return -ENODEV;
+    }
+
+    if (in->frames_in == 0) {
+        size = pcm_frames_to_bytes(in->pcm, in->config->period_size);
+        in->read_status = pcm_read(in->pcm,
+                                   (void*)in->buffer, size);
+        if (in->read_status != 0) {
+            ALOGE("get_next_buffer() pcm_read error %d", in->read_status);
+            buffer->raw = NULL;
+            buffer->frame_count = 0;
+            return in->read_status;
+        }
+
+        if (in->config->channels == 2) {
+            if (in->channel_flag & CH_CHECK) {
+                if (in->start_checkcount < SAMPLECOUNT) {
+                    in->start_checkcount += size;
+                } else {
+                    in->channel_flag = channel_check((void*)in->buffer, size / 2);
+                    in->channel_flag &= ~CH_CHECK;
+                }
+            }
+            channel_fixed((void*)in->buffer, size / 2, in->channel_flag & ~CH_CHECK);
+        }
+
+#ifdef RK_DENOISE_ENABLE
+        if (!(in->device & AUDIO_DEVICE_IN_HDMI)) {
+            rkdenoise_process(in->mDenioseState, (void*)in->buffer, size, (void*)in->buffer);
+        }
+#endif
+        //fwrite(in->buffer,pcm_frames_to_bytes(in->pcm,pcm_get_buffer_size(in->pcm)),1,in_debug);
+        in->frames_in = in->config->period_size;
+
+        /* Do stereo to mono conversion in place by discarding right channel */
+        if ((in->channel_mask == AUDIO_CHANNEL_IN_MONO)
+                &&(in->config->channels == 2)) {
+            //ALOGE("channel_mask = AUDIO_CHANNEL_IN_MONO");
+            for (i = 0; i < in->frames_in; i++)
+                in->buffer[i] = in->buffer[i * 2];
+        }
+    }
+
+    //ALOGV("pcm_frames_to_bytes(in->pcm,pcm_get_buffer_size(in->pcm)):%d",size);
+    buffer->frame_count = (buffer->frame_count > in->frames_in) ?
+                          in->frames_in : buffer->frame_count;
+    buffer->i16 = in->buffer +
+                  (in->config->period_size - in->frames_in) *
+                  audio_channel_count_from_in_mask(in->channel_mask);
+
+    return in->read_status;
+
+}
+
+static void release_buffer(struct resampler_buffer_provider *buffer_provider,
+                           struct resampler_buffer* buffer)
+{
+    struct stream_in *in;
+
+    if (buffer_provider == NULL || buffer == NULL)
+        return;
+
+    in = (struct stream_in *)((char *)buffer_provider -
+                              offsetof(struct stream_in, buf_provider));
+
+    in->frames_in -= buffer->frame_count;
+}
+
+static bool get_hdmiin_audio_info(struct audio_device *adev, char *prop, int *value)
+{
+    char strfile[128];
+    FILE* file = NULL;
+    char info[20] = {0};
+
+    if (!value)
+        return false;
+    sprintf(strfile, "/sys/class/hdmirx/%s/%s", "hdmirx", prop);
+    if (access(strfile, 0)) {
+        ALOGD("No exist %s", strfile);
+        return false;
+    }
+    file = fopen(strfile, "r");
+    if (!file) {
+        ALOGD("Could reading %s property", strfile);
+        return false;
+    }
+    fread(info, sizeof(char), sizeof(info)/sizeof(char) - 1, file);
+    fclose(file);
+    *value = atoi(info);
+    return true;
+}
+
+#define STR_32KHZ "32KHZ"
+#define STR_44_1KHZ "44.1KHZ"
+#define STR_48KHZ "48KHZ"
+/**
+ * @brief get_hdmiin_audio_rate
+ * @param
+ * @return hdmiin audio rate
+ */
+static int get_hdmiin_audio_rate(struct audio_device *adev)
+{
+    int rate;
+    char value[PROPERTY_VALUE_MAX] = "";
+
+    if (get_hdmiin_audio_info(adev, "audio_rate", &rate)) {
+        return rate;
+    }
+    property_get("vendor.hdmiin.audiorate", value, STR_44_1KHZ);
+    if ( 0 == strncmp(value, STR_32KHZ, strlen(STR_32KHZ)) ){
+        rate = 32000;
+    } else if ( 0 == strncmp(value, STR_44_1KHZ, strlen(STR_44_1KHZ)) ){
+        rate = 44100;
+    } else if ( 0 == strncmp(value, STR_48KHZ, strlen(STR_48KHZ)) ){
+        rate = 48000;
+    } else {
+        rate = atoi(value);
+        if (rate <= 0)
+            rate = 44100;
+    }
+
+    // if hdmiin connect to codec, use 44100 sample rate
+    // if (adev->dev_out[SND_IN_SOUND_CARD_HDMI].card
+    //         == adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].card)
+    //     rate = 44100;
+
+    return rate;
+}
+
+int create_resampler_helper(struct stream_in *in, uint32_t in_rate)
+{
+    int ret = 0;
+    if (in->resampler) {
+        release_resampler(in->resampler);
+        in->resampler = NULL;
+    }
+
+    in->buf_provider.get_next_buffer = get_next_buffer;
+    in->buf_provider.release_buffer = release_buffer;
+    ALOGD("create resampler, channel %d, rate %d => %d",
+                    audio_channel_count_from_in_mask(in->channel_mask),
+                    in_rate, in->requested_rate);
+    ret = create_resampler(in_rate,
+                    in->requested_rate,
+                    audio_channel_count_from_in_mask(in->channel_mask),
+                    RESAMPLER_QUALITY_DEFAULT,
+                    &in->buf_provider,
+                    &in->resampler);
+    if (ret != 0) {
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+/**
+ * @brief start_input_stream
+ * must be called with input stream and hw device mutexes locked
+ *
+ * @param in
+ *
+ * @returns
+ */
+static int start_input_stream(struct stream_in *in)
+{
+    struct audio_device *adev = in->dev;
+    int  ret = 0;
+    int card = 0;
+    int device = 0;
+    int hdmiin_present = 0;
+
+    channel_check_start(in);
+    in_dump(in, 0);
+    read_in_sound_card(in);
+
+    card = (int)adev->dev_in.card;
+    if (in->device & AUDIO_DEVICE_IN_HDMI && (card != (int)SND_OUT_SOUND_CARD_UNKNOWN)) {
+        if (get_hdmiin_audio_info(adev, "audio_present", &hdmiin_present)) {
+            if (!hdmiin_present) {
+                ALOGD("hdmiin audio is no present, don't open hdmiin sound");
+                return -EEXIST;
+            }
+        }
+        in->config->rate = get_hdmiin_audio_rate(adev);
+        in->pcm = pcm_open(card, PCM_DEVICE, PCM_IN, in->config);
+        ALOGD("open HDMIIN %d", card);
+        if (in->resampler) {
+            release_resampler(in->resampler);
+            in->resampler = NULL;
+        }
+
+        // if hdmiin connect to codec, don't resample
+        if (in->config->rate != in->requested_rate) {
+            ret = create_resampler_helper(in, in->config->rate);
+        }
+    } 
+
+    if (in->pcm && !pcm_is_ready(in->pcm)) {
+        ALOGE("pcm_open() failed: %s", pcm_get_error(in->pcm));
+        pcm_close(in->pcm);
+        return -ENOMEM;
+    }
+
+    /* if no supported sample rate is available, use the resampler */
+    if (in->resampler)
+        in->resampler->reset(in->resampler);
+
+    in->frames_in = 0;
+    adev->input_source = in->input_source;
+    adev->in_device = in->device;
+    adev->in_channel_mask = in->channel_mask;
+
+
+    /* initialize volume ramp */
+    in->ramp_frames = (CAPTURE_START_RAMP_MS * in->requested_rate) / 1000;
+    in->ramp_step = (uint16_t)(USHRT_MAX / in->ramp_frames);
+    in->ramp_vol = 0;;
+
+
+    return 0;
+}
+
+static size_t get_input_buffer_size(unsigned int sample_rate,
+                                    audio_format_t format,
+                                    unsigned int channel_count,
+                                    bool is_low_latency)
+{
+    const struct pcm_config *config = is_low_latency ?
+                                              &pcm_config_in_low_latency : &pcm_config_in;
+    size_t size;
+
+    /*
+     * take resampling into account and return the closest majoring
+     * multiple of 16 frames, as audioflinger expects audio buffers to
+     * be a multiple of 16 frames
+     */
+    size = (config->period_size * sample_rate) / config->rate;
+    size = ((size + 15) / 16) * 16;
+
+    return size * channel_count * audio_bytes_per_sample(format);
+}
+
+
+/**
+ * @brief read_frames
+ * read_frames() reads frames from kernel driver, down samples to capture rate
+ * if necessary and output the number of frames requested to the buffer specified
+ *
+ * @param in
+ * @param buffer
+ * @param frames
+ *
+ * @returns
+ */
+static ssize_t read_frames(struct stream_in *in, void *buffer, ssize_t frames)
+{
+    ssize_t frames_wr = 0;
+    size_t frame_size = audio_stream_in_frame_size(&in->stream);
+
+    while (frames_wr < frames) {
+        size_t frames_rd = frames - frames_wr;
+        if (in->resampler != NULL) {
+            in->resampler->resample_from_provider(in->resampler,
+                                                  (int16_t *)((char *)buffer +
+                                                          frames_wr * frame_size),
+                                                  &frames_rd);
+        } else {
+            struct resampler_buffer buf = {
+                { raw : NULL, },
+frame_count :
+                frames_rd,
+            };
+            if (get_next_buffer(&in->buf_provider, &buf))
+                break;
+            if (buf.raw != NULL) {
+                memcpy((char *)buffer +
+                       frames_wr * frame_size,
+                       buf.raw,
+                       buf.frame_count * frame_size);
+                frames_rd = buf.frame_count;
+            }
+            release_buffer(&in->buf_provider, &buf);
+        }
+        /* in->read_status is updated by getNextBuffer() also called by
+         * in->resampler->resample_from_provider() */
+        if (in->read_status != 0)
+            return in->read_status;
+
+        frames_wr += frames_rd;
+    }
+    return frames_wr;
+}
+
+static uint32_t out_get_sample_rate(const struct audio_stream *stream)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+    char value[PROPERTY_VALUE_MAX];
+    property_get("vendor.vts_test", value, NULL);
+    if (strcmp(value, "true") == 0) {
+        if (out->use_default_config) {
+            return 48000;
+        } else {
+            return out->aud_config.sample_rate;
+        }
+    } else {
+        return out->config.rate;
+    }
+}
+
+static int out_set_sample_rate(struct audio_stream *stream, uint32_t rate)
+{
+    return -ENOSYS;
+}
+
+static size_t out_get_buffer_size(const struct audio_stream *stream)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+
+    return out->config.period_size *
+           audio_stream_out_frame_size((const struct audio_stream_out *)stream);
+}
+
+static audio_channel_mask_t out_get_channels(const struct audio_stream *stream)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+    char value[PROPERTY_VALUE_MAX];
+    property_get("vendor.vts_test", value, NULL);
+    if (out->use_default_config) {
+        return AUDIO_CHANNEL_OUT_MONO;
+    } else {
+        return out->aud_config.channel_mask;
+    }
+}
+
+static audio_format_t out_get_format(const struct audio_stream *stream)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+    char value[PROPERTY_VALUE_MAX];
+    property_get("vendor.vts_test", value, NULL);
+    if (out->use_default_config) {
+        return AUDIO_FORMAT_PCM_16_BIT;
+    } else {
+        return out->aud_config.format;
+    }
+}
+
+static int out_set_format(struct audio_stream *stream, audio_format_t format)
+{
+    return -ENOSYS;
+}
+
+/**
+ * @brief output_devices
+ * Return the set of output devices associated with active streams
+ * other than out.  Assumes out is non-NULL and out->dev is locked.
+ *
+ * @param out
+ *
+ * @returns
+ */
+static audio_devices_t output_devices(struct stream_out *out)
+{
+    struct audio_device *dev = out->dev;
+    enum output_type type;
+    audio_devices_t devices = AUDIO_DEVICE_NONE;
+
+    for (type = 0; type < OUTPUT_TOTAL; ++type) {
+        struct stream_out *other = dev->outputs[type];
+        if (other && (other != out) && !other->standby) {
+            // TODO no longer accurate
+            /* safe to access other stream without a mutex,
+             * because we hold the dev lock,
+             * which prevents the other stream from being closed
+             */
+            devices |= other->device;
+        }
+    }
+
+    return devices;
+}
+
+/**
+ * @brief do_out_standby
+ * must be called with hw device outputs list, all out streams, and hw device mutex locked
+ *
+ * @param out
+ */
+static void do_out_standby(struct stream_out *out)
+{
+    struct audio_device *adev = out->dev;
+    int i;
+    ALOGD("%s,out = %p,device = 0x%x",__FUNCTION__,out,out->device);
+    if (!out->standby) {
+        if (out->pcm) {
+            pcm_close(out->pcm);
+            out->pcm = NULL;
+        }
+        out->standby = true;
+        out->nframes = 0;
+        if (out == adev->outputs[OUTPUT_HDMI_MULTI]) {
+            /* force standby on low latency output stream so that it can reuse HDMI driver if
+             * necessary when restarted */
+            force_non_hdmi_out_standby(adev);
+        }
+#ifdef USE_DRM
+        mixer_mode_set(out);
+#endif
+        /* re-calculate the set of active devices from other streams */
+        adev->out_device = output_devices(out);
+
+#ifdef AUDIO_3A
+        if (adev->voice_api != NULL) {
+            adev->voice_api->flush();
+        }
+#endif
+        route_pcm_close(PLAYBACK_OFF_ROUTE);
+        ALOGD("close device");
+
+        /* Skip resetting the mixer if no output device is active */
+        if (adev->out_device) {
+            route_pcm_open(getRouteFromDevice(adev->out_device));
+            ALOGD("change device");
+        }
+        if(adev->owner == (int*)out){
+            adev->owner = NULL;
+        }
+
+        bitstream_destory(&out->bistream);
+    }
+}
+
+static void lock_all_outputs(struct audio_device *adev)
+{
+    enum output_type type;
+    pthread_mutex_lock(&adev->lock_outputs);
+    for (type = 0; type < OUTPUT_TOTAL; ++type) {
+        struct stream_out *out = adev->outputs[type];
+        if (out)
+            pthread_mutex_lock(&out->lock);
+    }
+    pthread_mutex_lock(&adev->lock);
+}
+
+static void unlock_all_outputs(struct audio_device *adev, struct stream_out *except)
+{
+    /* unlock order is irrelevant, but for cleanliness we unlock in reverse order */
+    pthread_mutex_unlock(&adev->lock);
+    enum output_type type = OUTPUT_TOTAL;
+    do {
+        struct stream_out *out = adev->outputs[--type];
+        if (out && out != except)
+            pthread_mutex_unlock(&out->lock);
+    } while (type != (enum output_type) 0);
+    pthread_mutex_unlock(&adev->lock_outputs);
+}
+
+static int out_standby(struct audio_stream *stream)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+    struct audio_device *adev = out->dev;
+
+    lock_all_outputs(adev);
+
+    do_out_standby(out);
+
+    unlock_all_outputs(adev, NULL);
+
+    return 0;
+}
+
+int out_dump(const struct audio_stream *stream, int fd)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+
+    ALOGD("out->Device     : 0x%x", out->device);
+    ALOGD("out->SampleRate : %d", out->config.rate);
+    ALOGD("out->Channels   : %d", out->config.channels);
+    ALOGD("out->Format     : %d", out->config.format);
+    ALOGD("out->PreiodSize : %d", out->config.period_size);
+    return 0;
+}
+
+static int out_set_parameters(struct audio_stream *stream, const char *kvpairs)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+    struct audio_device *adev = out->dev;
+    struct str_parms *parms;
+    char value[32];
+    int ret;
+    int status = 0;
+    unsigned int val;
+
+    ALOGD("%s: kvpairs = %s", __func__, kvpairs);
+
+    parms = str_parms_create_str(kvpairs);
+
+    //set channel_mask
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_CHANNELS,
+                            value, sizeof(value));
+    if (ret >= 0) {
+        val = atoi(value);
+        out->aud_config.channel_mask = val;
+    }
+    // set sample rate
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_SAMPLING_RATE,
+                            value, sizeof(value));
+    if (ret >= 0) {
+        val = atoi(value);
+        out->aud_config.sample_rate = val;
+    }
+    // set format
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_FORMAT,
+                            value, sizeof(value));
+    if (ret >= 0) {
+        val = atoi(value);
+        out->aud_config.format = val;
+    }
+
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_ROUTING,
+                            value, sizeof(value));
+    lock_all_outputs(adev);
+    if (ret >= 0) {
+        val = atoi(value);
+        /* Don't switch HDMI audio in box products */
+        if ((val != 0) && ((out->device & val) != val) ||
+            (val != 0) && !(out->device & AUDIO_DEVICE_OUT_HDMI)) {
+            /* Force standby if moving to/from SPDIF or if the output
+             * device changes when in SPDIF mode */
+            if (((val & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET) ^
+                    (adev->out_device & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET)) ||
+                    (adev->out_device & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET)) {
+                do_out_standby(out);
+            }
+
+            /* force output standby to start or stop SCO pcm stream if needed */
+            if ((val & AUDIO_DEVICE_OUT_ALL_SCO) ^
+                    (out->device & AUDIO_DEVICE_OUT_ALL_SCO)) {
+                do_out_standby(out);
+            }
+
+            if (!out->standby && (out == adev->outputs[OUTPUT_HDMI_MULTI] ||
+                                  !adev->outputs[OUTPUT_HDMI_MULTI] ||
+                                  adev->outputs[OUTPUT_HDMI_MULTI]->standby)) {
+                adev->out_device = output_devices(out) | val;
+#ifndef RK3228
+                do_out_standby(out);
+#endif
+            }
+            out->device = val;
+        }
+    }
+    out->use_default_config = false;
+    unlock_all_outputs(adev, NULL);
+
+    str_parms_destroy(parms);
+
+    ALOGV("%s: exit: status(%d)", __func__, status);
+    return status;
+
+}
+
+/*
+ * function: get support formats
+ * Query supported formats. The response is a '|' separated list of strings from audio_format_t enum
+ *  e.g: "sup_formats=AUDIO_FORMAT_PCM_16_BIT"
+ */
+static int stream_get_parameter_formats(const struct audio_stream *stream,
+                                    struct str_parms *query,
+                                    struct str_parms *reply)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+    int avail = 1024;
+    char value[avail];
+    if (str_parms_has_key(query, AUDIO_PARAMETER_STREAM_SUP_FORMATS)) {
+        memset(value,0,avail);
+        // set support pcm 16 bit default
+        strcat(value, "AUDIO_FORMAT_PCM_16_BIT");
+        str_parms_add_str(reply, AUDIO_PARAMETER_STREAM_SUP_FORMATS, value);
+        return 0;
+    }
+
+    return -1;
+}
+
+
+/*
+ * function: get support channels
+ * Query supported channel masks. The response is a '|' separated list of strings from
+ * audio_channel_mask_t enum
+ * e.g: "sup_channels=AUDIO_CHANNEL_OUT_STEREO|AUDIO_CHANNEL_OUT_MONO"
+ */
+static int stream_get_parameter_channels(struct str_parms *query,
+                                    struct str_parms *reply,
+                                    audio_channel_mask_t *supported_channel_masks)
+{
+    char value[1024];
+    size_t i, j;
+    bool first = true;
+
+    if(str_parms_has_key(query, AUDIO_PARAMETER_STREAM_SUP_CHANNELS)){
+        value[0] = '\0';
+        i = 0;
+        /* the last entry in supported_channel_masks[] is always 0 */
+        while (supported_channel_masks[i] != 0) {
+            for (j = 0; j < ARRAY_SIZE(channels_name_to_enum_table); j++) {
+                if (channels_name_to_enum_table[j].value == supported_channel_masks[i]) {
+                    if (!first) {
+                        strcat(value, "|");
+                    }
+
+                    strcat(value, channels_name_to_enum_table[j].name);
+                    first = false;
+                    break;
+                }
+            }
+            i++;
+        }
+        str_parms_add_str(reply, AUDIO_PARAMETER_STREAM_SUP_CHANNELS, value);
+        return 0;
+    }
+
+    return -1;
+}
+
+/*
+ * function: get support sample_rates
+ * Query supported sampling rates. The response is a '|' separated list of integer values
+ * e.g: ""sup_sampling_rates=44100|48000"
+ */
+static int stream_get_parameter_rates(struct str_parms *query,
+                                struct str_parms *reply,
+                                uint32_t *supported_sample_rates)
+{
+    char value[256];
+    int ret = -1;
+
+    if (str_parms_has_key(query, AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES)) {
+        value[0] = '\0';
+        int cursor = 0;
+        int i = 0;
+        while(supported_sample_rates[i]){
+            int avail = sizeof(value) - cursor;
+            ret = snprintf(value + cursor, avail, "%s%d",
+                           cursor > 0 ? "|" : "",
+                           supported_sample_rates[i]);
+
+            if (ret < 0 || ret > avail){
+                value[cursor] = '\0';
+                break;
+            }
+
+            cursor += ret;
+            ++i;
+        }
+        str_parms_add_str(reply, AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES, value);
+        return 0;
+    }
+    return -1;
+}
+
+static char * out_get_parameters(const struct audio_stream *stream, const char *keys)
+{
+    ALOGD("%s: keys = %s", __func__, keys);
+
+    struct stream_out *out = (struct stream_out *)stream;
+    struct str_parms *query = str_parms_create_str(keys);
+    char *str = NULL;
+    struct str_parms *reply = str_parms_create();
+    out->use_default_config = true;
+
+    if (stream_get_parameter_formats(stream,query,reply) == 0) {
+        str = str_parms_to_str(reply);
+    } else if (stream_get_parameter_channels(query, reply, &out->supported_channel_masks[0]) == 0) {
+        str = str_parms_to_str(reply);
+    } else if (stream_get_parameter_rates(query, reply, &out->supported_sample_rates[0]) == 0) {
+        str = str_parms_to_str(reply);
+    } else {
+        ALOGD("%s,str_parms_get_str failed !",__func__);
+        str = strdup("");
+    }
+    str_parms_destroy(query);
+    str_parms_destroy(reply);
+
+    ALOGV("%s,exit -- str = %s",__func__,str);
+    return str;
+}
+
+static uint32_t out_get_latency(const struct audio_stream_out *stream)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+
+    return (out->config.period_size * out->config.period_count * 1000) /
+           out->config.rate;
+}
+
+static int out_set_volume(struct audio_stream_out *stream, float left,
+                          float right)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+    struct audio_device *adev = out->dev;
+    out->volume[0] = left;
+    out->volume[1] = right;
+
+    /* The mutex lock is not needed, because the client
+     * is not allowed to close the stream concurrently with this API
+     *  pthread_mutex_lock(&adev->lock_outputs);
+     */
+    bool is_HDMI = out == adev->outputs[OUTPUT_HDMI_MULTI];
+    /*  pthread_mutex_unlock(&adev->lock_outputs); */
+    if (is_HDMI) {
+        /* only take left channel into account: the API is for stereo anyway */
+        out->muted = (left == 0.0f);
+        return 0;
+    }
+    return -ENOSYS;
+}
+
+static void dump_out_data(const void* buffer,size_t bytes)
+{
+    char value[PROPERTY_VALUE_MAX];
+    property_get("vendor.audio.record", value, "0");
+    int size = atoi(value);
+    if (size <= 0)
+        return ;
+
+    ALOGD("dump pcm file.");
+    static FILE* fd = NULL;
+    static int offset = 0;
+    if (fd == NULL) {
+        fd=fopen("/data/misc/audioserver/debug.pcm","wb+");
+        if(fd == NULL) {
+            ALOGD("DEBUG open /data/debug.pcm ,errno = %s",strerror(errno));
+            offset = 0;
+        }
+    }
+
+    if (fd != NULL) {
+        fwrite(buffer,bytes,1,fd);
+        offset += bytes;
+        fflush(fd);
+        if(offset >= size*1024*1024) {
+            fclose(fd);
+            fd = NULL;
+            offset = 0;
+            property_set("vendor.audio.record", "0");
+            ALOGD("TEST playback pcmfile end");
+        }
+    }
+}
+
+static void dump_in_data(const void* buffer, size_t bytes)
+{
+    static int offset = 0;
+    static FILE* fd = NULL;
+    char value[PROPERTY_VALUE_MAX];
+    property_get("vendor.audio.record.in", value, "0");
+    int size = atoi(value);
+    if (size > 0) {
+        if(fd == NULL) {
+            fd=fopen("/data/misc/audioserver/debug_in.pcm","wb+");
+            if(fd == NULL) {
+                ALOGD("DEBUG open /data/misc/audioserver/debug_in.pcm ,errno = %s",strerror(errno));
+            } else {
+                ALOGD("dump pcm to file /data/misc/audioserver/debug_in.pcm");
+            }
+            offset = 0;
+        }
+    }
+
+    if (fd != NULL) {
+        ALOGD("dump in pcm %zu bytes", bytes);
+        fwrite(buffer,bytes,1,fd);
+        offset += bytes;
+        fflush(fd);
+        if (offset >= size*1024*1024) {
+            fclose(fd);
+            fd = NULL;
+            offset = 0;
+            property_set("vendor.audio.record.in", "0");
+            ALOGD("TEST record pcmfile end");
+        }
+    }
+}
+
+static void check_hdmi_reconnect(struct stream_out *out)
+{
+    if (out == NULL) {
+        return ;
+    }
+
+    struct audio_device *adev = out->dev;
+    lock_all_outputs(adev);
+    /*
+     * if snd_reopen is set to true, this means we need to reopen sound card.
+     * There are a situation, we need to do this:
+     *   current stream is bistream over hdmi, and hdmi is unpluged and plug later,
+     *   the driver of hdmi may init the hdmi in pcm mode automatically, according the
+     *   implement of driver of hdmi. If we contiune send bitstream to hdmi open in pcm mode,
+     *   hdmi may make noies or mute.
+     */
+    if (out->snd_reopen && !out->standby)
+    {
+        /*
+         * standby sound cards
+         * the driver of hdmi will auto init with last configurations,
+         * so, we don't need close and reopen sound card of hdmi here.
+         * If driver of hdmi not config the hdmi with last output configurations,
+         * please open this codes to close and reopen sound card of hdmi.
+         */
+  //      do_out_standby(out);
+  //      reset_bitstream_buf(out);
+    }
+    unlock_all_outputs(adev,NULL);
+    /*
+     * audio hal recived the msg of hdmi plugin, and other part of sdk will reviced it too.
+     * Other part(maybe hwc) will config hdmi after it reviced the msg.
+     * Audio must wait other part(maybe hwc) codes config hdmi finish, before send bitstream datas to hdmi
+     */
+    if (out->snd_reopen && is_bitstream(out) && (out->device == AUDIO_DEVICE_OUT_AUX_DIGITAL)) {
+#ifdef USE_DRM
+        const char* PATH = "/sys/class/drm/card0-HDMI-A-1/enabled";
+#else
+        const char* PATH = "/sys/class/display/HDMI/enabled";
+#endif
+        if (access(PATH, R_OK) != 0) {
+            /*
+             * in most test, the time is 700~800ms between received msg of hdmi plug in
+             * and hdmi init finish, so we sleep 1 sec here if no way to get the status of hdmi.
+             */
+            usleep(1000000);
+        } else {
+            /*
+             * read this node to judge the status of hdmi is config finish?
+             */
+            char buffer[1024];
+            int counter  = 200;
+            FILE* file = NULL;
+            while (counter >= 0 && ((file = fopen(PATH,"r")) != NULL)) {
+                int size = fread(buffer,1,sizeof(buffer),file);
+                if(size >= 0) {
+                    if(strstr(buffer,"enabled")) {
+                        fclose(file);
+                        usleep(10000);
+                        break;
+                    }
+                }
+                usleep(10000);
+                counter --;
+                fclose(file);
+            }
+        }
+        ALOGD("%s: out = %p",__FUNCTION__,out);
+        out->snd_reopen = false;
+    }
+}
+
+static void out_mute_data(struct stream_out *out,void* buffer,size_t bytes)
+{
+    struct audio_device *adev = out->dev;
+    bool mute = false;
+
+#ifdef MUTE_WHEN_SCREEN_OFF
+    mute = adev->screenOff;
+#endif
+    // for some special customer
+    char value[PROPERTY_VALUE_MAX];
+    property_get("vendor.audio.mute", value, "false");
+    if (!strcasecmp(value,"true")) {
+        mute = true;
+    }
+
+    if (out->muted || mute){
+        memset((void *)buffer, 0, bytes);
+    }
+}
+
+static int bitstream_write_data(struct stream_out *out, void* buffer, size_t bytes)
+{
+    if ((out == NULL) || (buffer == NULL) || (bytes <= 0)) {
+        ALOGD("%s: %d, input parameter is invalid",__FUNCTION__,__LINE__);
+        return -1;
+    }
+
+    struct audio_device *adev = out->dev;
+    int ret = 0;
+    if ((out->device & AUDIO_DEVICE_OUT_AUX_DIGITAL) && (is_multi_pcm(out) || is_bitstream(out))) {
+        int card = adev->dev_out.card;
+        if ((card != SND_OUT_SOUND_CARD_UNKNOWN) && (out->pcm != NULL)) {
+            if(out->config.format == PCM_FORMAT_S16_LE){
+                out_mute_data(out,buffer,bytes);
+                dump_out_data(buffer, bytes);
+                ret = pcm_write(out->pcm, (void *)buffer, bytes);
+            } else if(out->config.format == PCM_FORMAT_S24_LE ||
+                     out->config.format == PCM_FORMAT_IEC958_SUBFRAME_LE){
+                char *outBuffer = NULL;
+                int   outSize = 0;
+                ret = bitstream_encode(out->bistream, (char*)buffer, (int)bytes, &outBuffer, &outSize);
+                if (ret == 0 && outSize > 0) {
+                    out_mute_data(out,(void*)outBuffer, outSize);
+                    dump_out_data((void*)outBuffer, outSize);
+                    ret = pcm_write(out->pcm, (void *)outBuffer, outSize);
+                }
+            }
+        } else {
+            ALOGD("%s: %d: HDMI sound card not open",__FUNCTION__,__LINE__);
+            ret = -1;
+        }
+    }
+
+    return ret;
+}
+
+/*
+ * process volume of one multi pcm frame
+ * The multi pcm output no using mixer,so the can't control by volume setting,
+ * so here we process multi pcm datas with volume value.
+ *
+ */
+static void out_multi_pcm_volume_process(struct stream_out *out, void *buffer)
+{
+    if ((out == NULL) || (buffer == NULL)){
+        return ;
+    }
+
+    int format = out->config.format;
+    int channel = out->config.channels;
+    if((format == PCM_FORMAT_S16_LE)) {
+        float left = out->volume[0];
+        short *pcm = (short*)buffer;
+        float temp = 0;
+        for (int ch = 0;  ch < channel; ch++) {
+            temp = (float)pcm[ch];
+            pcm[ch] = (short)(temp*left);
+        }
+    }
+}
+
+/*
+ * switch LFE and FC of one multi pcm frame
+ * swtich Front Center's datas and Low Frequency datas
+ * 5.1            FL+FR+FC+LFE+BL+BR
+ * 5.1(side)      FL+FR+FC+LFE+SL+SR
+ * 7.1            FL+FR+FC+LFE+SL+SR+BL+BR
+ * the datas needed in HDMI is:
+ *                FL+FR+LFE+FC+SL+SR+BL+BR
+ */
+static void out_multi_pcm_switch_fc_lfe(struct stream_out *out, void *buffer)
+{
+    if ((out == NULL) || (buffer == NULL)) {
+        return ;
+    }
+
+    const int CENTER = 2;
+    const int LFE    = 3;
+    int channel = out->config.channels;
+    int format = out->config.format;
+    audio_channel_mask_t channel_mask = out->channel_mask;
+    bool hasLFE = ((channel_mask & AUDIO_CHANNEL_OUT_LOW_FREQUENCY) != 0);
+
+    if (format == PCM_FORMAT_S16_LE) {
+        short *pcm = (short*)buffer;
+        short temp = 0;
+        if (hasLFE && ((channel == 6) || (channel == 8))) {
+            // Front Center's datas
+            temp = pcm[CENTER];
+            // swap FC and Low Frequency Effect's datas
+            pcm[CENTER] = pcm[LFE];
+            pcm[LFE] = temp;
+        }
+    }
+}
+
+static void out_multi_pcm_process(struct stream_out *out, void * buffer, size_t len) {
+    if((out == NULL) || (buffer == NULL) || (len <= 0)){
+        return ;
+    }
+
+    int format = out->config.format;
+    // only process PCM16
+    if (format == PCM_FORMAT_S16_LE) {
+        short *pcm = (short*)buffer;
+        int channel = out->config.channels;
+        int frames = len/audio_stream_out_frame_size(out);
+        for (int frame = 0; frame < frames; frame ++){
+            out_multi_pcm_volume_process(out, pcm);
+            out_multi_pcm_switch_fc_lfe(out, pcm);
+            pcm += channel;
+        }
+    }
+}
+
+static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
+                         size_t bytes)
+{
+    int ret = 0;
+    struct stream_out *out = (struct stream_out *)stream;
+    struct audio_device *adev = out->dev;
+    size_t newbytes = bytes * 2;
+    int i,card;
+    /* FIXME This comment is no longer correct
+     * acquiring hw device mutex systematically is useful if a low
+     * priority thread is waiting on the output stream mutex - e.g.
+     * executing out_set_parameters() while holding the hw device
+     * mutex
+     */
+    check_hdmi_reconnect(out);
+    pthread_mutex_lock(&out->lock);
+    if (out->standby) {
+        pthread_mutex_unlock(&out->lock);
+        lock_all_outputs(adev);
+        if (!out->standby) {
+            unlock_all_outputs(adev, out);
+            goto false_alarm;
+        }
+        ret = start_output_stream(out);
+        if (ret < 0) {
+            unlock_all_outputs(adev, NULL);
+            goto final_exit;
+        }
+        out->standby = false;
+        unlock_all_outputs(adev, out);
+    }
+false_alarm:
+
+    if (out->disabled) {
+        ret = -EPIPE;
+        ALOGD("%s: %d: error out = %p",__FUNCTION__,__LINE__,out);
+        goto exit;
+    }
+
+
+#ifdef AUDIO_3A
+    if (adev->voice_api != NULL) {
+        int ret = 0;
+        adev->voice_api->queuePlaybackBuffer(buffer, bytes);
+        ret = adev->voice_api->getPlaybackBuffer(buffer, bytes);
+        if (ret < 0) {
+            memset((char *)buffer, 0x00, bytes);
+        }
+    }
+#endif
+
+    if ((out->device & AUDIO_DEVICE_OUT_AUX_DIGITAL) && is_bitstream(out)) {
+        ret = bitstream_write_data(out, (void*)buffer, bytes);
+        if(ret < 0) {
+            goto exit;
+        }
+    } else {
+        if(is_multi_pcm(out)) {
+            if(out->device == AUDIO_DEVICE_OUT_AUX_DIGITAL) {
+                out_multi_pcm_process(out, buffer, bytes);
+            }
+        }
+
+        out_mute_data(out,(void*)buffer,bytes);
+        dump_out_data(buffer, bytes);
+        ret = -1;
+        /*
+         * do not write hdmi snd sound if they are taken by other bitstream/multi channle pcm stream
+         */
+        if (out->pcm && adev->owner == NULL) {
+            ret = pcm_write(out->pcm, (void *)buffer, bytes);
+        }
+    }
+exit:
+    pthread_mutex_unlock(&out->lock);
+final_exit:
+    {
+        // For PCM we always consume the buffer and return #bytes regardless of ret.
+        out->written += bytes / (out->config.channels * sizeof(short));
+        out->nframes = out->written;
+    }
+    if (ret != 0) {
+        ALOGV("AudioData write  error , keep slience! ret = %d", ret);
+        usleep(bytes * 1000000 / audio_stream_out_frame_size(stream) /
+               out_get_sample_rate(&stream->common));
+    }
+
+    return bytes;
+}
+
+static int out_get_render_position(const struct audio_stream_out *stream,
+                                   uint32_t *dsp_frames)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+
+    *dsp_frames = out->nframes;
+    return 0;
+}
+
+static int out_add_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
+{
+    return 0;
+}
+
+static int out_remove_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
+{
+    return 0;
+}
+
+static int out_get_next_write_timestamp(const struct audio_stream_out *stream,
+                                        int64_t *timestamp)
+{
+    ALOGV("%s: %d Entered", __FUNCTION__, __LINE__);
+    return -ENOSYS;
+}
+
+static int out_get_presentation_position(const struct audio_stream_out *stream,
+        uint64_t *frames, struct timespec *timestamp)
+{
+    struct stream_out *out = (struct stream_out *)stream;
+    int ret = -1;
+
+    pthread_mutex_lock(&out->lock);
+
+    int i;
+    // There is a question how to implement this correctly when there is more than one PCM stream.
+    // We are just interested in the frames pending for playback in the kernel buffer here,
+    // not the total played since start.  The current behavior should be safe because the
+    // cases where both cards are active are marginal.
+    if (out->pcm) {
+        size_t avail;
+        if (pcm_get_htimestamp(out->pcm, &avail, timestamp) == 0) {
+            size_t kernel_buffer_size = out->config.period_size * out->config.period_count;
+            // FIXME This calculation is incorrect if there is buffering after app processor
+            int64_t signed_frames = out->written - kernel_buffer_size + avail;
+            // It would be unusual for this value to be negative, but check just in case ...
+            if (signed_frames >= 0) {
+                *frames = signed_frames;
+                ret = 0;
+            }
+        }
+    }
+    pthread_mutex_unlock(&out->lock);
+
+    return ret;
+}
+
+static uint32_t in_get_sample_rate(const struct audio_stream *stream)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+    //ALOGV("%s:get requested_rate : %d ",__FUNCTION__,in->requested_rate);
+    return in->requested_rate;
+}
+
+static int in_set_sample_rate(struct audio_stream *stream, uint32_t rate)
+{
+    return 0;
+}
+
+static audio_channel_mask_t in_get_channels(const struct audio_stream *stream)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+
+    //ALOGV("%s:get channel_mask : %d ",__FUNCTION__,in->channel_mask);
+    return in->channel_mask;
+}
+
+static size_t in_get_buffer_size(const struct audio_stream *stream)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+
+    return get_input_buffer_size(in->requested_rate,
+                                 AUDIO_FORMAT_PCM_16_BIT,
+                                 audio_channel_count_from_in_mask(in_get_channels(stream)),
+                                 (in->flags & AUDIO_INPUT_FLAG_FAST) != 0);
+}
+
+static audio_format_t in_get_format(const struct audio_stream *stream)
+{
+    return AUDIO_FORMAT_PCM_16_BIT;
+}
+
+static int in_set_format(struct audio_stream *stream, audio_format_t format)
+{
+    return -ENOSYS;
+}
+
+static void do_in_standby(struct stream_in *in)
+{
+    struct audio_device *adev = in->dev;
+
+    if (!in->standby) {
+        pcm_close(in->pcm);
+        in->pcm = NULL;
+
+        if (in->device & AUDIO_DEVICE_IN_HDMI) {
+            route_pcm_close(HDMI_IN_CAPTURE_OFF_ROUTE);
+        }
+
+        in->dev->input_source = AUDIO_SOURCE_DEFAULT;
+        in->dev->in_device = AUDIO_DEVICE_NONE;
+        in->dev->in_channel_mask = 0;
+        in->standby = true;
+        route_pcm_close(CAPTURE_OFF_ROUTE);
+    }
+
+}
+
+static int in_standby(struct audio_stream *stream)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+
+    pthread_mutex_lock(&in->lock);
+    pthread_mutex_lock(&in->dev->lock);
+
+    do_in_standby(in);
+
+    pthread_mutex_unlock(&in->dev->lock);
+    pthread_mutex_unlock(&in->lock);
+
+    return 0;
+}
+
+int in_dump(const struct audio_stream *stream, int fd)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+
+    ALOGD("in->Device     : 0x%x", in->device);
+    ALOGD("in->SampleRate : %d", in->config->rate);
+    ALOGD("in->Channels   : %d", in->config->channels);
+    ALOGD("in->Formate    : %d", in->config->format);
+    ALOGD("in->PreiodSize : %d", in->config->period_size);
+
+    return 0;
+}
+
+static int in_set_parameters(struct audio_stream *stream, const char *kvpairs)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+    struct audio_device *adev = in->dev;
+    struct str_parms *parms;
+    char value[32];
+    int ret;
+    int status = 0;
+    unsigned int val;
+    bool apply_now = false;
+
+    ALOGV("%s: kvpairs = %s", __func__, kvpairs);
+    parms = str_parms_create_str(kvpairs);
+
+    //set channel_mask
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_CHANNELS,
+                            value, sizeof(value));
+    if (ret >= 0) {
+        val = atoi(value);
+        in->channel_mask = val;
+    }
+     // set sample rate
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_SAMPLING_RATE,
+                            value, sizeof(value));
+    if (ret >= 0) {
+        val = atoi(value);
+        in->requested_rate = val;
+    }
+
+    pthread_mutex_lock(&in->lock);
+    pthread_mutex_lock(&adev->lock);
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_INPUT_SOURCE,
+                            value, sizeof(value));
+    if (ret >= 0) {
+        val = atoi(value);
+        /* no audio source uses val == 0 */
+        if ((in->input_source != val) && (val != 0)) {
+            in->input_source = val;
+            apply_now = !in->standby;
+        }
+    }
+
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_ROUTING,
+                            value, sizeof(value));
+    if (ret >= 0) {
+        /* strip AUDIO_DEVICE_BIT_IN to allow bitwise comparisons */
+        val = atoi(value) & ~AUDIO_DEVICE_BIT_IN;
+        /* no audio device uses val == 0 */
+        if ((in->device != val) && (val != 0)) {
+            channel_check_start(in);
+            /* force output standby to start or stop SCO pcm stream if needed */
+            if ((val & AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET) ^
+                    (in->device & AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET)) {
+                do_in_standby(in);
+            }
+            in->device = val;
+            apply_now = !in->standby;
+        }
+    }
+
+    if (apply_now) {
+        adev->input_source = in->input_source;
+        adev->in_device = in->device;
+        route_pcm_open(getRouteFromDevice(in->device | AUDIO_DEVICE_BIT_IN));
+    }
+
+    pthread_mutex_unlock(&adev->lock);
+    pthread_mutex_unlock(&in->lock);
+
+    str_parms_destroy(parms);
+
+    ALOGV("%s: exit: status(%d)", __func__, status);
+    return status;
+
+}
+
+static char * in_get_parameters(const struct audio_stream *stream,
+                                const char *keys)
+{
+    ALOGD("%s: keys = %s", __func__, keys);
+
+    struct stream_in *in = (struct stream_in *)stream;
+    struct str_parms *query = str_parms_create_str(keys);
+    char *str = NULL;
+    struct str_parms *reply = str_parms_create();
+
+    if (stream_get_parameter_formats(stream,query,reply) == 0) {
+        str = str_parms_to_str(reply);
+    } else if (stream_get_parameter_channels(query, reply, &in->supported_channel_masks[0]) == 0) {
+        str = str_parms_to_str(reply);
+    } else if (stream_get_parameter_rates(query, reply, &in->supported_sample_rates[0]) == 0) {
+        str = str_parms_to_str(reply);
+    } else {
+        ALOGD("%s,str_parms_get_str failed !",__func__);
+        str = strdup("");
+    }
+
+    str_parms_destroy(query);
+    str_parms_destroy(reply);
+
+    ALOGV("%s,exit -- str = %s",__func__,str);
+    return str;
+}
+
+static int in_set_gain(struct audio_stream_in *stream, float gain)
+{
+    return 0;
+}
+
+static void in_apply_ramp(struct stream_in *in, int16_t *buffer, size_t frames)
+{
+    size_t i;
+    uint16_t vol = in->ramp_vol;
+    uint16_t step = in->ramp_step;
+
+    frames = (frames < in->ramp_frames) ? frames : in->ramp_frames;
+
+    if (in->channel_mask == AUDIO_CHANNEL_IN_MONO)
+        for (i = 0; i < frames; i++) {
+            buffer[i] = (int16_t)((buffer[i] * vol) >> 16);
+            vol += step;
+        }
+    else
+        for (i = 0; i < frames; i++) {
+            buffer[2*i] = (int16_t)((buffer[2*i] * vol) >> 16);
+            buffer[2*i + 1] = (int16_t)((buffer[2*i + 1] * vol) >> 16);
+            vol += step;
+        }
+
+
+    in->ramp_vol = vol;
+    in->ramp_frames -= frames;
+}
+
+static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
+                       size_t bytes)
+{
+    int ret = 0;
+    struct stream_in *in = (struct stream_in *)stream;
+    struct audio_device *adev = in->dev;
+    size_t frames_rq = bytes / audio_stream_in_frame_size(stream);
+    size_t frames_rd = 0;
+
+    if (in->device & AUDIO_DEVICE_IN_HDMI) {
+        unsigned int rate = get_hdmiin_audio_rate(adev);
+        if(rate != in->config->rate){
+            ALOGD("HDMI-In: rate is changed: %d -> %d, restart input stream",
+                    in->config->rate, rate);
+            do_in_standby(in);
+        }
+    }
+    /*
+     * acquiring hw device mutex systematically is useful if a low
+     * priority thread is waiting on the input stream mutex - e.g.
+     * executing in_set_parameters() while holding the hw device
+     * mutex
+     */
+    pthread_mutex_lock(&in->lock);
+    if (in->standby) {
+        pthread_mutex_lock(&adev->lock);
+        ret = start_input_stream(in);
+        pthread_mutex_unlock(&adev->lock);
+        if (ret < 0)
+            goto exit;
+        in->standby = false;
+#ifdef AUDIO_3A
+        if (adev->voice_api != NULL) {
+            adev->voice_api->start();
+        }
+#endif
+    }
+
+    frames_rd = read_frames(in, buffer, frames_rq);
+    if (in->read_status) {
+        ret = -EPIPE;
+        goto exit;
+    } else if (frames_rd > 0) {
+        in->frames_read += frames_rd;
+        bytes = frames_rd * audio_stream_in_frame_size(stream);
+    }
+
+    dump_in_data(buffer, bytes);
+
+#ifdef AUDIO_3A
+    do {
+        if (adev->voice_api != NULL) {
+            int ret  = 0;
+            ret = adev->voice_api->quueCaputureBuffer(buffer, bytes);
+            if (ret < 0) break;
+            ret = adev->voice_api->getCapureBuffer(buffer, bytes);
+            if (ret < 0) memset(buffer, 0x00, bytes);
+        }
+    } while (0);
+#endif
+
+    //if (in->ramp_frames > 0)
+    //    in_apply_ramp(in, buffer, frames_rq);
+
+    /*
+     * Instead of writing zeroes here, we could trust the hardware
+     * to always provide zeroes when muted.
+     */
+    //if (ret == 0 && adev->mic_mute)
+    //    memset(buffer, 0, bytes);
+#ifdef ALSA_IN_DEBUG
+        fwrite(buffer, bytes, 1, in_debug);
+#endif
+exit:
+    if (ret < 0) {
+        memset(buffer, 0, bytes);
+        usleep(bytes * 1000000 / audio_stream_in_frame_size(stream) /
+               in_get_sample_rate(&stream->common));
+        do_in_standby(in);
+    }
+
+    pthread_mutex_unlock(&in->lock);
+    return bytes;
+}
+
+static uint32_t in_get_input_frames_lost(struct audio_stream_in *stream)
+{
+    return 0;
+}
+
+static int in_add_audio_effect(const struct audio_stream *stream,
+                               effect_handle_t effect)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+    effect_descriptor_t descr;
+    if ((*effect)->get_descriptor(effect, &descr) == 0) {
+
+        pthread_mutex_lock(&in->lock);
+        pthread_mutex_lock(&in->dev->lock);
+
+
+        pthread_mutex_unlock(&in->dev->lock);
+        pthread_mutex_unlock(&in->lock);
+    }
+
+    return 0;
+}
+
+static int in_remove_audio_effect(const struct audio_stream *stream,
+                                  effect_handle_t effect)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+    effect_descriptor_t descr;
+    if ((*effect)->get_descriptor(effect, &descr) == 0) {
+
+        pthread_mutex_lock(&in->lock);
+        pthread_mutex_lock(&in->dev->lock);
+
+
+        pthread_mutex_unlock(&in->dev->lock);
+        pthread_mutex_unlock(&in->lock);
+    }
+
+    return 0;
+}
+
+static int adev_get_microphones(const struct audio_hw_device *dev,
+                         struct audio_microphone_characteristic_t *mic_array,
+                         size_t *mic_count)
+{
+    struct audio_device *adev = (struct audio_device *)dev;
+    size_t actual_mic_count = 0;
+
+    int card_no = 0;
+
+    char snd_card_node_id[100]={0};
+    char snd_card_node_cap[100]={0};
+    char address[32] = "bottom";
+
+    do{
+        sprintf(snd_card_node_id, "/proc/asound/card%d/id", card_no);
+        if (access(snd_card_node_id,F_OK) == -1) break;
+
+        sprintf(snd_card_node_cap, "/proc/asound/card%d/pcm0c/info", card_no);
+        if (access(snd_card_node_cap,F_OK) == -1) continue;
+
+        actual_mic_count++;
+    }while(++card_no);
+
+    mic_array->device = -2147483644;
+    strcpy(mic_array->address,address);
+
+    ALOGD("%s,get capture mic actual_mic_count =%d",__func__,actual_mic_count);
+    *mic_count = actual_mic_count;
+    return 0;
+}
+
+static int in_get_capture_position(const struct audio_stream_in *stream,
+                        int64_t *frames, int64_t *time)
+{
+    if (stream == NULL || frames == NULL || time == NULL) {
+        return -EINVAL;
+    }
+    struct stream_in *in = (struct stream_in *)stream;
+    int ret = -ENOSYS;
+
+    pthread_mutex_lock(&in->lock);
+    // note: ST sessions do not close the alsa pcm driver synchronously
+    // on standby. Therefore, we may return an error even though the
+    // pcm stream is still opened.
+    if (in->standby) {
+        ALOGD("skip when standby is true.");
+        goto exit;
+    }
+    if (in->pcm) {
+        struct timespec timestamp;
+        size_t avail;
+        if (pcm_get_htimestamp(in->pcm, &avail, &timestamp) == 0) {
+            *frames = in->frames_read + avail;
+            *time = timestamp.tv_sec * 1000000000LL + timestamp.tv_nsec;
+            ret = 0;
+            ALOGD("Pos: %lld %lld", *time, *frames);
+        }
+    }
+exit:
+    pthread_mutex_unlock(&in->lock);
+
+    return ret;
+}
+
+static int in_get_active_microphones(const struct audio_stream_in *stream,
+                         struct audio_microphone_characteristic_t *mic_array,
+                         size_t *mic_count)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+    struct audio_device *adev = in->dev;
+    pthread_mutex_lock(&in->lock);
+    pthread_mutex_lock(&adev->lock);
+
+    size_t actual_mic_count = 0;
+    int card_no = 0;
+
+    char snd_card_node_id[100]={0};
+    char snd_card_node_cap[100]={0};
+    char snd_card_info[100]={0};
+    char snd_card_state[255]={0};
+
+    do{
+        sprintf(snd_card_node_id, "/proc/asound/card%d/id", card_no);
+        if (access(snd_card_node_id,F_OK) == -1) break;
+
+        sprintf(snd_card_node_cap, "/proc/asound/card%d/pcm0c/info", card_no);
+        if (access(snd_card_node_cap,F_OK) == -1) {
+            continue;
+        } else {
+            sprintf(snd_card_info, "/proc/asound/card%d/pcm0c/sub0/status", card_no);
+            int fd;
+            fd = open(snd_card_info, O_RDONLY);
+            if (fd < 0) {
+                ALOGE("%s,failed to open node: %s", __func__, snd_card_info);
+            } else {
+                int length = read(fd, snd_card_state, sizeof(snd_card_state) -1);
+                snd_card_state[length] = 0;
+                if (strcmp(snd_card_state, "closed") != 0) actual_mic_count++;
+            }
+            close(fd);
+        }
+    } while(++card_no);
+
+    pthread_mutex_unlock(&adev->lock);
+    pthread_mutex_unlock(&in->lock);
+
+    ALOGD("%s,get active mic actual_mic_count =%d", __func__, actual_mic_count);
+    *mic_count = actual_mic_count;
+    return 0;
+}
+
+/*
+ * get support channels mask of hdmi from parsing edid of hdmi
+ */
+static void get_hdmi_support_channels_masks(struct stream_out *out)
+{
+    if(out == NULL)
+        return ;
+
+    int channels = get_hdmi_audio_speaker_allocation(&out->hdmi_audio);
+    switch (channels) {
+    case AUDIO_CHANNEL_OUT_5POINT1:
+        ALOGD("%s: HDMI Support 5.1 channels pcm",__FUNCTION__);
+        out->supported_channel_masks[0] = AUDIO_CHANNEL_OUT_5POINT1;
+        out->supported_channel_masks[1] = AUDIO_CHANNEL_OUT_STEREO;
+        break;
+    case AUDIO_CHANNEL_OUT_7POINT1:
+        ALOGD("%s: HDMI Support 7.1 channels pcm",__FUNCTION__);
+        out->supported_channel_masks[0] = AUDIO_CHANNEL_OUT_5POINT1;
+        out->supported_channel_masks[1] = AUDIO_CHANNEL_OUT_7POINT1;
+        break;
+    case AUDIO_CHANNEL_OUT_STEREO:
+    default:
+        ALOGD("%s: HDMI Support 2 channels pcm",__FUNCTION__);
+        out->supported_channel_masks[0] = AUDIO_CHANNEL_OUT_STEREO;
+        out->supported_channel_masks[1] = AUDIO_CHANNEL_OUT_MONO;
+        break;
+    }
+}
+
+static int adev_open_output_stream(struct audio_hw_device *dev,
+                                   audio_io_handle_t handle,
+                                   audio_devices_t devices,
+                                   audio_output_flags_t flags,
+                                   struct audio_config *config,
+                                   struct audio_stream_out **stream_out,
+                                   const char *address __unused)
+{
+    struct audio_device *adev = (struct audio_device *)dev;
+    struct stream_out *out;
+    int ret;
+    enum output_type type = OUTPUT_LOW_LATENCY;
+    bool isPcm = audio_is_linear_pcm(config->format);
+
+    ALOGD("%s devices = 0x%x, flags = %d, samplerate = %d,format = 0x%x",
+          __func__, devices, flags, config->sample_rate,config->format);
+    out = (struct stream_out *)calloc(1, sizeof(struct stream_out));
+    if (!out)
+        return -ENOMEM;
+
+    /*get default supported channel_mask*/
+    memset(out->supported_channel_masks, 0, sizeof(out->supported_channel_masks));
+    out->supported_channel_masks[0] = AUDIO_CHANNEL_OUT_STEREO;
+    out->supported_channel_masks[1] = AUDIO_CHANNEL_OUT_MONO;
+    /*get default supported sample_rate*/
+    memset(out->supported_sample_rates, 0, sizeof(out->supported_sample_rates));
+    out->supported_sample_rates[0] = 44100;
+    out->supported_sample_rates[1] = 48000;
+
+    if(config != NULL)
+        memcpy(&(out->aud_config),config,sizeof(struct audio_config));
+    out->channel_mask = AUDIO_CHANNEL_OUT_STEREO;
+    if (devices == AUDIO_DEVICE_NONE)
+        devices = AUDIO_DEVICE_OUT_SPEAKER;
+    out->device = devices;
+    /*
+     * set output_direct_mode to LPCM, means data is not multi pcm or bitstream datas.
+     * set output_direct to false, means data is 2 channels pcm
+     */
+    out->output_direct_mode = LPCM;
+    out->output_direct = false;
+    out->snd_reopen = false;
+    out->use_default_config = false;
+    out->volume[0] = out->volume[1] = 1.0f;
+    out->bistream = NULL;
+
+    init_hdmi_audio(&out->hdmi_audio);
+    if(devices & AUDIO_DEVICE_OUT_AUX_DIGITAL) {
+        parse_hdmi_audio(&out->hdmi_audio);
+        get_hdmi_support_channels_masks(out);
+    }
+
+    if (flags & AUDIO_OUTPUT_FLAG_DIRECT) {
+        if (devices & AUDIO_DEVICE_OUT_AUX_DIGITAL) {
+            if (config->format == AUDIO_FORMAT_IEC61937) {
+                ALOGD("%s:out = %p HDMI Bitstream",__FUNCTION__,out);
+                out->channel_mask = config->channel_mask;
+                if (isValidSamplerate(config->sample_rate)) {
+                    out->config = pcm_config_direct;
+                    out->config.rate = config->sample_rate;
+                    out->output_direct = true;
+                    int channel = audio_channel_count_from_out_mask(config->channel_mask);
+
+                    if (channel == 8 && config->sample_rate == 192000) {
+                        out->output_direct_mode = HBR;
+                    } else {
+                        out->output_direct_mode = NLPCM;
+                    }
+
+                    if (out->config.format == PCM_FORMAT_S24_LE) {
+                        if (config->sample_rate >= 176400) {
+                            out->config.period_size = 1024 * 4;
+                        } else {
+                            out->config.period_size = 2048;
+                        }
+                    } else {
+                        out->config.period_size = config->sample_rate/100;   // 10ms
+                    }
+
+                    #ifdef RK3128  // only 3128 using 16bit to bitstream
+                    out->config.format = PCM_FORMAT_S16_LE;
+                    #endif
+                    type = OUTPUT_HDMI_MULTI;
+                } else {
+                    out->config = pcm_config;
+                    out->config.rate = 44100;
+                    ALOGE("hdmi bitstream samplerate %d unsupport", config->sample_rate);
+                }
+                out->config.channels = audio_channel_count_from_out_mask(config->channel_mask);
+                if (out->config.channels < 2)
+                    out->config.channels = 2;
+                out->pcm_device = PCM_DEVICE;
+                out->device = AUDIO_DEVICE_OUT_AUX_DIGITAL;
+            } else if (isPcm){ // multi pcm
+                if (config->sample_rate == 0)
+                    config->sample_rate = HDMI_MULTI_DEFAULT_SAMPLING_RATE;
+                if (config->channel_mask == 0)
+                    config->channel_mask = AUDIO_CHANNEL_OUT_5POINT1;
+
+                int layout = get_hdmi_audio_speaker_allocation(&out->hdmi_audio);
+                unsigned int mask = (layout&config->channel_mask);
+                ALOGD("%s:out = %p HDMI multi pcm: layout = 0x%x,mask = 0x%x",
+                    __FUNCTION__,out,layout,mask);
+                // current hdmi allocation(speaker) only support MONO or STEREO
+                if(mask <= (int)AUDIO_CHANNEL_OUT_STEREO) {
+                    ALOGD("%s:out = %p input stream is multi pcm,channle mask = 0x%x,but hdmi not support,mixer it to stereo output",
+                        __FUNCTION__,out,config->channel_mask);
+                    out->channel_mask = AUDIO_CHANNEL_OUT_STEREO;
+                    out->config = pcm_config;
+                    out->pcm_device = PCM_DEVICE;
+                    type = OUTPUT_LOW_LATENCY;
+                    out->device = AUDIO_DEVICE_OUT_AUX_DIGITAL;
+                    out->output_direct = false;
+                } else {
+                    /*
+                     * maybe input audio stream is 7.1 channels,
+                     * but hdmi only support 5.1, we also output 7.1 for default.
+                     * Is better than output 2 channels after mixer?
+                     * If customer like output 2 channles data after mixer,
+                     * modify codes here
+                     */
+                    out->channel_mask = config->channel_mask;
+                    out->config = pcm_config_hdmi_multi;
+                    out->config.rate = config->sample_rate;
+                    out->config.channels = audio_channel_count_from_out_mask(config->channel_mask);
+                    out->pcm_device = PCM_DEVICE;
+                    type = OUTPUT_HDMI_MULTI;
+                    out->device = AUDIO_DEVICE_OUT_AUX_DIGITAL;
+                    out->output_direct = true;
+                }
+            } else {
+                ALOGD("Not any bitstream mode!");
+            }
+        } else {
+            out->config = pcm_config;
+            out->pcm_device = PCM_DEVICE;
+            type = OUTPUT_LOW_LATENCY;
+        }
+    } else if (flags & AUDIO_OUTPUT_FLAG_DEEP_BUFFER) {
+        out->config = pcm_config_deep;
+        out->pcm_device = PCM_DEVICE_DEEP;
+        type = OUTPUT_DEEP_BUF;
+    } else {
+        out->config = pcm_config;
+        out->pcm_device = PCM_DEVICE;
+        type = OUTPUT_LOW_LATENCY;
+    }
+
+    ALOGD("out->config.rate = %d, out->config.channels = %d out->config.format = %d",
+          out->config.rate, out->config.channels, out->config.format);
+
+    out->stream.common.get_sample_rate = out_get_sample_rate;
+    out->stream.common.set_sample_rate = out_set_sample_rate;
+    out->stream.common.get_buffer_size = out_get_buffer_size;
+    out->stream.common.get_channels = out_get_channels;
+    out->stream.common.get_format = out_get_format;
+    out->stream.common.set_format = out_set_format;
+    out->stream.common.standby = out_standby;
+    out->stream.common.dump = out_dump;
+    out->stream.common.set_parameters = out_set_parameters;
+    out->stream.common.get_parameters = out_get_parameters;
+    out->stream.common.add_audio_effect = out_add_audio_effect;
+    out->stream.common.remove_audio_effect = out_remove_audio_effect;
+    out->stream.get_latency = out_get_latency;
+    out->stream.set_volume = out_set_volume;
+    out->stream.write = out_write;
+    out->stream.get_render_position = out_get_render_position;
+    out->stream.get_next_write_timestamp = out_get_next_write_timestamp;
+    out->stream.get_presentation_position = out_get_presentation_position;
+
+    out->dev = adev;
+
+    out->standby = true;
+    out->nframes = 0;
+
+    pthread_mutex_lock(&adev->lock_outputs);
+    if (adev->outputs[type]) {
+        pthread_mutex_unlock(&adev->lock_outputs);
+        ret = -EBUSY;
+        goto err_open;
+    }
+    adev->outputs[type] = out;
+    pthread_mutex_unlock(&adev->lock_outputs);
+
+    *stream_out = &out->stream;
+
+    return 0;
+
+err_open:
+    if (out != NULL) {
+        destory_hdmi_audio(&out->hdmi_audio);
+        free(out);
+    }
+    *stream_out = NULL;
+    return ret;
+}
+
+static void adev_close_output_stream(struct audio_hw_device *dev,
+                                     struct audio_stream_out *stream)
+{
+    struct audio_device *adev;
+    enum output_type type;
+
+    ALOGD("adev_close_output_stream!");
+    out_standby(&stream->common);
+    adev = (struct audio_device *)dev;
+    pthread_mutex_lock(&adev->lock_outputs);
+    for (type = 0; type < OUTPUT_TOTAL; ++type) {
+        if (adev->outputs[type] == (struct stream_out *) stream) {
+            adev->outputs[type] = NULL;
+            break;
+        }
+    }
+
+    {
+        struct stream_out *out = (struct stream_out *)stream;
+        destory_hdmi_audio(&out->hdmi_audio);
+    }
+
+    pthread_mutex_unlock(&adev->lock_outputs);
+    free(stream);
+}
+
+static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
+{
+    struct audio_device *adev = (struct audio_device *)dev;
+    struct str_parms *parms = NULL;
+    char value[32] = "";
+    /*
+     * ret is the result of str_parms_get_str,
+     * if no paramter which str_parms_get_str to get, it will return result < 0 always.
+     * For example: kvpairs = connect=1024 is coming
+     *              str_parms_get_str(parms, AUDIO_PARAMETER_KEY_SCREEN_STATE,value, sizeof(value))
+     *              will return result < 0,this means no screen_state in parms
+     */
+    int ret = 0;
+
+    /*
+     * status is the result of one process,
+     * For example: kvpairs = screen_state=on is coming,
+     *              str_parms_get_str(parms, AUDIO_PARAMETER_KEY_SCREEN_STATE,value, sizeof(value))
+     *              will return result >= 0,this means screen is on, we can do something,
+     *              if the things we do is correct, we set status = 0, or status < 0 means fail.
+     */
+    int status = 0;
+
+    ALOGD("%s: kvpairs = %s", __func__, kvpairs);
+    parms = str_parms_create_str(kvpairs);
+    pthread_mutex_lock(&adev->lock);
+
+    // screen state off/on
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_KEY_SCREEN_STATE, // screen_state
+                            value, sizeof(value));
+    if (ret >= 0) {
+        if(strcmp(value,"on") == 0){
+            adev->screenOff = false;
+        } else if(strcmp(value,"off") == 0){
+            adev->screenOff = true;
+        }
+    }
+
+#ifdef AUDIO_BITSTREAM_REOPEN_HDMI
+    // hdmi reconnect
+    ret = str_parms_get_str(parms, AUDIO_PARAMETER_DEVICE_CONNECT, // hdmi reconnect
+                            value, sizeof(value));
+    if (ret >= 0) {
+        int device = atoi(value);
+        if(device == (int)AUDIO_DEVICE_OUT_AUX_DIGITAL){
+            struct stream_out *out = adev->outputs[OUTPUT_HDMI_MULTI];
+            if((out != NULL) && is_bitstream(out) && (out->device == AUDIO_DEVICE_OUT_AUX_DIGITAL)) {
+                ALOGD("%s: hdmi connect when audio stream is output over hdmi, do something,out = %p",__FUNCTION__,out);
+                out->snd_reopen = true;
+            }
+
+        }
+    }
+#endif
+
+    pthread_mutex_unlock(&adev->lock);
+    str_parms_destroy(parms);
+    return status;
+}
+
+/*
+ * get support formats for bitstream
+ * There is no stand interface in andorid to get the formats can be bistream,
+ * so we extend get parameter to report formats
+ */
+static int get_support_bitstream_formats(struct str_parms *query,
+                                    struct str_parms *reply)
+{
+    int avail = 1024;
+    char value[avail];
+
+    struct hdmi_audio_infors hdmi_edid;
+    init_hdmi_audio(&hdmi_edid);
+    const char* AUDIO_PARAMETER_STREAM_SUP_BITSTREAM_FORMAT = "sup_bitstream_formats";
+    if (str_parms_has_key(query, AUDIO_PARAMETER_STREAM_SUP_BITSTREAM_FORMAT)) {
+        memset(value,0,avail);
+
+        // get the format can be bistream?
+        if(parse_hdmi_audio(&hdmi_edid) >= 0){
+            int cursor = 0;
+            for(int i = 0; i < ARRAY_SIZE(sSurroundFormat); i++){
+                if(is_support_format(&hdmi_edid,sSurroundFormat[i].format)){
+                    avail -= cursor;
+                    int length = snprintf(value + cursor, avail, "%s%s",
+                                   cursor > 0 ? "|" : "",
+                                   sSurroundFormat[i].value);
+                    if (length < 0 || length >= avail) {
+                        break;
+                    }
+                    cursor += length;
+                }
+            }
+        }
+
+        destory_hdmi_audio(&hdmi_edid);
+        str_parms_add_str(reply, AUDIO_PARAMETER_STREAM_SUP_BITSTREAM_FORMAT, value);
+        return 0;
+    }
+
+    return -1;
+}
+
+static char * adev_get_parameters(const struct audio_hw_device *dev,
+                                  const char *keys)
+{
+    struct audio_device *adev = (struct audio_device *)dev;
+    struct str_parms *parms = str_parms_create_str(keys);
+    struct str_parms *reply = str_parms_create();
+    char *str = NULL;
+    ALOGD("%s: keys = %s",__FUNCTION__,keys);
+    if (str_parms_has_key(parms, "ec_supported")) {
+        str_parms_destroy(parms);
+        parms = str_parms_create_str("ec_supported=yes");
+        str = str_parms_to_str(parms);
+    } else if (get_support_bitstream_formats(parms,reply) == 0) {
+        str = str_parms_to_str(reply);
+    } else {
+        str = strdup("");
+    }
+
+    str_parms_destroy(parms);
+    str_parms_destroy(reply);
+
+    return str;
+}
+
+static int adev_init_check(const struct audio_hw_device *dev)
+{
+    return 0;
+}
+
+static int adev_set_voice_volume(struct audio_hw_device *dev, float volume)
+{
+    int ret = 0;
+    struct audio_device *adev = (struct audio_device *)dev;
+    if(adev->mode == AUDIO_MODE_IN_CALL) {
+        if (volume < 0.0) {
+            volume = 0.0;
+        } else if (volume > 1.0) {
+            volume = 1.0;
+        }
+
+        const char *mixer_ctl_name = "Speaker Playback Volume";
+        ret = route_set_voice_volume(mixer_ctl_name,volume);
+    }
+
+    return ret;
+}
+
+static int adev_set_master_volume(struct audio_hw_device *dev, float volume)
+{
+    return -ENOSYS;
+}
+
+static int adev_set_mode(struct audio_hw_device *dev, audio_mode_t mode)
+{
+    struct audio_device *adev = (struct audio_device *)dev;
+
+    ALOGD("%s: set_mode = %d", __func__, mode);
+    adev->mode = mode;
+
+    return 0;
+}
+
+static int adev_set_mic_mute(struct audio_hw_device *dev, bool state)
+{
+    return -ENOSYS;
+}
+
+static int adev_get_mic_mute(const struct audio_hw_device *dev, bool *state)
+{
+    return -ENOSYS;
+}
+
+static size_t adev_get_input_buffer_size(const struct audio_hw_device *dev,
+        const struct audio_config *config)
+{
+
+    return get_input_buffer_size(config->sample_rate, config->format,
+                                 audio_channel_count_from_in_mask(config->channel_mask),
+                                 false /* is_low_latency: since we don't know, be conservative */);
+}
+
+static int adev_open_input_stream(struct audio_hw_device *dev,
+                                  audio_io_handle_t handle,
+                                  audio_devices_t devices,
+                                  struct audio_config *config,
+                                  struct audio_stream_in **stream_in,
+                                  audio_input_flags_t flags,
+                                  const char *address __unused,
+                                  audio_source_t source __unused)
+{
+    struct audio_device *adev = (struct audio_device *)dev;
+    struct stream_in *in;
+    int ret;
+
+    ALOGD("audio hal adev_open_input_stream devices = 0x%x, flags = %d, config->samplerate = %d,config->channel_mask = %x",
+           devices, flags, config->sample_rate,config->channel_mask);
+
+    *stream_in = NULL;
+#ifdef ALSA_IN_DEBUG
+    in_debug = fopen("/data/debug.pcm","wb");//please touch /data/debug.pcm first
+#endif
+    /* Respond with a request for mono if a different format is given. */
+    //ALOGV("%s:config->channel_mask %d",__FUNCTION__,config->channel_mask);
+    if (/*config->channel_mask != AUDIO_CHANNEL_IN_MONO &&
+            config->channel_mask != AUDIO_CHANNEL_IN_FRONT_BACK*/
+        config->channel_mask != AUDIO_CHANNEL_IN_STEREO) {
+        config->channel_mask = AUDIO_CHANNEL_IN_STEREO;
+        ALOGE("%s:channel is not support",__FUNCTION__);
+        return -EINVAL;
+    }
+    if (config->sample_rate == 0 ) {
+        config->sample_rate = 44100;
+        ALOGW("%s: rate is not support",__FUNCTION__);
+    }
+
+    in = (struct stream_in *)calloc(1, sizeof(struct stream_in));
+    if (!in)
+        return -ENOMEM;
+
+    /*get default supported channel_mask*/
+    memset(in->supported_channel_masks, 0, sizeof(in->supported_channel_masks));
+    in->supported_channel_masks[0] = AUDIO_CHANNEL_IN_STEREO;
+    in->supported_channel_masks[1] = AUDIO_CHANNEL_IN_MONO;
+    /*get default supported sample_rate*/
+    memset(in->supported_sample_rates, 0, sizeof(in->supported_sample_rates));
+    in->supported_sample_rates[0] = 44100;
+    in->supported_sample_rates[1] = 48000;
+
+    in->stream.common.get_sample_rate = in_get_sample_rate;
+    in->stream.common.set_sample_rate = in_set_sample_rate;
+    in->stream.common.get_buffer_size = in_get_buffer_size;
+    in->stream.common.get_channels = in_get_channels;
+    in->stream.common.get_format = in_get_format;
+    in->stream.common.set_format = in_set_format;
+    in->stream.common.standby = in_standby;
+    in->stream.common.dump = in_dump;
+    in->stream.common.set_parameters = in_set_parameters;
+    in->stream.common.get_parameters = in_get_parameters;
+    in->stream.common.add_audio_effect = in_add_audio_effect;
+    in->stream.common.remove_audio_effect = in_remove_audio_effect;
+    in->stream.set_gain = in_set_gain;
+    in->stream.read = in_read;
+    in->stream.get_input_frames_lost = in_get_input_frames_lost;
+    in->stream.get_active_microphones = in_get_active_microphones;
+    in->stream.get_capture_position = in_get_capture_position;
+
+#ifdef RK_DENOISE_ENABLE
+    in->mDenioseState = NULL;
+#endif
+    in->dev = adev;
+    in->standby = true;
+    in->requested_rate = config->sample_rate;
+    in->input_source = AUDIO_SOURCE_DEFAULT;
+    /* strip AUDIO_DEVICE_BIT_IN to allow bitwise comparisons */
+    in->device = devices & ~AUDIO_DEVICE_BIT_IN;
+    in->io_handle = handle;
+    in->channel_mask = config->channel_mask;
+    if (in->device & AUDIO_DEVICE_IN_HDMI) {
+        ALOGD("HDMI-In: use low latency");
+        flags |= AUDIO_INPUT_FLAG_FAST;
+    }
+    in->flags = flags;
+    struct pcm_config *pcm_config = flags & AUDIO_INPUT_FLAG_FAST ?
+                                            &pcm_config_in_low_latency : &pcm_config_in;
+#ifdef BT_AP_SCO
+    if (adev->mode == AUDIO_MODE_IN_COMMUNICATION && in->device & AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET) {
+        pcm_config = &pcm_config_in_bt;
+    }
+#endif
+
+    in->config = pcm_config;
+
+    in->buffer = malloc(pcm_config->period_size * pcm_config->channels
+                        * audio_stream_in_frame_size(&in->stream));
+    if (!in->buffer) {
+        ret = -ENOMEM;
+        goto err_malloc;
+    }
+
+    if ((in->requested_rate != 0) && (in->requested_rate != pcm_config->rate)) {
+        in->buf_provider.get_next_buffer = get_next_buffer;
+        in->buf_provider.release_buffer = release_buffer;
+
+        ALOGD("pcm_config->rate:%d,in->requested_rate:%d,in->channel_mask:%d",
+              pcm_config->rate,in->requested_rate,audio_channel_count_from_in_mask(in->channel_mask));
+        ret = create_resampler(pcm_config->rate,
+                               in->requested_rate,
+                               audio_channel_count_from_in_mask(in->channel_mask),
+                               RESAMPLER_QUALITY_DEFAULT,
+                               &in->buf_provider,
+                               &in->resampler);
+        if (ret != 0) {
+            ret = -EINVAL;
+            goto err_resampler;
+        }
+    }
+
+    if (in->device&AUDIO_DEVICE_IN_HDMI) {
+        goto out;
+    }
+
+#ifdef AUDIO_3A
+    ALOGD("voice process has opened, try to create voice process!");
+    adev->voice_api = rk_voiceprocess_create(DEFAULT_PLAYBACK_SAMPLERATE,
+                                             DEFAULT_PLAYBACK_CHANNELS,
+                                             in->requested_rate,
+                                             audio_channel_count_from_in_mask(in->channel_mask));
+    if (adev->voice_api == NULL) {
+        ALOGE("crate voice process failed!");
+    }
+#endif
+out:
+    *stream_in = &in->stream;
+    return 0;
+err_resampler:
+    free(in->buffer);
+err_malloc:
+    free(in);
+    return ret;
+}
+
+static void adev_close_input_stream(struct audio_hw_device *dev,
+                                    struct audio_stream_in *stream)
+{
+    struct stream_in *in = (struct stream_in *)stream;
+    struct audio_device *adev = (struct audio_device *)dev;
+
+    ALOGD("%s",__FUNCTION__);
+
+    in_standby(&stream->common);
+    if (in->resampler) {
+        release_resampler(in->resampler);
+        in->resampler = NULL;
+    }
+
+#ifdef ALSA_IN_DEBUG
+    fclose(in_debug);
+#endif
+#ifdef AUDIO_3A
+    if (adev->voice_api != NULL) {
+        rk_voiceprocess_destory();
+        adev->voice_api = NULL;
+    }
+#endif
+
+#ifdef RK_DENOISE_ENABLE
+    if (in->mDenioseState)
+        rkdenoise_destroy(in->mDenioseState);
+    in->mDenioseState = NULL;
+#endif
+    free(in->buffer);
+    free(stream);
+}
+
+static int adev_dump(const audio_hw_device_t *device, int fd)
+{
+    return 0;
+}
+
+static int adev_close(hw_device_t *device)
+{
+    ALOGD("%s in",__func__);
+    route_uninit();
+    free(device);
+    return 0;
+}
+
+static void adev_open_init(struct audio_device *adev)
+{
+    ALOGD("%s in",__func__);
+    int i = 0;
+    adev->mic_mute = false;
+    adev->screenOff = false;
+
+#ifdef AUDIO_3A
+    adev->voice_api = NULL;
+#endif
+
+    adev->input_source = AUDIO_SOURCE_DEFAULT;
+
+    for(i =0; i < OUTPUT_TOTAL; i++){
+        adev->outputs[i] = NULL;
+    }
+    set_default_dev_info(&adev->dev_out, 1);
+    set_default_dev_info(&adev->dev_in, 1);
+    adev->dev_out.id = "HDMI";
+    adev->dev_in.id = "HDMI";
+    adev->owner = NULL;
+
+    char value[PROPERTY_VALUE_MAX];
+    if (property_get("vendor.audio.period_size", value, NULL) > 0) {
+        pcm_config.period_size = atoi(value);
+        pcm_config_in.period_size = pcm_config.period_size;
+    }
+    if (property_get("vendor.audio.in_period_size", value, NULL) > 0)
+        pcm_config_in.period_size = atoi(value);
+}
+
+static int adev_open(const hw_module_t* module, const char* name,
+                     hw_device_t** device)
+{
+    struct audio_device *adev;
+    int ret;
+
+    ALOGD(AUDIO_HAL_VERSION);
+
+    if (strcmp(name, AUDIO_HARDWARE_INTERFACE) != 0)
+        return -EINVAL;
+
+    adev = calloc(1, sizeof(struct audio_device));
+    if (!adev)
+        return -ENOMEM;
+
+    adev->hw_device.common.tag = HARDWARE_DEVICE_TAG;
+    adev->hw_device.common.version = AUDIO_DEVICE_API_VERSION_2_0;
+    adev->hw_device.common.module = (struct hw_module_t *) module;
+    adev->hw_device.common.close = adev_close;
+
+    adev->hw_device.init_check = adev_init_check;
+    adev->hw_device.set_voice_volume = adev_set_voice_volume;
+    adev->hw_device.set_master_volume = adev_set_master_volume;
+    adev->hw_device.set_mode = adev_set_mode;
+    adev->hw_device.set_mic_mute = adev_set_mic_mute;
+    adev->hw_device.get_mic_mute = adev_get_mic_mute;
+    adev->hw_device.set_parameters = adev_set_parameters;
+    adev->hw_device.get_parameters = adev_get_parameters;
+    adev->hw_device.get_input_buffer_size = adev_get_input_buffer_size;
+    adev->hw_device.open_output_stream = adev_open_output_stream;
+    adev->hw_device.close_output_stream = adev_close_output_stream;
+    adev->hw_device.open_input_stream = adev_open_input_stream;
+    adev->hw_device.close_input_stream = adev_close_input_stream;
+    adev->hw_device.dump = adev_dump;
+    adev->hw_device.get_microphones = adev_get_microphones;
+    *device = &adev->hw_device.common;
+
+    adev_open_init(adev);
+    return 0;
+}
+
+static struct hw_module_methods_t hal_module_methods = {
+    .open = adev_open,
+};
+
+struct audio_module HAL_MODULE_INFO_SYM = {
+    .common = {
+        .tag = HARDWARE_MODULE_TAG,
+        .module_api_version = AUDIO_MODULE_API_VERSION_0_1,
+        .hal_api_version = HARDWARE_HAL_API_VERSION,
+        .id = AUDIO_HARDWARE_MODULE_ID,
+        .name = "SPDIF audio HW HAL",
+        .author = "The Android Open Source Project",
+        .methods = &hal_module_methods,
+    },
+};
diff --git a/hardware/rockchip/audio/hdmi_hal/audio_hw.h b/hardware/rockchip/audio/hdmi_hal/audio_hw.h
new file mode 100755
index 0000000000..15267c52db
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/audio_hw.h
@@ -0,0 +1,572 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file audio_hw.h
+ * @brief
+ *                 ALSA Audio Git Log
+ * - V0.1.0:add alsa audio hal,just support 312x now.
+ * - V0.2.0:remove unused variable.
+ * - V0.3.0:turn off device when do_standby.
+ * - V0.4.0:turn off device before open pcm.
+ * - V0.4.1:Need to re-open the control to fix no sound when suspend.
+ * - V0.5.0:Merge the mixer operation from legacy_alsa.
+ * - V0.6.0:Merge speex denoise from legacy_alsa.
+ * - V0.7.0:add copyright.
+ * - V0.7.1:add support for box audio
+ * - V0.7.2:add support for dircet output
+ * - V0.8.0:update the direct output for box, add the DVI mode
+ * - V1.0.0:stable version
+ *
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef AUIDO_HW_H
+#define AUIDO_HW_H
+#include <errno.h>
+#include <pthread.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <time.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <cutils/str_parms.h>
+
+#include <hardware/audio.h>
+#include <hardware/hardware.h>
+
+#include <linux/videodev2.h>
+
+#include <system/audio.h>
+
+#include "asoundlib.h"
+
+#include <audio_utils/resampler.h>
+#include <audio_route/audio_route.h>
+
+#include <poll.h>
+#include <linux/fb.h>
+#include <hardware_legacy/uevent.h>
+
+#include "voice_preprocess.h"
+#include "audio_hw_hdmi.h"
+#include "denoise/rkdenoise.h"
+#include "bitstream/audio_bitstream_manager.h"
+
+#define AUDIO_HAL_VERSION "ALSA Audio Version: V1.1.0"
+
+#define PCM_DEVICE 0
+#define PCM_DEVICE_SCO 1
+#define PCM_DEVICE_VOICE 2
+#define PCM_DEVICE_HDMIIN 2
+#define PCM_DEVICE_DEEP 3
+/* for bt client call */
+#define PCM_DEVICE_HFP 1
+
+#define MIXER_CARD 0
+
+/* duration in ms of volume ramp applied when starting capture to remove plop */
+#define CAPTURE_START_RAMP_MS 100
+
+/* default sampling for default output */
+#define DEFAULT_PLAYBACK_SAMPLERATE 44100
+
+#define DEFAULT_PLAYBACK_CHANNELS 2
+
+/* default sampling for HDMI multichannel output */
+#define HDMI_MULTI_DEFAULT_SAMPLING_RATE  44100
+/* maximum number of channel mask configurations supported. Currently the primary
+ * output only supports 1 (stereo) and the multi channel HDMI output 2 (5.1 and 7.1) */
+#define MAX_SUPPORTED_CHANNEL_MASKS 2
+#define MAX_SUPPORTED_SAMPLE_RATES 2
+
+#ifndef BOX_HAL
+#define RK_DENOISE_ENABLE
+#endif
+
+#define HW_PARAMS_FLAG_LPCM 0
+#define HW_PARAMS_FLAG_NLPCM 1
+
+#ifdef BOX_HAL
+struct pcm_config pcm_config = {
+    .channels = 2,
+    .rate = 44100,
+    .period_size = 512,
+    .period_count = 3,
+    .format = PCM_FORMAT_S16_LE,
+};
+
+struct pcm_config pcm_config_in = {
+    .channels = 2,
+    .rate = 44100,
+    .period_size = 1024,
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+};
+#elif defined RK3399_LAPTOP
+struct pcm_config pcm_config = {
+    .channels = 2,
+    .rate = 48000,
+    .period_size = 480,
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+};
+
+struct pcm_config pcm_config_in = {
+    .channels = 2,
+    .rate = 48000,
+    .period_size = 120,
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+};
+#else
+struct pcm_config pcm_config = {
+    .channels = 2,
+    .rate = 44100,
+    .period_size = 512,
+    .period_count = 6,
+    .format = PCM_FORMAT_S16_LE,
+};
+
+struct pcm_config pcm_config_in = {
+    .channels = 2,
+    .rate = 44100,
+#ifdef RK_DENOISE_ENABLE
+    .period_size = 441,
+#else
+    .period_size = 256,
+#endif
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+};
+#endif
+
+struct pcm_config pcm_config_in_low_latency = {
+    .channels = 2,
+    .rate = 44100,
+    .period_size = 256,
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+};
+
+struct pcm_config pcm_config_sco = {
+    .channels = 1,
+    .rate = 8000,
+    .period_size = 128,
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+};
+
+/* for bt client call*/
+struct pcm_config pcm_config_hfp = {
+    .channels = 2,
+    .rate = 44100,
+    .period_size = 256,
+    .period_count = 4,
+};
+#ifdef BT_AP_SCO
+struct pcm_config pcm_config_ap_sco = {
+    .channels = 2,
+    .rate = 8000,
+    .period_size = 80,
+    .period_count = 4,
+};
+
+struct pcm_config pcm_config_in_bt = {
+    .channels = 2,
+    .rate = 8000,
+    .period_size = 120,
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+};
+#endif
+struct pcm_config pcm_config_deep = {
+    .channels = 2,
+    .rate = 44100,
+    /* FIXME This is an arbitrary number, may change.
+     * Dynamic configuration based on screen on/off is not implemented;
+     * let's see what power consumption is first to see if necessary.
+     */
+    .period_size = 8192,
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+};
+
+struct pcm_config pcm_config_hdmi_multi = {
+    .channels = 6, /* changed when the stream is opened */
+    .rate = HDMI_MULTI_DEFAULT_SAMPLING_RATE,
+    .period_size = 1024,
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+};
+
+struct pcm_config pcm_config_direct = {
+    .channels = 2,
+    .rate = 48000,
+    .period_size = 1024,
+    .period_count = 4,
+
+#ifdef IEC958_FORAMT
+    .format = PCM_FORMAT_IEC958_SUBFRAME_LE,
+#else
+    .format = PCM_FORMAT_S24_LE,
+#endif
+};
+
+enum output_type {
+    OUTPUT_DEEP_BUF,      // deep PCM buffers output stream
+    OUTPUT_LOW_LATENCY,   // low latency output stream
+    OUTPUT_HDMI_MULTI,          // HDMI multi channel
+    OUTPUT_DIRECT,
+    OUTPUT_TOTAL
+};
+
+struct direct_mode_t {
+    int output_mode;
+    char* hbr_Buf;
+};
+
+enum snd_out_sound_cards {
+    SND_OUT_SOUND_CARD_UNKNOWN = -1,
+    SND_OUT_SOUND_CARD_SPEAKER = 0,
+    SND_OUT_SOUND_CARD_HDMI,
+    SND_OUT_SOUND_CARD_SPDIF,
+    SND_OUT_SOUND_CARD_BT,
+    SND_OUT_SOUND_CARD_MAX,
+};
+
+enum snd_in_sound_cards {
+    SND_IN_SOUND_CARD_UNKNOWN = -1,
+    SND_IN_SOUND_CARD_MIC = 0,
+    SND_IN_SOUND_CARD_BT,
+    SND_IN_SOUND_CARD_HDMI,
+    SND_IN_SOUND_CARD_MAX,
+};
+
+struct dev_proc_info
+{
+    const char *cid; /* cardX/id match */
+    const char *did; /* dai id match */
+};
+
+struct dev_info
+{
+    const char *id;
+    int card;
+    int device;
+    int score;
+};
+
+struct audio_device {
+    struct audio_hw_device hw_device;
+
+    pthread_mutex_t lock; /* see note below on mutex acquisition order */
+    audio_devices_t out_device; /* "or" of stream_out.device for all active output streams */
+    audio_devices_t in_device;
+    bool mic_mute;
+    struct audio_route *ar;
+    audio_source_t input_source;
+    audio_channel_mask_t in_channel_mask;
+
+    struct stream_out *outputs[OUTPUT_TOTAL];
+    pthread_mutex_t lock_outputs; /* see note below on mutex acquisition order */
+    unsigned int mode;
+    bool   screenOff;
+#ifdef AUDIO_3A
+    rk_process_api* voice_api;
+#endif
+
+    /*
+     * hh@rock-chips.com
+     * this is for HDMI/SPDIF bitstream
+     * when HDMI/SPDIF bistream AC3/EAC3/DTS/TRUEHD/DTS-HD, some key tone or other pcm
+     * datas may come(play a Ac3 audio and seek the file to play). It is not allow to open sound card
+     * as pcm format and not allow to write pcm datas to HDMI/SPDIF sound cards when open it
+     * with config.flag = 1.
+     */
+    int*  owner;
+
+    struct dev_info dev_out;
+    struct dev_info dev_in;
+};
+
+struct stream_out {
+    struct audio_stream_out stream;
+
+    pthread_mutex_t lock; /* see note below on mutex acquisition order */
+    struct pcm *pcm;
+    struct pcm_config config;
+    struct audio_config aud_config;
+    unsigned int pcm_device;
+    bool standby; /* true if all PCMs are inactive */
+    audio_devices_t device;
+    /* FIXME: when HDMI multichannel output is active, other outputs must be disabled as
+     * HDMI and WM1811 share the same I2S. This means that notifications and other sounds are
+     * silent when watching a 5.1 movie. */
+    bool disabled;
+    audio_channel_mask_t channel_mask;
+    /* Array of supported channel mask configurations. +1 so that the last entry is always 0 */
+    audio_channel_mask_t supported_channel_masks[MAX_SUPPORTED_CHANNEL_MASKS + 1];
+    uint32_t supported_sample_rates[MAX_SUPPORTED_SAMPLE_RATES + 1];
+    bool muted;
+    uint64_t written; /* total frames written, not cleared when entering standby */
+    uint64_t nframes;
+
+    /*
+     * true: current stream take sound card in exclusive Mode, when this stream using this sound card,
+     *       other stream can't using this sound card. This happen when current stream
+     *       is multi pcm stream or bitstream. Multi channels pcm datas or bitstream datas can't be mixed.
+     * false: current stream is 2 channels pcm stream
+     */
+    bool output_direct;
+
+    /*
+     * LPCM:  pcm datas(include multi channels pcm)
+     * others: bitstream
+     */
+    int output_direct_mode;
+    struct audio_device *dev;
+    struct resampler_itfe *resampler;
+
+    // for hdmi bitstream
+    rk_bistream *bistream;
+
+    struct hdmi_audio_infors hdmi_audio;
+
+    bool  snd_reopen;
+    bool  use_default_config;
+    float volume[2];
+};
+
+struct stream_in {
+    struct audio_stream_in stream;
+
+    pthread_mutex_t lock; /* see note below on mutex acquisition order */
+    struct pcm *pcm;
+    bool standby;
+
+    unsigned int requested_rate;
+    struct resampler_itfe *resampler;
+    struct resampler_buffer_provider buf_provider;
+    int16_t *buffer;
+    size_t frames_in;
+    int read_status;
+    audio_source_t input_source;
+    audio_io_handle_t io_handle;
+    audio_devices_t device;
+    uint16_t ramp_vol;
+    uint16_t ramp_step;
+    size_t  ramp_frames;
+    audio_channel_mask_t channel_mask;
+    audio_input_flags_t flags;
+    struct pcm_config *config;
+
+    struct audio_device *dev;
+    audio_channel_mask_t supported_channel_masks[MAX_SUPPORTED_CHANNEL_MASKS + 1];
+    uint32_t supported_sample_rates[MAX_SUPPORTED_SAMPLE_RATES + 1];
+#ifdef RK_DENOISE_ENABLE
+    hrkdeniose mDenioseState;
+#endif
+    uint32_t channel_flag;
+    int start_checkcount;
+    uint64_t frames_read;
+};
+
+#define STRING_TO_ENUM(string) { #string, string }
+
+struct string_to_enum {
+    const char *name;
+    uint32_t value;
+};
+
+static const struct string_to_enum channels_name_to_enum_table[] = {
+    STRING_TO_ENUM(AUDIO_CHANNEL_OUT_MONO),
+    STRING_TO_ENUM(AUDIO_CHANNEL_OUT_STEREO),
+    STRING_TO_ENUM(AUDIO_CHANNEL_OUT_5POINT1),
+    STRING_TO_ENUM(AUDIO_CHANNEL_OUT_7POINT1),
+    STRING_TO_ENUM(AUDIO_CHANNEL_IN_MONO),
+    STRING_TO_ENUM(AUDIO_CHANNEL_IN_STEREO),
+    STRING_TO_ENUM(AUDIO_CHANNEL_IN_FRONT_BACK),
+};
+
+enum {
+    OUT_DEVICE_SPEAKER,
+    OUT_DEVICE_HEADSET,
+    OUT_DEVICE_HEADPHONES,
+    OUT_DEVICE_BT_SCO,
+    OUT_DEVICE_SPEAKER_AND_HEADSET,
+    OUT_DEVICE_OFF,
+    OUT_DEVICE_TAB_SIZE,           /* number of rows in route_configs[][] */
+    OUT_DEVICE_NONE,
+    OUT_DEVICE_CNT
+};
+
+enum {
+    IN_SOURCE_MIC,
+    IN_SOURCE_CAMCORDER,
+    IN_SOURCE_VOICE_RECOGNITION,
+    IN_SOURCE_VOICE_COMMUNICATION,
+    IN_SOURCE_OFF,
+    IN_SOURCE_TAB_SIZE,            /* number of lines in route_configs[][] */
+    IN_SOURCE_NONE,
+    IN_SOURCE_CNT
+};
+
+enum {
+    LPCM = 0,
+    NLPCM,
+    HBR,
+};
+
+struct route_config {
+    const char * const output_route;
+    const char * const input_route;
+    const char * const output_off;
+    const char * const input_off;
+};
+
+const struct route_config media_speaker = {
+    "media-speaker",
+    "media-main-mic",
+    "playback-off",
+    "capture-off",
+};
+
+const struct route_config media_headphones = {
+    "media-headphones",
+    "media-main-mic",
+    "playback-off",
+    "capture-off",
+};
+
+const struct route_config media_headset = {
+    "media-headphones",
+    "media-headset-mic",
+    "playback-off",
+    "capture-off",
+};
+
+const struct route_config camcorder_speaker = {
+    "media-speaker",
+    "media-second-mic",
+    "playback-off",
+    "capture-off",
+};
+
+const struct route_config camcorder_headphones = {
+    "media-headphones",
+    "media-second-mic",
+    "playback-off",
+    "capture-off",
+};
+
+const struct route_config voice_rec_speaker = {
+    "voice-rec-speaker",
+    "voice-rec-main-mic",
+    "incall-off",
+    "incall-off",
+};
+
+const struct route_config voice_rec_headphones = {
+    "voice-rec-headphones",
+    "voice-rec-main-mic",
+    "incall-off",
+    "incall-off",
+};
+
+const struct route_config voice_rec_headset = {
+    "voice-rec-headphones",
+    "voice-rec-headset-mic",
+    "incall-off",
+    "incall-off",
+};
+
+const struct route_config communication_speaker = {
+    "communication-speaker",
+    "communication-main-mic",
+    "voip-off",
+    "voip-off",
+};
+
+const struct route_config communication_headphones = {
+    "communication-headphones",
+    "communication-main-mic",
+    "voip-off",
+    "voip-off",
+};
+
+const struct route_config communication_headset = {
+    "communication-headphones",
+    "communication-headset-mic",
+    "voip-off",
+    "voip-off",
+};
+
+const struct route_config speaker_and_headphones = {
+    "speaker-and-headphones",
+    "main-mic",
+    "playback-off",
+    "capture-off",
+};
+
+const struct route_config bluetooth_sco = {
+    "bt-sco-headset",
+    "bt-sco-mic",
+    "playback-off",
+    "capture-off",
+};
+
+const struct route_config * const route_configs[IN_SOURCE_TAB_SIZE]
+        [OUT_DEVICE_TAB_SIZE] = {
+    {   /* IN_SOURCE_MIC */
+        &media_speaker,             /* OUT_DEVICE_SPEAKER */
+        &media_headset,             /* OUT_DEVICE_HEADSET */
+        &media_headphones,          /* OUT_DEVICE_HEADPHONES */
+        &bluetooth_sco,             /* OUT_DEVICE_BT_SCO */
+        &speaker_and_headphones     /* OUT_DEVICE_SPEAKER_AND_HEADSET */
+    },
+    {   /* IN_SOURCE_CAMCORDER */
+        &camcorder_speaker,         /* OUT_DEVICE_SPEAKER */
+        &camcorder_headphones,      /* OUT_DEVICE_HEADSET */
+        &camcorder_headphones,      /* OUT_DEVICE_HEADPHONES */
+        &bluetooth_sco,             /* OUT_DEVICE_BT_SCO */
+        &speaker_and_headphones     /* OUT_DEVICE_SPEAKER_AND_HEADSET */
+    },
+    {   /* IN_SOURCE_VOICE_RECOGNITION */
+        &voice_rec_speaker,         /* OUT_DEVICE_SPEAKER */
+        &voice_rec_headset,         /* OUT_DEVICE_HEADSET */
+        &voice_rec_headphones,      /* OUT_DEVICE_HEADPHONES */
+        &bluetooth_sco,             /* OUT_DEVICE_BT_SCO */
+        &speaker_and_headphones     /* OUT_DEVICE_SPEAKER_AND_HEADSET */
+    },
+    {   /* IN_SOURCE_VOICE_COMMUNICATION */
+        &communication_speaker,     /* OUT_DEVICE_SPEAKER */
+        &communication_headset,     /* OUT_DEVICE_HEADSET */
+        &communication_headphones,  /* OUT_DEVICE_HEADPHONES */
+        &bluetooth_sco,             /* OUT_DEVICE_BT_SCO */
+        &speaker_and_headphones     /* OUT_DEVICE_SPEAKER_AND_HEADSET */
+    }
+};
+
+static void do_out_standby(struct stream_out *out);
+#endif
+
diff --git a/hardware/rockchip/audio/hdmi_hal/audio_hw_hdmi.c b/hardware/rockchip/audio/hdmi_hal/audio_hw_hdmi.c
new file mode 100755
index 0000000000..4a7a8e4e70
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/audio_hw_hdmi.c
@@ -0,0 +1,648 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * @file audio_hw_hdmi.c
+ * @brief
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#define LOG_TAG "audio_hdmi_parser"
+
+#include "audio_hw_hdmi.h"
+#include <unistd.h>
+#include <errno.h>
+#include <cutils/log.h>
+
+#ifdef USE_DRM
+#define HDMI_EDID_NODE      "/sys/class/drm/card0-HDMI-A-1/edid"
+#else
+#define HDMI_EDID_NODE      "/sys/class/display/HDMI/edid"
+#endif
+
+//#define DEBUG
+#ifdef DEBUG
+#define ALOGVV ALOGD
+#else
+#define ALOGVV
+#endif
+
+#define HDMI_EDID_BLOCK_SIZE    128
+#define HDMI_MAX_EDID_BLOCK     8
+#define HDMI_AUDIO_LPCM         1
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+
+struct HDMI_Audio_Sample {
+    int index;
+    int sample;
+};
+
+const struct HDMI_Audio_Sample HDMI_SAMPLE_TABLE[] =
+{
+    {HDMI_AUDIO_FS_32000,32000},
+    {HDMI_AUDIO_FS_44100,44100},
+    {HDMI_AUDIO_FS_48000,48000},
+    {HDMI_AUDIO_FS_88200,88200},
+    {HDMI_AUDIO_FS_96000,96000},
+    {HDMI_AUDIO_FS_176400,176400},
+    {HDMI_AUDIO_FS_192000,192000},
+};
+
+struct HDMI_Audio_Speaker_Allocation {
+    int index;
+    int location;
+    char* name;
+};
+
+/*
+ * the allocation is defined in CEA-861
+ */
+const struct HDMI_Audio_Speaker_Allocation HDMI_SPEAKER_ALLOCATION_TABLE[] =
+{
+    {(1<<0), AUDIO_CHANNEL_OUT_STEREO ,"FL/FR"},
+    {(1<<1), AUDIO_CHANNEL_OUT_LOW_FREQUENCY ,"LFE"},
+    {(1<<2), AUDIO_CHANNEL_OUT_FRONT_CENTER ,"FC"},
+    {(1<<3), (AUDIO_CHANNEL_OUT_SIDE_LEFT|AUDIO_CHANNEL_OUT_SIDE_RIGHT), "SL/SR"},
+    {(1<<4), AUDIO_CHANNEL_OUT_BACK_CENTER ,"RC"},
+    {(1<<5), (AUDIO_CHANNEL_OUT_FRONT_LEFT_OF_CENTER|AUDIO_CHANNEL_OUT_FRONT_RIGHT_OF_CENTER), "FLC/FRC"},
+    {(1<<6), (AUDIO_CHANNEL_OUT_BACK_LEFT|AUDIO_CHANNEL_OUT_BACK_RIGHT), "RLC/RRC"},
+    {(1<<7), AUDIO_CHANNEL_NONE, "FLW/FRW"}, // no FLW/FRW defined in AUDIO_CHANNEL_OUT_xx
+    {(1<<8), (AUDIO_CHANNEL_OUT_TOP_FRONT_LEFT|AUDIO_CHANNEL_OUT_TOP_FRONT_RIGHT), "FLH/FRH"},
+    {(1<<9), AUDIO_CHANNEL_OUT_TOP_CENTER, "TC"},
+    {(1<<10), AUDIO_CHANNEL_OUT_TOP_FRONT_CENTER, "FCH"},
+};
+
+int hdmi_edid_checksum(unsigned char *buf)
+{
+    int i;
+    int checksum = 0;
+    if(buf == NULL) {
+        return -1;
+    }
+
+    for(i = 0; i < HDMI_EDID_BLOCK_SIZE; i++)
+        checksum += buf[i];
+
+    checksum &= 0xff;
+    ALOGVV("%s checksum is %x\n", __FUNCTION__, checksum);
+    int result = 0;
+    if(checksum == 0) {
+        result = 0;
+    } else {
+        result = -1;
+    }
+
+    return result;
+}
+
+bool translate_sample(unsigned char index,unsigned int* sample,int size)
+{
+    bool result = false;
+    int i = 0, j = 0;
+    int sample_array_length = ARRAY_SIZE(HDMI_SAMPLE_TABLE);
+    for(i = 0; i < sample_array_length; i++) {
+        // every bit mean a samplerate
+        if(index & HDMI_SAMPLE_TABLE[i].index) {
+            sample[j] = HDMI_SAMPLE_TABLE[i].sample;
+            if(j < size){
+                j++;
+            }
+
+            result = true;
+        }
+    }
+
+    return result;
+}
+
+
+int hdmi_edid_parse_cea_audio(unsigned char *buf, struct hdmi_audio_infors *infor)
+{
+    int i, count;
+    struct hdmi_audio_information* audio = NULL;
+    if((buf == NULL) || (infor == NULL)) {
+        ALOGD("%s: error, input parameter is NULL",__FUNCTION__);
+        return -1;
+    }
+
+    count = buf[0] & 0x1F;
+    if(count > 0) {
+        audio = malloc(count*sizeof(struct hdmi_audio_information));
+        if (audio == NULL) {
+            ALOGD("%s: malloc hdmi_audio_information fail",__FUNCTION__);
+            return -1;
+        }
+
+        memset(audio,0,count*sizeof(struct hdmi_audio_information));
+        int audio_num = count / 3;
+        unsigned char sample = 0;
+        for (i = 0; i < count; i++) {
+            audio[i].type = (buf[i * 3 + 1] >> 3) & 0x0F;
+            audio[i].channel = (buf[i * 3 + 1] & 0x07) + 1;
+            audio[i].sample = buf[i * 3 + 2];
+            audio[i].value = buf[i * 3 + 3];
+            //   translate_sample(sample,audio[i].sample,8);
+
+            if (audio[i].type == HDMI_AUDIO_LPCM) {
+                audio[i].word_length = buf[i * 3 + 3];
+            } else if(audio[i].type >= HDMI_AUDIO_AC3 && audio[i].type <= HDMI_AUDIO_ATARC) {
+                audio[i].max_bitrate = 8000*buf[i * 3 + 3];
+            }
+
+            ALOGVV("%s: i = %d, type = %d,channel = %d, sample = %d,value = 0x%x",
+                __FUNCTION__,i,audio[i].type,audio[i].channel,audio[i].sample,audio[i].value);
+        }
+
+        infor->number = count;
+        infor->audio = audio;
+    }
+
+    return 0;
+}
+
+/*
+ * see document <cea-861-e.pdf> Part: Speaker Allocation Data Block(Page 67)
+ * multi LPCM
+ */
+int hdmi_edid_parse_speaker_allocation(unsigned char *buf, struct hdmi_audio_infors *infor)
+{
+    if((buf == NULL) || (infor == NULL)) {
+        ALOGD("%s: error, input parameter is NULL",__FUNCTION__);
+        return -1;
+    }
+
+    /*
+     * bytes in buf[1] ~ buf[3] is valid, see CEA-861 part:Speaker Allocation Data Block
+     */
+  //  int tag = (buf[0]>>5);
+  //  int length = buf[0] & 0x1f;
+    int hightlayout = (buf[2] & 0x07); // hight 5 bit is reseved
+    infor->channel_layout = ((hightlayout<<8) | buf[1]);
+    ALOGVV("%s : %d,buf[1]= 0x%x,buf[2]= 0x%x, layout = 0x%x",__FUNCTION__,__LINE__,buf[1],buf[2],infor->channel_layout);
+    return 0;
+}
+
+int hdmi_edid_parse_extensions_cea(unsigned char *buf, struct hdmi_audio_infors *infor)
+{
+    unsigned int ddc_offset, native_dtd_num, cur_offset = 4;
+    unsigned int tag, IEEEOUI = 0, count, i;
+    struct fb_videomode *vmode;
+
+    if((buf == NULL) || (infor == NULL)) {
+        ALOGD("%s: error, input parameter is NULL",__FUNCTION__);
+        return -1;
+    }
+
+    /* Check ces extension version */
+    if (buf[1] != 3) {
+        ALOGD("%s: %d [CEA] error version",__FUNCTION__,__LINE__);
+        return -1;
+    }
+
+    ddc_offset = buf[2];
+        /* Parse data block */
+    while (cur_offset < ddc_offset) {
+        tag = buf[cur_offset] >> 5;
+        count = buf[cur_offset] & 0x1F;
+        switch (tag) {
+            case 0x02:  /* Video Data Block */
+                ALOGVV("%s: [CEA] Video Data Block",__FUNCTION__);
+                break;
+            case 0x01:  /* Audio Data Block */
+                ALOGVV("%s [CEA] Audio Data Block",__FUNCTION__);
+                hdmi_edid_parse_cea_audio(buf + cur_offset,infor);
+                break;
+            case 0x04:  /* Speaker Allocation Data Block */
+                ALOGVV("%s: [CEA] Speaker Allocatio Data Block",__FUNCTION__);
+                hdmi_edid_parse_speaker_allocation(buf + cur_offset,infor);
+                break;
+            case 0x03:  /* Vendor Specific Data Block */
+                ALOGVV("%s: [CEA] Vendor Specific Data Block",__FUNCTION__);
+                break;
+            case 0x05:  /* VESA DTC Data Block */
+                ALOGVV("%s: [CEA] VESA DTC Data Block",__FUNCTION__);
+                break;
+            case 0x07:  /* Use Extended Tag */
+                ALOGVV("%s: [CEA] Use Extended Tag Data Block %02x",__FUNCTION__,buf[cur_offset + 1]);
+                switch (buf[cur_offset + 1]) {
+                case 0x00:
+                    ALOGVV("%s: [CEA] Video Capability Data Block",__FUNCTION__);
+                    break;
+                case 0x05:
+                    ALOGVV("%s: [CEA] Colorimetry Data Block",__FUNCTION__);
+                    break;
+                case 0x06:
+                    ALOGVV("%s: [CEA] HDR Static Metedata data Block",__FUNCTION__);
+                    break;
+                case 0x0e:
+                    ALOGVV("%s: [CEA] YCBCR 4:2:0 Video Data Block",__FUNCTION__);
+                    break;
+                case 0x0f:
+                    ALOGVV("%s: [CEA] YCBCR 4:2:0 Capability Map Data",__FUNCTION__);
+                    break;
+            }
+            break;
+            default:
+                ALOGVV("%s: [CEA] unkowned data block tag",__FUNCTION__);
+                break;
+        }
+        cur_offset += (buf[cur_offset] & 0x1F) + 1;
+    }
+
+    return 0;
+}
+
+
+int hdmi_edid_parse_extensions(unsigned char *buf, struct hdmi_audio_infors *infor)
+{
+    int rc;
+
+    if((buf == NULL) || (infor == NULL)) {
+        ALOGD("%s: error, input parameter is NULL",__FUNCTION__);
+        return -1;
+    }
+
+    /* Checksum */
+    rc = hdmi_edid_checksum(buf);
+    if (rc != 0) {
+        ALOGE("%s: [EDID] extensions block checksum error",__FUNCTION__);
+        return -1;
+    }
+    switch (buf[0]) {
+        case 0xF0:
+            ALOGVV("%s: [EDID-EXTEND] Iextensions block map",__FUNCTION__);
+            break;
+        case 0x02:
+            ALOGVV("%s: [EDID-EXTEND] CEA 861 Series Extension",__FUNCTION__);
+            hdmi_edid_parse_extensions_cea(buf, infor);
+            break;
+        case 0x10:
+            ALOGVV("%s: [EDID-EXTEND] Video Timing Block Extension",__FUNCTION__);
+            break;
+        case 0x40:
+            ALOGVV("%s: [EDID-EXTEND] Display Information Extension",__FUNCTION__);
+            break;
+        case 0x50:
+            ALOGVV("%s: [EDID-EXTEND] Localized String Extension",__FUNCTION__);
+            break;
+        case 0x60:
+            ALOGVV("%s: [EDID-EXTEND] Digital Packet Video Link Extension",__FUNCTION__);
+            break;
+        default:
+            ALOGVV("%s: [EDID-EXTEND] Unkowned Extension,tag = 0x%x",__FUNCTION__,buf[0]);
+            return -1;
+    }
+
+    return 0;
+}
+
+int hdmi_parse_base_block(unsigned char *buf, int *extend_num)
+{
+    if(buf == NULL || extend_num == NULL)
+        return -1;
+
+    *extend_num = (int)buf[0x7e];
+    // skip other informations
+    return 0;
+}
+
+void init_hdmi_audio(struct hdmi_audio_infors *infor)
+{
+    if(infor != NULL) {
+        pthread_mutex_init(&infor->lock, NULL);
+        infor->number = 0;
+        infor->channel_layout = -1;
+        infor->audio = NULL;
+    }
+}
+
+void destory_hdmi_audio(struct hdmi_audio_infors *infor)
+{
+    if(infor != NULL) {
+        pthread_mutex_lock(&infor->lock);
+        if(infor->audio != NULL) {
+            free(infor->audio);
+            infor->audio = NULL;
+        }
+
+        infor->number = 0;
+        infor->channel_layout = -1;
+        pthread_mutex_unlock(&infor->lock);
+        pthread_mutex_destroy(&infor->lock);
+    }
+}
+
+/*
+ * get the speaker allocation
+ * only valid when output stream is pcm
+ */
+int get_hdmi_audio_speaker_allocation(struct hdmi_audio_infors *infor)
+{
+    if((infor == NULL) || (infor->channel_layout == -1)) {
+        return AUDIO_CHANNEL_OUT_STEREO;
+    }
+
+    pthread_mutex_lock(&infor->lock);
+    int layout = AUDIO_CHANNEL_NONE;
+    int length = ARRAY_SIZE(HDMI_SPEAKER_ALLOCATION_TABLE);
+    for(int i = 0; i < length; i++) {
+        if(infor->channel_layout & HDMI_SPEAKER_ALLOCATION_TABLE[i].index) {
+            layout |= HDMI_SPEAKER_ALLOCATION_TABLE[i].location;
+        }
+    }
+    pthread_mutex_unlock(&infor->lock);
+    return layout;
+}
+
+int parse_hdmi_audio(struct hdmi_audio_infors *infor)
+{
+    if(infor == NULL) {
+        ALOGD("%s: error, input parameter is NULL",__FUNCTION__);
+        return -1;
+    }
+
+    FILE* file = fopen(HDMI_EDID_NODE,"rb");
+    if(file == NULL) {
+        ALOGVV("%s: open %s fail,reason = %s",__FUNCTION__,HDMI_EDID_NODE,strerror(errno));
+        return -1;
+    }
+    pthread_mutex_lock(&infor->lock);
+    // there is 128 bytes in every block
+    unsigned char buffer[HDMI_EDID_BLOCK_SIZE];
+    memset(buffer, 0, HDMI_EDID_BLOCK_SIZE);
+    int size = 0;
+    int retry = 20;
+    do{
+        /*
+         * using hdmi drm function to get this information is a better way,
+         * but using this functions need System permissions.
+         * May be this is no information in Node HDMI_EDID_NODE,
+         * so if read fail ,we retry to read.
+         */
+        size = fread(buffer, 1, HDMI_EDID_BLOCK_SIZE, file);
+        if(size == 0){
+            usleep(20000);
+            retry --;
+        }
+    }while((size==0) && (retry>0));
+    ALOGVV("%s: %d: size = %d",__FUNCTION__,__LINE__,size);
+    int extendblock = 0;
+    int i = 0;
+
+    // parse base block, we just need the information of the numbers of extend block
+    hdmi_parse_base_block(buffer, &extendblock);
+    ALOGVV("%s: %d: extendblock = %d",__FUNCTION__,__LINE__,extendblock);
+    // paser extend block
+    if(extendblock > 0) {
+        for (i = 1; (i < extendblock + 1) && (i < HDMI_MAX_EDID_BLOCK); i++) {
+            memset(buffer, 0, HDMI_EDID_BLOCK_SIZE);
+            size = fread(buffer, 1, HDMI_EDID_BLOCK_SIZE, file);
+            if(size > 0) {
+                hdmi_edid_parse_extensions(buffer,infor);
+            } else {
+                break;
+            }
+        }
+    }
+    pthread_mutex_unlock(&infor->lock);
+
+    dump(infor);
+EXIT:
+    if(file != NULL) {
+        fclose(file);
+        file = NULL;
+    }
+
+    return 0;
+}
+
+int translate_format(audio_format_t format)
+{
+    int type = (int)HDMI_AUDIO_FORMAT_INVALID;
+    switch(format)
+    {
+        case AUDIO_FORMAT_AC3:
+            type = (int)HDMI_AUDIO_AC3;
+            break;
+        case AUDIO_FORMAT_E_AC3:
+            type = (int)HDMI_AUDIO_E_AC3;
+            break;
+        case AUDIO_FORMAT_DTS:
+            type = (int)HDMI_AUDIO_DTS;
+            break;
+        case AUDIO_FORMAT_DTS_HD:
+            type = (int)HDMI_AUDIO_DTS_HD;
+            break;
+        case AUDIO_FORMAT_AAC_LC:
+            type = (int)HDMI_AUDIO_AAC_LC;
+            break;
+        case AUDIO_FORMAT_DOLBY_TRUEHD:
+            type = (int)HDMI_AUDIO_MLP;
+            break;
+        case AUDIO_FORMAT_AC4:
+            type = (int)HDMI_AUDIO_E_AC3;
+            break;
+        default:
+            break;
+    }
+
+    return type;
+}
+
+bool is_support_ac4(int type,int support)
+{
+    /* Bits of byte 3
+     * bit0 = 1 Decoding of joint object coding content is supported
+     * bit1 = 1 Decoding of joint object coding content with ACMOD 28 is supported
+     */
+    if((type == (int)HDMI_AUDIO_E_AC3) && (support & 0x1)) {
+        return true;
+    }
+
+    return false;
+}
+bool is_support_format(struct hdmi_audio_infors *infor,audio_format_t format)
+{
+    if((infor == NULL) || (infor->number <= 0) || (infor->audio == NULL)) {
+        return false;
+    }
+
+    pthread_mutex_lock(&infor->lock);
+    bool support = false;
+    int type = translate_format(format);
+    for(int i = 0; i < infor->number; i++) {
+        // AC4 have the same value with EAC3, must judge the byte3 if cea_audio
+        if(format == AUDIO_FORMAT_AC4){
+            support = is_support_ac4((int)infor->audio[i].type,(int)infor->audio[i].value);
+            if(support){
+                break;
+            }
+        }else if(type == (int)infor->audio[i].type) {
+            support = true;
+            break;
+        }
+    }
+    pthread_mutex_unlock(&infor->lock);
+    return support;
+}
+
+void dump_hdmi_audio_sample(int index,char*name,int size)
+{
+    int i = 0;
+    bool first = true;
+    int offset = 0;
+
+    if((name == NULL) || (size < 0)){
+        return ;
+    }
+
+    int sample_array_length = ARRAY_SIZE(HDMI_SAMPLE_TABLE);
+    for(i = 0; i < sample_array_length; i++) {
+        // every bit mean a samplerate
+        if(index & HDMI_SAMPLE_TABLE[i].index) {
+            if(name != NULL) {
+                int length = snprintf(name + offset, size-offset, "%s%d",
+                                               first ? "" : ",",
+                                               HDMI_SAMPLE_TABLE[i].sample);
+                first = false;
+                offset += length;
+            }
+        }
+    }
+}
+
+void dump_hdmi_audio_format(int format,int support,char* buffer,int size)
+{
+    if((buffer == NULL) || (size <= 0)){
+        return ;
+    }
+
+    char* name = NULL;
+    switch(format)
+    {
+        case HDMI_AUDIO_LPCM:
+            name = "Pcm";
+            break;
+        case HDMI_AUDIO_AC3:
+            name = "AC3";
+            break;
+        case HDMI_AUDIO_MPEG1:
+            name = "MPEG1";
+            break;
+        case HDMI_AUDIO_MP3:
+            name = "MP3";
+            break;
+        case HDMI_AUDIO_MPEG2:
+            name = "MP2";
+            break;
+        case HDMI_AUDIO_AAC_LC:
+            name = "AAC_LC";
+            break;
+        case HDMI_AUDIO_DTS:
+            name = "DTS";
+            break;
+        case HDMI_AUDIO_ATARC:
+            name = "ATARC";
+            break;
+        case HDMI_AUDIO_DSD:
+            name = "DSD";
+            break;
+        case HDMI_AUDIO_E_AC3:
+            name = "EAC3";
+            if(is_support_ac4(format,support)){
+                name = "EAC3/AC4";
+            }
+            break;
+        case HDMI_AUDIO_DTS_HD:
+            name = "DTS-HD";
+            break;
+        case HDMI_AUDIO_MLP:
+            name = "MLP";
+            break;
+        case HDMI_AUDIO_DST:
+            name = "DST";
+            break;
+        case HDMI_AUDIO_WMA_PRO:
+            name = "WMA-PRO";
+            break;
+        default:
+            name = "Unknow";
+            break;
+    }
+
+    if(name != NULL){
+        snprintf(buffer, size, "%s", name);
+    }
+}
+
+void dump_hdmi_audio_speaker_layout(int layout)
+{
+    int i = 0;
+    bool first = true;
+    int offset = 0;
+    char buffer[512];
+    int size = 512;
+
+    memset(buffer,0,size);
+    int length = ARRAY_SIZE(HDMI_SPEAKER_ALLOCATION_TABLE);
+    for(i = 0; i < length; i++) {
+        // every bit mean a samplerate
+        if(layout & HDMI_SPEAKER_ALLOCATION_TABLE[i].index) {
+            int length = snprintf(buffer + offset, size-offset, "%s%s",
+                                           first ? "" : ",",
+                                           HDMI_SPEAKER_ALLOCATION_TABLE[i].name);
+            first = false;
+            if(offset+length < size){
+                offset += length;
+            } else {
+                ALOGVV("%s: buffer is not enought",__FUNCTION__);
+                break;
+            }
+        }
+    }
+
+    ALOGVV("%s: speaker allocation = %s",__FUNCTION__,buffer);
+}
+
+void dump(struct hdmi_audio_infors *infor)
+{
+    if((infor == NULL) || (infor->number <= 0) || (infor->audio == NULL)) {
+        return ;
+    }
+
+    char format[20];
+    char channel[50];
+    char sample[1024];
+    char* name = NULL;
+
+    pthread_mutex_lock(&infor->lock);
+    for(int i = 0; i < infor->number; i++) {
+        if(infor->audio[i].type == 0){
+            continue;
+        }
+
+        dump_hdmi_audio_format(infor->audio[i].type,infor->audio[i].value,format,20);
+        dump_hdmi_audio_sample(infor->audio[i].sample,sample,1024);
+        ALOGVV("%s: type = %s,channel = %d,sample = %s",__FUNCTION__,format,infor->audio[i].channel,sample);
+    }
+
+    if(infor->channel_layout != -1){
+        dump_hdmi_audio_speaker_layout(infor->channel_layout);
+    }
+    pthread_mutex_unlock(&infor->lock);
+}
diff --git a/hardware/rockchip/audio/hdmi_hal/audio_hw_hdmi.h b/hardware/rockchip/audio/hdmi_hal/audio_hw_hdmi.h
new file mode 100755
index 0000000000..3aa8eda923
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/audio_hw_hdmi.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * parse HDMI's EDID for get the information of support's format,samplerate,channel and channeMask
+ * the driver of hdmi not give the interface how to get audio information of audio(hdmi),so we
+ * parse the edid myself to get the inforamtions.
+ * this parse codes is following CEA-861
+ */
+
+#ifndef AUIDO_HDMI_AUIOD_INFORMATION_PARSER_H
+#define AUIDO_HDMI_AUIOD_INFORMATION_PARSER_H
+
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <system/audio.h>
+#include <pthread.h>
+
+
+/* HDMI Audio Sample Rate */
+enum hdmi_audio_samplerate {
+    HDMI_AUDIO_FS_32000  = (1<<0),
+    HDMI_AUDIO_FS_44100  = (1<<1),
+    HDMI_AUDIO_FS_48000  = (1<<2),
+    HDMI_AUDIO_FS_88200  = (1<<3),
+    HDMI_AUDIO_FS_96000  = (1<<4),
+    HDMI_AUDIO_FS_176400 = (1<<5),
+    HDMI_AUDIO_FS_192000 = (1<<6)
+};
+
+/* HDMI Audio Word Length */
+enum hdmi_audio_word_length {
+    HDMI_AUDIO_WORD_LENGTH_16bit = 0x1,
+    HDMI_AUDIO_WORD_LENGTH_20bit = 0x2,
+    HDMI_AUDIO_WORD_LENGTH_24bit = 0x4
+};
+
+enum hdmi_audio_type {
+    HDMI_AUDIO_NLPCM = 0,
+    HDMI_AUDIO_LPCM = 1,    /* PCM */
+    HDMI_AUDIO_AC3,
+    HDMI_AUDIO_MPEG1,
+    HDMI_AUDIO_MP3,
+    HDMI_AUDIO_MPEG2,
+    HDMI_AUDIO_AAC_LC,      /*AAC */
+    HDMI_AUDIO_DTS,
+    HDMI_AUDIO_ATARC,
+    HDMI_AUDIO_DSD,
+    HDMI_AUDIO_E_AC3 = 10,
+    HDMI_AUDIO_DTS_HD,
+    HDMI_AUDIO_MLP,        /*Dolby TrueHD and Dolby MAT */
+    HDMI_AUDIO_DST,
+    HDMI_AUDIO_WMA_PRO,
+
+    HDMI_AUDIO_FORMAT_INVALID = 0xff
+};
+
+struct hdmi_audio_information {
+    unsigned char type;
+    unsigned char channel;
+    unsigned char sample;            // index of sample, every bit mean a samplerate
+    unsigned char value;             // Audio coding type dependent value, some audio codec type using the same type(Dolby TrueHD and Dolby MAT, AC4 ande EAC3),
+                                     // so need this value judge which type supported?
+    unsigned char word_length;       // support pcm word length, only valid when type = HDMI_AUDIO_LPCM
+    unsigned int  max_bitrate;       // support max bitrates, only valid when type belong to [HDMI_AUDIO_AC3,HDMI_AUDIO_ATARC]
+};
+
+struct hdmi_audio_infors {
+    pthread_mutex_t lock;
+    int number;
+    int channel_layout; // the layout of speaker, only valid when type = HDMI_AUDIO_LPCM
+    struct hdmi_audio_information* audio;
+};
+
+extern void init_hdmi_audio(struct hdmi_audio_infors *infor);
+extern int parse_hdmi_audio(struct hdmi_audio_infors *audios);
+extern int get_hdmi_audio_speaker_allocation(struct hdmi_audio_infors *infor);
+extern bool is_support_format(struct hdmi_audio_infors *infor,audio_format_t format);
+extern void destory_hdmi_audio(struct hdmi_audio_infors *infor);
+extern void dump(struct hdmi_audio_infors *infor);
+#endif
diff --git a/hardware/rockchip/audio/hdmi_hal/audio_setting.h b/hardware/rockchip/audio/hdmi_hal/audio_setting.h
new file mode 100755
index 0000000000..a32eff761f
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/audio_setting.h
@@ -0,0 +1,15 @@
+#ifndef _RK_AUDIO_HAL_SETTING_
+#define _RK_AUDIO_HAL_SETTING_
+
+
+#include <stdbool.h>
+
+#define DEFAULT_MODE 0
+#define HDMI_BITSTREAM_MODE 6
+#define SPDIF_PASSTHROUGH_MODE 8
+
+extern bool isBypass();
+extern bool isMultiPcm();
+extern int getOutputDevice();
+
+#endif
\ No newline at end of file
diff --git a/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream.c b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream.c
new file mode 100755
index 0000000000..7cec49c8fb
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream.c
@@ -0,0 +1,326 @@
+#include "audio_bitstream.h"
+#include "stdio.h"
+#include <stdlib.h>
+#include <string.h>
+#include <cutils/log.h>
+#include <sys/endian.h>
+
+/* b, p, c, u, v, 0, 0, 0*/
+#define B_BIT_SHIFT    7
+#define P_BIT_SHIFT    6
+#define C_BIT_SHIFT    5
+#define U_BIT_SHIFT    4
+#define V_BIT_SHIFT    3
+#define C_BIT_SET      (0x1<<C_BIT_SHIFT)
+#define C_BIT_UNSET    (~(0x1<<C_BIT_SHIFT))
+
+
+#define CHASTA_BIT0    0
+#define CHASTA_BIT1    1
+/* bit 24~27  sampling frequency */
+#define CHASTA_BIT24   24
+#define CHASTA_BIT25   25
+#define CHASTA_BIT26   26
+#define CHASTA_BIT27   27
+/* bit 32~35 sample word lentgh */
+#define CHASTA_BIT32   32
+#define CHASTA_BIT33   33
+#define CHASTA_BIT34   34
+#define CHASTA_BIT35   35
+/* bit 36~39 original samplling frequency */
+#define CHASTA_BIT36   36
+#define CHASTA_BIT37   37
+#define CHASTA_BIT38   38
+#define CHASTA_BIT39   39
+
+
+static int scount = 0;
+
+bool isValidSamplerate(int samplerate)
+{
+    if ((samplerate == 44100) || (samplerate== 48000) || (samplerate == 32000) ||
+            (samplerate == 176400) || (samplerate == 192000)) {
+        return true;
+    }
+    return false;
+}
+
+
+/**
+ * @brief initchnsta
+ */
+void initchnsta(char* buffer)
+{
+    scount = 0;
+    if (buffer != NULL) {
+        memset(buffer, 0x0, CHASTA_SUB_NUM);
+        buffer[CHASTA_BIT1*2] = 1;
+        buffer[CHASTA_BIT1*2+1] = 1;
+        /* word length default 24 bit*/
+        buffer[CHASTA_BIT32*2] = 1;
+        buffer[CHASTA_BIT32*2+1] = 1;
+        buffer[CHASTA_BIT33*2] = 1;
+        buffer[CHASTA_BIT33*2+1] = 1;
+        buffer[CHASTA_BIT35*2] = 1;
+        buffer[CHASTA_BIT35*2+1] = 1;
+        /* sampling frequency default 48k */
+        buffer[CHASTA_BIT25*2] = 1;
+        buffer[CHASTA_BIT25*2+1] = 1;
+        /* original sampling frequency default 48k */
+        buffer[CHASTA_BIT36*2] = 1;
+        buffer[CHASTA_BIT36*2+1] = 1;
+        buffer[CHASTA_BIT38*2] = 1;
+        buffer[CHASTA_BIT38*2+1] = 1;
+        buffer[CHASTA_BIT39*2] = 1;
+        buffer[CHASTA_BIT39*2+1] = 1;
+
+        /* b, p, c, u, v, 0, 0, 0*/
+        int i = 0;
+        for (i=0; i<CHASTA_SUB_NUM; i++)
+            buffer[i] = (buffer[i]<<C_BIT_SHIFT) | (0x1<<V_BIT_SHIFT);
+
+        /* B bit */
+        buffer[CHASTA_BIT0*2] |= (0X1<<B_BIT_SHIFT);
+        buffer[CHASTA_BIT0*2+1] |= (0X1<<B_BIT_SHIFT);
+    }
+}
+
+void set176400chnsta(char* buffer)
+{
+    if (buffer == NULL)
+        return;    
+
+    /* sampling frequency default 176.4K */
+    buffer[CHASTA_BIT24*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT24*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT25*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT25*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT26*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT26*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT27*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT27*2+1] |= C_BIT_SET;
+    /* original sampling frequency */
+    buffer[CHASTA_BIT36*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT36*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT37*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT37*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT38*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT38*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT39*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT39*2+1] &= C_BIT_UNSET;
+}
+
+void set32000chnsta(char* buffer)
+{
+    if (buffer == NULL)
+        return;
+
+    /* sampling frequency default 32K */
+    buffer[CHASTA_BIT24*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT24*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT25*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT25*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT26*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT26*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT27*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT27*2+1] &= C_BIT_UNSET;
+    /* original sampling frequency */
+    buffer[CHASTA_BIT36*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT36*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT37*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT37*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT38*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT38*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT39*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT39*2+1] |= C_BIT_SET;
+}
+
+
+void set44100chnsta(char* buffer)
+{
+    if (buffer == NULL)
+        return;
+
+    /* sampling frequency default 44.1K */
+    buffer[CHASTA_BIT24*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT24*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT25*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT25*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT26*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT26*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT27*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT27*2+1] &= C_BIT_UNSET;
+    /* original sampling frequency */
+    buffer[CHASTA_BIT36*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT36*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT37*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT37*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT38*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT38*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT39*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT39*2+1] |= C_BIT_SET;
+}
+
+/**
+ * @brief setnlpcmchnsta
+ */
+void setnlpcmchnsta(char* buffer)
+{
+    if (buffer == NULL)
+        return;
+
+    /* sampling frequency default 48k */
+    buffer[CHASTA_BIT24*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT24*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT25*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT25*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT26*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT26*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT27*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT27*2+1] &= C_BIT_UNSET;
+    /* original sampling frequency */
+    buffer[CHASTA_BIT36*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT36*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT37*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT37*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT38*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT38*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT39*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT39*2+1] |= C_BIT_SET;
+}
+
+void setddpchnsta(char* buffer)
+{
+    if (buffer == NULL)
+        return;
+    
+    /* sampling frequency default 192k */
+    buffer[CHASTA_BIT24*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT24*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT25*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT25*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT26*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT26*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT27*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT27*2+1] |= C_BIT_SET;
+    /* original sampling frequency */
+    buffer[CHASTA_BIT36*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT36*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT37*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT37*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT38*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT38*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT39*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT39*2+1] &= C_BIT_UNSET;
+}
+
+
+/**
+ * @brief sethbrchnsta
+ */
+void sethbrchnsta(char* buffer)
+{
+    if (buffer == NULL)
+        return;
+
+    buffer[CHASTA_BIT24*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT24*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT25*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT25*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT26*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT26*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT27*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT27*2+1] |= C_BIT_SET;
+    /* original sampling frequency */
+    buffer[CHASTA_BIT36*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT36*2+1] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT37*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT37*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT38*2] |= C_BIT_SET;
+    buffer[CHASTA_BIT38*2+1] |= C_BIT_SET;
+    buffer[CHASTA_BIT39*2] &= C_BIT_UNSET;
+    buffer[CHASTA_BIT39*2+1] &= C_BIT_UNSET;
+}
+
+void setChanSta(char* buffer,int samplerate, int channel)
+{
+    if (buffer == NULL)
+        return;
+
+    if (channel == 8) {
+        sethbrchnsta(buffer);
+    } else {
+        switch (samplerate) {
+        case 192000:
+            setddpchnsta(buffer);
+            break;
+        case 176400:
+            set176400chnsta(buffer);
+            break;
+        case 44100:
+            set44100chnsta(buffer);
+            break;
+        case 32000:
+            set32000chnsta(buffer);
+            break;
+        case 48000:
+        default:
+            setnlpcmchnsta(buffer);
+            break;
+        }
+    }
+}
+
+int fill_hdmi_bitstream_buf(void * in, void* out,void* chan, int length)
+{
+    int temp, p, j = 0;
+    char *ptr = (char *)in;
+    char *ptr_end = (char *)in+length;
+    char *newptr = (char *)out;
+    char* channel = (char *)chan;
+    if((ptr == NULL) || (newptr == NULL) || (channel == NULL) || (length <= 0))
+        return -1;
+
+    while (ptr < ptr_end) {
+        newptr[0] = (ptr[0]&0x1f)<<3;
+        newptr[1] = ((ptr[0]&0xe0)>>5)|((ptr[1]&0x1f)<<3);
+        newptr[2] = (ptr[1]&0xe0)>>5;
+        newptr[2] |= channel[scount];
+        temp = (newptr[2]<<24) | (newptr[1]<<16) | (newptr[0]<<8);
+        j=0;
+        p=0;
+        while (j<31) {
+            p ^= temp&0x1;
+            p &= 0x1;
+            temp >>= 1;
+            j++;
+        }
+        newptr[2] |= (p&0x01)<<6;
+        newptr[3] = 0x00;
+        scount++;
+        scount %= 384;
+        ptr +=2;
+        newptr +=4;
+    }
+
+	return 0;
+}
+
+
+/**
+ * @brief dumpchnsta
+ */
+void dumpchnsta(char* buffer)
+{
+    if (buffer == NULL)
+        return;
+
+    for (int i=0; i<CHASTA_SUB_NUM; i+=16) {
+        ALOGD("%02d: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x "
+              "0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
+              i/16, buffer[i], buffer[i+1], buffer[i+2], buffer[i+3],
+              buffer[i+4], buffer[i+5], buffer[i+6], buffer[i+7],
+              buffer[i+8], buffer[i+9], buffer[i+10], buffer[i+11],
+              buffer[i+12], buffer[i+13], buffer[i+14], buffer[i+15]);
+    }
+}
diff --git a/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream.h b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream.h
new file mode 100755
index 0000000000..e714965e9c
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream.h
@@ -0,0 +1,32 @@
+#ifndef _RK_AUDIO_HDMI_BITSTREAM_
+#define _RK_AUDIO_HDMI_BITSTREAM_
+
+#include <stdbool.h>
+
+#define CHASTA_NUM     192
+#define CHASTA_SUB_NUM (CHASTA_NUM*2)
+
+/*
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This is inplement for bitstram/passthrougth
+ * Adaptation kernel4.9 or before version
+ */
+
+extern bool isValidSamplerate(int samplerate);
+extern void initchnsta(char* buffer);
+extern void setChanSta(char* buffer,int samplerate, int channel);
+extern int fill_hdmi_bitstream_buf(void * in, void* out,void* chan, int length);
+#endif
\ No newline at end of file
diff --git a/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream_manager.c b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream_manager.c
new file mode 100755
index 0000000000..a07a316f3a
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream_manager.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2020 Rockchip Electronics Co. LTD
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * Author: hh@rock-chips.com
+ * Date: 2021/11/27
+ */
+
+
+#include "audio_bitstream_manager.h"
+#include <utils/Log.h>
+#include <string.h>
+#include "stdio.h"
+#include <stdlib.h>
+
+#ifdef LOG_TAG
+#undef LOG_TAG
+#endif
+
+#define LOG_TAG "bitstream_manager"
+
+rk_bistream* bitstream_init(enum pcm_format format, int samplerate, int channel) {
+    rk_bistream *bs = (rk_bistream*)malloc(sizeof(rk_bistream));
+    memset(bs, 0, sizeof(rk_bistream));
+    bs->format = format;
+    bs->buffer = NULL;
+    bs->chnStatus = NULL;
+
+    if (format == PCM_FORMAT_S24_LE) {
+        bs->chnStatus = malloc(CHASTA_SUB_NUM);
+        initchnsta(bs->chnStatus);
+        setChanSta(bs->chnStatus, samplerate, channel);
+    } else if (format == PCM_FORMAT_IEC958_SUBFRAME_LE) {
+        iec958_init(&bs->iec958, samplerate, channel, false);
+    } else {
+        ALOGD("%s: format = %d not support", __FUNCTION__, (int)format);
+        free(bs);
+        return NULL;
+    }
+    ALOGD("%s:%d format = %d, samplerate = %d, channel = %d",
+        __FUNCTION__, __LINE__, format, samplerate, channel);
+    return bs;
+}
+
+int bitstream_encode(rk_bistream *bs, char *inBuffer, int inSize, char **outBuffer, int *outSize) {
+    if (bs == NULL)
+        return -1;
+
+    if ((bs->buffer == NULL) || (bs->capaticy < inSize*2)) {
+        if (bs->buffer != NULL) {
+            free(bs->buffer);
+        }
+
+        bs->capaticy = inSize*2;
+        bs->buffer = (char *)malloc(bs->capaticy);
+        ALOGD("%s: %d malloc bistream buffer(size = %d)", __FUNCTION__, __LINE__, bs->capaticy);
+    }
+
+    *outBuffer = bs->buffer;
+    *outSize   = 2*inSize;
+    int ret = -1;
+    if (bs->format == PCM_FORMAT_S24_LE) {
+        ret = fill_hdmi_bitstream_buf((void *)inBuffer, (void *)bs->buffer,(void*)bs->chnStatus, (int)inSize);
+    } else if (bs->format == PCM_FORMAT_IEC958_SUBFRAME_LE) {
+        ret = iec958_frame_encode(&bs->iec958, inBuffer, inSize, bs->buffer, outSize);
+    } else {
+        ALOGD("%s: format = %d not support", __FUNCTION__, (int)bs->format);
+        *outSize = 0;
+    }
+
+    return ret;
+}
+
+void bitstream_destory(rk_bistream **bitstream) {
+    rk_bistream *bs = *bitstream;
+    if (bs == NULL)
+        return;
+
+    if (bs->format == PCM_FORMAT_S24_LE) {
+        if (bs->chnStatus != NULL) {
+            free(bs->chnStatus);
+            bs->chnStatus = NULL;
+        }
+    } else if (bs->format == PCM_FORMAT_IEC958_SUBFRAME_LE) {
+    }
+
+    if (bs->buffer != NULL) {
+        free(bs->buffer);
+        bs->buffer = NULL;
+    }
+
+    bs->capaticy = 0;
+    iec958_deInit(&bs->iec958);
+    free(bs);
+    *bitstream = NULL;
+}
+
diff --git a/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream_manager.h b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream_manager.h
new file mode 100755
index 0000000000..0d205cfc98
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_bitstream_manager.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2020 Rockchip Electronics Co. LTD
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: hh@rock-chips.com
+ * Date: 2021/11/27
+ */
+#ifndef AUIDO_HW_BITSTREAM_INTERFACE_
+#define AUIDO_HW_BITSTREAM_INTERFACE_
+
+#include "audio_iec958.h"
+#include "audio_bitstream.h"
+#include "../asoundlib.h"
+
+typedef struct _rk_bistream {
+    char *buffer;             // output buffer
+    int  capaticy;            // output buffer size
+    enum pcm_format format;   // output format
+    char *chnStatus;          // for kernel 4.19 and before version
+    rk_iec958 iec958;         // for kernel 5.10 and later version
+} rk_bistream;
+
+rk_bistream* bitstream_init(enum pcm_format format, int samplerate, int channel);
+int bitstream_encode(rk_bistream *bs, char *inBuffer, int inSize,
+    char **outBuffer, int *outSize);
+void bitstream_destory(rk_bistream **bs);
+
+#endif  // AUIDO_HW_BITSTREAM_INTERFACE_
diff --git a/hardware/rockchip/audio/hdmi_hal/bitstream/audio_iec958.c b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_iec958.c
new file mode 100755
index 0000000000..0c40e00f96
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_iec958.c
@@ -0,0 +1,336 @@
+/*
+ * Copyright 2020 Rockchip Electronics Co. LTD
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: hh@rock-chips.com
+ * Date: 2021/11/27
+ */
+#include <utils/Log.h>
+#include "stdio.h"
+#include <stdlib.h>
+#include <string.h>
+#include "audio_iec958.h"
+
+#ifdef LOG_TAG
+#undef LOG_TAG
+#endif
+
+#define LOG_TAG "iec958"
+
+/* see IEC 60958-3-2006.pdf
+ *
+ * Byte 2: Source and channel number
+ * Bits 16~19  Source number, bit 16 = LSB, bit 19 = MSB
+ * Bit     16, 17, 18, 19
+ * State   0   0   0   0     Do not take into account
+ *         1   0   0   0     1
+ *         0   1   0   0     2
+ *         1   1   0   0     3
+ *         ......
+ *         1   1   1   1     15
+ *
+ * Bits 20 to 23  Channel number(audio channel), bit 20 = LSB, bit 23 = MSB
+ * Bit     20  21  22  23
+ * State   0   0   0   0   Do not take into account
+ *         1   0   0   0   (left channel for stereo channel format)
+ *         0   1   0   0   (right channel for stereo channel format)
+ *         1   1   0   0
+ *         ......
+ *         1   1   1   1
+ *
+ *
+ * Byte 3 Sampling frequency and clock accuracy
+ * Bit 24~27 for samplerate
+ * Bit      24, 25, 26, 27
+ * State:   0   0   1   0    22050 hz
+ *          0   0   0   0    44100 hz
+ *          0   0   0   1    88200 hz
+ *          0   0   1   1    176400 hz
+ *          0   1   1   0    24000 hz
+ *          0   1   0   0    48000 hz
+ *          0   1   0   1    96000 hz
+ *          0   1   1   1    192000 hz
+ *          1   1   0   0    32000 hz
+ *          1   0   0   0    samplerate not indicated
+ *          1   0   0   1    768000 hz
+ *
+ *
+ * Bit 32 Word length
+ * Bit      0  Maximum audio sample word length is 20bis
+ *          1  Maximum audio sample word length is 24bis
+ *
+ *
+ * Bit 33~35 for sample word length
+ * Bit       33, 34, 35   Audio sample word length if
+ *                        maxumum lenth is 24bits(see bit32=1)
+ *                        indicated by bit 32
+ * State:    0   0   0    Word length not indicated dicated
+ *                        (default)
+ *           1   0   0      20bits
+ *           0   1   0      22bits
+ *           0   0   1      23bits
+ *           1   0   1      24bits
+ *           0   1   1      21bits
+ *
+ * Bit       33, 34, 35   Audio sample word length if
+ *                        maxumum lenth is 20bits(see bit32=0)
+ *                        indicated by bit 32
+ * State:    0   0   0    Word length not indicated dicated
+ *                        (default)
+ *           1   0   0      16bits
+ *           0   1   0      18bits
+ *           0   0   1      19bits
+ *           1   0   1      20bits
+ *           0   1   1      17bits
+ *
+ *
+ * Bit 36~39 for Original sampling frequency
+ * Bit       36 37 38 39
+ * State:    1  1  1  1     44100 hz
+ *           1  1  1  0     88200 hz
+ *           1  1  0  1     22050 hz
+ *           1  1  0  0     176400 hz
+ *           1  0  1  1     48000 hz
+ *           1  0  1  0     96000 hz
+ *           1  0  0  1     24000 hz
+ *           1  0  0  0     192000 hz
+ *           0  1  1  1     reserved
+ *           0  1  1  0     8000 hz
+ *           0  1  0  1     11025 hz
+ *           0  1  0  0     12000 hz
+ *           0  0  1  1     32000 hz
+ *           0  0  1  0     reserved
+ *           0  0  0  1     16000 hz
+ *           0  0  0  0     Original sampling frequency not indicated(default)
+ */
+
+unsigned int iec958_16to32(short *buffer) {
+    unsigned int data = (*buffer) << 16;
+    return data;
+}
+
+static unsigned int iec958_parity(unsigned int data) {
+    unsigned int parity;
+    int bit;
+
+    /*
+    * Compose 32bit IEC958 subframe, two sub frames
+    * build one frame with two channels.
+    *
+    * This is IP of HDMI data map:
+    * Audio Width  31 30 29 28 27 26 ......  12  11  10  9  8  7  6  5  4   3   2   1   0
+    *     24       B  P  C  U  V  MSB                                       LSB
+    *     20       B  P  C  U  V  MSB                          LSB
+    *     16       B  P  C  U  V  MSB            LSB
+    *
+    * So, for 16bit(IEC61937) to IEC958 subframe,
+    * bit 0-10  = padding
+    *     11-26 = data
+    *     27    = validity (0 for valid data, else 'in error')
+    *     28    = user data (0)
+    *     29    = channel status (24 bytes for 192 frames)
+    *     30    = parity
+    *     31    = block start
+    */
+    parity = 0;
+    data >>= 11;
+    for (bit = 11; bit <= 29; bit++) {
+        if (data & 1)
+            parity++;
+        data >>= 1;
+    }
+    return (parity & 1);
+}
+
+static uint32_t iec958_subframe(rk_iec958 *iec, uint32_t data, int channel) {
+    unsigned int byte = iec->counter >> 3;
+    unsigned int mask = 1 << (iec->counter - (byte << 3));
+
+    data = (data & 0xffff0000) >> 5;
+
+    /* set IEC status bits (up to 192 bits) */
+    if (iec->status[byte] & mask)
+        data |= 0x20000000;
+
+    if (iec958_parity(data))
+        data |= 0x40000000;
+
+    /* block start */
+    if (!iec->counter)
+        data |= 0x80000000;
+
+    return data;
+}
+
+int iec958_frame_encode(rk_iec958 *iec, char *in, int inLength, char *out, int *outLength) {
+    if (iec == NULL)
+        return -1;
+
+    if (in == NULL || inLength <= 0 || out == NULL || outLength == NULL)
+        return -1;
+
+    int size = 2;
+    int counter  = iec->counter;
+    int channels = iec->channels;
+    int frames   = inLength/(size*channels);
+    int frame1   = frames;
+
+    short *input     = NULL;
+    uint32_t *output = NULL;
+    uint32_t data    = 0;
+    for (int channel = 0; channel < channels; ++channel) {
+        iec->counter = counter;
+        frame1 = frames;
+        input  = (short *)in+channel;
+        output = (uint32_t *)out+channel;
+        while (frame1 > 0) {
+            data = iec958_16to32(input);
+            *output = iec958_subframe(iec, data, channel);
+            input += channels;
+            output += channels;
+            iec->counter++;
+            iec->counter %= 192;
+            frame1--;
+        }
+    }
+    *outLength = 2*inLength;
+
+    return 0;
+}
+
+void setResample(unsigned char *status, int sameplerate) {
+    // set AES3(Byte3) bit24~27
+    switch(sameplerate) {
+        case 22050:
+            *status = IEC958_AES3_CON_FS_22050;
+            break;
+        case 24000:
+            *status = IEC958_AES3_CON_FS_24000;
+            break;
+        case 32000:
+            *status = IEC958_AES3_CON_FS_32000;
+            break;
+        case 44100:
+            *status = IEC958_AES3_CON_FS_44100;
+            break;
+        case 48000:
+            *status = IEC958_AES3_CON_FS_48000;
+            break;
+        case 88200:
+            *status = IEC958_AES3_CON_FS_88200;
+            break;
+        case 96000:
+            *status = IEC958_AES3_CON_FS_96000;
+            break;
+        case 176400:
+            *status = IEC958_AES3_CON_FS_176400;
+            break;
+        case 192000:
+            *status = IEC958_AES3_CON_FS_192000;
+            break;
+        case 768000:
+            *status = IEC958_AES3_CON_FS_768000;
+            break;
+        default:
+            ALOGD("samplerate = %d not support", sameplerate);
+            break;
+    }
+}
+
+void setOriginalResample(unsigned char *status, int sameplerate) {
+    // set AES4(Byte4) bit36~39
+    switch(sameplerate) {
+        case 22050:
+            *status |= IEC958_AES4_CON_FS_22050;
+            break;
+        case 24000:
+            *status |= IEC958_AES4_CON_FS_24000;
+            break;
+        case 32000:
+            *status |= IEC958_AES4_CON_FS_32000;
+            break;
+        case 44100:
+            *status |= IEC958_AES4_CON_FS_44100;
+            break;
+        case 48000:
+            *status |= IEC958_AES4_CON_FS_48000;
+            break;
+        case 88200:
+            *status |= IEC958_AES4_CON_FS_88200;
+            break;
+        case 96000:
+            *status |= IEC958_AES4_CON_FS_96000;
+            break;
+        case 176400:
+            *status |= IEC958_AES4_CON_FS_176400;
+            break;
+        case 192000:
+            *status |= IEC958_AES4_CON_FS_192000;
+            break;
+        default:
+            break;
+    }
+}
+
+
+int iec958_init(rk_iec958 *iec, int samplerate, int channel, bool isPcm) {
+    const unsigned char pcm_status_bits[] = {
+        IEC958_AES0_CON_EMPHASIS_NONE,   // Byte0 consumer, not-copyright, emphasis-none, mode=0
+        IEC958_AES1_CON_ORIGINAL | IEC958_AES1_CON_PCM_CODER,  // Byte1 original, PCM coder
+        0,  // Byte2 source and channel
+        IEC958_AES3_CON_FS_48000,  // Byte3 fs=48000Hz, clock accuracy=1000ppm
+    };
+
+    const unsigned char bistream_status_bits[] = {
+        IEC958_AES0_NONAUDIO, // non pcm
+        0,  // bit8~bit15
+        0,  // Byte2 source and channel bit16~bit23
+        IEC958_AES3_CON_FS_48000,  // bit24~bit31
+        IEC958_AES4_CON_BITS24,
+    };
+
+    if (iec == NULL)
+        return -1;
+
+    iec->counter = 0;
+    memset(iec->status, 0, sizeof(iec->status));
+    if (isPcm) {
+        memcpy(iec->status, pcm_status_bits, sizeof(pcm_status_bits));
+    } else {
+        memcpy(iec->status, bistream_status_bits, sizeof(bistream_status_bits));
+        // HBR for example TRUEHD, DTS-HD using 768000 samplerate
+        if (channel == 8) {
+            samplerate = 768000;
+        }
+    }
+
+    // always using channel = 2 to convert IEC61937/PCM frame to IEC958 frame
+    channel = 2;
+    setResample(&iec->status[3], samplerate);
+    setOriginalResample(&iec->status[4], samplerate);
+
+    iec->samplerate = samplerate;
+    iec->channels   = channel;
+    ALOGV("this = %p, status: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x",
+        iec, iec->status[0], iec->status[1], iec->status[2], iec->status[3], iec->status[4]);
+    ALOGV("this = %p, samplerate = %d, channel = %d", iec, samplerate, channel);
+
+    return 0;
+}
+
+int iec958_deInit(rk_iec958 *iec) {
+    (void)iec;
+    return 0;
+}
+
diff --git a/hardware/rockchip/audio/hdmi_hal/bitstream/audio_iec958.h b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_iec958.h
new file mode 100755
index 0000000000..5abad0de0e
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/bitstream/audio_iec958.h
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2020 Rockchip Electronics Co. LTD
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * This is new inplement for bitstram/passthrougth
+ * Adaptation kernel5.1 or later version
+ *
+ * Author: hh@rock-chips.com
+ * Date: 2021/11/27
+ */
+
+#ifndef _RK_AUDIO_IEC958_
+#define _RK_AUDIO_IEC958_
+
+#include "stdbool.h"
+
+ /* AES/IEC958 channel status bits */
+#define IEC958_AES0_PROFESSIONAL	(1<<0)	/* 0 = consumer, 1 = professional */
+#define IEC958_AES0_NONAUDIO		(1<<1)	/* 0 = audio, 1 = non-audio */
+#define IEC958_AES0_PRO_EMPHASIS	(7<<2)	/* mask - emphasis */
+#define IEC958_AES0_PRO_EMPHASIS_NOTID	(0<<2)	/* emphasis not indicated */
+#define IEC958_AES0_PRO_EMPHASIS_NONE	(1<<2)	/* none emphasis */
+#define IEC958_AES0_PRO_EMPHASIS_5015	(3<<2)	/* 50/15us emphasis */
+#define IEC958_AES0_PRO_EMPHASIS_CCITT	(7<<2)	/* CCITT J.17 emphasis */
+#define IEC958_AES0_PRO_FREQ_UNLOCKED	(1<<5)	/* source sample frequency: 0 = locked, 1 = unlocked */
+#define IEC958_AES0_PRO_FS		(3<<6)	/* mask - sample frequency */
+#define IEC958_AES0_PRO_FS_NOTID	(0<<6)	/* fs not indicated */
+#define IEC958_AES0_PRO_FS_44100	(1<<6)	/* 44.1kHz */
+#define IEC958_AES0_PRO_FS_48000	(2<<6)	/* 48kHz */
+#define IEC958_AES0_PRO_FS_32000	(3<<6)	/* 32kHz */
+#define IEC958_AES0_CON_NOT_COPYRIGHT	(1<<2)	/* 0 = copyright, 1 = not copyright */
+#define IEC958_AES0_CON_EMPHASIS	(7<<3)	/* mask - emphasis */
+#define IEC958_AES0_CON_EMPHASIS_NONE	(0<<3)	/* none emphasis */
+#define IEC958_AES0_CON_EMPHASIS_5015	(1<<3)	/* 50/15us emphasis */
+#define IEC958_AES0_CON_MODE		(3<<6)	/* mask - mode */
+#define IEC958_AES1_PRO_MODE		(15<<0)	/* mask - channel mode */
+#define IEC958_AES1_PRO_MODE_NOTID	(0<<0)	/* not indicated */
+#define IEC958_AES1_PRO_MODE_STEREOPHONIC (2<<0) /* stereophonic - ch A is left */
+#define IEC958_AES1_PRO_MODE_SINGLE	(4<<0)	/* single channel */
+#define IEC958_AES1_PRO_MODE_TWO	(8<<0)	/* two channels */
+#define IEC958_AES1_PRO_MODE_PRIMARY	(12<<0)	/* primary/secondary */
+#define IEC958_AES1_PRO_MODE_BYTE3	(15<<0)	/* vector to byte 3 */
+#define IEC958_AES1_PRO_USERBITS	(15<<4)	/* mask - user bits */
+#define IEC958_AES1_PRO_USERBITS_NOTID	(0<<4)	/* not indicated */
+#define IEC958_AES1_PRO_USERBITS_192	(8<<4)	/* 192-bit structure */
+#define IEC958_AES1_PRO_USERBITS_UDEF	(12<<4)	/* user defined application */
+#define IEC958_AES1_CON_CATEGORY	0x7f
+#define IEC958_AES1_CON_GENERAL		0x00
+#define IEC958_AES1_CON_EXPERIMENTAL	0x40
+#define IEC958_AES1_CON_SOLIDMEM_MASK	0x0f
+#define IEC958_AES1_CON_SOLIDMEM_ID	0x08
+#define IEC958_AES1_CON_BROADCAST1_MASK 0x07
+#define IEC958_AES1_CON_BROADCAST1_ID	0x04
+#define IEC958_AES1_CON_DIGDIGCONV_MASK 0x07
+#define IEC958_AES1_CON_DIGDIGCONV_ID	0x02
+#define IEC958_AES1_CON_ADC_COPYRIGHT_MASK 0x1f
+#define IEC958_AES1_CON_ADC_COPYRIGHT_ID 0x06
+#define IEC958_AES1_CON_ADC_MASK	0x1f
+#define IEC958_AES1_CON_ADC_ID		0x16
+#define IEC958_AES1_CON_BROADCAST2_MASK 0x0f
+#define IEC958_AES1_CON_BROADCAST2_ID	0x0e
+#define IEC958_AES1_CON_LASEROPT_MASK	0x07
+#define IEC958_AES1_CON_LASEROPT_ID	0x01
+#define IEC958_AES1_CON_MUSICAL_MASK	0x07
+#define IEC958_AES1_CON_MUSICAL_ID	0x05
+#define IEC958_AES1_CON_MAGNETIC_MASK	0x07
+#define IEC958_AES1_CON_MAGNETIC_ID	0x03
+#define IEC958_AES1_CON_IEC908_CD	(IEC958_AES1_CON_LASEROPT_ID|0x00)
+#define IEC958_AES1_CON_NON_IEC908_CD	(IEC958_AES1_CON_LASEROPT_ID|0x08)
+#define IEC958_AES1_CON_PCM_CODER	(IEC958_AES1_CON_DIGDIGCONV_ID|0x00)
+#define IEC958_AES1_CON_SAMPLER		(IEC958_AES1_CON_DIGDIGCONV_ID|0x20)
+#define IEC958_AES1_CON_MIXER		(IEC958_AES1_CON_DIGDIGCONV_ID|0x10)
+#define IEC958_AES1_CON_RATE_CONVERTER	(IEC958_AES1_CON_DIGDIGCONV_ID|0x18)
+#define IEC958_AES1_CON_SYNTHESIZER	(IEC958_AES1_CON_MUSICAL_ID|0x00)
+#define IEC958_AES1_CON_MICROPHONE	(IEC958_AES1_CON_MUSICAL_ID|0x08)
+#define IEC958_AES1_CON_DAT		(IEC958_AES1_CON_MAGNETIC_ID|0x00)
+#define IEC958_AES1_CON_VCR		(IEC958_AES1_CON_MAGNETIC_ID|0x08)
+#define IEC958_AES1_CON_ORIGINAL	(1<<7)	/* this bits depends on the category code */
+#define IEC958_AES2_PRO_SBITS		(7<<0)	/* mask - sample bits */
+#define IEC958_AES2_PRO_SBITS_20	(2<<0)	/* 20-bit - coordination */
+#define IEC958_AES2_PRO_SBITS_24	(4<<0)	/* 24-bit - main audio */
+#define IEC958_AES2_PRO_SBITS_UDEF	(6<<0)	/* user defined application */
+#define IEC958_AES2_PRO_WORDLEN		(7<<3)	/* mask - source word length */
+#define IEC958_AES2_PRO_WORDLEN_NOTID	(0<<3)	/* not indicated */
+#define IEC958_AES2_PRO_WORDLEN_22_18	(2<<3)	/* 22-bit or 18-bit */
+#define IEC958_AES2_PRO_WORDLEN_23_19	(4<<3)	/* 23-bit or 19-bit */
+#define IEC958_AES2_PRO_WORDLEN_24_20	(5<<3)	/* 24-bit or 20-bit */
+#define IEC958_AES2_PRO_WORDLEN_20_16	(6<<3)	/* 20-bit or 16-bit */
+#define IEC958_AES2_CON_SOURCE		(15<<0)	/* mask - source number */
+#define IEC958_AES2_CON_SOURCE_UNSPEC	(0<<0)	/* unspecified */
+#define IEC958_AES2_CON_CHANNEL		(15<<4)	/* mask - channel number */
+#define IEC958_AES2_CON_CHANNEL_UNSPEC	(0<<4)	/* unspecified */
+#define IEC958_AES3_CON_FS		(15<<0)	/* mask - sample frequency */
+#define IEC958_AES3_CON_FS_22050    (0x4)   /* 22.5kHz */
+#define IEC958_AES3_CON_FS_24000    (0x6)   /* 24kHz */
+#define IEC958_AES3_CON_FS_44100	(0<<0)	/* 44.1kHz */
+#define IEC958_AES3_CON_FS_48000	(2<<0)	/* 48kHz */
+#define IEC958_AES3_CON_FS_32000	(3<<0)	/* 32kHz */
+#define IEC958_AES3_CON_FS_88200	(0x8)	/* 88.2kHz */
+#define IEC958_AES3_CON_FS_176400	(0xc)	/* 176.4kHz */
+#define IEC958_AES3_CON_FS_192000	(0xe)	/* 192kHz */
+#define IEC958_AES3_CON_FS_96000	(0xa)	/* 96kHz */
+#define IEC958_AES3_CON_FS_768000	(0x9)	/* 768kHz */
+#define IEC958_AES3_CON_CLOCK		(3<<4)	/* mask - clock accuracy */
+#define IEC958_AES3_CON_CLOCK_1000PPM	(0<<4)	/* 1000 ppm */
+#define IEC958_AES3_CON_CLOCK_50PPM	(1<<4)	/* 50 ppm */
+#define IEC958_AES3_CON_CLOCK_VARIABLE	(2<<4)	/* variable pitch */
+
+#define IEC958_AES4_CON_BITS24      0x0b
+#define IEC958_AES4_CON_FS_44100    0xf0
+#define IEC958_AES4_CON_FS_88200	0x70
+#define IEC958_AES4_CON_FS_22050    0xb0
+#define IEC958_AES4_CON_FS_176400	0x30
+#define IEC958_AES4_CON_FS_48000	0xd0
+#define IEC958_AES4_CON_FS_96000	0x50
+#define IEC958_AES4_CON_FS_24000    0x90
+#define IEC958_AES4_CON_FS_192000   0x10
+#define IEC958_AES4_CON_FS_32000    0xc0
+
+typedef struct _rk_iec958 {
+    unsigned int  counter;
+    unsigned char status[24];
+    unsigned char preamble[3];  /* B/M/W or Z/X/Y */
+
+    int           channels;
+    int           samplerate;
+} rk_iec958;
+
+extern int iec958_init(rk_iec958 *iec, int samplerate, int channel, bool isPcm);
+extern int iec958_deInit(rk_iec958 *iec);
+extern int iec958_frame_encode(rk_iec958 *iec, char *in, int inLength, char *out, int *outLength);
+
+#endif  // _RK_AUDIO_IEC958_
\ No newline at end of file
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/config.h
new file mode 100755
index 0000000000..ef932db0b0
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/config.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+
+struct config_control
+{
+    const char *ctl_name; //name of control.
+    const char *str_val; //value of control, which type is stream.
+    const int int_val[2]; //left and right value of control, which type are int.
+};
+
+struct config_route
+{
+    const int sound_card;
+    const int devices;
+    const struct config_control *controls;
+    const unsigned controls_count;
+};
+
+struct config_route_table
+{
+    const struct config_route speaker_normal;
+    const struct config_route speaker_incall;
+    const struct config_route speaker_ringtone;
+    const struct config_route speaker_voip;
+
+    const struct config_route earpiece_normal;
+    const struct config_route earpiece_incall;
+    const struct config_route earpiece_ringtone;
+    const struct config_route earpiece_voip;
+
+    const struct config_route headphone_normal;
+    const struct config_route headphone_incall;
+    const struct config_route headphone_ringtone;
+    const struct config_route speaker_headphone_normal;
+    const struct config_route speaker_headphone_ringtone;
+    const struct config_route headphone_voip;
+
+    const struct config_route headset_normal;
+    const struct config_route headset_incall;
+    const struct config_route headset_ringtone;
+    const struct config_route headset_voip;
+
+    const struct config_route bluetooth_normal;
+    const struct config_route bluetooth_incall;
+    const struct config_route bluetooth_voip;
+
+    const struct config_route main_mic_capture;
+    const struct config_route hands_free_mic_capture;
+    const struct config_route bluetooth_sco_mic_capture;
+
+    const struct config_route playback_off;
+    const struct config_route capture_off;
+    const struct config_route incall_off;
+    const struct config_route voip_off;
+
+    const struct config_route hdmi_normal;
+
+    const struct config_route usb_normal;
+    const struct config_route usb_capture;
+
+    const struct config_route spdif_normal;
+
+    const struct config_route hdmiin_normal;
+    const struct config_route hdmiin_off;
+    const struct config_route hdmiin_captrue;
+    const struct config_route hdmiin_captrue_off;
+};
+
+#define on 1
+#define off 0
+
+#define DEVICES_0 0
+#define DEVICES_0_1 1
+#define DEVICES_0_2 2
+#define DEVICES_0_1_2 3
+
+#endif //_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/config_list.h b/hardware/rockchip/audio/hdmi_hal/codec_config/config_list.h
new file mode 100644
index 0000000000..ff26863c7d
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/config_list.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file config_list.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _CONFIG_LIST_H_
+#define _CONFIG_LIST_H_
+
+#include "config.h"
+#include "default_config.h"
+#include "rk616_config.h"
+#include "rt3261_config.h"
+#include "rt5616_config.h"
+#include "rt5640_config.h"
+#include "rt5678_config.h"
+#include "rt3224_config.h"
+#include "wm8960_config.h"
+#include "es8388_config.h"
+#include "es8396_config.h"
+#include "rt5651_config.h"
+#include "es8316_config.h"
+#include "cx2072_config.h"
+#include "hdmi_analog_config.h"
+
+struct alsa_sound_card_config
+{
+    const char *sound_card_name;
+    const struct config_route_table *route_table;
+};
+
+/*
+* List of sound card name and config table.
+* Audio will get config_route_table and set route 
+* according to the name of sound card 0 and sound_card_name.
+*/
+struct alsa_sound_card_config sound_card_config_list[] = {
+    {
+        .sound_card_name = "RKRK616",
+        .route_table = &rk616_config_table,
+    },
+    {
+        .sound_card_name = "RK29RT3224",
+        .route_table = &rt3224_config_table,
+    },
+    {
+        .sound_card_name = "rockchiprt5640c",
+        .route_table = &rt5640_config_table,
+    },
+    {
+        .sound_card_name = "realtekrt5678co",
+        .route_table = &rt5678_config_table,
+    },
+    {
+        .sound_card_name = "rockchipes8388",
+        .route_table = &es8388_config_table,
+    },
+    {
+        .sound_card_name = "rockchipes8388c",
+        .route_table = &es8388_config_table,
+    },
+    {
+        .sound_card_name = "rockchipes8396c",
+        .route_table = &es8396_config_table,
+    },
+    {
+        .sound_card_name = "RK29RT3261",
+        .route_table = &rt3261_config_table,
+    },
+    {
+        .sound_card_name = "RK29WM8960",
+        .route_table = &wm8960_config_table,
+    },
+    {
+        .sound_card_name = "RKRT3224",
+        .route_table = &rt3224_config_table,
+    },
+    {
+        .sound_card_name = "RKRT3261",
+        .route_table = &rt3261_config_table,
+    },
+    {
+        .sound_card_name = "RKWM8960",
+        .route_table = &wm8960_config_table,
+    },
+    {
+        .sound_card_name = "RKRT5616",
+        .route_table = &rt5616_config_table,
+    },
+    {
+        .sound_card_name = "realtekrt5651co",
+        .route_table = &rt5651_config_table,
+    },
+    {
+        .sound_card_name = "rockchipes8316c",
+        .route_table = &es8316_config_table,
+    },
+    {
+        .sound_card_name = "rockchipcx2072x",
+        .route_table = &cx2072_config_table,
+    },
+    {
+        .sound_card_name = "rkhdmianalogsnd",
+        .route_table = &hdmi_analog_config_table,
+    }
+};
+
+#endif //_CONFIG_LIST_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/cx2072_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/cx2072_config.h
new file mode 100644
index 0000000000..2460ea8025
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/cx2072_config.h
@@ -0,0 +1,332 @@
+#ifndef _CX2072_CONFIG_H_
+#define _CX2072_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control cx2072_speaker_normal_controls[] = {
+    {
+        .ctl_name = "PortG Mux",
+        .int_val = {0},
+    },
+};
+
+const struct config_control cx2072_speaker_incall_controls[] = {
+};
+
+const struct config_control cx2072_speaker_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_speaker_voip_controls[] = {
+};
+
+const struct config_control cx2072_earpiece_normal_controls[] = {
+};
+
+const struct config_control cx2072_earpiece_incall_controls[] = {
+};
+
+const struct config_control cx2072_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_earpiece_voip_controls[] = {
+};
+
+const struct config_control cx2072_headphone_normal_controls[] = {
+    {
+        .ctl_name = "PortG Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control cx2072_headphone_incall_controls[] = {
+};
+
+const struct config_control cx2072_headphone_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control cx2072_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_headphone_voip_controls[] = {
+};
+
+const struct config_control cx2072_headset_normal_controls[] = {
+    {
+        .ctl_name = "PortG Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control cx2072_headset_incall_controls[] = {
+};
+
+const struct config_control cx2072_headset_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_headset_voip_controls[] = {
+};
+
+const struct config_control cx2072_bluetooth_normal_controls[] = {
+};
+
+const struct config_control cx2072_bluetooth_incall_controls[] = {
+};
+
+const struct config_control cx2072_bluetooth_voip_controls[] = {
+};
+
+const struct config_control cx2072_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "ADC1 Mux",
+        .int_val = {2},
+    },
+    {
+        .ctl_name = "PortC Boost",
+        .int_val = {2, 2},
+    },
+};
+
+const struct config_control cx2072_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "ADC1 Mux",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "PortD Boost",
+        .int_val = {2, 2},
+    },
+};
+
+const struct config_control cx2072_bluetooth_sco_mic_capture_controls[] = {
+    {
+        .ctl_name = "PortG Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control cx2072_playback_off_controls[] = {
+};
+
+const struct config_control cx2072_capture_off_controls[] = {
+};
+
+const struct config_control cx2072_incall_off_controls[] = {
+};
+
+const struct config_control cx2072_voip_off_controls[] = {
+};
+
+const struct config_route_table cx2072_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_normal_controls,
+        .controls_count = sizeof(cx2072_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_incall_controls,
+        .controls_count = sizeof(cx2072_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_ringtone_controls,
+        .controls_count = sizeof(cx2072_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_voip_controls,
+        .controls_count = sizeof(cx2072_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_earpiece_normal_controls,
+        .controls_count = sizeof(cx2072_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_earpiece_incall_controls,
+        .controls_count = sizeof(cx2072_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_earpiece_ringtone_controls,
+        .controls_count = sizeof(cx2072_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_earpiece_voip_controls,
+        .controls_count = sizeof(cx2072_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headphone_normal_controls,
+        .controls_count = sizeof(cx2072_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headphone_incall_controls,
+        .controls_count = sizeof(cx2072_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headphone_ringtone_controls,
+        .controls_count = sizeof(cx2072_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_headphone_normal_controls,
+        .controls_count = sizeof(cx2072_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(cx2072_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headphone_voip_controls,
+        .controls_count = sizeof(cx2072_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headset_normal_controls,
+        .controls_count = sizeof(cx2072_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headset_incall_controls,
+        .controls_count = sizeof(cx2072_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headset_ringtone_controls,
+        .controls_count = sizeof(cx2072_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headset_voip_controls,
+        .controls_count = sizeof(cx2072_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_bluetooth_normal_controls,
+        .controls_count = sizeof(cx2072_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = cx2072_bluetooth_incall_controls,
+        .controls_count = sizeof(cx2072_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = cx2072_bluetooth_voip_controls,
+        .controls_count = sizeof(cx2072_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_main_mic_capture_controls,
+        .controls_count = sizeof(cx2072_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_hands_free_mic_capture_controls,
+        .controls_count = sizeof(cx2072_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = cx2072_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(cx2072_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = cx2072_playback_off_controls,
+        .controls_count = sizeof(cx2072_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = cx2072_capture_off_controls,
+        .controls_count = sizeof(cx2072_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = cx2072_incall_off_controls,
+        .controls_count = sizeof(cx2072_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = cx2072_voip_off_controls,
+        .controls_count = sizeof(cx2072_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_CX2072_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/default_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/default_config.h
new file mode 100755
index 0000000000..a55449261a
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/default_config.h
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file default_config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _DEFAULT_CONFIG_H_
+#define _DEFAULT_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control default_speaker_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK",
+    },
+};
+
+const struct config_control default_speaker_incall_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK",
+    },
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "SPK",
+    },
+};
+
+const struct config_control default_speaker_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RING_SPK",
+    },
+};
+
+const struct config_control default_speaker_voip_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK",
+    },
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "SPK",
+    },
+};
+
+const struct config_control default_earpiece_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RCV",
+    },
+};
+
+const struct config_control default_earpiece_incall_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK",
+    },
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "RCV",
+    },
+};
+
+const struct config_control default_earpiece_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RCV",
+    },
+};
+
+const struct config_control default_earpiece_voip_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RCV",
+    },
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "RCV",
+    },
+};
+
+const struct config_control default_headphone_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP_NO_MIC",
+    },
+};
+
+const struct config_control default_headphone_incall_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP_NO_MIC",
+    },
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "HP_NO_MIC",
+    },
+};
+
+const struct config_control default_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RING_HP_NO_MIC",
+    },
+};
+
+const struct config_control default_speaker_headphone_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK_HP",
+    },
+};
+
+const struct config_control default_speaker_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RING_SPK_HP",
+    },
+};
+
+const struct config_control default_headphone_voip_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP_NO_MIC",
+    },
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "HP_NO_MIC",
+    },
+};
+
+const struct config_control default_headset_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP",
+    },
+};
+
+const struct config_control default_headset_incall_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP",
+    },
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "HP",
+    },
+};
+
+const struct config_control default_headset_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RING_HP",
+    },
+};
+
+const struct config_control default_headset_voip_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP",
+    },
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "HP",
+    },
+};
+
+const struct config_control default_bluetooth_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "BT",
+    },
+};
+
+const struct config_control default_bluetooth_incall_controls[] = {
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "BT",
+    },
+};
+
+const struct config_control default_bluetooth_voip_controls[] = {
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "BT",
+    },
+};
+
+const struct config_control default_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture MIC Path",
+        .str_val = "Main Mic",
+    },
+};
+
+const struct config_control default_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture MIC Path",
+        .str_val = "Hands Free Mic",
+    },
+};
+
+const struct config_control default_bluetooth_sco_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture MIC Path",
+        .str_val = "BT Sco Mic",
+    },
+};
+
+const struct config_control default_playback_off_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "OFF",
+    },
+};
+
+const struct config_control default_capture_off_controls[] = {
+    {
+        .ctl_name = "Capture MIC Path",
+        .str_val = "MIC OFF",
+    },
+};
+
+const struct config_control default_incall_off_controls[] = {
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "OFF",
+    },
+};
+
+const struct config_control default_voip_off_controls[] = {
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "OFF",
+    },
+};
+
+const struct config_route_table default_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_normal_controls,
+        .controls_count = sizeof(default_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_incall_controls,
+        .controls_count = sizeof(default_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_ringtone_controls,
+        .controls_count = sizeof(default_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_voip_controls,
+        .controls_count = sizeof(default_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_earpiece_normal_controls,
+        .controls_count = sizeof(default_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_earpiece_incall_controls,
+        .controls_count = sizeof(default_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_earpiece_ringtone_controls,
+        .controls_count = sizeof(default_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_earpiece_voip_controls,
+        .controls_count = sizeof(default_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headphone_normal_controls,
+        .controls_count = sizeof(default_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headphone_incall_controls,
+        .controls_count = sizeof(default_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headphone_ringtone_controls,
+        .controls_count = sizeof(default_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_headphone_normal_controls,
+        .controls_count = sizeof(default_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(default_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headphone_voip_controls,
+        .controls_count = sizeof(default_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headset_normal_controls,
+        .controls_count = sizeof(default_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headset_incall_controls,
+        .controls_count = sizeof(default_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headset_ringtone_controls,
+        .controls_count = sizeof(default_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headset_voip_controls,
+        .controls_count = sizeof(default_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_bluetooth_normal_controls,
+        .controls_count = sizeof(default_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = default_bluetooth_incall_controls,
+        .controls_count = sizeof(default_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = default_bluetooth_voip_controls,
+        .controls_count = sizeof(default_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_main_mic_capture_controls,
+        .controls_count = sizeof(default_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_hands_free_mic_capture_controls,
+        .controls_count = sizeof(default_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = default_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(default_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = default_playback_off_controls,
+        .controls_count = sizeof(default_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = default_capture_off_controls,
+        .controls_count = sizeof(default_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = default_incall_off_controls,
+        .controls_count = sizeof(default_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = default_voip_off_controls,
+        .controls_count = sizeof(default_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_DEFAULT_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/es8316_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/es8316_config.h
new file mode 100644
index 0000000000..75a8e59f71
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/es8316_config.h
@@ -0,0 +1,363 @@
+#ifndef _ES8316_CONFIG_H_
+#define _ES8316_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control es8316_speaker_normal_controls[] = {
+    {
+        .ctl_name = "DAC Playback Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Left Headphone Mixer Left DAC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Headphone Mixer Right DAC Switch",
+	.int_val = {on},
+    },
+};
+
+const struct config_control es8316_speaker_incall_controls[] = {
+};
+
+const struct config_control es8316_speaker_ringtone_controls[] = {
+};
+
+const struct config_control es8316_speaker_voip_controls[] = {
+};
+
+const struct config_control es8316_earpiece_normal_controls[] = {
+};
+
+const struct config_control es8316_earpiece_incall_controls[] = {
+};
+
+const struct config_control es8316_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control es8316_earpiece_voip_controls[] = {
+};
+
+const struct config_control es8316_headphone_normal_controls[] = {
+    {
+        .ctl_name = "DAC Playback Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Left Headphone Mixer Left DAC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Headphone Mixer Right DAC Switch",
+	.int_val = {on},
+    },
+};
+
+const struct config_control es8316_headphone_incall_controls[] = {
+};
+
+const struct config_control es8316_headphone_ringtone_controls[] = {
+};
+
+const struct config_control es8316_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control es8316_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control es8316_headphone_voip_controls[] = {
+};
+
+const struct config_control es8316_headset_normal_controls[] = {
+    {
+        .ctl_name = "DAC Playback Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Left Headphone Mixer Left DAC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Headphone Mixer Right DAC Switch",
+    },
+};
+
+const struct config_control es8316_headset_incall_controls[] = {
+};
+
+const struct config_control es8316_headset_ringtone_controls[] = {
+};
+
+const struct config_control es8316_headset_voip_controls[] = {
+};
+
+const struct config_control es8316_bluetooth_normal_controls[] = {
+};
+
+const struct config_control es8316_bluetooth_incall_controls[] = {
+};
+
+const struct config_control es8316_bluetooth_voip_controls[] = {
+};
+
+const struct config_control es8316_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {192},
+    },
+    {
+        .ctl_name = "Differential Mux",
+        .int_val = {0},
+    },
+};
+
+const struct config_control es8316_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {192},
+    },
+    {
+        .ctl_name = "Differential Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control es8316_bluetooth_sco_mic_capture_controls[] = {
+};
+
+const struct config_control es8316_playback_off_controls[] = {
+    {
+        .ctl_name = "DAC Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Left Headphone Mixer Left DAC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Headphone Mixer Right DAC Switch",
+	.int_val = {off},
+    },
+};
+
+const struct config_control es8316_capture_off_controls[] = {
+};
+
+const struct config_control es8316_incall_off_controls[] = {
+};
+
+const struct config_control es8316_voip_off_controls[] = {
+};
+
+const struct config_route_table es8316_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_normal_controls,
+        .controls_count = sizeof(es8316_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_incall_controls,
+        .controls_count = sizeof(es8316_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_ringtone_controls,
+        .controls_count = sizeof(es8316_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_voip_controls,
+        .controls_count = sizeof(es8316_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_earpiece_normal_controls,
+        .controls_count = sizeof(es8316_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_earpiece_incall_controls,
+        .controls_count = sizeof(es8316_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_earpiece_ringtone_controls,
+        .controls_count = sizeof(es8316_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_earpiece_voip_controls,
+        .controls_count = sizeof(es8316_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headphone_normal_controls,
+        .controls_count = sizeof(es8316_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headphone_incall_controls,
+        .controls_count = sizeof(es8316_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headphone_ringtone_controls,
+        .controls_count = sizeof(es8316_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_headphone_normal_controls,
+        .controls_count = sizeof(es8316_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(es8316_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headphone_voip_controls,
+        .controls_count = sizeof(es8316_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headset_normal_controls,
+        .controls_count = sizeof(es8316_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headset_incall_controls,
+        .controls_count = sizeof(es8316_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headset_ringtone_controls,
+        .controls_count = sizeof(es8316_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headset_voip_controls,
+        .controls_count = sizeof(es8316_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_bluetooth_normal_controls,
+        .controls_count = sizeof(es8316_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8316_bluetooth_incall_controls,
+        .controls_count = sizeof(es8316_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8316_bluetooth_voip_controls,
+        .controls_count = sizeof(es8316_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_main_mic_capture_controls,
+        .controls_count = sizeof(es8316_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_hands_free_mic_capture_controls,
+        .controls_count = sizeof(es8316_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8316_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(es8316_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = es8316_playback_off_controls,
+        .controls_count = sizeof(es8316_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = es8316_capture_off_controls,
+        .controls_count = sizeof(es8316_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = es8316_incall_off_controls,
+        .controls_count = sizeof(es8316_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = es8316_voip_off_controls,
+        .controls_count = sizeof(es8316_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_ES8316_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/es8388_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/es8388_config.h
new file mode 100644
index 0000000000..af943f80d2
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/es8388_config.h
@@ -0,0 +1,428 @@
+#ifndef _es8388_CONFIG_H_
+#define _es8388_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control es8388_speaker_normal_controls[] = {
+    {
+        .ctl_name = "Left Mixer Left Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Mixer Right Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Output 2 Playback Volume",
+        .int_val = {27, 27},
+    },
+    {
+        .ctl_name = "aw87xxx_profile_switch_0",
+        .str_val = "Music",
+    },
+    {
+        .ctl_name = "aw87xxx_profile_switch_1",
+        .str_val = "Music",
+    },
+};
+
+const struct config_control es8388_speaker_incall_controls[] = {
+};
+
+const struct config_control es8388_speaker_ringtone_controls[] = {
+};
+
+const struct config_control es8388_speaker_voip_controls[] = {
+};
+
+const struct config_control es8388_earpiece_normal_controls[] = {
+};
+
+const struct config_control es8388_earpiece_incall_controls[] = {
+};
+
+const struct config_control es8388_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control es8388_earpiece_voip_controls[] = {
+};
+
+const struct config_control es8388_headphone_normal_controls[] = {
+    {
+        .ctl_name = "Left Mixer Left Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Mixer Right Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Output 1 Playback Volume",
+        .int_val = {27, 27},
+    },
+};
+
+const struct config_control es8388_headphone_incall_controls[] = {
+};
+
+const struct config_control es8388_headphone_ringtone_controls[] = {
+};
+
+const struct config_control es8388_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control es8388_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control es8388_headphone_voip_controls[] = {
+};
+
+const struct config_control es8388_headset_normal_controls[] = {
+    {
+        .ctl_name = "Left Mixer Left Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Mixer Right Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Output 1 Playback Volume",
+        .int_val = {27, 27},
+    },
+};
+
+const struct config_control es8388_headset_incall_controls[] = {
+};
+
+const struct config_control es8388_headset_ringtone_controls[] = {
+};
+
+const struct config_control es8388_headset_voip_controls[] = {
+};
+
+const struct config_control es8388_bluetooth_normal_controls[] = {
+};
+
+const struct config_control es8388_bluetooth_incall_controls[] = {
+};
+
+const struct config_control es8388_bluetooth_voip_controls[] = {
+};
+
+const struct config_control es8388_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture Digital Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Capture Mute",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Channel Capture Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "Right Channel Capture Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "Right PGA Mux",
+        .str_val = "DifferentialR",
+    },
+    {
+        .ctl_name = "Left PGA Mux",
+        .str_val = "DifferentialL",
+    },
+    {
+        .ctl_name = "Differential Mux",
+        .str_val = "Line 2",
+    },
+};
+
+const struct config_control es8388_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture Digital Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Capture Mute",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Channel Capture Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "Right Channel Capture Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "Right PGA Mux",
+        .str_val = "DifferentialR",
+    },
+    {
+        .ctl_name = "Left PGA Mux",
+        .str_val = "DifferentialL",
+    },
+    {
+        .ctl_name = "Differential Mux",
+        .str_val = "Line 1",
+    },
+};
+
+const struct config_control es8388_bluetooth_sco_mic_capture_controls[] = {
+};
+
+const struct config_control es8388_playback_off_controls[] = {
+    {
+        .ctl_name = "Left Mixer Left Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Mixer Right Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Output 2 Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Output 1 Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "aw87xxx_profile_switch_0",
+        .str_val = "Off",
+    },
+    {
+        .ctl_name = "aw87xxx_profile_switch_1",
+        .str_val = "Off",
+    },
+};
+
+const struct config_control es8388_capture_off_controls[] = {
+    {
+        .ctl_name = "Capture Mute",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8388_incall_off_controls[] = {
+};
+
+const struct config_control es8388_voip_off_controls[] = {
+};
+
+const struct config_route_table es8388_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_normal_controls,
+        .controls_count = sizeof(es8388_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_incall_controls,
+        .controls_count = sizeof(es8388_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_ringtone_controls,
+        .controls_count = sizeof(es8388_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_voip_controls,
+        .controls_count = sizeof(es8388_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_earpiece_normal_controls,
+        .controls_count = sizeof(es8388_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_earpiece_incall_controls,
+        .controls_count = sizeof(es8388_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_earpiece_ringtone_controls,
+        .controls_count = sizeof(es8388_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_earpiece_voip_controls,
+        .controls_count = sizeof(es8388_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headphone_normal_controls,
+        .controls_count = sizeof(es8388_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headphone_incall_controls,
+        .controls_count = sizeof(es8388_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headphone_ringtone_controls,
+        .controls_count = sizeof(es8388_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_headphone_normal_controls,
+        .controls_count = sizeof(es8388_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(es8388_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headphone_voip_controls,
+        .controls_count = sizeof(es8388_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headset_normal_controls,
+        .controls_count = sizeof(es8388_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headset_incall_controls,
+        .controls_count = sizeof(es8388_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headset_ringtone_controls,
+        .controls_count = sizeof(es8388_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headset_voip_controls,
+        .controls_count = sizeof(es8388_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_bluetooth_normal_controls,
+        .controls_count = sizeof(es8388_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8388_bluetooth_incall_controls,
+        .controls_count = sizeof(es8388_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8388_bluetooth_voip_controls,
+        .controls_count = sizeof(es8388_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_main_mic_capture_controls,
+        .controls_count = sizeof(es8388_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_hands_free_mic_capture_controls,
+        .controls_count = sizeof(es8388_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8388_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(es8388_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = es8388_playback_off_controls,
+        .controls_count = sizeof(es8388_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = es8388_capture_off_controls,
+        .controls_count = sizeof(es8388_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = es8388_incall_off_controls,
+        .controls_count = sizeof(es8388_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = es8388_voip_off_controls,
+        .controls_count = sizeof(es8388_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_es8388_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/es8396_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/es8396_config.h
new file mode 100644
index 0000000000..2260f7121a
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/es8396_config.h
@@ -0,0 +1,377 @@
+#ifndef _ES8396_CONFIG_H_
+#define _ES8396_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control es8396_speaker_normal_controls[] = {
+/*
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+// for BT client call
+const struct config_control es8396_speaker_incall_controls[] = {
+    /*down link*/
+    {
+        .ctl_name = "DACSRC Mux",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {on},
+    },
+    /*up link*/
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MASTERSDPO Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8396_headphone_normal_controls[] = {
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8396_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "VOICESDPO Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8396_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "VOICESDPO Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8396_playback_off_controls[] = {
+#if 0
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {off},
+    },
+#endif
+};
+
+const struct config_control es8396_capture_off_controls[] = {
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "VOICESDPO Mux",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control es8396_incall_off_controls[] = {
+    /*TODO*/
+    /*downlink*/
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DACSRC Mux",
+        .int_val = {0},
+    },
+    /*uplink*/
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MASTERSDPO Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {off},
+    },
+#if 1
+    {
+        .ctl_name = "RDMIX2 Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LDMIX2 Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RDMIX1 Mux",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "LDMIX1 Mux",
+        .int_val = {0},
+    },
+#endif
+};
+
+const struct config_route_table es8396_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_speaker_normal_controls,
+        .controls_count = sizeof(es8396_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_speaker_incall_controls,
+        .controls_count = sizeof(es8396_speaker_incall_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_headphone_normal_controls,
+        .controls_count = sizeof(es8396_headphone_normal_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_main_mic_capture_controls,
+        .controls_count = sizeof(es8396_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_hands_free_mic_capture_controls,
+        .controls_count = sizeof(es8396_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = es8396_playback_off_controls,
+        .controls_count = sizeof(es8396_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = es8396_capture_off_controls,
+        .controls_count = sizeof(es8396_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = es8396_incall_off_controls,
+        .controls_count = sizeof(es8396_incall_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+#endif //_ES8396_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/hdmi_analog_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/hdmi_analog_config.h
new file mode 100755
index 0000000000..73483e49c2
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/hdmi_analog_config.h
@@ -0,0 +1,324 @@
+#ifndef _HDMI_ANALOG_CONFIG_H_
+#define _HDMI_ANALOG_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control hdmi_analog_speaker_normal_controls[] = {
+	{
+		.ctl_name = "DAC Playback Volume",
+		.int_val = {192, 192},
+	},
+};
+
+const struct config_control hdmi_analog_speaker_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_speaker_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_speaker_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_earpiece_normal_controls[] = {
+};
+
+const struct config_control hdmi_analog_earpiece_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_earpiece_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_headphone_normal_controls[] = {
+	{
+		.ctl_name = "DAC Playback Volume",
+		.int_val = {192, 192},
+	},
+};
+
+const struct config_control hdmi_analog_hdmi_normal_controls[] = {
+	{
+		.ctl_name = "DAC Playback Volume",
+		.int_val = {0, 0},
+	},
+};
+
+const struct config_control hdmi_analog_headphone_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_headphone_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control hdmi_analog_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_headphone_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_headset_normal_controls[] = {
+};
+
+const struct config_control hdmi_analog_headset_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_headset_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_headset_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_bluetooth_normal_controls[] = {
+};
+
+const struct config_control hdmi_analog_bluetooth_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_bluetooth_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Differential Mux",
+        .int_val = {0},
+    },
+};
+
+const struct config_control hdmi_analog_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "Differential Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control hdmi_analog_bluetooth_sco_mic_capture_controls[] = {
+};
+
+const struct config_control hdmi_analog_playback_off_controls[] = {
+};
+
+const struct config_control hdmi_analog_capture_off_controls[] = {
+};
+
+const struct config_control hdmi_analog_incall_off_controls[] = {
+};
+
+const struct config_control hdmi_analog_voip_off_controls[] = {
+};
+
+const struct config_route_table hdmi_analog_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_normal_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_incall_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_voip_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_earpiece_normal_controls,
+        .controls_count = sizeof(hdmi_analog_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_earpiece_incall_controls,
+        .controls_count = sizeof(hdmi_analog_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_earpiece_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_earpiece_voip_controls,
+        .controls_count = sizeof(hdmi_analog_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headphone_normal_controls,
+        .controls_count = sizeof(hdmi_analog_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headphone_incall_controls,
+        .controls_count = sizeof(hdmi_analog_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headphone_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_headphone_normal_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headphone_voip_controls,
+        .controls_count = sizeof(hdmi_analog_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headset_normal_controls,
+        .controls_count = sizeof(hdmi_analog_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headset_incall_controls,
+        .controls_count = sizeof(hdmi_analog_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headset_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headset_voip_controls,
+        .controls_count = sizeof(hdmi_analog_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_bluetooth_normal_controls,
+        .controls_count = sizeof(hdmi_analog_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = hdmi_analog_bluetooth_incall_controls,
+        .controls_count = sizeof(hdmi_analog_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = hdmi_analog_bluetooth_voip_controls,
+        .controls_count = sizeof(hdmi_analog_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_main_mic_capture_controls,
+        .controls_count = sizeof(hdmi_analog_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_hands_free_mic_capture_controls,
+        .controls_count = sizeof(hdmi_analog_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = hdmi_analog_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(hdmi_analog_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = hdmi_analog_playback_off_controls,
+        .controls_count = sizeof(hdmi_analog_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = hdmi_analog_capture_off_controls,
+        .controls_count = sizeof(hdmi_analog_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = hdmi_analog_incall_off_controls,
+        .controls_count = sizeof(hdmi_analog_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = hdmi_analog_voip_off_controls,
+        .controls_count = sizeof(hdmi_analog_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_hdmi_normal_controls,
+        .controls_count = sizeof(hdmi_analog_hdmi_normal_controls) / sizeof(struct config_control),
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_HDMI_ANALOG_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/mixer_paths.xml b/hardware/rockchip/audio/hdmi_hal/codec_config/mixer_paths.xml
new file mode 100755
index 0000000000..ab75eda21e
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/mixer_paths.xml
@@ -0,0 +1,110 @@
+<mixer>
+  <!-- These are the initial mixer settings -->
+
+  <ctl name="Capture MIC Path" value="MIC OFF" />
+  <ctl name="Playback Path" value="OFF" />
+  <ctl name="Voice Call Path" value="OFF" />
+  <ctl name="Voip Path" value="OFF" />
+
+  <!-- These are commonly used control sequences -->
+  
+  <!-- These are useful named paths -->
+ 
+  <path name="speaker">
+    <ctl name="Playback Path" value="SPK" />
+  </path>
+
+  <path name="main-mic">
+    <ctl name="Capture MIC Path" value="Main Mic" />
+  </path>
+
+  <path name="headphones">
+    <ctl name="Playback Path" value="HP_NO_MIC" />
+  </path>
+
+  <!-- Playback paths -->
+  
+  <path name="media-speaker">
+    <path name="speaker" />
+  </path>
+  <path name="media-headphones">
+    <path name="headphones" />
+  </path>
+
+  <path name="voice-rec-speaker">
+    <path name="speaker" />
+    <ctl name="Voice Call Path" value="SPK" />
+  </path>
+
+  <path name="voice-rec-headphones">
+    <path name="headphones" />
+    <ctl name="Voice Call Path" value="HP_NO_MIC" />
+  </path>
+
+  <path name="communication-speaker">
+    <path name="speaker" />
+    <ctl name="Voip Path" value="SPK" />
+  </path>
+
+  <path name="communication-headphones">
+    <path name="headphones" />
+    <ctl name="Voip Path" value="HP_NO_MIC" />
+  </path>
+
+  <path name="speaker-and-headphones">
+  </path>
+
+  <path name="bt-sco-headset">
+    <ctl name="Playback Path" value="BT" />
+  </path>
+  
+  <!-- Capture paths -->
+  
+  <path name="media-main-mic">
+    <path name="main-mic" />
+  </path>
+  <path name="voice-rec-main-mic">
+    <path name="main-mic" />
+  </path>
+
+  <path name="communication-main-mic">
+    <path name="main-mic" />
+  </path>
+
+  <path name="media-second-mic">
+    <path name="main-mic" />
+  </path>
+
+  <path name="media-headset-mic">
+    <path name="main-mic" />
+  </path>
+
+  <path name="bt-sco-mic">
+    <ctl name="Capture MIC Path" value="BT Sco Mic" />
+  </path>
+
+  <path name="voice-rec-headset-mic">
+    <path name="main-mic" />
+  </path>
+
+  <path name="communication-headset-mic">
+    <path name="main-mic" />
+  </path>
+
+  <!-- Off paths -->
+
+  <path name="playback-off">
+      <ctl name="Playback Path" value="OFF" />
+  </path>
+
+  <path name="capture-off">
+      <ctl name="Capture MIC Path" value="MIC OFF" />
+  </path>
+
+  <path name="incall-off">
+       <ctl name="Voice Call Path" value="OFF" />
+  </path>
+  <path name="voip-off">
+       <ctl name="Voip Path" value="OFF" />
+  </path>
+</mixer>
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/rk616_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/rk616_config.h
new file mode 100755
index 0000000000..a6336749c1
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/rk616_config.h
@@ -0,0 +1,1607 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rk616_config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RK616_CONFIG_H_
+#define _RK616_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rk616_speaker_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {22, 22},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_speaker_incall_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //mic1-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTL",
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "BST_L Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Main Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {29},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P ---> SPK
+    {
+        .ctl_name = "HPMix Mux",
+        .str_val = "DIFFIN",
+    },
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIFFIN Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXR Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_speaker_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_speaker_voip_controls[] = {
+
+};
+
+const struct config_control rk616_earpiece_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {22, 22},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_earpiece_incall_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //mic1-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTL",
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "BST_L Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Main Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {29},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P ---> SPK
+    {
+        .ctl_name = "HPMix Mux",
+        .str_val = "DIFFIN",
+    },
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIFFIN Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXR Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_earpiece_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_earpiece_voip_controls[] = {
+
+};
+
+const struct config_control rk616_headphone_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headphone_incall_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //mic1-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTL",
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "BST_L Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Main Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {29},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P ---> HP
+    {
+        .ctl_name = "HPMix Mux",
+        .str_val = "DIFFIN",
+    },
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIFFIN Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXR Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_speaker_headphone_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rk616_speaker_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    }, 
+};
+
+const struct config_control rk616_headphone_voip_controls[] = {
+
+};
+
+const struct config_control rk616_headset_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headset_incall_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //mic2-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTR",
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Micbias2 Voltage",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "BST_R Mode",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Headset Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Headset Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {29},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P ---> HP
+    {
+        .ctl_name = "HPMix Mux",
+        .str_val = "DIFFIN",
+    },
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIFFIN Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXR Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headset_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headset_voip_controls[] = {
+
+};
+
+const struct config_control rk616_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rk616_bluetooth_incall_controls[] = {
+    //DACL --> line1/2
+    {
+        .ctl_name = "LINEMIX DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P-->ADCL
+    {
+        .ctl_name = "MIXINL IN1P Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IN1P to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    }, 
+};
+
+const struct config_control rk616_bluetooth_voip_controls[] = {
+
+};
+
+const struct config_control rk616_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Headset Mic Capture Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTL",
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Main Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "BST_L Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    }, 
+};
+
+const struct config_control rk616_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {0},
+    },
+
+    {
+        .ctl_name = "Headset Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTR",
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headset Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "BST_R Mode",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Micbias2 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {25},
+    },
+    {
+        .ctl_name = "Headset Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    }, 
+};
+
+const struct config_control rk616_bluetooth_sco_mic_capture_controls[] = {
+
+};
+
+const struct config_control rk616_playback_off_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+};
+
+const struct config_control rk616_capture_off_controls[] = {
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Headset Mic Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Headset Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {off},
+    }, 
+};
+
+const struct config_control rk616_incall_off_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //close mic1-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {off},
+    },
+    //clsoe IN1N/P ---> SPK
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+};
+
+const struct config_control rk616_voip_off_controls[] = {
+
+};
+
+const struct config_route_table rk616_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_normal_controls,
+        .controls_count = sizeof(rk616_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_incall_controls,
+        .controls_count = sizeof(rk616_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_ringtone_controls,
+        .controls_count = sizeof(rk616_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_voip_controls,
+        .controls_count = sizeof(rk616_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_earpiece_normal_controls,
+        .controls_count = sizeof(rk616_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_earpiece_incall_controls,
+        .controls_count = sizeof(rk616_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_earpiece_ringtone_controls,
+        .controls_count = sizeof(rk616_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_earpiece_voip_controls,
+        .controls_count = sizeof(rk616_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headphone_normal_controls,
+        .controls_count = sizeof(rk616_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headphone_incall_controls,
+        .controls_count = sizeof(rk616_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headphone_ringtone_controls,
+        .controls_count = sizeof(rk616_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rk616_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rk616_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headphone_voip_controls,
+        .controls_count = sizeof(rk616_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headset_normal_controls,
+        .controls_count = sizeof(rk616_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headset_incall_controls,
+        .controls_count = sizeof(rk616_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headset_ringtone_controls,
+        .controls_count = sizeof(rk616_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headset_voip_controls,
+        .controls_count = sizeof(rk616_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_bluetooth_normal_controls,
+        .controls_count = sizeof(rk616_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_bluetooth_incall_controls,
+        .controls_count = sizeof(rk616_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_bluetooth_voip_controls,
+        .controls_count = sizeof(rk616_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_main_mic_capture_controls,
+        .controls_count = sizeof(rk616_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rk616_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rk616_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rk616_playback_off_controls,
+        .controls_count = sizeof(rk616_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rk616_capture_off_controls,
+        .controls_count = sizeof(rk616_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rk616_incall_off_controls,
+        .controls_count = sizeof(rk616_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rk616_voip_off_controls,
+        .controls_count = sizeof(rk616_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+#endif //_RK616_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/rk_audio.mk b/hardware/rockchip/audio/hdmi_hal/codec_config/rk_audio.mk
new file mode 100755
index 0000000000..15aa73c5b5
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/rk_audio.mk
@@ -0,0 +1,3 @@
+PRODUCT_COPY_FILES += \
+    hardware/rockchip/audio/tinyalsa_hal/codec_config/mixer_paths.xml:system/etc/mixer_paths.xml 
+	
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/rt3224_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/rt3224_config.h
new file mode 100755
index 0000000000..c395c5b110
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/rt3224_config.h
@@ -0,0 +1,3969 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rt3224_config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RT3224_CONFIG_H_
+#define _RT3224_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt3224_speaker_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",               
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_speaker_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset incall
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_speaker_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_speaker_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",               
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control rt3224_earpiece_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset incall
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_earpiece_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_earpiece_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",               
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_headphone_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headphone_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headphone_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_speaker_headphone_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_speaker_headphone_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headphone_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headset_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headset_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN3 Mode Control",
+        .str_val = "Single ended",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN3 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headset_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headset_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt3224_bluetooth_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //INF1_DAC -> DAC MIXL
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {on},
+    },
+
+    {
+        .ctl_name = "Mono ADC Capture Volume",        
+        .int_val = {127, 127},
+    },
+    {
+        .ctl_name = "Mono DAC Playback Volume",       
+        .int_val = {175, 175},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=39
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {39, 39},
+    },
+
+    //IN2 -> ADC_L -> Stereo_ADC_Mixer_L -> IF1_ADC_L  
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {45, 45},
+    },   
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset incall
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3224_bluetooth_voip_controls[] = {
+    //close speaker
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",             
+        .int_val = {off},
+    },
+
+    // IF2 DAC L ->DAC L2 Volume ->DIG MIXL ->Stereo ADC L2 Mux ->Stereo ADC MIXL ->IF1_ADC_L 
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L2 Mux",  
+        .str_val = "DMIC1",
+    },
+    {
+        .ctl_name = "Stereo ADC L2 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC R2 Mux",  
+        .str_val = "DMIC1",
+    },
+    {
+        .ctl_name = "Stereo ADC R2 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {on},
+    },
+    // MX-2C[15]   MX-2C[11] 
+    {
+        .ctl_name = "DIG MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    // MX-29[15]   MX-29[7]  
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",  
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",  
+        .int_val = {off},
+    },
+    // DIG MIXL ->Stereo ADC L1 Mux ->Stereo ADC MIXL 
+    {
+        .ctl_name = "Stereo ADC L1 Mux",  
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC R1 Mux",  
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC R1 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },    
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L1 Switch",  
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Enable",
+    },      
+
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "ADC Capture Volume", 
+        .int_val = {47, 47},
+    },
+};
+
+const struct config_control rt3224_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {off},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "right copy to left",
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {5},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {60, 60},
+    },
+};
+
+const struct config_control rt3224_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "right copy to left",
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN3 Mode Control",
+        .str_val = "Single ended",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN3 Boost",
+        .int_val = {5},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {60, 60},
+    },
+};
+
+const struct config_control rt3224_bluetooth_sco_mic_capture_controls[] = {
+    // IF1_DAC_L -> DACL1 -> Mono_DAC_Mixer_L -> Mono ADC L1 Mux  ->Mono ADC MIXL->IF2 ADC L Mux->  IF2_ADC_L  
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC L1 Mux",  
+        .str_val = "Mono DAC MIXL",
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC L Mux",
+        .str_val = "Mono ADC MIXL",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "Normal",
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",  
+        .str_val = "Mono DAC MIXR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    //  MX-2B[12]       MX-2B[10]      MX-2B[4]       MX-2B[2]  
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt3224_playback_off_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+/*
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //speaker incall
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+*/
+};
+
+const struct config_control rt3224_capture_off_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3224_incall_off_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3224_voip_off_controls[] = {
+
+};
+
+const struct config_route_table rt3224_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_normal_controls,
+        .controls_count = sizeof(rt3224_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_incall_controls,
+        .controls_count = sizeof(rt3224_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_ringtone_controls,
+        .controls_count = sizeof(rt3224_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_voip_controls,
+        .controls_count = sizeof(rt3224_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_earpiece_normal_controls,
+        .controls_count = sizeof(rt3224_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_earpiece_incall_controls,
+        .controls_count = sizeof(rt3224_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt3224_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_earpiece_voip_controls,
+        .controls_count = sizeof(rt3224_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headphone_normal_controls,
+        .controls_count = sizeof(rt3224_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headphone_incall_controls,
+        .controls_count = sizeof(rt3224_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headphone_ringtone_controls,
+        .controls_count = sizeof(rt3224_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt3224_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt3224_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headphone_voip_controls,
+        .controls_count = sizeof(rt3224_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headset_normal_controls,
+        .controls_count = sizeof(rt3224_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headset_incall_controls,
+        .controls_count = sizeof(rt3224_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headset_ringtone_controls,
+        .controls_count = sizeof(rt3224_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headset_voip_controls,
+        .controls_count = sizeof(rt3224_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_bluetooth_normal_controls,
+        .controls_count = sizeof(rt3224_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3224_bluetooth_incall_controls,
+        .controls_count = sizeof(rt3224_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3224_bluetooth_voip_controls,
+        .controls_count = sizeof(rt3224_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_main_mic_capture_controls,
+        .controls_count = sizeof(rt3224_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt3224_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3224_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt3224_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt3224_playback_off_controls,
+        .controls_count = sizeof(rt3224_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt3224_capture_off_controls,
+        .controls_count = sizeof(rt3224_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt3224_incall_off_controls,
+        .controls_count = sizeof(rt3224_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt3224_voip_off_controls,
+        .controls_count = sizeof(rt3224_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_RT3224_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/rt3261_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/rt3261_config.h
new file mode 100755
index 0000000000..2b4a2e75c6
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/rt3261_config.h
@@ -0,0 +1,3758 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rt3261_config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RT3261_CONFIG_H_
+#define _RT3261_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt3261_speaker_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",                
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_speaker_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",                
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {on},
+    },
+    //SEND DOWNSTREAM INTO DSP
+    {
+        .ctl_name = "RxDP1 Mux",
+        .str_val = "DAC1",
+    },
+    {
+        .ctl_name = "RxDP Mux",
+        .str_val = "RxDP1",
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //SEND UPSTREAM INTO DSP
+    {
+        .ctl_name = "RECMIXR BST1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RxDC Mux",
+        .str_val = "Mono_ADC",
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "TxDP",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {71, 71},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //headphone && headset incall
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_speaker_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_speaker_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control rt3261_earpiece_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {on},
+    },
+    //SEND DOWNSTREAM INTO DSP
+    {
+        .ctl_name = "RxDP1 Mux",
+        .str_val = "DAC1",
+    },
+    {
+        .ctl_name = "RxDP Mux",
+        .str_val = "RxDP1",
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //SEND UPSTREAM INTO DSP
+    {
+        .ctl_name = "RECMIXR BST1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RxDC Mux",
+        .str_val = "Mono_ADC",
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "TxDP",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {71, 71},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //headphone && headset incall
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_earpiece_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_earpiece_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //speaker incall
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_headphone_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headphone_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headphone_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_speaker_headphone_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_speaker_headphone_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headphone_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headset_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headset_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},  
+    },
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    {
+        .ctl_name = "RECMIXR BST3 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN3 Mode Control",
+        .str_val = "Single ended",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN3 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXR BST1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headset_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headset_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt3261_bluetooth_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },
+    //INF1_DAC -> DAC MIXL
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Volume",        
+        .int_val = {127, 127},
+    },
+    {
+        .ctl_name = "Mono DAC Playback Volume",       
+        .int_val = {175, 175},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=39
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {39, 39},
+    },
+    //IN2 -> ADC_L -> Stereo_ADC_Mixer_L -> IF1_ADC_L  
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {45, 45},
+    },   
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //headphone && headset incall
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_bluetooth_voip_controls[] = {
+    // IF2 DAC L ->DAC L2 Volume ->DIG MIXL ->Stereo ADC L2 Mux ->Stereo ADC MIXL ->IF1_ADC_L 
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L2 Mux",  
+        .str_val = "DMIC1",
+    },
+    {
+        .ctl_name = "Stereo ADC L2 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC R2 Mux",  
+        .str_val = "DMIC1",
+    },
+    {
+        .ctl_name = "Stereo ADC R2 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {on},
+    },
+    //  MX-2C[15]   MX-2C[11] 
+    //  
+    {
+        .ctl_name = "DIG MIXL DAC L1 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    //  MX-29[15]   MX-29[7]  
+    // 
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",  
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",  
+        .int_val = {off},
+    },
+    //  DIG MIXL ->Stereo ADC L1 Mux ->Stereo ADC MIXL 
+    {
+        .ctl_name = "Stereo ADC L1 Mux",  
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC R1 Mux",  
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC R1 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    // 
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L1 Switch",  
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "SPOL MIX SPKVOL L Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},    
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    //enable ASRCreg61[7]()reg62[15]()reg61[7]reg62[15]
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Enable",
+    },      
+
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {127, 127},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",  
+        .int_val = {47, 47},   
+    },
+};
+
+const struct config_control rt3261_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RxDC Mux",
+        .str_val = "Mono_ADC",
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "TxDP",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "right copy to left",
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {71, 71},
+    },
+};
+
+const struct config_control rt3261_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RxDC Mux",
+        .str_val = "Mono_ADC",
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "TxDP",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "right copy to left",
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN3 Mode Control",
+        .str_val = "Single ended",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN3 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {71, 71},
+    },
+};
+
+const struct config_control rt3261_bluetooth_sco_mic_capture_controls[] = {
+    // IF1_DAC_L -> DACL1 -> Mono_DAC_Mixer_L -> Mono ADC L1 Mux  ->Mono ADC MIXL->IF2 ADC L Mux->  IF2_ADC_L  
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC L1 Mux",  
+        .str_val = "Mono DAC MIXL",
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC L Mux",
+        .str_val = "Mono ADC MIXL",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "Normal",
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",  
+        .str_val = "Mono DAC MIXR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    //  MX-2B[12]       MX-2B[10]      MX-2B[4]       MX-2B[2]    
+    //  (IF2 DAC)
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC R2 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC L2 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {127, 127},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume", 
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt3261_playback_off_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_capture_off_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_incall_off_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_voip_off_controls[] = {
+
+};
+
+const struct config_route_table rt3261_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_normal_controls,
+        .controls_count = sizeof(rt3261_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_incall_controls,
+        .controls_count = sizeof(rt3261_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_ringtone_controls,
+        .controls_count = sizeof(rt3261_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_voip_controls,
+        .controls_count = sizeof(rt3261_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_earpiece_normal_controls,
+        .controls_count = sizeof(rt3261_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_earpiece_incall_controls,
+        .controls_count = sizeof(rt3261_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt3261_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_earpiece_voip_controls,
+        .controls_count = sizeof(rt3261_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headphone_normal_controls,
+        .controls_count = sizeof(rt3261_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headphone_incall_controls,
+        .controls_count = sizeof(rt3261_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headphone_ringtone_controls,
+        .controls_count = sizeof(rt3261_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt3261_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt3261_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headphone_voip_controls,
+        .controls_count = sizeof(rt3261_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headset_normal_controls,
+        .controls_count = sizeof(rt3261_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headset_incall_controls,
+        .controls_count = sizeof(rt3261_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headset_ringtone_controls,
+        .controls_count = sizeof(rt3261_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headset_voip_controls,
+        .controls_count = sizeof(rt3261_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_bluetooth_normal_controls,
+        .controls_count = sizeof(rt3261_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3261_bluetooth_incall_controls,
+        .controls_count = sizeof(rt3261_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3261_bluetooth_voip_controls,
+        .controls_count = sizeof(rt3261_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_main_mic_capture_controls,
+        .controls_count = sizeof(rt3261_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt3261_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3261_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt3261_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt3261_playback_off_controls,
+        .controls_count = sizeof(rt3261_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt3261_capture_off_controls,
+        .controls_count = sizeof(rt3261_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt3261_incall_off_controls,
+        .controls_count = sizeof(rt3261_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt3261_voip_off_controls,
+        .controls_count = sizeof(rt3261_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_RT3261_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/rt5616_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/rt5616_config.h
new file mode 100755
index 0000000000..aadfc1ba00
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/rt5616_config.h
@@ -0,0 +1,890 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rt5616_config.h
+ * @brief 
+ * @author  RKAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RT5616_CONFIG_H_
+#define _RT5616_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt5616_speaker_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {on},
+    },/*
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {on},
+    },
+      {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {31, 31},
+    }, 
+    */
+};
+
+const struct config_control rt5616_speaker_incall_controls[] = {
+
+};
+
+const struct config_control rt5616_speaker_ringtone_controls[] = {    
+ 
+};
+
+const struct config_control rt5616_speaker_voip_controls[] = {
+ 
+};
+
+const struct config_control rt5616_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control rt5616_earpiece_incall_controls[] = {
+
+};
+
+const struct config_control rt5616_earpiece_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5616_earpiece_voip_controls[] = {
+
+};
+
+const struct config_control rt5616_headphone_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    /*{
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    }, */
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {on},
+    },/*
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    }, */
+};
+
+const struct config_control rt5616_headphone_incall_controls[] = {
+ 
+};
+
+const struct config_control rt5616_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5616_speaker_headphone_normal_controls[] = {
+ 
+};
+
+const struct config_control rt5616_speaker_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5616_headphone_voip_controls[] = {
+
+};
+
+const struct config_control rt5616_headset_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    /*{
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    }, */
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {on},
+    },/*
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    }, */
+};
+
+const struct config_control rt5616_headset_incall_controls[] = {
+
+};
+
+const struct config_control rt5616_headset_ringtone_controls[] = {
+ 
+};
+
+const struct config_control rt5616_headset_voip_controls[] = {
+ 
+};
+
+const struct config_control rt5616_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt5616_bluetooth_incall_controls[] = {
+ 
+};
+
+const struct config_control rt5616_bluetooth_voip_controls[] = {
+ 
+};
+
+const struct config_control rt5616_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL INL1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+   {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "IN2 Mode Control",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {32,32},
+    },
+    {
+        .ctl_name = "ADC Boost Gain",
+        .int_val = {3,3},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5616_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL INL1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+   {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "IN1 Mode Control",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {40,40},
+    },
+    {
+        .ctl_name = "ADC Boost Gain",
+        .int_val = {1,1},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {on},
+    },
+ 
+};
+
+const struct config_control rt5616_bluetooth_sco_mic_capture_controls[] = {
+ 
+};
+
+const struct config_control rt5616_playback_off_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+/*
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "HP Playback Switch",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL INL1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {0},
+    },   
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC L1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC R1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {0, 0},
+    }, 
+*/ 
+};
+
+const struct config_control rt5616_capture_off_controls[] = {
+    {
+        .ctl_name = "RECMIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL INL1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {0,0},
+    },
+   {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "IN1 Mode Control",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN2 Mode Control",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {0,0},
+    },
+    {
+        .ctl_name = "ADC Boost Gain",
+        .int_val = {0,0},
+    },
+    {
+        .ctl_name = "IN Capture Volume",
+        .int_val = {0,0},
+    },
+    {
+        .ctl_name = "RECMIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL INL1 Switch",
+        .int_val = {0},
+    },
+};
+
+const struct config_control rt5616_incall_off_controls[] = {
+ 
+};
+
+const struct config_control rt5616_voip_off_controls[] = {
+
+};
+
+const struct config_route_table rt5616_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_normal_controls,
+        .controls_count = sizeof(rt5616_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_incall_controls,
+        .controls_count = sizeof(rt5616_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_ringtone_controls,
+        .controls_count = sizeof(rt5616_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_voip_controls,
+        .controls_count = sizeof(rt5616_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_earpiece_normal_controls,
+        .controls_count = sizeof(rt5616_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_earpiece_incall_controls,
+        .controls_count = sizeof(rt5616_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt5616_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_earpiece_voip_controls,
+        .controls_count = sizeof(rt5616_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headphone_normal_controls,
+        .controls_count = sizeof(rt5616_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headphone_incall_controls,
+        .controls_count = sizeof(rt5616_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5616_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt5616_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5616_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headphone_voip_controls,
+        .controls_count = sizeof(rt5616_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headset_normal_controls,
+        .controls_count = sizeof(rt5616_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headset_incall_controls,
+        .controls_count = sizeof(rt5616_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headset_ringtone_controls,
+        .controls_count = sizeof(rt5616_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headset_voip_controls,
+        .controls_count = sizeof(rt5616_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_bluetooth_normal_controls,
+        .controls_count = sizeof(rt5616_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5616_bluetooth_incall_controls,
+        .controls_count = sizeof(rt5616_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5616_bluetooth_voip_controls,
+        .controls_count = sizeof(rt5616_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_main_mic_capture_controls,
+        .controls_count = sizeof(rt5616_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt5616_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5616_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt5616_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt5616_playback_off_controls,
+        .controls_count = sizeof(rt5616_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt5616_capture_off_controls,
+        .controls_count = sizeof(rt5616_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt5616_incall_off_controls,
+        .controls_count = sizeof(rt5616_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt5616_voip_off_controls,
+        .controls_count = sizeof(rt5616_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_RT5616_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/rt5640_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/rt5640_config.h
new file mode 100644
index 0000000000..2b650d9285
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/rt5640_config.h
@@ -0,0 +1,1468 @@
+#ifndef _RT5640_CONFIG_H_
+#define _RT5640_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt5640_speaker_normal_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPOL MIX SPKVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPOR MIX SPKVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {30, 33},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {on,on},
+    },
+};
+
+const struct config_control rt5640_speaker_incall_controls[] = {
+
+};
+
+const struct config_control rt5640_speaker_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5640_speaker_voip_controls[] = {
+
+};
+
+const struct config_control rt5640_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control rt5640_earpiece_incall_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_earpiece_ringtone_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_earpiece_voip_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_headphone_normal_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+};
+
+const struct config_control rt5640_headphone_incall_controls[] = {
+
+};
+
+const struct config_control rt5640_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5640_speaker_headphone_normal_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPOL MIX SPKVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPOR MIX SPKVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {30, 33},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+};
+
+const struct config_control rt5640_speaker_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5640_headphone_voip_controls[] = {
+
+};
+
+
+const struct config_control rt5640_headpset_normal_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+};
+
+const struct config_control rt5640_headset_incall_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_headset_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5640_headset_voip_controls[] = {
+
+};
+
+
+const struct config_control rt5640_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt5640_bluetooth_incall_controls[] = {
+
+};
+
+const struct config_control rt5640_bluetooth_voip_controls[] = {
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+       .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC L1 Mux",
+        .str_val = "Mono DAC MIXL",
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "Mono DAC MIXR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "BT Up Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "BT Down Switch",
+        .int_val = {on},
+    },
+};
+
+
+const struct config_control rt5640_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Int Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_bluetooth_sco_mic_capture_controls[] = {
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC L1 Mux",
+        .str_val = "Mono DAC MIXL",
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "Mono DAC MIXR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "BT Up Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "BT Down Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_playback_off_controls[] = {
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt5640_capture_off_controls[] = {
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Int Mic Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt5640_incall_off_controls[] = {
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Int Mic Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt5640_voip_off_controls[] = {
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Int Mic Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "BT Up Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "BT Down Switch",
+        .int_val = {off},
+    },
+};
+
+
+const struct config_route_table rt5640_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_normal_controls,
+        .controls_count = sizeof(rt5640_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_incall_controls,
+        .controls_count = sizeof(rt5640_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_ringtone_controls,
+        .controls_count = sizeof(rt5640_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_voip_controls,
+        .controls_count = sizeof(rt5640_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_earpiece_normal_controls,
+        .controls_count = sizeof(rt5640_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_earpiece_incall_controls,
+        .controls_count = sizeof(rt5640_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt5640_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_earpiece_voip_controls,
+        .controls_count = sizeof(rt5640_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headphone_normal_controls,
+        .controls_count = sizeof(rt5640_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headphone_incall_controls,
+        .controls_count = sizeof(rt5640_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5640_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt5640_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5640_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headphone_voip_controls,
+        .controls_count = sizeof(rt5640_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headpset_normal_controls,
+        .controls_count = sizeof(rt5640_headpset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headset_incall_controls,
+        .controls_count = sizeof(rt5640_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headset_ringtone_controls,
+        .controls_count = sizeof(rt5640_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headset_voip_controls,
+        .controls_count = sizeof(rt5640_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_bluetooth_normal_controls,
+        .controls_count = sizeof(rt5640_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_bluetooth_incall_controls,
+        .controls_count = sizeof(rt5640_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_bluetooth_voip_controls,
+        .controls_count = sizeof(rt5640_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_main_mic_capture_controls,
+        .controls_count = sizeof(rt5640_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt5640_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt5640_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt5640_playback_off_controls,
+        .controls_count = sizeof(rt5640_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt5640_capture_off_controls,
+        .controls_count = sizeof(rt5640_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt5640_incall_off_controls,
+        .controls_count = sizeof(rt5640_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt5640_voip_off_controls,
+        .controls_count = sizeof(rt5640_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+#endif //_RT5640_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/rt5651_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/rt5651_config.h
new file mode 100644
index 0000000000..fa16c4251d
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/rt5651_config.h
@@ -0,0 +1,1234 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rt5651_config.h
+ * @brief
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RT5651_CONFIG_H_
+#define _RT5651_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt5651_speaker_normal_controls[] = {
+    /*
+    	{
+            .ctl_name = "DAC MIXL INF1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "DAC MIXR INF1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "OUT MIXL DAC L1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "OUT MIXR DAC R1 Switch",
+            .int_val = {on},
+        },
+        	{
+            .ctl_name = "OUTVOL L Switch",
+            .int_val = {on},
+        },
+        	{
+            .ctl_name = "OUTVOL R Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "LOUT MIX OUTVOL L Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "LOUT MIX OUTVOL R Switch",
+            .int_val = {on},
+        },
+        {
+            .ctl_name = "LOUT L Playback Switch",
+            .int_val = {on},
+        },
+          {
+            .ctl_name = "LOUT R Playback Switch",
+            .int_val = {on},
+        },
+    */
+     {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+
+};
+
+const struct config_control rt5651_speaker_incall_controls[] = {
+
+
+};
+
+const struct config_control rt5651_speaker_ringtone_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUTVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUTVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT R Playback Switch",
+        .int_val = {on},
+    },
+
+};
+
+const struct config_control rt5651_speaker_voip_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUTVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUTVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT R Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5651_earpiece_normal_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+
+};
+
+const struct config_control rt5651_earpiece_incall_controls[] = {
+
+};
+
+const struct config_control rt5651_earpiece_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5651_earpiece_voip_controls[] = {
+
+};
+
+const struct config_control rt5651_headphone_normal_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_headphone_incall_controls[] = {
+
+};
+
+const struct config_control rt5651_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_speaker_headphone_normal_controls[] = {
+
+};
+
+const struct config_control rt5651_speaker_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5651_headphone_voip_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_headset_normal_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_headset_incall_controls[] = {
+
+};
+
+const struct config_control rt5651_headset_ringtone_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_headset_voip_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt5651_bluetooth_incall_controls[] = {
+
+};
+
+const struct config_control rt5651_bluetooth_voip_controls[] = {
+
+};
+
+const struct config_control rt5651_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXL BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo1 ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo1 ADC R1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+
+};
+
+const struct config_control rt5651_main_mic_capture_controls[] = {
+    /* {
+         .ctl_name = "Stereo1 ADC L2 Mux",
+         .str_val = "DMIC",
+     },
+    {
+         .ctl_name = "Stereo1 ADC R2 Mux",
+         .str_val = "DMIC",
+     },
+    {
+         .ctl_name = "Stereo1 ADC MIXL ADC2 Switch",
+         .int_val = {on},
+     },
+    {
+         .ctl_name = "Stereo1 ADC MIXR ADC2 Switch",
+         .int_val = {on},
+     },*/
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo1 ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo1 ADC R1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {2},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+
+};
+
+const struct config_control rt5651_bluetooth_sco_mic_capture_controls[] = {
+
+};
+
+const struct config_control rt5651_playback_off_controls[] = {
+
+};
+
+const struct config_control rt5651_capture_off_controls[] = {
+
+};
+
+const struct config_control rt5651_incall_off_controls[] = {
+
+};
+
+const struct config_control rt5651_voip_off_controls[] = {
+
+};
+
+const struct config_control rt5651_hdmiin_normal_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Enable",
+    },
+    {
+        .ctl_name = "IF2 ASRC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+
+};
+
+const struct config_control rt5651_hdmiin_off_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "IF2 ASRC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {1, 1},
+    },
+};
+
+const struct config_control rt5651_hdmiin_captrue_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "IF2 ASRC Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DD MIXL DAC L2 Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DD MIXR DAC R2 Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Stereo1 ADC L2 Mux",
+        .str_val = "DD MIX",
+    },
+    {
+        .ctl_name = "Stereo1 ADC R2 Mux",
+        .str_val = "DD MIX",
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXL ADC2 Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXR ADC2 Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {1, 1},
+    },
+
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+};
+
+const struct config_control rt5651_hdmiin_captrue_off_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IF2 ASRC Switch",
+        .int_val = {0},
+    },
+
+    {
+        .ctl_name = "DD MIXL DAC L2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DD MIXR DAC R2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXL ADC2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXR ADC2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {0, 0},
+    },
+};
+
+const struct config_route_table rt5651_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_normal_controls,
+        .controls_count = sizeof(rt5651_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_incall_controls,
+        .controls_count = sizeof(rt5651_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_ringtone_controls,
+        .controls_count = sizeof(rt5651_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_voip_controls,
+        .controls_count = sizeof(rt5651_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_earpiece_normal_controls,
+        .controls_count = sizeof(rt5651_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_earpiece_incall_controls,
+        .controls_count = sizeof(rt5651_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt5651_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_earpiece_voip_controls,
+        .controls_count = sizeof(rt5651_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headphone_normal_controls,
+        .controls_count = sizeof(rt5651_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headphone_incall_controls,
+        .controls_count = sizeof(rt5651_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5651_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt5651_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5651_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headphone_voip_controls,
+        .controls_count = sizeof(rt5651_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headset_normal_controls,
+        .controls_count = sizeof(rt5651_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headset_incall_controls,
+        .controls_count = sizeof(rt5651_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headset_ringtone_controls,
+        .controls_count = sizeof(rt5651_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headset_voip_controls,
+        .controls_count = sizeof(rt5651_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_bluetooth_normal_controls,
+        .controls_count = sizeof(rt5651_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5651_bluetooth_incall_controls,
+        .controls_count = sizeof(rt5651_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5651_bluetooth_voip_controls,
+        .controls_count = sizeof(rt5651_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_main_mic_capture_controls,
+        .controls_count = sizeof(rt5651_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt5651_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5651_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt5651_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt5651_playback_off_controls,
+        .controls_count = sizeof(rt5651_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt5651_capture_off_controls,
+        .controls_count = sizeof(rt5651_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt5651_incall_off_controls,
+        .controls_count = sizeof(rt5651_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt5651_voip_off_controls,
+        .controls_count = sizeof(rt5651_voip_off_controls) / sizeof(struct config_control),
+    },
+    .hdmiin_normal = {
+        .controls = rt5651_hdmiin_normal_controls,
+        .controls_count = sizeof(rt5651_hdmiin_normal_controls) / sizeof(struct config_control),
+    },
+
+    .hdmiin_off = {
+        .controls = rt5651_hdmiin_off_controls,
+        .controls_count = sizeof(rt5651_hdmiin_off_controls) / sizeof(struct config_control),
+    },
+
+    .hdmiin_captrue = {
+        .controls = rt5651_hdmiin_captrue_controls,
+        .controls_count = sizeof(rt5651_hdmiin_captrue_controls) / sizeof(struct config_control),
+    },
+    .hdmiin_captrue_off = {
+        .controls = rt5651_hdmiin_captrue_off_controls,
+        .controls_count = sizeof(rt5651_hdmiin_captrue_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_RT5651_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/rt5678_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/rt5678_config.h
new file mode 100644
index 0000000000..6d81dd37a2
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/rt5678_config.h
@@ -0,0 +1,308 @@
+#ifndef _RT5678_CONFIG_H_
+#define _RT5678_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt5678_speaker_normal_controls[] = {
+	{
+		.ctl_name = "DA STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "DAC1 Mux",
+		.str_val = "IF3 DAC",
+	},
+	{
+		.ctl_name = "DAC1 MIXL DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 MIXR DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXL DAC1 L Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXR DAC1 R Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 L Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC1 R Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC3 Source Mux",
+		.str_val = "STO1 DAC MIX",
+	},
+	{
+		.ctl_name = "LOUT1 Playback Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "LOUT2 Playback Switch",
+		.int_val = {on},
+	},
+};
+
+const struct config_control rt5678_headphone_normal_controls[] = {
+	{
+		.ctl_name = "DA STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "DAC1 Mux",
+		.str_val = "IF3 DAC",
+	},
+	{
+		.ctl_name = "DAC1 MIXL DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 MIXR DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXL DAC1 L Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXR DAC1 R Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 L Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC1 R Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC12 Source Mux",
+		.str_val = "STO1 DAC MIX",
+	},
+};
+
+const struct config_control rt5678_mono_normal_controls[] = {
+	{
+		.ctl_name = "DA STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "DAC1 Mux",
+		.str_val = "IF3 DAC",
+	},
+	{
+		.ctl_name = "DAC1 MIXL DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 MIXR DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXL DAC1 L Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXR DAC1 R Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 L Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC5 Source Mux",
+		.str_val = "STO1 DAC MIXL",
+	},
+};
+
+const struct config_control rt5678_headset_mic_capture_controls[] = {
+	{
+		.ctl_name = "AD STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "Stereo1 ADC Mux",
+		.str_val = "ADC12",
+	},
+	{
+		.ctl_name = "IN1 Capture Volume",
+		.int_val = {35},
+	},
+	{
+		.ctl_name = "IN2 Capture Volume",
+		.int_val = {35},
+	},
+	{
+		.ctl_name = "Stereo1 ADC1 Mux",
+		.str_val = "ADC/DMIC",
+	},
+	{
+		.ctl_name = "Sto1 ADC MIXL ADC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "IF3 ADC Mux",
+		.str_val =  "STO1 ADC MIX",
+	},
+	{
+		.ctl_name = "IF1 ADC1 Swap Mux",
+		.str_val =  "L/L",
+	},
+};
+
+const struct config_control rt5678_main_mic_capture_controls[] = {
+	{
+		.ctl_name = "AD STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "Stereo1 ADC Mux",
+		.str_val = "ADC34",
+	},
+	{
+		.ctl_name = "IN3 Capture Volume",
+		.int_val = {35},
+	},
+	{
+		.ctl_name = "IN4 Capture Volume",
+		.int_val = {35},
+	},
+	{
+		.ctl_name = "Stereo1 ADC1 Mux",
+		.str_val = "ADC/DMIC",
+	},
+	{
+		.ctl_name = "Sto1 ADC MIXL ADC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Sto1 ADC MIXR ADC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "IF3 ADC Mux",
+		.str_val =  "STO1 ADC MIX",
+	},
+	{
+		.ctl_name = "IF3 ADC Swap Mux",
+		.str_val =  "R/R",
+	},
+};
+
+const struct config_control rt5678_playback_off_controls[] = {
+	{
+		.ctl_name = "DAC1 MIXL DAC1 Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "DAC1 MIXR DAC1 Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXL DAC1 L Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXR DAC1 R Switch",
+		.int_val = {off},
+	},
+};
+
+const struct config_control rt5678_capture_off_controls[] = {
+	{
+		.ctl_name = "Sto1 ADC MIXL ADC1 Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "Sto1 ADC MIXR ADC1 Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "IF1 ADC1 Swap Mux",
+		.str_val =  "L/R",
+	},
+};
+
+const struct config_route_table rt5678_config_table = {
+	//speaker
+	.speaker_normal = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_speaker_normal_controls,
+		.controls_count = sizeof(rt5678_speaker_normal_controls) / sizeof(struct config_control),
+	},
+
+	//headphone
+	.headphone_normal = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_headphone_normal_controls,
+		.controls_count = sizeof(rt5678_headphone_normal_controls) / sizeof(struct config_control),
+	},
+
+#if 0
+	//mono
+	.mono_normal = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_mono_normal_controls,
+		.controls_count = sizeof(rt5678_mono_normal_controls) / sizeof(struct config_control),
+	},
+#endif
+
+	//capture
+	.hands_free_mic_capture = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_headset_mic_capture_controls,
+		.controls_count = sizeof(rt5678_headset_mic_capture_controls) / sizeof(struct config_control),
+	},
+
+	//capture
+	.main_mic_capture = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_main_mic_capture_controls,
+		.controls_count = sizeof(rt5678_main_mic_capture_controls) / sizeof(struct config_control),
+	},
+
+	//off
+	.playback_off = {
+		.controls = rt5678_playback_off_controls,
+		.controls_count = sizeof(rt5678_playback_off_controls) / sizeof(struct config_control),
+	},
+	.capture_off = {
+		.controls = rt5678_capture_off_controls,
+		.controls_count = sizeof(rt5678_capture_off_controls) / sizeof(struct config_control),
+	},
+
+	//hdmi
+	.hdmi_normal = {
+		.sound_card = 1,
+		.devices = DEVICES_0,
+		.controls_count = 0,
+	},
+
+	//usb audio
+	.usb_normal = {
+		.sound_card = 2,
+		.devices = DEVICES_0,
+		.controls_count = 0,
+	},
+	.usb_capture = {
+		.sound_card = 2,
+		.devices = DEVICES_0,
+		.controls_count = 0,
+	},
+};
+
+#endif //_RT5678_CONFIG_H_
\ No newline at end of file
diff --git a/hardware/rockchip/audio/hdmi_hal/codec_config/wm8960_config.h b/hardware/rockchip/audio/hdmi_hal/codec_config/wm8960_config.h
new file mode 100755
index 0000000000..bf6dbb1f00
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/codec_config/wm8960_config.h
@@ -0,0 +1,869 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file wm8960_config.h
+ * @brief 
+ * @author  RKAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _WM8960_CONFIG_H_
+#define _WM8960_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control wm8960_speaker_normal_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {120, 120},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_speaker_incall_controls[] = {
+};
+
+const struct config_control wm8960_speaker_ringtone_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {120, 120},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_speaker_voip_controls[] = {
+
+};
+
+const struct config_control wm8960_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control wm8960_earpiece_incall_controls[] = {
+};
+
+const struct config_control wm8960_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control wm8960_earpiece_voip_controls[] = {
+
+};
+
+const struct config_control wm8960_headphone_normal_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {116, 116},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_headphone_incall_controls[] = {
+
+};
+
+const struct config_control wm8960_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {116, 116},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+ };
+
+const struct config_control wm8960_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control wm8960_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control wm8960_headphone_voip_controls[] = {
+};
+
+const struct config_control wm8960_headset_normal_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {116, 116},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_headset_incall_controls[] = {
+ };
+
+const struct config_control wm8960_headset_ringtone_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {116, 116},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_headset_voip_controls[] = {
+
+};
+
+const struct config_control wm8960_bluetooth_normal_controls[] = {
+ };
+
+const struct config_control wm8960_bluetooth_incall_controls[] = { 
+};
+
+const struct config_control wm8960_bluetooth_voip_controls[] = {
+
+};
+
+const struct config_control wm8960_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC High Pass Filter Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINPUT2 To Left Boost Mixer Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "LINPUT3 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT2 To Right Boost Mixer Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "RINPUT3 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Lmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Rmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Capture Volume",
+        .int_val = {63,63},
+    }, 
+    {
+        .ctl_name = "ADC PCM Capture Volume",
+        .int_val = {127,127},
+    }, 
+    {
+        .ctl_name = "Capture Volume Switch",
+        .int_val = {0,0},
+    }, 
+    {
+        .ctl_name = "Capture Switch",
+        .int_val = {on,on},
+    }, 
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_hands_free_mic_capture_controls[] = {
+  {
+        .ctl_name = "Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC High Pass Filter Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINPUT2 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LINPUT3 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT2 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT3 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Lmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Rmic Boost",
+        .str_val = "13db",
+    },
+    {
+        .ctl_name = "Capture Volume",
+        .int_val = {0,63},
+    }, 
+    {
+        .ctl_name = "ADC PCM Capture Volume",
+        .int_val = {0,80},
+    }, 
+    {
+        .ctl_name = "Capture Volume Switch",
+        .int_val = {0,0},
+    }, 
+    {
+        .ctl_name = "Capture Switch",
+        .int_val = {off,on},
+    }, 
+};
+
+const struct config_control wm8960_bluetooth_sco_mic_capture_controls[] = {
+};
+
+const struct config_control wm8960_playback_off_controls[] = {
+   {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {0, 0},
+    }, 
+};
+
+const struct config_control wm8960_capture_off_controls[] = {
+    {
+        .ctl_name = "Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC High Pass Filter Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINPUT2 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LINPUT3 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT2 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT3 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Lmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Rmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Capture Volume",
+        .int_val = {0,0},
+    }, 
+    {
+        .ctl_name = "ADC PCM Capture Volume",
+        .int_val = {0,0},
+    }, 
+    {
+        .ctl_name = "Capture Volume Switch",
+        .int_val = {0,0},
+    }, 
+};
+
+const struct config_control wm8960_incall_off_controls[] = { 
+};
+
+const struct config_control wm8960_voip_off_controls[] = {
+
+};
+
+const struct config_route_table wm8960_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_normal_controls,
+        .controls_count = sizeof(wm8960_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_incall_controls,
+        .controls_count = sizeof(wm8960_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_ringtone_controls,
+        .controls_count = sizeof(wm8960_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_voip_controls,
+        .controls_count = sizeof(wm8960_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_earpiece_normal_controls,
+        .controls_count = sizeof(wm8960_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_earpiece_incall_controls,
+        .controls_count = sizeof(wm8960_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_earpiece_ringtone_controls,
+        .controls_count = sizeof(wm8960_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_earpiece_voip_controls,
+        .controls_count = sizeof(wm8960_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headphone_normal_controls,
+        .controls_count = sizeof(wm8960_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headphone_incall_controls,
+        .controls_count = sizeof(wm8960_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headphone_ringtone_controls,
+        .controls_count = sizeof(wm8960_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_headphone_normal_controls,
+        .controls_count = sizeof(wm8960_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(wm8960_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headphone_voip_controls,
+        .controls_count = sizeof(wm8960_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headset_normal_controls,
+        .controls_count = sizeof(wm8960_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headset_incall_controls,
+        .controls_count = sizeof(wm8960_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headset_ringtone_controls,
+        .controls_count = sizeof(wm8960_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headset_voip_controls,
+        .controls_count = sizeof(wm8960_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_bluetooth_normal_controls,
+        .controls_count = sizeof(wm8960_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_bluetooth_incall_controls,
+        .controls_count = sizeof(wm8960_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_bluetooth_voip_controls,
+        .controls_count = sizeof(wm8960_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_main_mic_capture_controls,
+        .controls_count = sizeof(wm8960_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_hands_free_mic_capture_controls,
+        .controls_count = sizeof(wm8960_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(wm8960_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = wm8960_playback_off_controls,
+        .controls_count = sizeof(wm8960_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = wm8960_capture_off_controls,
+        .controls_count = sizeof(wm8960_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = wm8960_incall_off_controls,
+        .controls_count = sizeof(wm8960_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = wm8960_voip_off_controls,
+        .controls_count = sizeof(wm8960_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+#endif //_wm8960_CONFIG_H_
diff --git a/hardware/rockchip/audio/hdmi_hal/denoise/rkdenoise.c b/hardware/rockchip/audio/hdmi_hal/denoise/rkdenoise.c
new file mode 100644
index 0000000000..65ed394823
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/denoise/rkdenoise.c
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <errno.h>
+#include <pthread.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <time.h>
+#include <fcntl.h>
+#include <string.h>
+#include <cutils/log.h>
+#include <speex/speex_preprocess.h>
+#include <dlfcn.h>
+#include "rkdenoise.h"
+#include "skv/skv_anr.h"
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "RKDENOISE"
+
+typedef struct SKVANRParam_ {
+    float noiseFactor;
+    int swU;
+    float PsiMin;
+    float PsiMax;
+    float fGmin;
+    int frameType;
+} SKVANRParam;
+
+typedef struct _SKV_APIS_ {
+    int period;
+    void* st_anr;
+    SKVANRParam *param;
+    rkaudio_anr_param_deinit anr_deinit;
+    skv_anr_param_printf anr_printf;
+    skv_anr_destory anr_destory;
+    skv_anr_process_time anr_process;
+    skv_anrstruct_bank_init anr_init;
+} SKV_APIS;
+
+typedef struct _DENOISE_STATE_ {
+    int period;
+    int rate;
+    int ch;
+    int flag;
+    SpeexPreprocessState* mSpeexState;
+    int mSpeexFrameSize;
+    int16_t *mSpeexPcmIn;
+    void *hskvlib;
+    SKV_APIS skvapi;
+} DENOISE_STATE;
+
+SKVANRParam *_rkaudio_anr_param_init(int rate, int ch, int period)
+{
+    SKVANRParam *param = NULL;
+    int frameType = -1;
+
+    if (rate == 48000) {
+        if (period == 480)
+            frameType = 0;
+        else if (period == 768)
+            frameType = 1;
+    } else if (rate == 44100) {
+        if (period == 441)
+            frameType = 0;
+    } else if (rate == 32000) {
+        if (period == 320)
+            frameType = 0;
+        else if (period == 512)
+            frameType = 1;
+    } else if (rate == 16000) {
+        if (period == 160)
+            frameType = 0;
+        else if (period == 256)
+            frameType = 1;
+    } else if (rate == 8000) {
+        if (period == 80)
+            frameType = 0;
+        else if (period == 128)
+            frameType = 1;
+    }
+    if (frameType == -1)
+        return NULL;
+    param = (SKVANRParam*)malloc(sizeof(SKVANRParam));
+    if (!param)
+        return NULL;
+    param->noiseFactor = 0.88;
+    param->swU = 10;
+    param->PsiMin = 0.05;
+    param->PsiMax = 0.516;
+    param->fGmin = 0.1;
+    param->frameType = frameType; /* 0 stands for 10ms; 1 stands for 16ms */
+    return param;
+}
+
+#define LOADE_AND_CHECK(h, api, name)\
+    ALOGD("%s: loading api(%s)...", __FUNCTION__, name);\
+    api = (typeof(api))dlsym(h, name);\
+    if (!api) {\
+        ALOGE("%s: load api(%s)fail:(%s)!!!", __FUNCTION__, name, dlerror());\
+        goto load_exit;\
+    }
+int _skv_denoise_create(DENOISE_STATE *pDenoiseState, int rate, int ch, int period)
+{
+    SKV_APIS *pskvapi = &pDenoiseState->skvapi;
+    void *hskvlib;
+    int frame_size;
+    const char *libname = "/vendor/lib/hw/libanr.so";
+
+    hskvlib = dlopen(libname, RTLD_LAZY);
+    if (hskvlib == NULL) {
+        ALOGE("%s: loader libanr.so fail!!!", __FUNCTION__);
+        goto fail_exit;
+    }
+    LOADE_AND_CHECK(hskvlib, pskvapi->anr_deinit, "rkaudio_anr_param_deinit")
+    LOADE_AND_CHECK(hskvlib, pskvapi->anr_printf, "skv_anr_param_printf")
+    LOADE_AND_CHECK(hskvlib, pskvapi->anr_destory, "skv_anr_destory")
+    LOADE_AND_CHECK(hskvlib, pskvapi->anr_process, "skv_anr_process_time")
+    LOADE_AND_CHECK(hskvlib, pskvapi->anr_init, "skv_anrstruct_bank_init")
+    pskvapi->param = _rkaudio_anr_param_init(rate, ch, period);
+    if (!pskvapi->param) {
+        ALOGE("%s: para init error\n", __FUNCTION__);
+        goto load_exit;
+    }
+    pskvapi->st_anr = pskvapi->anr_init(rate, ch, &frame_size, pskvapi->param);
+    if (!pskvapi->st_anr) {
+        ALOGE("%s: Failed to create audio preprocess handle\n", __FUNCTION__);
+        goto load_exit;
+    }
+    pDenoiseState->hskvlib = hskvlib;
+    pskvapi->period = frame_size;
+    ALOGD("%s: skv denoise create okay period:%d", __FUNCTION__, pskvapi->period);
+    return 0;
+load_exit:
+    if (hskvlib)
+        dlclose(hskvlib);
+    if (pskvapi->param)
+        free(pskvapi->param);
+    pskvapi->param = NULL;
+    pDenoiseState->hskvlib = NULL;
+fail_exit:
+    return -1;
+}
+#undef LOADE_AND_CHECK
+
+int _spx_denoise_create(DENOISE_STATE *pDenoiseState, int rate, int ch, int period)
+{
+    int denoise = 1;
+    int noiseSuppress = -24;
+
+    pDenoiseState->mSpeexFrameSize = period;
+    pDenoiseState->mSpeexPcmIn = malloc(sizeof(int16_t) * pDenoiseState->mSpeexFrameSize);
+    if(!pDenoiseState->mSpeexPcmIn) {
+        ALOGE("speexPcmIn malloc failed");
+        return -1;
+    }
+    pDenoiseState->mSpeexState = speex_preprocess_state_init(pDenoiseState->mSpeexFrameSize, pDenoiseState->rate);
+    if(pDenoiseState->mSpeexState == NULL) {
+        ALOGE("speex error");
+        goto err_speex_malloc;
+    }
+    speex_preprocess_ctl(pDenoiseState->mSpeexState, SPEEX_PREPROCESS_SET_DENOISE, &denoise);
+    speex_preprocess_ctl(pDenoiseState->mSpeexState, SPEEX_PREPROCESS_SET_NOISE_SUPPRESS, &noiseSuppress);
+    return 0;
+err_speex_malloc:
+    if (pDenoiseState->mSpeexPcmIn)
+        free(pDenoiseState->mSpeexPcmIn);
+    pDenoiseState->mSpeexPcmIn = NULL;
+    return -1;
+}
+
+hrkdeniose rkdenoise_create(int rate, int ch, int period, uint32_t flag)
+{
+    DENOISE_STATE *pDenoiseState = (DENOISE_STATE*)malloc(sizeof(DENOISE_STATE));
+
+    ALOGD("%s: rate:%d ch:%d, flag:%x", __FUNCTION__, rate, ch, flag);
+    if (!pDenoiseState) {
+        ALOGE("pDenoiseState malloc failed");
+        return NULL;
+    }
+    memset(pDenoiseState, 0, sizeof(*pDenoiseState));
+    if ((flag&ALG_SKV) || (flag&ALG_AUTO))
+        flag = ALG_SKV;
+    pDenoiseState->flag  = flag;
+    pDenoiseState->ch = ch;
+    pDenoiseState->rate = rate;
+    if (pDenoiseState->flag & ALG_SPX) {
+        if (_spx_denoise_create(pDenoiseState, rate, ch, period))
+            goto exit;
+        pDenoiseState->period = pDenoiseState->mSpeexFrameSize;
+    } else if (pDenoiseState->flag & ALG_SKV) {
+        if (_skv_denoise_create(pDenoiseState, rate, ch, period))
+            goto exit;
+        pDenoiseState->period = pDenoiseState->skvapi.period;
+    }
+    return (hrkdeniose)pDenoiseState;
+exit:
+    return NULL;
+}
+
+int rkdenoise_get_period(hrkdeniose context)
+{
+    DENOISE_STATE *pDenoiseState = (DENOISE_STATE *)context;
+
+    return pDenoiseState->period;
+}
+
+int _skv_denoise_process(DENOISE_STATE *pDenoiseState, void *bufferin, int bytes, void *bufferout)
+{
+    SKV_APIS *skvapi = &pDenoiseState->skvapi;
+    int index = 0;
+    int startPos = 0;
+    spx_int16_t* data = (spx_int16_t*) bufferin;
+    int ch = pDenoiseState->ch;
+    int curFrameSize = bytes/(ch*sizeof(int16_t));
+    long cid;
+    int out_size;
+
+    ALOGV("%s: ch:%d, framesize:%d", __FUNCTION__, ch, pDenoiseState->period);
+    if(curFrameSize != skvapi->period) {
+        ALOGW("%s:frame size mismatch skv FrameSize %d curFrameSize:%d( bytes:%d)",
+              __FUNCTION__, skvapi->period, curFrameSize, bytes);
+    }
+    out_size = skvapi->anr_process(bufferin, bufferout, skvapi->st_anr);
+    if (curFrameSize != out_size) {
+        ALOGD("%s:_skv_denoise_process, in_size(%d) != out_size(%d)",
+              __FUNCTION__, curFrameSize, out_size);
+    }
+    return 0;
+}
+
+int _spx_denoise_process(DENOISE_STATE *pDenoiseState, void *bufferin, int bytes, void *bufferout)
+{
+        int index = 0;
+        int startPos = 0;
+        spx_int16_t* data = (spx_int16_t*) bufferin;
+        int ch = pDenoiseState->ch;
+        int curFrameSize = bytes/(ch*sizeof(int16_t));
+        long cid;
+
+        ALOGV("%s: ch:%d, framesize:%d", __FUNCTION__, ch, pDenoiseState->period);
+        if(curFrameSize != pDenoiseState->period) {
+            ALOGW("%s:frame size mismatch speex FrameSize %d curFrameSize:%d( bytes:%d)",
+                  __FUNCTION__, pDenoiseState->period, curFrameSize, bytes);
+        }
+        while(curFrameSize >= startPos + pDenoiseState->mSpeexFrameSize) {
+            if( 2 == ch) {
+                for(index = startPos; index < startPos +pDenoiseState->mSpeexFrameSize; index++ )
+                    pDenoiseState->mSpeexPcmIn[index-startPos] = data[index*ch]/2 + data[index*ch+1]/2;
+            } else {
+                for(index = startPos; index< startPos +pDenoiseState->mSpeexFrameSize; index++ )
+                    pDenoiseState->mSpeexPcmIn[index-startPos] = data[index*ch];
+            }
+            speex_preprocess_run(pDenoiseState->mSpeexState, pDenoiseState->mSpeexPcmIn);
+#ifndef TARGET_RK2928
+            for(cid = 0 ; cid < ch; cid++)
+                for(index = startPos; index< startPos + pDenoiseState->mSpeexFrameSize ; index++ ) {
+                    data[index*ch + cid] = pDenoiseState->mSpeexPcmIn[index-startPos];
+                }
+#else
+            for(index = startPos; index< startPos + pDenoiseState->mSpeexFrameSize ; index++ ) {
+                int tmp = (int)pDenoiseState->mSpeexPcmIn[index-startPos]+ pDenoiseState->mSpeexPcmIn[index-startPos]/2;
+                data[index*ch+0] = tmp > 32767 ? 32767 : (tmp < -32768 ? -32768 : tmp);
+            }
+            for(cid = 1 ; cid < ch; cid++)
+                for(index = startPos; index < startPos + pDenoiseState->mSpeexFrameSize ; index++ ) {
+                    data[index*ch + cid] = data[index*ch+0];
+                }
+#endif
+            startPos += pDenoiseState->mSpeexFrameSize;
+        }
+        return 0;
+}
+
+int rkdenoise_process(hrkdeniose context, void *bufferin, int bytes, void *bufferout)
+{
+    DENOISE_STATE *pDenoiseState = (DENOISE_STATE *)context;
+
+    if (pDenoiseState == NULL) {
+        ALOGE("%s: pDenoiseState NULL", __FUNCTION__);
+        return -1;
+    }
+    if (pDenoiseState->flag & ALG_SPX) {
+        return _spx_denoise_process(pDenoiseState, bufferin, bytes, bufferout);
+    } else if (pDenoiseState->flag & ALG_SKV){
+        return _skv_denoise_process(pDenoiseState, bufferin, bytes, bufferout);
+    }
+    return -1;
+}
+
+void rkdenoise_destroy(hrkdeniose context)
+{
+    DENOISE_STATE *pDenoiseState = (DENOISE_STATE *)context;
+
+    ALOGD("%s: rkdenoise context destroy", __FUNCTION__);
+    if(pDenoiseState) {
+        if(pDenoiseState->mSpeexPcmIn)
+            free(pDenoiseState->mSpeexPcmIn);
+        if(pDenoiseState->hskvlib) {
+            SKV_APIS *skvapi = &pDenoiseState->skvapi;
+            if (skvapi->anr_destory && skvapi->st_anr)
+                skvapi->anr_destory(skvapi->st_anr);
+            if (skvapi->anr_deinit)
+                skvapi->anr_deinit(skvapi->param);
+            dlclose(pDenoiseState->hskvlib);
+        }
+        free(pDenoiseState);
+    }
+    return;
+}
diff --git a/hardware/rockchip/audio/hdmi_hal/denoise/rkdenoise.h b/hardware/rockchip/audio/hdmi_hal/denoise/rkdenoise.h
new file mode 100644
index 0000000000..2e21b18049
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/denoise/rkdenoise.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef RK_DENOISE_H
+#define RK_DENOISE_H
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <system/audio.h>
+
+#define ALG_AUTO (1<<31)
+#define ALG_SPX (1<<0)
+#define ALG_SKV (1<<1)
+
+typedef void *hrkdeniose;
+hrkdeniose rkdenoise_create(int rate, int ch, int period, uint32_t flag);
+int rkdenoise_process(hrkdeniose context, void *bufferin, int bytes, void *bufferout);
+void rkdenoise_destroy(hrkdeniose context);
+
+#endif
diff --git a/hardware/rockchip/audio/hdmi_hal/denoise/skv/libanr.so b/hardware/rockchip/audio/hdmi_hal/denoise/skv/libanr.so
new file mode 100755
index 0000000000000000000000000000000000000000..da475659c588f7f8d2f207e3705d7700d628ad2b
GIT binary patch
literal 60320
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

literal 0
HcmV?d00001

diff --git a/hardware/rockchip/audio/hdmi_hal/denoise/skv/skv_anr.h b/hardware/rockchip/audio/hdmi_hal/denoise/skv/skv_anr.h
new file mode 100644
index 0000000000..695cf857e4
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/denoise/skv/skv_anr.h
@@ -0,0 +1,21 @@
+
+#ifndef SKV_ANR_H
+#define SKV_ANR_H
+
+/*--------------------------------------- include -----------------------------------*/
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+typedef void (*rkaudio_anr_param_deinit)(void* param_);
+/*-----------------------------------------  ---------------------------------------*/
+typedef void (*skv_anr_param_printf)(void* param_);
+typedef void (*skv_anr_destory)(void* pstAnr);
+typedef int (*skv_anr_process_time)(short* pfSigIn, short* pfSigOut, void* pstAnr);
+typedef void* (*skv_anrstruct_bank_init)(int mSampleRate, int nb_mic, int* frame_size, void* param_);
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/hardware/rockchip/audio/hdmi_hal/voice_preprocess.c b/hardware/rockchip/audio/hdmi_hal/voice_preprocess.c
new file mode 100644
index 0000000000..3c6e0327a2
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/voice_preprocess.c
@@ -0,0 +1,686 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file    voice_preprocess.c
+ * @author  Sun Mingjun <smj@rock-chips.com>
+ * @date    2017-05-08
+ */
+
+//#define LOG_NDEBUG 0
+
+#include <pthread.h>
+#include <semaphore.h>
+#include <unistd.h>
+#include <errno.h>
+#include <pthread.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <dlfcn.h>  // for dlopen/dlclose
+#include <fcntl.h>
+#include <string.h>
+
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <cutils/str_parms.h>
+
+//#include <speex/speex.h>
+#include <speex/speex_preprocess.h>
+#include <speex/speex_resampler.h>
+
+
+#include "voice_preprocess.h"
+
+#define LOG_TAG "voice_process"
+
+
+#define MAX_BUFFER_SIZE (500 * 1024)
+#define PROCESS_BUFFER_SIZE (256)
+#define FILE_PATH "/etc/RK_VoicePara.bin"
+#define false (0)
+#define true  (1)
+#define bool  int
+
+//#define ALSA_3A_DEBUG
+#ifdef ALSA_3A_DEBUG
+FILE *in_capture_debug;
+FILE *out_capture_debug;
+FILE *in_playback_debug;
+FILE *out_playback_debug;
+#endif
+
+typedef struct voiceThread_t_ {
+    bool            running;
+    pthread_t       thread;
+    sem_t           sem;
+    int             threadStatus;
+    pthread_mutex_t queueCapLock;
+    pthread_mutex_t queuePlyLock;
+    pthread_mutex_t getCapOutLock;
+    pthread_mutex_t getPlyOutLock;
+} voiceThread_t;
+
+typedef struct rk_voice_api_ {
+    int (*init)(char *para);
+    void  (*processCapture)(short  *in, short *ref, short *out, int len);
+    void  (*processPlayback)(short *in, short *out, int len);
+    void  (*deinit)();
+} rk_voice_api;
+
+
+typedef struct rk_voice_handle_ {
+    void*   voiceLibHandle;
+    rk_voice_api *voiceApi;
+    rk_process_api *processApi;
+    char*  playBackBuffer;
+    char*  captureBuffer;
+    char*  outPlayBuffer;
+    char*  outCaptureBuffer;
+    SpeexResamplerState* speexCapureDownResample;
+    SpeexResamplerState* speexCapureUpResample;
+    SpeexResamplerState* speexPlaybackDownResample;
+    SpeexResamplerState* speexPlaybackUpResample;
+    voiceThread_t voice_thread;
+    int    playbackBufferSize;
+    int    captureBufferSize;
+    int    outPlaybackBufferSize;
+    int    outCaptureBufferSize;
+    int    captureInSamplerate;
+    int    processSamplerate;
+    int    playbackInSamplerate;
+    int    captureInChannels;
+    int    processChannels;
+    int    playbackInChannels;
+    int    processBuffersize;
+    int    minPlaybackBuffersize;
+    int    minCaptureBuffersize;
+} rk_voice_handle;
+
+
+static rk_voice_handle *voice_handle = NULL;
+static int prop_pcm_record = 0;
+
+static void thread_loop(rk_voice_handle* handle);
+static void*  thread_start(void* argv);
+static void dump_out_data(const void* buffer,size_t bytes, int *size)
+{
+    static FILE* fd = NULL;
+    static int offset = 0;
+    if(fd == NULL) {
+        fd=fopen("/data/1.pcm","wb+");
+        if(fd == NULL) {
+            ALOGD("DEBUG open  error =%d ,errno = %d",fd,errno);
+            offset = 0;
+        }
+    }
+    fwrite(buffer,bytes,1,fd);
+    offset += bytes;
+    fflush(fd);
+    if(offset >= (*size)*1024*1024) {
+        *size = 0;
+        fclose(fd);
+        offset = 0;
+    }
+}
+
+static inline rk_voice_handle* getHandle()
+{
+    return voice_handle;
+}
+
+
+static int start()
+{
+    rk_voice_handle* voiceHandle = getHandle();
+
+    sem_init(&voice_handle->voice_thread.sem, 0, 1);
+    voiceHandle->voice_thread.running = true;
+
+    if (voiceHandle->voice_thread.threadStatus == -1)
+        voiceHandle->voice_thread.threadStatus = pthread_create(&voiceHandle->voice_thread.thread, NULL, thread_start, voiceHandle);
+
+    ALOGD("voice process start !, ret = %d", voiceHandle->voice_thread.threadStatus);
+
+    return 0;
+}
+
+static int queueCaputureBuffer(void *buf, int size)
+{
+    rk_voice_handle* voiceHandle = getHandle();
+
+    if (voiceHandle->playbackBufferSize <= 0) {
+        ALOGV("not queue capture buffer until playback buffer queued");
+        return -1;
+    }
+
+    pthread_mutex_lock(&voiceHandle->voice_thread.queueCapLock);
+    if (voiceHandle->captureBufferSize + size >= MAX_BUFFER_SIZE) {
+        ALOGW("capture buffer size out of range, flush");
+        memset(voiceHandle->captureBuffer, 0x00, MAX_BUFFER_SIZE);
+        voiceHandle->captureBufferSize = 0;
+    }
+    memcpy((char *)voiceHandle->captureBuffer + voiceHandle->captureBufferSize, (char *)buf, size);
+    voiceHandle->captureBufferSize += size;
+    pthread_mutex_unlock(&voiceHandle->voice_thread.queueCapLock);
+
+
+    if ((voiceHandle->captureBufferSize >= voiceHandle->minCaptureBuffersize)
+            && (voiceHandle->playbackBufferSize >= voiceHandle->minPlaybackBuffersize)) {
+        sem_post(&voiceHandle->voice_thread.sem);
+    }
+    return 0;
+}
+
+static int queuePlaybackBuffer(void *buf, int size)
+{
+    rk_voice_handle* voiceHandle = getHandle();
+
+    pthread_mutex_lock(&voiceHandle->voice_thread.queuePlyLock);
+    if (voiceHandle->playbackBufferSize + size >= MAX_BUFFER_SIZE) {
+        ALOGW("capture buffer size out of range, flush");
+        memset(voiceHandle->playBackBuffer, 0x00, MAX_BUFFER_SIZE);
+        voiceHandle->playbackBufferSize = 0;
+    }
+    memcpy((char *)voiceHandle->playBackBuffer+ voiceHandle->playbackBufferSize, (char *)buf, size);
+    voiceHandle->playbackBufferSize+= size;
+    pthread_mutex_unlock(&voiceHandle->voice_thread.queuePlyLock);
+
+    if ((voiceHandle->captureBufferSize >= voiceHandle->minCaptureBuffersize)
+            && (voiceHandle->playbackBufferSize >= voiceHandle->minPlaybackBuffersize)) {
+        sem_post(&voiceHandle->voice_thread.sem);
+    }
+    return 0;
+}
+
+static int getCapureBuffer(void *buf, int size)
+{
+    rk_voice_handle* voiceHandle = getHandle();
+
+    if (voiceHandle->outCaptureBufferSize < size) {
+        ALOGW("cannot get caputre buffer currently, try next time");
+        return -1;
+    }
+    pthread_mutex_lock(&voiceHandle->voice_thread.getCapOutLock);
+    memcpy((char *)buf, voiceHandle->outCaptureBuffer, size);
+    memcpy(voiceHandle->outCaptureBuffer, voiceHandle->outCaptureBuffer+size, MAX_BUFFER_SIZE-size);
+    voiceHandle->outCaptureBufferSize -= size;
+    pthread_mutex_unlock(&voiceHandle->voice_thread.getCapOutLock);
+    return 0;
+}
+
+static int getPlaybackBuffer(void *buf, int size)
+{
+    rk_voice_handle* voiceHandle = getHandle();
+
+    if (voiceHandle->outPlaybackBufferSize < size) {
+        ALOGW("cannot get playback buffer currently, try next time");
+        return -1;
+    }
+    pthread_mutex_lock(&voiceHandle->voice_thread.getPlyOutLock);
+    memcpy((char *)buf, (char *)voiceHandle->outPlayBuffer, size);
+    memcpy((char *)voiceHandle->outPlayBuffer, (char *)voiceHandle->outPlayBuffer+size, MAX_BUFFER_SIZE-size);
+    voiceHandle->outPlaybackBufferSize -= size;
+    pthread_mutex_unlock(&voiceHandle->voice_thread.getPlyOutLock);
+
+    return 0;
+}
+
+static int flush()
+{
+    rk_voice_handle* voiceHandle = getHandle();
+
+    pthread_mutex_lock(&voiceHandle->voice_thread.queuePlyLock);
+    memset((char *)voiceHandle->playBackBuffer, 0x00, MAX_BUFFER_SIZE);
+    voiceHandle->playbackBufferSize = 0;
+    pthread_mutex_unlock(&voiceHandle->voice_thread.queuePlyLock);
+
+    pthread_mutex_lock(&voiceHandle->voice_thread.queueCapLock);
+    memset((char *)voiceHandle->captureBuffer, 0x00, MAX_BUFFER_SIZE);
+    voiceHandle->captureBufferSize = 0;
+    pthread_mutex_unlock(&voiceHandle->voice_thread.queueCapLock);
+
+    return 0;
+}
+
+
+rk_process_api* rk_voiceprocess_create(int ply_sr, int ply_ch, int cap_sr, int cap_ch)
+{
+    if (voice_handle != NULL) {
+        ALOGW(" voice handle has already opened, return");
+        return voice_handle->processApi;
+    }
+
+    voice_handle = (rk_voice_handle *)malloc(sizeof(rk_voice_handle));
+
+    if (voice_handle== NULL) {
+        ALOGE("voice Handle malloc failed!");
+        goto failed;
+    }
+
+    voice_handle->voiceLibHandle        = NULL;
+    voice_handle->voiceApi              = NULL;
+    voice_handle->processApi            = NULL;
+    voice_handle->playBackBuffer        = NULL;
+    voice_handle->captureBuffer         = NULL;
+    voice_handle->speexCapureDownResample   = NULL;
+    voice_handle->speexCapureUpResample     = NULL;
+    voice_handle->speexPlaybackDownResample = NULL;
+    voice_handle->speexPlaybackUpResample   = NULL;
+    voice_handle->playbackBufferSize     = 0;
+    voice_handle->captureBufferSize      = 0;
+    voice_handle->outPlaybackBufferSize  = 0;
+    voice_handle->outCaptureBufferSize   = 0;
+    voice_handle->captureInSamplerate    = cap_sr;
+    voice_handle->processSamplerate      = 16000;
+    voice_handle->playbackInSamplerate   = ply_sr;
+    voice_handle->captureInChannels      = cap_ch;
+    voice_handle->processChannels        = 1;
+    voice_handle->playbackInChannels     = ply_ch;
+
+    voice_handle->minPlaybackBuffersize = PROCESS_BUFFER_SIZE * 2 * voice_handle->playbackInSamplerate / voice_handle->processSamplerate * voice_handle->playbackInChannels;
+    voice_handle->minCaptureBuffersize = PROCESS_BUFFER_SIZE * 2 * voice_handle->captureInSamplerate / voice_handle->processSamplerate * voice_handle->captureInChannels;
+
+    voice_handle->voice_thread.running = false;
+    voice_handle->voice_thread.threadStatus = -1;
+
+    // open the voice process lib
+    voice_handle->voiceLibHandle = dlopen("/system/lib/libvoiceprocess.so", RTLD_LAZY);
+    if (voice_handle->voiceLibHandle == NULL) {
+        ALOGW("dlopen libvoiceprocess lib error!");
+        goto failed;
+    }
+    voice_handle->voiceApi = (rk_voice_api *)malloc(sizeof(rk_voice_api));
+    if (voice_handle->voiceApi == NULL) {
+        ALOGE("voiceApi malloc error!  return");
+        goto failed;
+    }
+
+    memset(voice_handle->voiceApi, 0, sizeof(rk_voice_api));
+
+    voice_handle->voiceApi->init = (int (*)(char *))dlsym(voice_handle->voiceLibHandle,
+                                   "RK_VOICE_Init");
+    voice_handle->voiceApi->processCapture = (void (*)(short  *in,
+            short *ref, short *out,
+            int len))dlsym(voice_handle->voiceLibHandle,
+                           "RK_VOICE_ProcessTx");
+    voice_handle->voiceApi->processPlayback = (void (*)(short  *in,
+            short *out,
+            int len))dlsym(voice_handle->voiceLibHandle,
+                           "RK_VOICE_ProcessRx");
+    voice_handle->voiceApi->deinit= (void (*)())dlsym(voice_handle->voiceLibHandle,
+                                    "RK_VOICE_Destory");
+
+    if ((voice_handle->voiceApi->init == NULL)
+            || (voice_handle->voiceApi->processCapture == NULL)
+            || (voice_handle->voiceApi->processPlayback == NULL)
+            || (voice_handle->voiceApi->deinit == NULL)) {
+        ALOGE("dlsym voice process lib failed, return");
+        goto failed;
+    }
+
+    // init the voice process lib
+    int ret = 0;
+    ret = voice_handle->voiceApi->init(FILE_PATH);
+    ALOGD("voice api init ret = %d", ret);
+    if (ret != 0) {
+        ALOGE("init %s failed", FILE_PATH);
+    }
+
+    // init the processApi interface
+    voice_handle->processApi = (rk_process_api *)malloc(sizeof(rk_process_api));
+    voice_handle->processApi->start = start;
+    voice_handle->processApi->getCapureBuffer = getCapureBuffer;
+    voice_handle->processApi->getPlaybackBuffer = getPlaybackBuffer;
+    voice_handle->processApi->queuePlaybackBuffer = queuePlaybackBuffer;
+    voice_handle->processApi->quueCaputureBuffer = queueCaputureBuffer;
+    voice_handle->processApi->flush = flush;
+
+    // malloc process buffers
+    voice_handle->playBackBuffer = (char *)malloc(MAX_BUFFER_SIZE);
+    voice_handle->captureBuffer = (char *)malloc(MAX_BUFFER_SIZE);
+    voice_handle->outPlayBuffer = (char *)malloc(MAX_BUFFER_SIZE);
+    voice_handle->outCaptureBuffer = (char *)malloc(MAX_BUFFER_SIZE);
+
+    if ((voice_handle->playBackBuffer == NULL) || (voice_handle->captureBuffer == NULL)
+            ||(voice_handle->outPlayBuffer == NULL) || (voice_handle->outCaptureBuffer == NULL)) {
+        ALOGE("malloc playback or capure buffer falied!");
+        goto failed;
+    }
+
+    pthread_mutex_init(&voice_handle->voice_thread.queuePlyLock, NULL);
+    pthread_mutex_init(&voice_handle->voice_thread.queueCapLock, NULL);
+    pthread_mutex_init(&voice_handle->voice_thread.getCapOutLock, NULL);
+    pthread_mutex_init(&voice_handle->voice_thread.getPlyOutLock, NULL);
+
+    if (voice_handle->captureInSamplerate != voice_handle->processSamplerate) {
+        voice_handle->speexCapureDownResample = speex_resampler_init(1, voice_handle->captureInSamplerate, voice_handle->processSamplerate, SPEEX_RESAMPLER_QUALITY_DESKTOP, NULL);
+        voice_handle->speexCapureUpResample = speex_resampler_init(1, voice_handle->processSamplerate, voice_handle->captureInSamplerate, SPEEX_RESAMPLER_QUALITY_DESKTOP, NULL);
+    }
+
+    if (voice_handle->playbackInSamplerate!= voice_handle->processSamplerate) {
+        voice_handle->speexPlaybackDownResample = speex_resampler_init(1, voice_handle->playbackInSamplerate, voice_handle->processSamplerate, SPEEX_RESAMPLER_QUALITY_DESKTOP, NULL);
+        voice_handle->speexPlaybackUpResample = speex_resampler_init(1, voice_handle->processSamplerate, voice_handle->playbackInSamplerate, SPEEX_RESAMPLER_QUALITY_DESKTOP, NULL);
+    }
+
+    ALOGD("voice proceess handle create success!");
+
+    return voice_handle->processApi;
+
+failed :
+
+    rk_voiceprocess_destory();
+    ALOGD("voice process handle create failed");
+    return NULL;
+}
+
+
+int rk_voiceprocess_destory()
+{
+    ALOGD("voiceprocess_destory");
+    if (voice_handle == NULL) {
+        ALOGD("voiceprocess_destory return");
+        return 0;
+    }
+    if (voice_handle->voice_thread.threadStatus >= 0) {
+        voice_handle->voice_thread.running = false;
+        sem_post(&voice_handle->voice_thread.sem);
+        ALOGD("join thread in");
+        pthread_join(voice_handle->voice_thread.thread, NULL);
+        voice_handle->voice_thread.threadStatus = -1;
+        ALOGD("join thread out");
+
+        sem_destroy(&voice_handle->voice_thread.sem);
+    }
+
+    if (voice_handle->speexCapureDownResample) {
+        speex_resampler_destroy(voice_handle->speexCapureDownResample);
+        voice_handle->speexCapureDownResample = NULL;
+    }
+
+    if (voice_handle->speexCapureDownResample) {
+        speex_resampler_destroy(voice_handle->speexCapureDownResample);
+        voice_handle->speexCapureDownResample = NULL;
+    }
+
+    if (voice_handle->speexPlaybackUpResample) {
+        speex_resampler_destroy(voice_handle->speexPlaybackUpResample);
+        voice_handle->speexPlaybackUpResample = NULL;
+    }
+
+    if (voice_handle->speexPlaybackDownResample) {
+        speex_resampler_destroy(voice_handle->speexPlaybackDownResample);
+        voice_handle->speexPlaybackDownResample = NULL;
+    }
+
+    if (voice_handle->playBackBuffer != NULL) {
+        pthread_mutex_lock(&voice_handle->voice_thread.queuePlyLock);
+        free(voice_handle->playBackBuffer);
+        voice_handle->playBackBuffer = NULL;
+        voice_handle->playbackBufferSize = 0;
+        pthread_mutex_unlock(&voice_handle->voice_thread.queuePlyLock);
+    }
+
+    if (voice_handle->captureBuffer != NULL) {
+        pthread_mutex_lock(&voice_handle->voice_thread.queueCapLock);
+        free(voice_handle->captureBuffer);
+        voice_handle->captureBuffer = NULL;
+        voice_handle->captureBufferSize = 0;
+        pthread_mutex_unlock(&voice_handle->voice_thread.queueCapLock);
+    }
+
+    if (voice_handle->outPlayBuffer != NULL) {
+        pthread_mutex_lock(&voice_handle->voice_thread.getPlyOutLock);
+        free(voice_handle->outPlayBuffer);
+        voice_handle->outPlayBuffer = NULL;
+        voice_handle->outPlaybackBufferSize = 0;
+        pthread_mutex_unlock(&voice_handle->voice_thread.getPlyOutLock);
+    }
+
+    if (voice_handle->outCaptureBuffer != NULL) {
+        pthread_mutex_lock(&voice_handle->voice_thread.getCapOutLock);
+        free(voice_handle->outCaptureBuffer);
+        voice_handle->outCaptureBuffer = NULL;
+        voice_handle->outCaptureBufferSize = 0;
+        pthread_mutex_unlock(&voice_handle->voice_thread.getCapOutLock);
+    }
+
+    if (voice_handle->processApi) {
+        free(voice_handle->processApi);
+        voice_handle->processApi = NULL;
+    }
+
+    if (voice_handle->voiceApi) {
+        voice_handle->voiceApi->deinit();
+    }
+
+    if (voice_handle->voiceApi != NULL) {
+        free(voice_handle->voiceApi);
+        voice_handle->voiceApi = NULL;
+    }
+    if (voice_handle->voiceLibHandle != NULL) {
+        dlclose(voice_handle->voiceLibHandle);
+        voice_handle->voiceLibHandle = NULL;
+    }
+
+    if (voice_handle != NULL) {
+        free(voice_handle);
+        voice_handle = NULL;
+    }
+    ALOGD("voice process handle destory success!");
+    return 0;
+}
+
+
+static int processBuffertoMono(void *buffer, int size)
+{
+    short *in = (short *)buffer;
+    short out[size/4];
+    int i = 0, j = 0;
+
+    for(i = 0, j = 0; i < size/4; i++) {
+        out[i] = (in[j] + in[j+1]) / 2;
+        j+=2;
+    }
+    memset((char *)in, 0x00, size);
+    memcpy((char *)in, (char *)out, size/2);
+    return 0;
+}
+
+static int processBuffertoStereo(void *buffer, int size)
+{
+    short *in = (short *)buffer;
+    short out[size];
+    int i = 0,j = 0;;
+
+    for (i = 0, j = 0; i < size/2; i++) {
+        out[j] = in[i];
+        out[j+1] = in[i];
+        j+=2;
+    }
+    memcpy((char *)in, (char *)out, size * 2);
+    return 0;
+}
+
+
+static void thread_loop(rk_voice_handle* handle)
+{
+    int playback_samplerate = handle->playbackInSamplerate;
+    int capture_samplerate = handle->captureInSamplerate;
+    int process_samplerate = handle->processSamplerate;
+    int playback_channel = handle->playbackInChannels;
+    int capture_channel = handle->captureInChannels;
+    int process_buffer_size = PROCESS_BUFFER_SIZE * 2;
+
+    int playback_min_buffersize = process_buffer_size * playback_samplerate / process_samplerate * playback_channel;
+    int capture_min_buffersize = process_buffer_size * capture_samplerate / process_samplerate * capture_channel;
+
+    char tmp_playback_buffer[playback_min_buffersize];
+    char tmp_capture_buffer[capture_min_buffersize];
+
+    char tmp_outplayback_buffer[playback_min_buffersize];
+    char tmp_outcapture_buffer[capture_min_buffersize];
+#ifdef ALSA_3A_DEBUG
+    in_capture_debug = fopen("/data/3a_capture_in.pcm","wb");//please touch /data/3a_in.pcm first
+    out_capture_debug = fopen("/data/3a_capture_out.pcm","wb");//please touch /data/3a_out.pcm first
+    in_playback_debug = fopen("/data/3a_playback_in.pcm","wb");//please touch /data/3a_ref.pcm first
+    out_playback_debug = fopen("/data/3a_playback_out.pcm","wb");//please touch /data/3a_rx.pcm first
+#endif
+
+    while (handle->voice_thread.running) {
+
+        bool isGetBuffer = false;
+
+        //wait the enough raw buffer
+        if ((handle->captureBufferSize < capture_min_buffersize) || (handle->playbackBufferSize < playback_min_buffersize)) {
+            sem_wait(&handle->voice_thread.sem);
+        }
+
+        char value[PROPERTY_VALUE_MAX] = "";
+        property_get("vendor.audio.record", value, NULL);
+        prop_pcm_record = atoi(value);
+
+        // try to get the raw buffer to process
+        if ((handle->captureBufferSize >= capture_min_buffersize) && (handle->playbackBufferSize >= playback_min_buffersize)) {
+            pthread_mutex_lock(&handle->voice_thread.queueCapLock);
+            memcpy(tmp_capture_buffer, handle->captureBuffer, capture_min_buffersize);
+            memcpy(handle->captureBuffer, handle->captureBuffer+capture_min_buffersize, MAX_BUFFER_SIZE-capture_min_buffersize);
+            handle->captureBufferSize -= capture_min_buffersize;
+            pthread_mutex_unlock(&handle->voice_thread.queueCapLock);
+
+            pthread_mutex_lock(&handle->voice_thread.queuePlyLock);
+            memcpy(tmp_playback_buffer, handle->playBackBuffer, playback_min_buffersize);
+            memcpy(handle->playBackBuffer, handle->playBackBuffer+playback_min_buffersize, MAX_BUFFER_SIZE-playback_min_buffersize);
+            handle->playbackBufferSize -= playback_min_buffersize;
+            pthread_mutex_unlock(&handle->voice_thread.queuePlyLock);
+            isGetBuffer = true;
+        }
+
+        // process the raw buffer and queue to output list
+        if (isGetBuffer) {
+            // process buffer to mono
+            if (playback_channel > 1) {
+                processBuffertoMono(tmp_playback_buffer, playback_min_buffersize);
+            }
+
+            if (capture_channel > 1) {
+                processBuffertoMono(tmp_capture_buffer, capture_min_buffersize);
+            }
+
+            // resample raw buffer to processed samplerate
+            if (playback_samplerate != process_samplerate) {
+                int in_sample = playback_min_buffersize / playback_channel / 2;
+                int out_sample = in_sample;
+                char tmp_resample_buffer[playback_min_buffersize];
+
+                memcpy(tmp_resample_buffer, tmp_playback_buffer, playback_min_buffersize);
+                memset(tmp_playback_buffer, 0x00, playback_min_buffersize);
+                speex_resampler_process_interleaved_int(handle->speexPlaybackDownResample,
+                                                        (spx_int16_t *)tmp_resample_buffer, &in_sample,
+                                                        (spx_int16_t *)tmp_playback_buffer, &out_sample);
+                ALOGV("playback down resample process, in_sample = %d, out_sample = %d", in_sample, out_sample);
+            }
+
+            if (capture_samplerate != process_samplerate) {
+                int in_sample = capture_min_buffersize / capture_channel / 2;
+                int out_sample = in_sample;
+                char tmp_resample_buffer[playback_min_buffersize];
+                memcpy(tmp_resample_buffer, tmp_capture_buffer, capture_min_buffersize);
+                memset(tmp_capture_buffer, 0x00, capture_min_buffersize);
+                speex_resampler_process_interleaved_int(handle->speexCapureDownResample,
+                                                        (spx_int16_t *)tmp_resample_buffer, &in_sample,
+                                                        (spx_int16_t *)tmp_capture_buffer, &out_sample);
+                ALOGV("capture down resample process, in_sample = %d, out_sample = %d,capture_samplerate = %d", in_sample, out_sample,capture_samplerate);
+            }
+
+            // main process call
+            if (handle->voiceApi) {
+                //memcpy((char *)tmp_outplayback_buffer, (char *)tmp_playback_buffer, PROCESS_BUFFER_SIZE * 2);
+                //memcpy((char *)tmp_outcapture_buffer, (char *)tmp_capture_buffer, PROCESS_BUFFER_SIZE * 2);
+                handle->voiceApi->processPlayback((short *)tmp_playback_buffer, (short *)tmp_outplayback_buffer, PROCESS_BUFFER_SIZE);
+                handle->voiceApi->processCapture((short *)tmp_capture_buffer, (short *)tmp_outplayback_buffer, (short *)tmp_outcapture_buffer, PROCESS_BUFFER_SIZE);
+#ifdef ALSA_3A_DEBUG           
+                fwrite(tmp_capture_buffer,sizeof(short),PROCESS_BUFFER_SIZE,in_capture_debug);
+                fwrite(tmp_outcapture_buffer,sizeof(short),PROCESS_BUFFER_SIZE,out_capture_debug);
+                fwrite(tmp_playback_buffer,sizeof(short),PROCESS_BUFFER_SIZE,in_playback_debug);
+		fwrite(tmp_outplayback_buffer,sizeof(short),PROCESS_BUFFER_SIZE,out_playback_debug);
+#endif
+            }
+
+            // upresample the processed buffer to raw buffer samplerate
+            if (playback_samplerate != process_samplerate) {
+                int in_sample = PROCESS_BUFFER_SIZE;
+                int out_sample = playback_min_buffersize;
+                memset(tmp_playback_buffer, 0x00, playback_min_buffersize);
+                memcpy(tmp_playback_buffer, tmp_outplayback_buffer, process_buffer_size);
+                speex_resampler_process_interleaved_int(handle->speexPlaybackUpResample,
+                                                        (spx_int16_t *)tmp_playback_buffer, &in_sample,
+                                                        (spx_int16_t *)tmp_outplayback_buffer, &out_sample);
+                ALOGV("playback up resample process, in_sample = %d, out_sample = %d", in_sample, out_sample);
+
+            }
+
+            if (capture_samplerate != process_samplerate) {
+                int in_sample = PROCESS_BUFFER_SIZE;
+                int out_sample = capture_min_buffersize;
+                memset(tmp_capture_buffer, 0x00, capture_min_buffersize);
+                memcpy(tmp_capture_buffer, tmp_outcapture_buffer, process_buffer_size);
+                speex_resampler_process_interleaved_int(handle->speexCapureUpResample,
+                                                        (spx_int16_t *)tmp_capture_buffer, &in_sample,
+                                                        (spx_int16_t *)tmp_outcapture_buffer, &out_sample);
+                ALOGV("capture up resample process, in_sample = %d, out_sample = %d", in_sample, out_sample);
+            }
+
+            // up adjust channel to raw buffer channels
+            if (playback_channel > 1) {
+                processBuffertoStereo(tmp_outplayback_buffer, playback_min_buffersize/2);
+            }
+
+            if (capture_channel > 1) {
+                processBuffertoStereo(tmp_outcapture_buffer, capture_min_buffersize/2);
+            }
+
+            // queue processed buffer to output list
+            pthread_mutex_lock(&handle->voice_thread.getCapOutLock);
+            memcpy((char *)handle->outCaptureBuffer + handle->outCaptureBufferSize, tmp_outcapture_buffer, capture_min_buffersize);
+            handle->outCaptureBufferSize += capture_min_buffersize;
+            pthread_mutex_unlock(&handle->voice_thread.getCapOutLock);
+
+            pthread_mutex_lock(&handle->voice_thread.getPlyOutLock);
+            memcpy((char *)handle->outPlayBuffer + handle->outPlaybackBufferSize, tmp_outplayback_buffer, playback_min_buffersize);
+            handle->outPlaybackBufferSize += playback_min_buffersize;
+            pthread_mutex_unlock(&handle->voice_thread.getPlyOutLock);
+        }
+    }
+
+#ifdef ALSA_3A_DEBUG
+    fclose(in_capture_debug);
+    fclose(out_capture_debug);
+    fclose(in_playback_debug);
+    fclose(out_playback_debug);
+#endif
+
+}
+
+static void*  thread_start(void* argv)
+{
+    rk_voice_handle* handle = (rk_voice_handle*)argv;
+
+    thread_loop(handle);
+
+    return NULL;
+}
+
diff --git a/hardware/rockchip/audio/hdmi_hal/voice_preprocess.h b/hardware/rockchip/audio/hdmi_hal/voice_preprocess.h
new file mode 100644
index 0000000000..9efb32f15c
--- /dev/null
+++ b/hardware/rockchip/audio/hdmi_hal/voice_preprocess.h
@@ -0,0 +1,26 @@
+#ifndef VOICE_PREPROCESS_H_
+#define VOICE_PREPROCESS_H_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct rk_process_api_ {
+    int (*start)();
+    int (*quueCaputureBuffer)(void *buf, int size);
+    int (*queuePlaybackBuffer)(void *buf, int size);
+    int (*getCapureBuffer)(void *buf, int size);
+    int (*getPlaybackBuffer)(void *buf, int size);
+    int (*flush)();
+} rk_process_api;
+
+rk_process_api* rk_voiceprocess_create(int ply_sr, int ply_ch, int cap_sr, int cap_ch);
+int rk_voiceprocess_destory();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
-- 
2.25.1

