diff --git a/bootable/recovery/mtdutils/Android.bp b/bootable/recovery/mtdutils/Android.bp
new file mode 100644
index 0000000000..b2f294876c
--- /dev/null
+++ b/bootable/recovery/mtdutils/Android.bp
@@ -0,0 +1,39 @@
+//
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+cc_defaults {
+    name: "libmtdutils_defaults",
+    srcs: [
+        "rk29.c",
+        "mtdutils.c",
+        "mounts.c",
+    ],
+    cflags: [
+        "-Wall",
+        "-Werror",
+    ],
+}
+
+cc_library_static {
+    name: "libmtdutils",
+    defaults: [
+        "libmtdutils_defaults",
+    ],
+    recovery_available: true,
+    export_include_dirs: [
+        "include",
+    ],
+}
diff --git a/bootable/recovery/mtdutils/include/mtdutils/mounts.h b/bootable/recovery/mtdutils/include/mtdutils/mounts.h
new file mode 100644
index 0000000000..d721355b83
--- /dev/null
+++ b/bootable/recovery/mtdutils/include/mtdutils/mounts.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MTDUTILS_MOUNTS_H_
+#define MTDUTILS_MOUNTS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct MountedVolume MountedVolume;
+
+int scan_mounted_volumes(void);
+
+const MountedVolume *find_mounted_volume_by_device(const char *device);
+
+const MountedVolume *
+find_mounted_volume_by_mount_point(const char *mount_point);
+
+int unmount_mounted_volume(const MountedVolume *volume);
+
+int remount_read_only(const MountedVolume* volume);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // MTDUTILS_MOUNTS_H_
diff --git a/bootable/recovery/mtdutils/include/mtdutils/mtdutils.h b/bootable/recovery/mtdutils/include/mtdutils/mtdutils.h
new file mode 100644
index 0000000000..362f2449bf
--- /dev/null
+++ b/bootable/recovery/mtdutils/include/mtdutils/mtdutils.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MTDUTILS_H_
+#define MTDUTILS_H_
+
+#include <sys/types.h>  // for size_t, etc.
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct MtdPartition MtdPartition;
+
+int mtd_scan_partitions(void);
+
+const MtdPartition *mtd_find_partition_by_name(const char *name);
+
+/* mount_point is like "/system"
+ * filesystem is like "yaffs2"
+ */
+int mtd_mount_partition(const MtdPartition *partition, const char *mount_point,
+        const char *filesystem, int read_only);
+
+/* get the partition and the minimum erase/write block size.  NULL is ok.
+ */
+int mtd_partition_info(const MtdPartition *partition,
+        size_t *total_size, size_t *erase_size, size_t *write_size);
+
+/* read or write raw data from a partition, starting at the beginning.
+ * skips bad blocks as best we can.
+ */
+typedef struct MtdReadContext MtdReadContext;
+typedef struct MtdWriteContext MtdWriteContext;
+
+MtdReadContext *mtd_read_partition(const MtdPartition *);
+ssize_t mtd_read_data(MtdReadContext *, char *data, size_t data_len);
+void mtd_read_close(MtdReadContext *);
+
+MtdWriteContext *mtd_write_partition(const MtdPartition *);
+ssize_t mtd_write_data(MtdWriteContext *, const char *data, size_t data_len);
+off_t mtd_erase_blocks(MtdWriteContext *, int blocks);  /* 0 ok, -1 for all */
+int mtd_write_close(MtdWriteContext *);
+int mtd_get_partition_index(MtdPartition *partiton);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // MTDUTILS_H_
diff --git a/bootable/recovery/mtdutils/include/mtdutils/rk29.h b/bootable/recovery/mtdutils/include/mtdutils/rk29.h
new file mode 100644
index 0000000000..67bc96e9ac
--- /dev/null
+++ b/bootable/recovery/mtdutils/include/mtdutils/rk29.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECOVERY_RK29_H_
+#define RECOVERY_RK29_H_
+
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define READ_SIZE 16384
+#define READ_MASK (READ_SIZE - 1)
+
+#define WRITE_SIZE 16384
+#define WRITE_MASK (WRITE_SIZE - 1)
+
+int run(const char *filename, char *const argv[]);
+int rk_make_ext3fs(const char *filename);
+int rk_check_and_resizefs(const char *filename);
+int rk_check_and_resizefs_f2fs(const char *filename);
+int rk_make_ext4fs(const char *filename, long long len, const char *mountpoint);
+size_t rk29_fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
+size_t rk29_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
+int make_vfat(const char *filename,const char* volumelabel);
+int make_ntfs(const char *filename,const char* volumelabel);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // RECOVERY_RK29_H_
diff --git a/bootable/recovery/mtdutils/mounts.c b/bootable/recovery/mtdutils/mounts.c
new file mode 100644
index 0000000000..11ef133501
--- /dev/null
+++ b/bootable/recovery/mtdutils/mounts.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <mntent.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/mount.h>
+
+#include "mtdutils/mounts.h"
+
+struct MountedVolume {
+    const char *device;
+    const char *mount_point;
+    const char *filesystem;
+    const char *flags;
+};
+
+typedef struct {
+    MountedVolume *volumes;
+    int volumes_allocd;
+    int volume_count;
+} MountsState;
+
+static MountsState g_mounts_state = {
+    NULL,   // volumes
+    0,      // volumes_allocd
+    0       // volume_count
+};
+
+static inline void
+free_volume_internals(const MountedVolume *volume, int zero)
+{
+    free((char *)volume->device);
+    free((char *)volume->mount_point);
+    free((char *)volume->filesystem);
+    free((char *)volume->flags);
+    if (zero) {
+        memset((void *)volume, 0, sizeof(*volume));
+    }
+}
+
+#define PROC_MOUNTS_FILENAME   "/proc/mounts"
+
+int
+scan_mounted_volumes()
+{
+    FILE* fp;
+    struct mntent* mentry;
+
+    if (g_mounts_state.volumes == NULL) {
+        const int numv = 32;
+        MountedVolume *volumes = malloc(numv * sizeof(*volumes));
+        if (volumes == NULL) {
+            errno = ENOMEM;
+            return -1;
+        }
+        g_mounts_state.volumes = volumes;
+        g_mounts_state.volumes_allocd = numv;
+        memset(volumes, 0, numv * sizeof(*volumes));
+    } else {
+        /* Free the old volume strings.
+         */
+        int i;
+        for (i = 0; i < g_mounts_state.volume_count; i++) {
+            free_volume_internals(&g_mounts_state.volumes[i], 1);
+        }
+    }
+    g_mounts_state.volume_count = 0;
+
+    /* Open and read mount table entries. */
+    fp = setmntent(PROC_MOUNTS_FILENAME, "r");
+    if (fp == NULL) {
+        return -1;
+    }
+    while ((mentry = getmntent(fp)) != NULL) {
+        MountedVolume* v = &g_mounts_state.volumes[g_mounts_state.volume_count++];
+        v->device = strdup(mentry->mnt_fsname);
+        v->mount_point = strdup(mentry->mnt_dir);
+        v->filesystem = strdup(mentry->mnt_type);
+        v->flags = strdup(mentry->mnt_opts);
+    }
+    endmntent(fp);
+    return 0;
+}
+
+const MountedVolume *
+find_mounted_volume_by_device(const char *device)
+{
+    if (g_mounts_state.volumes != NULL) {
+        int i;
+        for (i = 0; i < g_mounts_state.volume_count; i++) {
+            MountedVolume *v = &g_mounts_state.volumes[i];
+            /* May be null if it was unmounted and we haven't rescanned.
+             */
+            if (v->device != NULL) {
+                if (strcmp(v->device, device) == 0) {
+                    return v;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+const MountedVolume *
+find_mounted_volume_by_mount_point(const char *mount_point)
+{
+    if (g_mounts_state.volumes != NULL) {
+        int i;
+        for (i = 0; i < g_mounts_state.volume_count; i++) {
+            MountedVolume *v = &g_mounts_state.volumes[i];
+            /* May be null if it was unmounted and we haven't rescanned.
+             */
+            if (v->mount_point != NULL) {
+                if (strcmp(v->mount_point, mount_point) == 0) {
+                    return v;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+int
+unmount_mounted_volume(const MountedVolume *volume)
+{
+    /* Intentionally pass NULL to umount if the caller tries
+     * to unmount a volume they already unmounted using this
+     * function.
+     */
+    int ret = umount(volume->mount_point);
+    if (ret == 0) {
+        free_volume_internals(volume, 1);
+        return 0;
+    }
+    return ret;
+}
+
+int
+remount_read_only(const MountedVolume* volume)
+{
+    return mount(volume->device, volume->mount_point, volume->filesystem,
+                 MS_NOATIME | MS_NODEV | MS_NODIRATIME |
+                 MS_RDONLY | MS_REMOUNT, 0);
+}
diff --git a/bootable/recovery/mtdutils/mtdutils.c b/bootable/recovery/mtdutils/mtdutils.c
new file mode 100644
index 0000000000..2dede3bdc6
--- /dev/null
+++ b/bootable/recovery/mtdutils/mtdutils.c
@@ -0,0 +1,654 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/mount.h>  // for _IOW, _IOR, mount()
+#include <sys/stat.h>
+#include <mtd/mtd-user.h>
+#undef NDEBUG
+#include <assert.h>
+
+#include "mtdutils/mtdutils.h"
+
+struct MtdPartition {
+    int device_index;
+    unsigned int size;
+    unsigned int erase_size;
+    char *name;
+};
+
+struct MtdReadContext {
+    const MtdPartition *partition;
+    char *buffer;
+    size_t consumed;
+    int fd;
+};
+
+struct MtdWriteContext {
+    const MtdPartition *partition;
+    char *buffer;
+    size_t stored;
+    int fd;
+
+    off_t* bad_block_offsets;
+    int bad_block_alloc;
+    int bad_block_count;
+};
+
+typedef struct {
+    MtdPartition *partitions;
+    int partitions_allocd;
+    int partition_count;
+} MtdState;
+
+static MtdState g_mtd_state = {
+    NULL,   // partitions
+    0,      // partitions_allocd
+    -1      // partition_count
+};
+
+#define MTD_PROC_FILENAME   "/proc/mtd"
+
+int
+mtd_scan_partitions()
+{
+    char buf[2048];
+    const char *bufp;
+    int fd;
+    int i;
+    ssize_t nbytes;
+
+    if (g_mtd_state.partitions == NULL) {
+        const int nump = 32;
+        MtdPartition *partitions = malloc(nump * sizeof(*partitions));
+        if (partitions == NULL) {
+            errno = ENOMEM;
+            return -1;
+        }
+        g_mtd_state.partitions = partitions;
+        g_mtd_state.partitions_allocd = nump;
+        memset(partitions, 0, nump * sizeof(*partitions));
+    }
+    g_mtd_state.partition_count = 0;
+
+    /* Initialize all of the entries to make things easier later.
+     * (Lets us handle sparsely-numbered partitions, which
+     * may not even be possible.)
+     */
+    for (i = 0; i < g_mtd_state.partitions_allocd; i++) {
+        MtdPartition *p = &g_mtd_state.partitions[i];
+        if (p->name != NULL) {
+            free(p->name);
+            p->name = NULL;
+        }
+        p->device_index = -1;
+    }
+
+    /* Open and read the file contents.
+     */
+    fd = open(MTD_PROC_FILENAME, O_RDONLY);
+    if (fd < 0) {
+        goto bail;
+    }
+    nbytes = TEMP_FAILURE_RETRY(read(fd, buf, sizeof(buf) - 1));
+    close(fd);
+    if (nbytes < 0) {
+        goto bail;
+    }
+    buf[nbytes] = '\0';
+
+    /* Parse the contents of the file, which looks like:
+     *
+     *     # cat /proc/mtd
+     *     dev:    size   erasesize  name
+     *     mtd0: 00080000 00020000 "bootloader"
+     *     mtd1: 00400000 00020000 "mfg_and_gsm"
+     *     mtd2: 00400000 00020000 "0000000c"
+     *     mtd3: 00200000 00020000 "0000000d"
+     *     mtd4: 04000000 00020000 "system"
+     *     mtd5: 03280000 00020000 "userdata"
+     */
+    bufp = buf;
+    while (nbytes > 0) {
+        int mtdnum, mtdsize, mtderasesize;
+        int matches;
+        char mtdname[64];
+        mtdname[0] = '\0';
+        mtdnum = -1;
+
+    #ifndef USE_OLD_NAND_DRIVER
+        matches = sscanf(bufp, "rknand%d: %x %x \"%63[^\"]",
+                         &mtdnum, &mtdsize, &mtderasesize, mtdname);
+        printf("matches %d, mtdnum %d, mtdsize %X, mtderasesize %X, mtdname %s\n", matches, mtdnum, mtdsize, mtderasesize, mtdname);
+    #else
+        matches = sscanf(bufp, "mtd%d: %x %x \"%63[^\"]",
+                &mtdnum, &mtdsize, &mtderasesize, mtdname);
+    #endif
+        /* This will fail on the first line, which just contains
+         * column headers.
+         */
+        if (matches == 4) {
+            MtdPartition *p = &g_mtd_state.partitions[mtdnum];
+            p->device_index = mtdnum;
+            p->size = mtdsize;
+            p->erase_size = mtderasesize;
+            p->name = strdup(mtdname);
+            if (p->name == NULL) {
+                errno = ENOMEM;
+                goto bail;
+            }
+            g_mtd_state.partition_count++;
+        }
+
+        /* Eat the line.
+         */
+        while (nbytes > 0 && *bufp != '\n') {
+            bufp++;
+            nbytes--;
+        }
+        if (nbytes > 0) {
+            bufp++;
+            nbytes--;
+        }
+    }
+
+    return g_mtd_state.partition_count;
+
+bail:
+    // keep "partitions" around so we can free the names on a rescan.
+    g_mtd_state.partition_count = -1;
+    return -1;
+}
+
+int mtd_get_partition_index(MtdPartition *partition)
+{
+        return partition->device_index;
+}
+
+const MtdPartition *
+mtd_find_partition_by_name(const char *name)
+{
+    if (g_mtd_state.partitions != NULL) {
+        int i;
+        for (i = 0; i < g_mtd_state.partitions_allocd; i++) {
+            MtdPartition *p = &g_mtd_state.partitions[i];
+            if (p->device_index >= 0 && p->name != NULL) {
+                printf ("find_partition : p->name %s, name %s\n", p->name, name);
+                if (strcmp(p->name, name) == 0) {
+                    return p;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+int
+mtd_mount_partition(const MtdPartition *partition, const char *mount_point,
+        const char *filesystem, int read_only)
+{
+    const unsigned long flags = MS_NOATIME | MS_NODEV | MS_NODIRATIME;
+    char devname[64];
+    int rv = -1;
+
+#ifndef USE_OLD_NAND_DRIVER
+    sprintf(devname, "/dev/block/rknand_%s", partition->name);
+#else
+    sprintf(devname, "/dev/block/mtdblock%d", partition->device_index);
+#endif
+    if (!read_only) {
+        rv = mount(devname, mount_point, filesystem, flags, NULL);
+    }
+    if (read_only || rv < 0) {
+        rv = mount(devname, mount_point, filesystem, flags | MS_RDONLY, 0);
+        if (rv < 0) {
+            printf("Failed to mount %s on %s: %s\n",
+                    devname, mount_point, strerror(errno));
+        } else {
+            printf("Mount %s on %s read-only\n", devname, mount_point);
+        }
+    }
+#if 1   //TODO: figure out why this is happening; remove include of stat.h
+    if (rv >= 0) {
+        /* For some reason, the x bits sometimes aren't set on the root
+         * of mounted volumes.
+         */
+        struct stat st;
+        rv = stat(mount_point, &st);
+        if (rv < 0) {
+            return rv;
+        }
+        mode_t new_mode = st.st_mode | S_IXUSR | S_IXGRP | S_IXOTH;
+        if (new_mode != st.st_mode) {
+printf("Fixing execute permissions for %s\n", mount_point);
+            rv = chmod(mount_point, new_mode);
+            if (rv < 0) {
+                printf("Couldn't fix permissions for %s: %s\n",
+                        mount_point, strerror(errno));
+            }
+        }
+    }
+#endif
+    return rv;
+}
+
+int
+mtd_partition_info(const MtdPartition *partition,
+        size_t *total_size, size_t *erase_size, size_t *write_size)
+{
+    char mtddevname[32];
+#ifndef USE_OLD_NAND_DRIVER
+    sprintf(mtddevname, "/dev/block/rknand_%s", partition->name);
+#else
+    sprintf(mtddevname, "/dev/mtd/mtd%d", partition->device_index);
+#endif
+    int fd = open(mtddevname, O_RDONLY);
+    if (fd < 0) return -1;
+
+#ifdef USE_OLD_NAND_DRIVER
+    struct mtd_info_user mtd_info;
+    int ret = ioctl(fd, MEMGETINFO, &mtd_info);
+    close(fd);
+    if (ret < 0) return -1;
+
+    if (total_size != NULL) *total_size = mtd_info.size;
+    //if (erase_size != NULL) *erase_size = mtd_info.erasesize;
+    //if (write_size != NULL) *write_size = mtd_info.writesize;
+    if (erase_size != NULL)
+        *erase_size = (mtd_info.erasesize>32*512)?mtd_info.erasesize:32*512;
+
+    if (write_size != NULL)
+        *write_size = (mtd_info.erasesize>32*512)?mtd_info.erasesize:32*512;
+#else
+    if (total_size != NULL)
+        *total_size = partition->size;
+
+    if (erase_size != NULL)
+        *erase_size = (partition->erase_size > 32*512) ? partition->erase_size : 32*512;
+
+    if (write_size != NULL)
+        *write_size = (partition->erase_size > 32*512) ? partition->erase_size : 32*512;
+#endif
+    return 0;
+}
+
+MtdReadContext *mtd_read_partition(const MtdPartition *partition)
+{
+    MtdReadContext *ctx = (MtdReadContext*) malloc(sizeof(MtdReadContext));
+    if (ctx == NULL) return NULL;
+
+    ctx->buffer = malloc(partition->erase_size);
+    if (ctx->buffer == NULL) {
+        free(ctx);
+        return NULL;
+    }
+
+    char mtddevname[32];
+#ifndef USE_OLD_NAND_DRIVER
+    sprintf(mtddevname, "/dev/block/rknand_%s", partition->name);
+    printf(" %d : devname : %s\n", __LINE__, mtddevname);
+#else
+    sprintf(mtddevname, "/dev/mtd/mtd%d", partition->device_index);
+#endif
+    ctx->fd = open(mtddevname, O_RDONLY);
+    if (ctx->fd < 0) {
+        free(ctx->buffer);
+        free(ctx);
+        return NULL;
+    }
+
+    ctx->partition = partition;
+    ctx->consumed = partition->erase_size;
+    return ctx;
+}
+
+// Seeks to a location in the partition.  Don't mix with reads of
+// anything other than whole blocks; unpredictable things will result.
+void mtd_read_skip_to(const MtdReadContext* ctx, size_t offset) {
+    lseek64(ctx->fd, offset, SEEK_SET);
+}
+
+static int read_block(const MtdPartition *partition, int fd, char *data)
+{
+    ssize_t size = partition->erase_size;
+    off_t pos = lseek(fd, 0, SEEK_CUR);
+    (void)pos;
+    if (read(fd, data, size) != size) {
+        fprintf(stderr, "mtd: read error (%s)\n", strerror(errno));
+        errno = ENOSPC;
+        return -1;
+    }
+    return 0;
+    /*  RK platform no used
+    struct mtd_ecc_stats before, after;
+    if (ioctl(fd, ECCGETSTATS, &before)) {
+        printf("mtd: ECCGETSTATS error (%s)\n", strerror(errno));
+        return -1;
+    }
+
+    loff_t pos = TEMP_FAILURE_RETRY(lseek64(fd, 0, SEEK_CUR));
+    if (pos == -1) {
+        printf("mtd: read_block: couldn't SEEK_CUR: %s\n", strerror(errno));
+        return -1;
+    }
+
+    ssize_t size = partition->erase_size;
+    int mgbb;
+
+    while (pos + size <= (int) partition->size) {
+        if (TEMP_FAILURE_RETRY(lseek64(fd, pos, SEEK_SET)) != pos ||
+                    TEMP_FAILURE_RETRY(read(fd, data, size)) != size) {
+            printf("mtd: read error at 0x%08llx (%s)\n",
+                   (long long)pos, strerror(errno));
+        } else if (ioctl(fd, ECCGETSTATS, &after)) {
+            printf("mtd: ECCGETSTATS error (%s)\n", strerror(errno));
+            return -1;
+        } else if (after.failed != before.failed) {
+            printf("mtd: ECC errors (%d soft, %d hard) at 0x%08llx\n",
+                   after.corrected - before.corrected,
+                   after.failed - before.failed, (long long)pos);
+            // copy the comparison baseline for the next read.
+            memcpy(&before, &after, sizeof(struct mtd_ecc_stats));
+        } else if ((mgbb = ioctl(fd, MEMGETBADBLOCK, &pos))) {
+            fprintf(stderr,
+                    "mtd: MEMGETBADBLOCK returned %d at 0x%08llx: %s\n",
+                    mgbb, (long long)pos, strerror(errno));
+        } else {
+            return 0;  // Success!
+        }
+
+        pos += partition->erase_size;
+    }
+
+    errno = ENOSPC;
+    return -1;
+    */
+}
+
+ssize_t mtd_read_data(MtdReadContext *ctx, char *data, size_t len)
+{
+    size_t read = 0;
+    while (read < len) {
+        if (ctx->consumed < ctx->partition->erase_size) {
+            size_t avail = ctx->partition->erase_size - ctx->consumed;
+            size_t copy = len - read < avail ? len - read : avail;
+            memcpy(data + read, ctx->buffer + ctx->consumed, copy);
+            ctx->consumed += copy;
+            read += copy;
+        }
+
+        // Read complete blocks directly into the user's buffer
+        while (ctx->consumed == ctx->partition->erase_size &&
+               len - read >= ctx->partition->erase_size) {
+            if (read_block(ctx->partition, ctx->fd, data + read)) return -1;
+            read += ctx->partition->erase_size;
+        }
+
+        if (read >= len) {
+            return read;
+        }
+
+        // Read the next block into the buffer
+        if (ctx->consumed == ctx->partition->erase_size && read < len) {
+            if (read_block(ctx->partition, ctx->fd, ctx->buffer)) return -1;
+            ctx->consumed = 0;
+        }
+    }
+
+    return read;
+}
+
+void mtd_read_close(MtdReadContext *ctx)
+{
+    close(ctx->fd);
+    free(ctx->buffer);
+    free(ctx);
+}
+
+MtdWriteContext *mtd_write_partition(const MtdPartition *partition)
+{
+    MtdWriteContext *ctx = (MtdWriteContext*) malloc(sizeof(MtdWriteContext));
+    if (ctx == NULL) return NULL;
+
+    ctx->bad_block_offsets = NULL;
+    ctx->bad_block_alloc = 0;
+    ctx->bad_block_count = 0;
+
+    ctx->buffer = malloc(partition->erase_size);
+    if (ctx->buffer == NULL) {
+        free(ctx);
+        return NULL;
+    }
+
+    char mtddevname[32];
+#ifndef USE_OLD_NAND_DRIVER
+    sprintf(mtddevname, "/dev/block/rknand_%s", partition->name);
+    printf(" %d : devname : %s\n", __LINE__, mtddevname);
+#else
+    sprintf(mtddevname, "/dev/mtd/mtd%d", partition->device_index);
+#endif
+    ctx->fd = open(mtddevname, O_RDWR);
+    if (ctx->fd < 0) {
+        free(ctx->buffer);
+        free(ctx);
+        return NULL;
+    }
+
+    ctx->partition = partition;
+    ctx->stored = 0;
+    return ctx;
+}
+
+/*
+static void add_bad_block_offset(MtdWriteContext *ctx, off_t pos) {
+    if (ctx->bad_block_count + 1 > ctx->bad_block_alloc) {
+        ctx->bad_block_alloc = (ctx->bad_block_alloc*2) + 1;
+        ctx->bad_block_offsets = realloc(ctx->bad_block_offsets,
+                                         ctx->bad_block_alloc * sizeof(off_t));
+    }
+    ctx->bad_block_offsets[ctx->bad_block_count++] = pos;
+}
+*/
+
+static int write_block(MtdWriteContext *ctx, const char *data)
+{
+    const MtdPartition *partition = ctx->partition;
+    int fd = ctx->fd;
+    off_t pos = lseek(fd, 0, SEEK_CUR);
+    if (pos == (off_t) -1) return 1;
+    ssize_t size = partition->erase_size;
+
+    if (write(fd, data, size) != size) {
+        fprintf(stderr,"mtd: write error (%s)\n", strerror(errno));
+        errno = ENOSPC;
+        return -1;
+    }
+    return 0;
+
+    /* RK platform no used
+    off_t pos = TEMP_FAILURE_RETRY(lseek(fd, 0, SEEK_CUR));
+    if (pos == (off_t) -1) {
+        printf("mtd: write_block: couldn't SEEK_CUR: %s\n", strerror(errno));
+        return -1;
+    }
+
+    ssize_t size = partition->erase_size;
+    while (pos + size <= (int) partition->size) {
+        loff_t bpos = pos;
+        int ret = ioctl(fd, MEMGETBADBLOCK, &bpos);
+        if (ret != 0 && !(ret == -1 && errno == EOPNOTSUPP)) {
+            add_bad_block_offset(ctx, pos);
+            fprintf(stderr,
+                    "mtd: not writing bad block at 0x%08lx (ret %d): %s\n",
+                    pos, ret, strerror(errno));
+            pos += partition->erase_size;
+            continue;  // Don't try to erase known factory-bad blocks.
+        }
+
+        struct erase_info_user erase_info;
+        erase_info.start = pos;
+        erase_info.length = size;
+        int retry;
+        for (retry = 0; retry < 2; ++retry) {
+            if (ioctl(fd, MEMERASE, &erase_info) < 0) {
+                printf("mtd: erase failure at 0x%08lx (%s)\n",
+                        pos, strerror(errno));
+                continue;
+            }
+            if (TEMP_FAILURE_RETRY(lseek(fd, pos, SEEK_SET)) != pos ||
+                TEMP_FAILURE_RETRY(write(fd, data, size)) != size) {
+                printf("mtd: write error at 0x%08lx (%s)\n",
+                        pos, strerror(errno));
+            }
+
+            char verify[size];
+            if (TEMP_FAILURE_RETRY(lseek(fd, pos, SEEK_SET)) != pos ||
+                TEMP_FAILURE_RETRY(read(fd, verify, size)) != size) {
+                printf("mtd: re-read error at 0x%08lx (%s)\n",
+                        pos, strerror(errno));
+                continue;
+            }
+            if (memcmp(data, verify, size) != 0) {
+                printf("mtd: verification error at 0x%08lx (%s)\n",
+                        pos, strerror(errno));
+                continue;
+            }
+
+            if (retry > 0) {
+                printf("mtd: wrote block after %d retries\n", retry);
+            }
+            printf("mtd: successfully wrote block at %lx\n", pos);
+            return 0;  // Success!
+        }
+
+        // Try to erase it once more as we give up on this block
+        add_bad_block_offset(ctx, pos);
+        printf("mtd: skipping write block at 0x%08lx\n", pos);
+        ioctl(fd, MEMERASE, &erase_info);
+        pos += partition->erase_size;
+    }
+
+    // Ran out of space on the device
+    errno = ENOSPC;
+    return -1;
+    */
+}
+
+ssize_t mtd_write_data(MtdWriteContext *ctx, const char *data, size_t len)
+{
+    size_t wrote = 0;
+    while (wrote < len) {
+        // Coalesce partial writes into complete blocks
+        if (ctx->stored > 0 || len - wrote < ctx->partition->erase_size) {
+            size_t avail = ctx->partition->erase_size - ctx->stored;
+            size_t copy = len - wrote < avail ? len - wrote : avail;
+            memcpy(ctx->buffer + ctx->stored, data + wrote, copy);
+            ctx->stored += copy;
+            wrote += copy;
+        }
+
+        // If a complete block was accumulated, write it
+        if (ctx->stored == ctx->partition->erase_size) {
+            if (write_block(ctx, ctx->buffer)) return -1;
+            ctx->stored = 0;
+        }
+
+        // Write complete blocks directly from the user's buffer
+        while (ctx->stored == 0 && len - wrote >= ctx->partition->erase_size) {
+            if (write_block(ctx, data + wrote)) return -1;
+            wrote += ctx->partition->erase_size;
+        }
+    }
+
+    return wrote;
+}
+
+off_t mtd_erase_blocks(MtdWriteContext *ctx, int blocks)
+{
+    // Zero-pad and write any pending data to get us to a block boundary
+    if (ctx->stored > 0) {
+        size_t zero = ctx->partition->erase_size - ctx->stored;
+        memset(ctx->buffer + ctx->stored, 0, zero);
+        if (write_block(ctx, ctx->buffer)) return -1;
+        ctx->stored = 0;
+    }
+
+    off_t pos = TEMP_FAILURE_RETRY(lseek(ctx->fd, 0, SEEK_CUR));
+    if ((off_t) pos == (off_t) -1) {
+        printf("mtd_erase_blocks: couldn't SEEK_CUR: %s\n", strerror(errno));
+        return -1;
+    }
+
+    const int total = (ctx->partition->size - pos) / ctx->partition->erase_size;
+    if (blocks < 0) blocks = total;
+    if (blocks > total) {
+        errno = ENOSPC;
+        return -1;
+    }
+
+    // Erase the specified number of blocks
+    while (blocks-- > 0) {
+        loff_t bpos = pos;
+        if (ioctl(ctx->fd, MEMGETBADBLOCK, &bpos) > 0) {
+            printf("mtd: not erasing bad block at 0x%08lx\n", pos);
+            pos += ctx->partition->erase_size;
+            continue;  // Don't try to erase known factory-bad blocks.
+        }
+
+        struct erase_info_user erase_info;
+        erase_info.start = pos;
+        erase_info.length = ctx->partition->erase_size;
+        if (ioctl(ctx->fd, MEMERASE, &erase_info) < 0) {
+            printf("mtd: erase failure at 0x%08lx\n", pos);
+        }
+        pos += ctx->partition->erase_size;
+    }
+
+    return pos;
+}
+
+int mtd_write_close(MtdWriteContext *ctx)
+{
+    int r = 0;
+    // Make sure any pending data gets written
+    if (mtd_erase_blocks(ctx, 0) == (off_t) -1) r = -1;
+    if (close(ctx->fd)) r = -1;
+    free(ctx->bad_block_offsets);
+    free(ctx->buffer);
+    free(ctx);
+    return r;
+}
+
+
+/* Return the offset of the first good block at or after pos (which
++ * might be pos itself).
++ */
+off_t mtd_find_write_start(MtdWriteContext *ctx, off_t pos) {
+    int i;
+    for (i = 0; i < ctx->bad_block_count; ++i) {
+        if (ctx->bad_block_offsets[i] == pos) {
+            pos += ctx->partition->erase_size;
+        } else if (ctx->bad_block_offsets[i] > pos) {
+            return pos;
+        }
+    }
+    return pos;
+}
diff --git a/bootable/recovery/mtdutils/rk29.c b/bootable/recovery/mtdutils/rk29.c
new file mode 100644
index 0000000000..f0c2e12229
--- /dev/null
+++ b/bootable/recovery/mtdutils/rk29.c
@@ -0,0 +1,319 @@
+#define _GNU_SOURCE
+
+#include <dirent.h>
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/mount.h>
+#include <errno.h>
+#include "mtdutils/mtdutils.h"
+#include "mtdutils/rk29.h"
+
+int run(const char *filename, char *const argv[])
+{
+    struct stat s;
+    int status;
+    pid_t pid;
+
+    if (stat(filename, &s) != 0) {
+        fprintf(stderr, "cannot find '%s'", filename);
+        return -1;
+    }
+
+    printf("executing '%s'\n", filename);
+
+    pid = fork();
+
+    if (pid == 0) {
+        setpgid(0, getpid());
+        /* execute */
+        execv(filename, argv);
+        fprintf(stderr, "can't run %s (%s)\n", filename, strerror(errno));
+        /* exit */
+        _exit(0);
+    }
+
+    if (pid < 0) {
+        fprintf(stderr, "failed to fork and start '%s'\n", filename);
+        return -1;
+    }
+
+    if (-1 == waitpid(pid, &status, WCONTINUED | WUNTRACED)) {
+        fprintf(stderr, "wait for child error\n");
+        return -1;
+    }
+
+    if (WIFEXITED(status)) {
+        printf("executed '%s' done\n", filename);
+    }
+
+    printf("executed '%s' return %d\n", filename, WEXITSTATUS(status));
+    return 0;
+}
+
+//int rk_make_ext4fs(const char *filename, s64 len)
+//{
+//    const char *const mke2fs_argv[] = { "/sbin/mke2fs", "-t", "ext4", "-O", "^huge_file", "-m", "0", "-q", filename, NULL };
+//    printf("format '%s' to ext4 filesystem\n", filename);
+//    return run(mke2fs_argv[0], (char **) mke2fs_argv);
+//}
+
+int rk_make_ext4fs(const char *filename,long long len, const char *mountpoint)
+{
+    int result;
+
+    (void)len; 
+    const char *const mke2fs_argv[] = { "/sbin/mke2fs", "-t", "ext4", "-b", "4096", "-O", "^huge_file", "-m", "0", "-q", filename, NULL };
+    const char *const e2fsck_argv[] = { "/sbin/e2fsck", "-fy", filename, NULL };
+    printf("format '%s' to ext4 filesystem\n", filename);
+    result = run(mke2fs_argv[0], (char **) mke2fs_argv);
+    if(result) {
+        printf("format '%s' to ext4 error!\n", filename);
+        return result;
+    }
+
+    result = run(e2fsck_argv[0], (char **) e2fsck_argv);
+    if(result) {
+        printf("e2fsck check '%s' fail!\n", filename);
+        return result;
+    }
+
+    if(mountpoint != NULL) {
+        int result2 = mount(filename, mountpoint, "ext4",
+                                   MS_NOATIME | MS_NODEV | MS_NODIRATIME, "");
+        if(result2) {
+            printf("mount '%s' to %s fail!\n", filename, mountpoint);
+        }
+    }
+
+    return result;
+}
+
+int rk_check_and_resizefs(const char *filename) {
+    int result;
+
+    const char *const e2fsck_argv[] = { "/sbin/e2fsck", "-fy", filename, NULL };
+    const char *const resizefs_argv[] = { "/sbin/resize2fs", filename, NULL  };
+
+    result = run(e2fsck_argv[0], (char **) e2fsck_argv);
+    if(result) {
+        printf("e2fsck check '%s' failed!\n", filename);
+        return result;
+    }
+
+    result = run(resizefs_argv[0], (char **) resizefs_argv);
+    if(result) {
+        printf("resizefs '%s' failed!\n", filename);
+    }
+
+    return result;
+}
+
+int rk_check_and_resizefs_f2fs(const char *filename) {
+	int result;
+
+	const char *const e2fsck_argv[] = { "/system/bin/fsck.f2fs", filename, NULL };
+	const char *const resizefs_argv[] = { "/system/bin/resize.f2fs", filename, NULL  };
+	printf("fsck_f2fs check '%s' 11111111111111!\n", filename);
+	result = run(e2fsck_argv[0], (char **) e2fsck_argv);
+	if(result) {
+		printf("fsck_f2fs check '%s' failed!\n", filename);
+		return result;
+	}
+
+	result = run(resizefs_argv[0], (char **) resizefs_argv);
+	if(result) {
+		printf("resize.f2fs '%s' failed!\n", filename);
+	}
+
+	return result;
+}
+
+
+int rk_make_ext3fs(const char *filename)
+{
+    int result;
+
+    const char *const mke2fs_argv[] = { "/sbin/mke2fs", "-t", "ext3", "-b", "4096", "-O", "^huge_file", "-m", "0", "-q", filename, NULL };
+    const char *const e2fsck_argv[] = { "/sbin/e2fsck", "-fy", filename, NULL };
+    printf("format '%s' to ext3 filesystem\n", filename);
+    result = run(mke2fs_argv[0], (char **) mke2fs_argv);
+    if(result) {
+        printf("format '%s' to ext3 fail!\n", filename);
+        return result;
+    }
+
+    result = run(e2fsck_argv[0], (char **) e2fsck_argv);
+    if(result) {
+        printf("e2fsck check '%s' fail!\n", filename);
+    }
+
+    return result;
+}
+
+int make_vfat(const char *filename,const char* volumelabel)
+{
+    printf("format '%s' to vfat filesystem\n", filename);
+    if(volumelabel == NULL){
+         const char *const mke2fs_argv[] = { "/sbin/mkdosfs", filename, NULL };
+         return run(mke2fs_argv[0], (char **) mke2fs_argv);
+    }else{
+         const char *const mke2fs_withLabel_argv[] = { "/sbin/mkdosfs", "-L", volumelabel, filename, NULL };
+         return run(mke2fs_withLabel_argv[0], (char **) mke2fs_withLabel_argv);
+    }
+}
+
+int make_ntfs(const char *filename,const char* volumelabel) {
+    printf("format '%s' to NTFS filesystem.\n", filename);
+
+    if(volumelabel == NULL){
+         const char *const mkntfs_argv[] = { "/system/bin/mkntfs", "-f", filename, NULL };
+         return run(mkntfs_argv[0], (char **) mkntfs_argv);
+    }else{
+         const char *const mkntfs_withLabel_argv[] = { "/system/bin/mkntfs", "-f", "-L", volumelabel, filename, NULL };
+         return run(mkntfs_withLabel_argv[0], (char **) mkntfs_withLabel_argv);
+    }
+}
+
+#ifndef min
+#define min(a,b) ((a)<(b)?(a):(b))
+#endif
+
+size_t rk29_fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
+{
+    char buf[READ_SIZE];
+    int fd;
+    long begin, end;
+    off_t offset;
+    ssize_t sz;
+    size_t count = 0, total;
+    char *p = ptr;
+
+    if (!ptr)
+        return 0;
+    if (!size || !nmemb)
+        return 0;
+    if (!stream)
+        return 0;
+    fd = fileno(stream);
+    if (fd < 0)
+        return 0;
+
+    begin = ftell(stream);
+    if (begin < 0)
+        begin = 0;
+
+    total = size * nmemb;
+    if (!total)
+        return 0;
+
+    end = begin + total;
+    offset = begin & ~READ_MASK;
+
+    if (begin & READ_MASK) {
+        sz = pread(fd, buf, READ_SIZE, offset);
+        if (sz < READ_SIZE)
+            goto out;
+        count = min(end, offset + READ_SIZE) - begin;
+        memcpy(p, buf + (begin & READ_MASK), count);
+        p += count;
+        offset += READ_SIZE;
+    }
+
+    for (; offset < (end & ~READ_MASK); offset += READ_SIZE) {
+        sz = pread(fd, buf, READ_SIZE, offset);
+        if (sz < READ_SIZE)
+            goto out;
+        count += READ_SIZE;
+        memcpy(p, buf, READ_SIZE);
+        p += READ_SIZE;
+    }
+
+    if (count < total && (end & READ_MASK)) {
+        offset = end & ~READ_MASK;
+        sz = pread(fd, buf, READ_SIZE, offset);
+        if (sz < READ_SIZE)
+            goto out;
+        memcpy(p, buf, end - offset);
+        count += end - offset;
+    }
+out:
+    count /= size;
+    fseek(stream, begin + count * size, SEEK_SET);
+    return count;
+}
+
+size_t rk29_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
+{
+    char buf[WRITE_SIZE];
+    int fd;
+    long begin, end;
+    off_t offset;
+    ssize_t sz;
+    size_t count = 0, total;
+    char *p = (char *)ptr;
+
+    if (!ptr)
+        return 0;
+    if (!size || !nmemb)
+        return 0;
+    if (!stream)
+        return 0;
+    fd = fileno(stream);
+    if (fd < 0)
+        return 0;
+
+    begin = ftell(stream);
+    if (begin < 0)
+        begin = 0;
+
+    total = size * nmemb;
+    if (!total)
+        return 0;
+
+    end = begin + total;
+    offset = begin & ~WRITE_MASK;
+
+    if (begin & WRITE_MASK) {
+        sz = pread(fd, buf, WRITE_SIZE, offset);
+        if (sz < WRITE_SIZE)
+            goto out;
+        count = min(end, offset + WRITE_SIZE) - begin;
+        memcpy(buf + (begin & WRITE_MASK), p, count);
+        sz = pwrite(fd, buf, WRITE_SIZE, offset);
+        if (sz < WRITE_SIZE)
+            goto out;
+        p += count;
+        offset += WRITE_SIZE;
+    }
+
+    for (; offset < (end & ~WRITE_MASK); offset += WRITE_SIZE) {
+        sz = pwrite(fd, p, WRITE_SIZE, offset);
+        if (sz < WRITE_SIZE)
+            goto out;
+        count += WRITE_SIZE;
+        p += WRITE_SIZE;
+    }
+
+    if (count < total && (end & WRITE_MASK)) {
+        offset = end & ~WRITE_MASK;
+        sz = pread(fd, buf, WRITE_SIZE, offset);
+        if (sz < WRITE_SIZE)
+            goto out;
+        memcpy(buf, p, end - offset);
+        sz = pwrite(fd, buf, WRITE_SIZE, offset);
+        if (sz < WRITE_SIZE)
+            goto out;
+        count += end - offset;
+    }
+out:
+    count /= size;
+    fseek(stream, begin + count * size, SEEK_SET);
+    return count;
+}
+
diff --git a/bootable/recovery/pcba_core/Android.bp b/bootable/recovery/pcba_core/Android.bp
new file mode 100644
index 0000000000..f0e1b392e4
--- /dev/null
+++ b/bootable/recovery/pcba_core/Android.bp
@@ -0,0 +1,87 @@
+cc_library_static {
+    name: "librkfactory_test",
+
+    defaults: [
+        "librecovery_defaults",
+    ],
+
+    srcs: [
+        "rkfactory_test.cpp",
+        "ddr_emmc_test.cpp",
+        "script.c",
+        "script_parser.c",
+        "wlan_test.cpp",
+        "rtc_test.cpp",
+        "gsensor_test.cpp",
+        "bt_test.cpp",
+        "udisk_test.cpp",
+        "sdcard_test.cpp",
+        "battery_test.cpp",
+        "rkhal3_camera/camera_test.cpp",
+        "audiodev_test/codec_test.cpp",
+        "audiodev_test/audio_hw.c",
+        "audiodev_test/alsa_route.c",
+        "audiodev_test/alsa_mixer.c",
+        "audiodev_test/tinyalsa/mixer.c",
+        "audiodev_test/tinyalsa/pcm.c",
+    ],
+
+    local_include_dirs: ["audiodev_test/tinyalsa/include"],
+    shared_libs: [
+        "android.hardware.health@2.0",
+        "libbase",
+        "libbootloader_message",
+        "libcrypto",
+        "libcutils",
+        "libfs_mgr",
+        "liblog",
+        "libziparchive",
+        "libcamera_metadata",
+    ],
+    cflags: [
+        "-Wno-error",
+    ],
+    static_libs: [
+        "libinstall",
+        "librecovery_fastboot",
+        "libminui",
+        "libotautil",
+        "libmtdutils",
+        "librkutility",
+        "librkupdate",
+        "librkwifi-ctrl-static",
+        "android.hardware.camera.common@1.0-helper",
+
+        // external dependencies
+        "libhealthhalutils",
+        "libfstab",
+    ],
+
+    recovery_available: true,
+}
+
+cc_binary {
+    name: "codec_test",
+    srcs: [
+        "audiodev_test/codec_main.cpp",
+        "audiodev_test/codec_test.cpp",
+        "audiodev_test/audio_hw.c",
+        "audiodev_test/alsa_route.c",
+        "audiodev_test/alsa_mixer.c",
+        "audiodev_test/tinyalsa/mixer.c",
+        "audiodev_test/tinyalsa/pcm.c",
+    ],
+    local_include_dirs: ["audiodev_test/tinyalsa/include"],
+    shared_libs: [
+        "android.hardware.health@2.0",
+        "libbase",
+        "libbootloader_message",
+        "libcrypto",
+        "libcutils",
+        "libfs_mgr",
+        "liblog",
+        "libziparchive",
+    ],
+    cflags: ["-Wno-error"],
+    recovery_available: true,
+}
diff --git a/bootable/recovery/pcba_core/Docs/rkhal3_camera_pcba_porting_guide.docx b/bootable/recovery/pcba_core/Docs/rkhal3_camera_pcba_porting_guide.docx
new file mode 100644
index 0000000000..5c7d126330
Binary files /dev/null and b/bootable/recovery/pcba_core/Docs/rkhal3_camera_pcba_porting_guide.docx differ
diff --git a/bootable/recovery/pcba_core/Language/language.h b/bootable/recovery/pcba_core/Language/language.h
new file mode 100644
index 0000000000..4c730dedd5
--- /dev/null
+++ b/bootable/recovery/pcba_core/Language/language.h
@@ -0,0 +1,12 @@
+#ifndef __LANGUAGE_H_
+#define __LANGUAGE_H_
+
+#define LANGUAGE_COFIG      0
+
+#if LANGUAGE_COFIG
+	#include "language_cn.h"
+#else
+	#include "language_en.h"
+#endif
+
+#endif
diff --git a/bootable/recovery/pcba_core/Language/language_cn.h b/bootable/recovery/pcba_core/Language/language_cn.h
new file mode 100644
index 0000000000..93b84f5fe7
--- /dev/null
+++ b/bootable/recovery/pcba_core/Language/language_cn.h
@@ -0,0 +1,73 @@
+#ifndef __LANGUAGE_CN_H_
+#define __LANGUAGE_CN_H_
+
+#define PCBA_VERSION_NAME "ROCKCHIP PCBA TEST V2.3"
+#define PCBA_MANUAL_TEST  "手动测试"
+#define PCBA_AUTO_TEST  "自动测试"
+#define PCBA_SECCESS "通过"
+#define PCBA_FAILED "失败"
+#define PCBA_BLUETOOTH "蓝牙"
+#define PCBA_GSENSOR "重力传感器"
+#define PCBA_KEY "按键"
+#define PCBA_RTC "时钟"
+#define PCBA_NAND "NandFlash"
+#define PCBA_EMMC "eMMC"
+#define PCBA_SIM "SIM卡"
+#define PCBA_SIM2 "SIM卡2"
+#define PCBA_SDCARD  "SD卡"
+#define PCBA_VIBRATOR  "马达震动"
+#define PCBA_FM  "收音机"
+#define PCBA_UCARD  "U盘"
+#define PCBA_WIFI   "网络"
+#define PCBA_WIFI_SIGNAL "信号"
+#define PCBA_WIFI_SIGNAL1 "格"
+#define PCBA_BATTERY   "电池"
+#define PCBA_BATTERY_CHARGE   "充电"
+#define PCBA_BATTERY_DISCHARGE   "放电"
+#define PCBA_BATTERY_FULLCHARGE   "满电"
+#define PCBA_BATTERY_VOLTAGE  "电压"
+#define PCBA_BATTERY_CAPACITY  "电量"
+#define PCBA_AC_ONLINE "电源连接"
+#define PCBA_AC_OFFLINE "电源断开"
+#define PCBA_RECORD "录音"
+#define PCBA_VOLUME "音量"
+#define PCBA_CODEC "声音"
+#define PCBA_WITHOUT_EP_CODEC_INFO "Vol+:录音和扬声器 Vol-:耳机录音和播放"
+#define PCBA_CODEC_INFO "Vol+:录音和扬声器 Vol-:耳机录音和播放 Power:听筒"
+#define PCBA_CODEC_VOL_UP "录音和扬声器测试中..."
+#define PCBA_CODEC_VOL_DOWN "耳机录音和播放测试中..."
+#define PCBA_CODEC_VOL_POWER "听筒测试中..."
+#define PCBA_RINGMIC "MIC阵列"
+#define PCBA_DDR	"内存"
+#define PCBA_DDR_EMMC "设备内存"
+#define PCBA_LCD "屏幕"
+#define PCBA_TESTED "已测试"
+#define PCBA_FLASHLIGHT "闪光灯"
+#define PCBA_CAMERA "相机"
+#define PCBA_FRONT_CAMERA "前置摄像头"
+#define PCBA_BACK_CAMERA "后置摄像头"
+#define PCBA_TESTING "测试中"
+#define PCBA_ERR_CHECK "检测错误"
+#define PCBA_ERR_FREQ "变频错误"
+#define PCBA_SDCARD_NOINSERT "没有插入sd卡"
+#define PCBA_INTEL_PTEST_MODE "ptest模式"
+#define PCBA_BOOT_IN_ANDROID_FUCTION "连续按5次power键，退出ptest模式!"
+#define PCBA_BOOT_IN_CORE_FUNCTION	"power, vol+, vol- 各按一次进入PCBA模式"
+#define PCBA_BOOT_IN_TOUCH_FUNCTION	"在该界面画线进行触摸屏测试"
+#define PCBA_TIP_IN_PCBA_FUNCTION	"按VOL+或VOL-超5秒松开退出PTEST模式"
+#define PCBA_LSENSOR	"光传感器"
+#define PCBA_GNSS		"GPS"
+#define PCBA_PSENSOR	"距离传感器"
+#define PCBA_COMPASS	"电子罗盘"
+#define PCBA_POWER_KEY  "按下电源键"
+#define PCBA_VOLUME_UP_KEY  "按下音量+键"
+#define PCBA_VOLUME_DOWN_KEY   "按下音量-键"
+#define PCBA_RF_CAL   "RF校准:"
+#define PCBA_WIFI_CAL   "WIFI校准:"
+#define PCBA_IMEI_NO   "IMEI号:"
+#define PCBA_CAL_YES   "已校准"
+#define PCBA_CAL_NO   "未校准"
+#define PCBA_LAN	"以太网"
+#define PCBA_GYRO	"陀螺仪"
+#define PCBA_GSENSOR_CALIBRATE	"重力校准"
+#endif
diff --git a/bootable/recovery/pcba_core/Language/language_en.h b/bootable/recovery/pcba_core/Language/language_en.h
new file mode 100644
index 0000000000..8250345406
--- /dev/null
+++ b/bootable/recovery/pcba_core/Language/language_en.h
@@ -0,0 +1,73 @@
+#ifndef __LANGUAGE_EN_H_
+#define __LANGUAGE_EN_H_
+
+#define PCBA_VERSION_NAME "RockChip Pcba Test V3.0 Recovery"
+#define PCBA_MANUAL_TEST  "Manual Test"
+#define PCBA_AUTO_TEST  "Automatic Test"
+#define PCBA_SECCESS "Pass"
+#define PCBA_FAILED "Failed"
+#define PCBA_BLUETOOTH "BlueTooth"
+#define PCBA_GSENSOR "Gsensor"
+#define PCBA_KEY "Key"
+#define PCBA_RTC "Rtc"
+#define PCBA_SIM "Sim"
+#define PCBA_SIM2 "Sim2"
+#define PCBA_SDCARD  "SDCard"
+#define PCBA_VIBRATOR  "VIBRATOR"
+#define PCBA_FM  "FM"
+#define PCBA_UCARD  "UDisk"
+#define PCBA_LAN	"Ethernet"
+#define PCBA_WIFI   "Wifi"
+#define PCBA_WIFI_SIGNAL "Level"
+#define PCBA_WIFI_SIGNAL1 ""
+#define PCBA_BATTERY   "Battery"
+#define PCBA_BATTERY_CHARGE   "Charge"
+#define PCBA_BATTERY_DISCHARGE   "DisCharge"
+#define PCBA_BATTERY_FULLCHARGE   "FullCharge"
+#define PCBA_BATTERY_VOLTAGE  "Voltage"
+#define PCBA_BATTERY_CAPACITY  "Capacity"
+#define PCBA_RECORD "Record Volum"
+#define PCBA_VOLUME "Volume"
+#define PCBA_CODEC "Codec"
+#define PCBA_CODEC_INFO "Vol+:INT_MIC/LS Vol-:EXT_MIC/HS Power:EP"
+#define PCBA_WITHOUT_EP_CODEC_INFO "Vol+:INT_MIC/LS Vol-:EXT_MIC/HS"
+#define PCBA_CODEC_VOL_UP "INT_MIC/LS testing"
+#define PCBA_CODEC_VOL_DOWN "EXT_MIC/HS testing"
+#define PCBA_CODEC_VOL_POWER "EP testing"
+#define PCBA_RINGMIC "RIingMic"
+#define PCBA_DDR "DDR"
+#define PCBA_EMMC "eMMC"
+#define PCBA_NAND "Nand"
+#define PCBA_FLASHLIGHT "FLASHLIGHT"
+#define PCBA_CAMERA "Camera"
+#define PCBA_FRONT_CAMERA "Front Camera"
+#define PCBA_BACK_CAMERA "Back Camera"
+#define PCBA_TESTING "Testing..."
+#define PCBA_ERR_CHECK "Detect errors"
+#define PCBA_ERR_FREQ "Frequency conversion error"
+#define PCBA_SDCARD_NOINSERT "no sdcard"
+#define PCBA_INTEL_PTEST_MODE "PTEST MODE"
+#define PCBA_BOOT_IN_ANDROID_FUCTION "Click power button 5 times to exit ptest!"
+#define PCBA_BOOT_IN_CORE_FUNCTION	"Clik each key(power, vol+, vol-) 1 time to go to pcba core"
+#define PCBA_BOOT_IN_TOUCH_FUNCTION	"Please draw line in this screen to execute TP test"
+#define PCBA_TIP_IN_PCBA_FUNCTION	"Press VOL+ or VOL- longer than 5 seconds to exit PTEST mode"
+#define PCBA_LSENSOR	"LSensor"
+#define PCBA_GNSS		"GPS"
+#define PCBA_PSENSOR	"PSensor"
+#define PCBA_COMPASS	"ECompass"
+#define PCBA_POWER_KEY  "press down power key"
+#define PCBA_VOLUME_UP_KEY  "press down volume+ key"
+#define PCBA_VOLUME_DOWN_KEY   "press down volume- key"
+#define PCBA_RF_CAL   "RF calibration:"
+#define PCBA_WIFI_CAL   "WIFI calibration:"
+#define PCBA_IMEI_NO   "IMEI number:"
+#define PCBA_CAL_YES   "YES"
+#define PCBA_CAL_NO   "NO"
+#define PCBA_GYRO   "Gyro"
+#define PCBA_GSENSOR_CALIBRATE   "Gsensor Cal"
+#define PCBA_DDR_EMMC "Device memory"
+#define PCBA_LCD "LCD"
+#define PCBA_TESTED "Tested"
+#define PCBA_AC_ONLINE "Power Online"
+#define PCBA_AC_OFFLINE "Power OFFline"
+#endif
diff --git a/bootable/recovery/pcba_core/audiodev_test/alsa_audio.h b/bootable/recovery/pcba_core/audiodev_test/alsa_audio.h
new file mode 100644
index 0000000000..aa94450256
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/alsa_audio.h
@@ -0,0 +1,135 @@
+/*
+** Copyright 2010, The Android Open-Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+/**
+ * @file alsa_audio.h
+ * @brief
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _AUDIO_H_
+#define _AUDIO_H_
+#ifdef __cplusplus
+extern "C"{
+#endif
+typedef enum _AudioRoute {
+    SPEAKER_NORMAL_ROUTE = 0,
+    SPEAKER_INCALL_ROUTE, // 1
+    SPEAKER_RINGTONE_ROUTE,
+    SPEAKER_VOIP_ROUTE,
+
+    EARPIECE_NORMAL_ROUTE, // 4
+    EARPIECE_INCALL_ROUTE,
+    EARPIECE_RINGTONE_ROUTE,
+    EARPIECE_VOIP_ROUTE,
+
+    HEADPHONE_NORMAL_ROUTE, // 8
+    HEADPHONE_INCALL_ROUTE,
+    HEADPHONE_RINGTONE_ROUTE,
+    SPEAKER_HEADPHONE_NORMAL_ROUTE,
+    SPEAKER_HEADPHONE_RINGTONE_ROUTE,
+    HEADPHONE_VOIP_ROUTE,
+
+    HEADSET_NORMAL_ROUTE, // 14
+    HEADSET_INCALL_ROUTE,
+    HEADSET_RINGTONE_ROUTE,
+    HEADSET_VOIP_ROUTE,
+
+    BLUETOOTH_NORMAL_ROUTE, // 18
+    BLUETOOTH_INCALL_ROUTE,
+    BLUETOOTH_VOIP_ROUTE,
+
+    MAIN_MIC_CAPTURE_ROUTE, // 21
+    HANDS_FREE_MIC_CAPTURE_ROUTE,
+    BLUETOOTH_SOC_MIC_CAPTURE_ROUTE,
+
+    PLAYBACK_OFF_ROUTE, // 24
+    CAPTURE_OFF_ROUTE,
+    INCALL_OFF_ROUTE,
+    VOIP_OFF_ROUTE,
+
+    HDMI_NORMAL_ROUTE, // 28
+
+    SPDIF_NORMAL_ROUTE,
+
+    USB_NORMAL_ROUTE, // 30
+    USB_CAPTURE_ROUTE,
+
+    HDMI_IN_NORMAL_ROUTE,
+    HDMI_IN_OFF_ROUTE,
+    HDMI_IN_CAPTURE_ROUTE,
+    HDMI_IN_CAPTURE_OFF_ROUTE,
+
+    MAX_ROUTE, //36
+} AudioRoute;
+
+#define PCM_ERROR_MAX 128
+
+struct pcm {
+    int fd;
+    unsigned flags;
+    int running:1;
+    int underruns;
+    unsigned buffer_size;
+    char error[PCM_ERROR_MAX];
+};
+
+struct mixer_ctl {
+    struct mixer *mixer;
+    struct snd_ctl_elem_info *info;
+    struct snd_ctl_tlv *tlv;
+    char **ename;
+};
+
+struct mixer {
+    int fd;
+    struct snd_ctl_elem_info *info;
+    struct mixer_ctl *ctl;
+    unsigned count;
+};
+
+struct mixer *mixer_open_legacy(unsigned card);
+void mixer_close_legacy(struct mixer *mixer);
+void mixer_dump(struct mixer *mixer);
+
+struct mixer_ctl *mixer_get_control(struct mixer *mixer,
+                                    const char *name, unsigned index);
+struct mixer_ctl *mixer_get_nth_control(struct mixer *mixer, unsigned n);
+
+int mixer_ctl_set_val(struct mixer_ctl *ctl,int value);
+int mixer_ctl_set(struct mixer_ctl *ctl, unsigned percent);
+int mixer_ctl_select(struct mixer_ctl *ctl, const char *value);
+void mixer_ctl_print(struct mixer_ctl *ctl);
+int mixer_ctl_set_int_double(struct mixer_ctl *ctl, long long left, long long right);
+int mixer_ctl_set_int(struct mixer_ctl *ctl, long long value);
+int mixer_tlv_get_dB_range(unsigned int *tlv, long rangemin, long rangemax,
+                           long *min, long *max);
+int mixer_get_ctl_minmax(struct mixer_ctl *ctl, long long *min, long long *max);
+int mixer_get_dB_range(struct mixer_ctl *ctl, long rangemin, long rangemax,
+                       float *dB_min, float *dB_max, float *dB_step);
+
+int route_card_init(void **pproute_data, int card);
+int route_set_controls(void *proute_data, unsigned route);
+void route_uninit(void *proute_data);
+int is_playback_route(unsigned route);
+void route_pcm_card_open(void **pproute_data, int card, unsigned route);
+int route_pcm_close(void *proute_data, unsigned route);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/bootable/recovery/pcba_core/audiodev_test/alsa_mixer.c b/bootable/recovery/pcba_core/audiodev_test/alsa_mixer.c
new file mode 100644
index 0000000000..245bac8fb2
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/alsa_mixer.c
@@ -0,0 +1,789 @@
+/*
+** Copyright 2010, The Android Open-Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+/**
+ * @file alsa_mixer.c
+ * @brief
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+
+#include <linux/ioctl.h>
+#define __force
+#define __bitwise
+#define __user
+#include "asound.h"
+#define LOG_TAG "alsa_mixer"
+
+//#define LOG_NDEBUG 0
+
+#include "alsa_audio.h"
+#include <cutils/log.h>
+
+#define MAX_SOUND_CARDS     10
+#define VOLUME_PERCENTS     90
+#define SOUND_CTL_PREFIX    "/dev/snd/controlC%d"
+
+/* convert to index of integer array */
+#define int_index(size)	(((size) + sizeof(int) - 1) / sizeof(int))
+/* max size of a TLV entry for dB information (including compound one) */
+#define MAX_TLV_RANGE_SIZE	256
+
+char *volume_controls_name_table[] = {
+    "Earpiece Playback Volume",
+    "Speaker Playback Volume",
+    "Headphone Playback Volume",
+    "PCM Playback Volume",
+    "Mic Capture Volume",
+};
+
+/**
+ * @brief elem_iface_name
+ *
+ * @param n
+ *
+ * @returns
+ */
+static const char *elem_iface_name(snd_ctl_elem_iface_t n)
+{
+    switch (n) {
+    case SNDRV_CTL_ELEM_IFACE_CARD:
+        return "CARD";
+    case SNDRV_CTL_ELEM_IFACE_HWDEP:
+        return "HWDEP";
+    case SNDRV_CTL_ELEM_IFACE_MIXER:
+        return "MIXER";
+    case SNDRV_CTL_ELEM_IFACE_PCM:
+        return "PCM";
+    case SNDRV_CTL_ELEM_IFACE_RAWMIDI:
+        return "MIDI";
+    case SNDRV_CTL_ELEM_IFACE_TIMER:
+        return "TIMER";
+    case SNDRV_CTL_ELEM_IFACE_SEQUENCER:
+        return "SEQ";
+    default:
+        return "???";
+    }
+}
+
+/**
+ * @brief elem_type_name
+ *
+ * @param n
+ *
+ * @returns
+ */
+static const char *elem_type_name(snd_ctl_elem_type_t n)
+{
+    switch (n) {
+    case SNDRV_CTL_ELEM_TYPE_NONE:
+        return "NONE";
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        return "BOOL";
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        return "INT32";
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        return "ENUM";
+    case SNDRV_CTL_ELEM_TYPE_BYTES:
+        return "BYTES";
+    case SNDRV_CTL_ELEM_TYPE_IEC958:
+        return "IEC958";
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        return "INT64";
+    default:
+        return "???";
+    }
+}
+
+/**
+ * @brief mixer_close_legacy
+ *
+ * @param mixer
+ */
+void mixer_close_legacy(struct mixer *mixer)
+{
+    unsigned n,m;
+
+    if (!mixer)
+        return;
+
+    if (mixer->fd >= 0)
+        close(mixer->fd);
+
+    if (mixer->ctl) {
+        for (n = 0; n < mixer->count; n++) {
+            if (mixer->ctl[n].tlv)
+                free(mixer->ctl[n].tlv);
+            if (mixer->ctl[n].ename) {
+                unsigned max = mixer->ctl[n].info->value.enumerated.items;
+                for (m = 0; m < max; m++)
+                    if(mixer->ctl[n].ename[m])
+                        free(mixer->ctl[n].ename[m]);
+                if(mixer->ctl[n].ename)
+                    free(mixer->ctl[n].ename);
+            }
+        }
+        free(mixer->ctl);
+    }
+
+    if (mixer->info)
+        free(mixer->info);
+
+    free(mixer);
+}
+
+/**
+ * @brief mixer_open_legacy
+ *
+ * @param card
+ *
+ * @returns
+ */
+struct mixer *mixer_open_legacy(unsigned card)
+{
+    char dname[sizeof(SOUND_CTL_PREFIX) + 20];
+    struct snd_ctl_elem_list elist;
+    struct snd_ctl_elem_info tmp;
+    struct snd_ctl_elem_id *eid = NULL;
+    struct mixer *mixer = NULL;
+    unsigned n, m, i, max = sizeof(volume_controls_name_table) / sizeof(char *);
+    int fd;
+    sprintf(dname, SOUND_CTL_PREFIX, card);
+
+    fd = open(dname, O_RDWR);
+
+    if (fd < 0) {
+        ALOGE("mixer_open() Can not open %s for card %d", dname, card);
+        return 0;
+    }
+
+    memset(&elist, 0, sizeof(elist));
+    if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_LIST, &elist) < 0)
+        goto fail;
+
+    mixer = calloc(1, sizeof(*mixer));
+    if (!mixer)
+        goto fail;
+
+    mixer->ctl = calloc(elist.count, sizeof(struct mixer_ctl));
+    mixer->info = calloc(elist.count, sizeof(struct snd_ctl_elem_info));
+    if (!mixer->ctl || !mixer->info)
+        goto fail;
+
+    eid = calloc(elist.count, sizeof(struct snd_ctl_elem_id));
+    if (!eid)
+        goto fail;
+
+    mixer->count = elist.count;
+    mixer->fd = fd;
+    elist.space = mixer->count;
+    elist.pids = eid;
+    if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_LIST, &elist) < 0)
+        goto fail;
+
+    for (n = 0; n < mixer->count; n++) {
+        struct snd_ctl_elem_info *ei = mixer->info + n;
+        ei->id.numid = eid[n].numid;
+        if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_INFO, ei) < 0)
+            goto fail;
+        mixer->ctl[n].info = ei;
+        mixer->ctl[n].mixer = mixer;
+        if (ei->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+            char **enames = calloc(ei->value.enumerated.items, sizeof(char*));
+            if (!enames)
+                goto fail;
+            mixer->ctl[n].ename = enames;
+            for (m = 0; m < ei->value.enumerated.items; m++) {
+                memset(&tmp, 0, sizeof(tmp));
+                tmp.id.numid = ei->id.numid;
+                tmp.value.enumerated.item = m;
+                if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_INFO, &tmp) < 0)
+                    goto fail;
+                enames[m] = strdup(tmp.value.enumerated.name);
+                if (!enames[m])
+                    goto fail;
+            }
+        }
+
+        //add for incall volume by Jear.Chen. get tlv.
+        for (i = 0; i < max; i++) {
+            if (!strcmp((char*) mixer->ctl[n].info->id.name, volume_controls_name_table[i]))
+                break;
+        }
+
+        if (i >= max) {
+            mixer->ctl[n].tlv = NULL;
+            continue;
+        }
+
+        if ((mixer->ctl[n].info->access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) == 0) {
+            ALOGV("mixer_open() type of control %s is not TLVT_DB", mixer->ctl[n].info->id.name);
+            mixer->ctl[n].tlv = NULL;
+            continue;
+        }
+
+        unsigned int tlv_size = 2 * sizeof(unsigned int) + 2 * sizeof(unsigned int);
+        struct snd_ctl_tlv *tlv = malloc(sizeof(struct sndrv_ctl_tlv) + tlv_size);
+
+        //tlv->numid < (info->id.numid + info->count) and
+        //tlv->numid >= info->id.numid
+        tlv->numid = mixer->ctl[n].info->id.numid;
+        //length >= tlv.p[1] + 2 * sizeof(unsigned int);
+        //tlv.p is DECLARE_TLV_DB_SCALE defined in kernel
+        tlv->length = tlv_size;
+
+        if (ioctl(fd, SNDRV_CTL_IOCTL_TLV_READ, tlv) < 0) {
+            ALOGE("mixer_open() get tlv for control %s fail", mixer->ctl[n].info->id.name);
+            free(tlv);
+            mixer->ctl[n].tlv = tlv = NULL;
+            continue;
+        }
+
+        ALOGV("mixer_open() get tlv for control %s", mixer->ctl[n].info->id.name);
+        mixer->ctl[n].tlv = tlv;
+        //add for incall volume end
+    }
+
+    free(eid);
+    return mixer;
+
+fail:
+    if (eid)
+        free(eid);
+    if (mixer)
+        mixer_close_legacy(mixer);
+    else if (fd >= 0)
+        close(fd);
+    return 0;
+}
+
+/**
+ * @brief mixer_ctl_print
+ *
+ * @param ctl
+ */
+void mixer_ctl_print(struct mixer_ctl *ctl)
+{
+    struct snd_ctl_elem_value ev;
+    struct snd_ctl_elem_info *ei = ctl->info;
+    unsigned m;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    if (ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_READ, &ev))
+        return;
+    printf("%s:", ctl->info->id.name);
+
+    switch (ei->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        for (m = 0; m < ei->count; m++)
+            printf(" %s", ev.value.integer.value[m] ? "ON" : "OFF");
+
+        printf(" { OFF=0, ON=1 }");
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        for (m = 0; m < ei->count; m++)
+            printf(" %ld", ev.value.integer.value[m]);
+
+        printf(ei->value.integer.step ?
+               " { %ld-%ld, %ld }\n" : " { %ld-%ld }",
+               ei->value.integer.min,
+               ei->value.integer.max,
+               ei->value.integer.step);
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        for (m = 0; m < ei->count; m++)
+            printf(" %lld", ev.value.integer64.value[m]);
+
+        printf(ei->value.integer64.step ?
+               " { %lld-%lld, %lld }\n" : " { %lld-%lld }",
+               ei->value.integer64.min,
+               ei->value.integer64.max,
+               ei->value.integer64.step);
+        break;
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED: {
+        for (m = 0; m < ei->count; m++) {
+            unsigned v = ev.value.enumerated.item[m];
+            printf(" (%d %s)", v,
+                   (v < ei->value.enumerated.items) ? ctl->ename[v] : "???");
+        }
+
+        printf(" { %s=0", ctl->ename[0]);
+        for (m = 1; m < ei->value.enumerated.items; m++)
+            printf(", %s=%d", ctl->ename[m],m);
+        printf(" }");
+        break;
+    }
+    default:
+        printf(" ???");
+    }
+    printf("\n");
+}
+
+/**
+ * @brief mixer_dump
+ *
+ * @param mixer
+ */
+void mixer_dump(struct mixer *mixer)
+{
+    unsigned n;
+
+    printf("  id iface dev sub idx num perms     type   name\n");
+    for (n = 0; n < mixer->count; n++) {
+        struct snd_ctl_elem_info *ei = mixer->info + n;
+
+        printf("%4d %5s %3d %3d %3d %3d %c%c%c%c%c%c%c%c%c %-6s ",
+               ei->id.numid, elem_iface_name(ei->id.iface),
+               ei->id.device, ei->id.subdevice, ei->id.index,
+               ei->count,
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_READ) ? 'r' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ? 'w' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_VOLATILE) ? 'V' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TIMESTAMP) ? 'T' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) ? 'R' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) ? 'W' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) ? 'C' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE) ? 'I' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_LOCK) ? 'L' : ' ',
+               elem_type_name(ei->type));
+
+        mixer_ctl_print(mixer->ctl + n);
+    }
+}
+
+/**
+ * @brief mixer_get_control
+ *
+ * @param mixer
+ * @param name
+ * @param index
+ *
+ * @returns
+ */
+struct mixer_ctl *mixer_get_control(struct mixer *mixer,
+                                    const char *name, unsigned index)
+{
+    unsigned n;
+    for (n = 0; n < mixer->count; n++) {
+        if (mixer->info[n].id.index == index) {
+            if (!strcmp(name, (char*) mixer->info[n].id.name)) {
+                ALOGV("mixer_get_control() %s access 0x%08x",mixer->info[n].id.name,mixer->info[n].access);
+                return mixer->ctl + n;
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * @brief mixer_get_nth_control
+ *
+ * @param mixer
+ * @param n
+ *
+ * @returns
+ */
+struct mixer_ctl *mixer_get_nth_control(struct mixer *mixer, unsigned n)
+{
+    if (n < mixer->count)
+        return mixer->ctl + n;
+    return 0;
+}
+
+/**
+ * @brief scale_int
+ *
+ * @param ei
+ * @param _percent
+ *
+ * @returns
+ */
+static long scale_int(struct snd_ctl_elem_info *ei, unsigned _percent)
+{
+    long percent;
+    long range;
+
+    if (_percent > 100)
+        percent = 100;
+    else
+        percent = (long) _percent;
+
+    range = (ei->value.integer.max - ei->value.integer.min);
+
+    return ei->value.integer.min + (range * percent) / 100LL;
+}
+
+/**
+ * @brief scale_int64
+ *
+ * @param ei
+ * @param _percent
+ *
+ * @returns
+ */
+static long long scale_int64(struct snd_ctl_elem_info *ei, unsigned _percent)
+{
+    long long percent;
+    long long range;
+
+    if (_percent > 100)
+        percent = 100;
+    else
+        percent = (long) _percent;
+
+    range = (ei->value.integer.max - ei->value.integer.min) * 100LL;
+
+    return ei->value.integer.min + (range / percent);
+}
+/**
+ * @brief mixer_ctl_set_val
+ *
+ * @param ctl
+ * @param value
+ *
+ * @returns
+ */
+
+
+int mixer_ctl_set_val(struct mixer_ctl *ctl, int value)
+{
+    struct snd_ctl_elem_value ev;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        ev.value.integer.value[0] = !!value;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        ev.value.integer.value[0] = value;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        ev.value.integer64.value[0] = value;
+        break;
+defalut:
+        errno = EINVAL;
+        return -1;
+    }
+    return ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+}
+
+/**
+ * @brief mixer_ctl_set
+ *
+ * @param ctl
+ * @param percent
+ *
+ * @returns
+ */
+int mixer_ctl_set(struct mixer_ctl *ctl, unsigned percent)
+{
+    struct snd_ctl_elem_value ev;
+    unsigned n;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        for (n = 0; n < ctl->info->count; n++)
+            ev.value.integer.value[n] = !!percent;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER: {
+        long value = scale_int(ctl->info, percent);
+        for (n = 0; n < ctl->info->count; n++)
+            ev.value.integer.value[n] = value;
+        break;
+    }
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64: {
+        long long value = scale_int64(ctl->info, percent);
+        for (n = 0; n < ctl->info->count; n++)
+            ev.value.integer64.value[n] = value;
+        break;
+    }
+    default:
+        errno = EINVAL;
+        return -1;
+    }
+
+    return ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+}
+
+/**
+ * @brief mixer_ctl_select
+ *
+ * @param ctl
+ * @param value
+ *
+ * @returns
+ */
+int mixer_ctl_select(struct mixer_ctl *ctl, const char *value)
+{
+    unsigned n, max;
+    struct snd_ctl_elem_value ev;
+
+    if (ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    max = ctl->info->value.enumerated.items;
+    for (n = 0; n < max; n++) {
+        if (!strcmp(value, ctl->ename[n])) {
+            memset(&ev, 0, sizeof(ev));
+            ev.value.enumerated.item[0] = n;
+            ev.id.numid = ctl->info->id.numid;
+            if (ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev) < 0)
+                return -1;
+            return 0;
+        }
+    }
+
+    errno = EINVAL;
+    return -1;
+}
+
+/**
+ * @brief mixer_ctl_set_int_double
+ *
+ * @param ctl
+ * @param left
+ * @param right
+ *
+ * @returns
+ */
+int mixer_ctl_set_int_double(struct mixer_ctl *ctl, long long left, long long right)
+{
+    struct snd_ctl_elem_value ev;
+    unsigned n;
+    long long max, min, value = left;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        for (n = 0; n < ctl->info->count; n++) {
+            ev.value.integer.value[n] = !!value;
+            value = right;
+        }
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER: {
+        max = ctl->info->value.integer.max;
+        min = ctl->info->value.integer.min;
+
+        left = left > max ? max : left;
+        left = left < min ? min : left;
+        right = right > max ? max : right;
+        right = right < min ? min : right;
+
+        value = left;
+
+        for (n = 0; n < ctl->info->count; n++) {
+            ev.value.integer.value[n] = (long)value;
+            value = right;
+        }
+        break;
+    }
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64: {
+        max = ctl->info->value.integer64.max;
+        min = ctl->info->value.integer64.min;
+
+        left = left > max ? max : left;
+        left = left < min ? min : left;
+        right = right > max ? max : right;
+        right = right < min ? min : right;
+
+        value = left;
+
+        for (n = 0; n < ctl->info->count; n++) {
+            ev.value.integer64.value[n] = value;
+            value = right;
+        }
+        break;
+    }
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        max = ctl->info->value.enumerated.items;
+        return mixer_ctl_select(ctl, ctl->ename[value > max ? max : value]);
+    default:
+        errno = EINVAL;
+        return -1;
+    }
+
+    return ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+}
+
+/**
+ * @brief mixer_ctl_set_int
+ *
+ * @param ctl
+ * @param value
+ *
+ * @returns
+ */
+int mixer_ctl_set_int(struct mixer_ctl *ctl, long long value)
+{
+    return mixer_ctl_set_int_double(ctl, value, value);
+}
+
+/**
+ * @brief mixer_get_ctl_minmax
+ *
+ * @param ctl
+ * @param min
+ * @param max
+ *
+ * @returns
+ */
+int mixer_get_ctl_minmax(struct mixer_ctl *ctl, long long *min, long long *max)
+{
+    struct snd_ctl_elem_info *ei = ctl->info;
+
+    switch (ei->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        *min = ei->value.integer.min;
+        *max = ei->value.integer.max;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        *min = ei->value.integer64.min;
+        *max = ei->value.integer64.max;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        *min = 0;
+        *max = ei->value.enumerated.items;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+/**
+ * @brief mixer_tlv_get_dB_range
+ * Get dB range from tlv[] which is obtained from control
+ *
+ * @param tlv
+ * @param rangemin
+ * @param rangemax
+ * @param min
+ * @param max
+ *
+ * @returns
+ */
+int mixer_tlv_get_dB_range(unsigned int *tlv, long rangemin, long rangemax,
+                           long *min, long *max)
+{
+    int err;
+
+    switch (tlv[0]) {
+    case SND_CTL_TLVT_DB_RANGE: {
+        unsigned int pos, len;
+        len = int_index(tlv[1]);
+        if (len > MAX_TLV_RANGE_SIZE)
+            return -EINVAL;
+        pos = 2;
+        while (pos + 4 <= len) {
+            long rmin, rmax;
+            rangemin = (int)tlv[pos];
+            rangemax = (int)tlv[pos + 1];
+            err = mixer_tlv_get_dB_range(tlv + pos + 2,
+                                         rangemin, rangemax,
+                                         &rmin, &rmax);
+            if (err < 0)
+                return err;
+            if (pos > 2) {
+                if (rmin < *min)
+                    *min = rmin;
+                if (rmax > *max)
+                    *max = rmax;
+            } else {
+                *min = rmin;
+                *max = rmax;
+            }
+            pos += int_index(tlv[pos + 3]) + 4;
+        }
+        return 0;
+    }
+    case SND_CTL_TLVT_DB_SCALE: {
+        long step;
+        *min = (int)tlv[2];
+        step = (tlv[3] & 0xffff);
+        *max = *min + (long)(step * (rangemax - rangemin));
+        return 0;
+    }
+    case SND_CTL_TLVT_DB_MINMAX:
+    case SND_CTL_TLVT_DB_MINMAX_MUTE:
+    case SND_CTL_TLVT_DB_LINEAR:
+        *min = (int)tlv[2];
+        *max = (int)tlv[3];
+        return 0;
+    }
+    return -EINVAL;
+}
+
+/**
+ * @brief mixer_get_dB_range
+ * Get dB range of control
+ *
+ * @param ctl
+ * @param rangemin
+ * @param rangemax
+ * @param dB_min
+ * @param dB_max
+ * @param dB_step
+ *
+ * @returns
+ */
+int mixer_get_dB_range(struct mixer_ctl *ctl, long rangemin, long rangemax,
+                       float *dB_min, float *dB_max, float *dB_step)
+{
+    unsigned int *tlv;
+    long min, max;
+
+    if (ctl->tlv == NULL) {
+        ALOGE("mixer_get_dB_range() tlv of control %s is NULL", ctl->info->id.name);
+        return -EINVAL;
+    }
+
+    if (mixer_tlv_get_dB_range(ctl->tlv->tlv, rangemin, rangemax,
+                               &min, &max) < 0) {
+        ALOGE("mixer_get_dB_range() get control dB range fail");
+        return -EINVAL;
+    }
+
+    *dB_min = min * 1.0 / 100;
+    *dB_max = max * 1.0 / 100;
+    *dB_step = (max - min) * 1.0 / (rangemax - rangemin) / 100;
+
+    ALOGV("control %s : dB min = %f, dB max = %f, dB step = %f",
+          ctl->info->id.name,
+          *dB_min,
+          *dB_max,
+          *dB_step);
+
+    return 0;
+}
diff --git a/bootable/recovery/pcba_core/audiodev_test/alsa_pcm.c b/bootable/recovery/pcba_core/audiodev_test/alsa_pcm.c
new file mode 100644
index 0000000000..29566bc9e3
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/alsa_pcm.c
@@ -0,0 +1,518 @@
+#define LOG_TAG "alsa_pcm"
+//#define LOG_NDEBUG 0
+#include <cutils/log.h>
+#include <cutils/config_utils.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+
+#include <linux/ioctl.h>
+
+#include "alsa_audio.h"
+
+#define __force
+#define __bitwise
+#define __user
+#include "asound.h"
+#include "common.h"
+
+#define DEBUG 0
+
+/* alsa parameter manipulation cruft */
+
+#define PARAM_MAX SNDRV_PCM_HW_PARAM_LAST_INTERVAL
+
+static inline int param_is_mask(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_MASK) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_MASK);
+}
+
+static inline int param_is_interval(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL);
+}
+
+static inline struct snd_interval *param_to_interval(struct snd_pcm_hw_params *p, int n)
+{
+    return &(p->intervals[n - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL]);
+}
+
+static inline struct snd_mask *param_to_mask(struct snd_pcm_hw_params *p, int n)
+{
+    return &(p->masks[n - SNDRV_PCM_HW_PARAM_FIRST_MASK]);
+}
+
+static void param_set_mask(struct snd_pcm_hw_params *p, int n, unsigned bit)
+{
+    if (bit >= SNDRV_MASK_MAX)
+        return;
+    if (param_is_mask(n)) {
+        struct snd_mask *m = param_to_mask(p, n);
+        m->bits[0] = 0;
+        m->bits[1] = 0;
+        m->bits[bit >> 5] |= (1 << (bit & 31));
+    }
+}
+
+static void param_set_min(struct snd_pcm_hw_params *p, int n, unsigned val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->min = val;
+    }
+}
+
+static void param_set_max(struct snd_pcm_hw_params *p, int n, unsigned val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->max = val;
+    }
+}
+
+static void param_set_int(struct snd_pcm_hw_params *p, int n, unsigned val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->min = val;
+        i->max = val;
+        i->integer = 1;
+    }
+}
+
+static void param_init(struct snd_pcm_hw_params *p)
+{
+    int n;
+    memset(p, 0, sizeof(*p));
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_MASK;
+         n <= SNDRV_PCM_HW_PARAM_LAST_MASK; n++) {
+            struct snd_mask *m = param_to_mask(p, n);
+            m->bits[0] = ~0;
+            m->bits[1] = ~0;
+    }
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL;
+         n <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; n++) {
+            struct snd_interval *i = param_to_interval(p, n);
+            i->min = 0;
+            i->max = ~0;
+    }
+}
+
+/* debugging gunk */
+
+#if DEBUG
+static const char *param_name[PARAM_MAX+1] = {
+    [SNDRV_PCM_HW_PARAM_ACCESS] = "access",
+    [SNDRV_PCM_HW_PARAM_FORMAT] = "format",
+    [SNDRV_PCM_HW_PARAM_SUBFORMAT] = "subformat",
+
+    [SNDRV_PCM_HW_PARAM_SAMPLE_BITS] = "sample_bits",
+    [SNDRV_PCM_HW_PARAM_FRAME_BITS] = "frame_bits",
+    [SNDRV_PCM_HW_PARAM_CHANNELS] = "channels",
+    [SNDRV_PCM_HW_PARAM_RATE] = "rate",
+    [SNDRV_PCM_HW_PARAM_PERIOD_TIME] = "period_time",
+    [SNDRV_PCM_HW_PARAM_PERIOD_SIZE] = "period_size",
+    [SNDRV_PCM_HW_PARAM_PERIOD_BYTES] = "period_bytes",
+    [SNDRV_PCM_HW_PARAM_PERIODS] = "periods",
+    [SNDRV_PCM_HW_PARAM_BUFFER_TIME] = "buffer_time",
+    [SNDRV_PCM_HW_PARAM_BUFFER_SIZE] = "buffer_size",
+    [SNDRV_PCM_HW_PARAM_BUFFER_BYTES] = "buffer_bytes",
+    [SNDRV_PCM_HW_PARAM_TICK_TIME] = "tick_time",
+};
+
+static void param_dump(struct snd_pcm_hw_params *p)
+{
+    int n;
+
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_MASK;
+         n <= SNDRV_PCM_HW_PARAM_LAST_MASK; n++) {
+            struct snd_mask *m = param_to_mask(p, n);
+            LOGV("%s = %08x%08x\n", param_name[n],
+                   m->bits[1], m->bits[0]);
+    }
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL;
+         n <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; n++) {
+            struct snd_interval *i = param_to_interval(p, n);
+            LOGV("%s = (%d,%d) omin=%d omax=%d int=%d empty=%d\n",
+                   param_name[n], i->min, i->max, i->openmin,
+                   i->openmax, i->integer, i->empty);
+    }
+    LOGV("info = %08x\n", p->info);
+    LOGV("msbits = %d\n", p->msbits);
+    LOGV("rate = %d/%d\n", p->rate_num, p->rate_den);
+    LOGV("fifo = %d\n", (int) p->fifo_size);
+}
+
+static void info_dump(struct snd_pcm_info *info)
+{
+    LOGV("device = %d\n", info->device);
+    LOGV("subdevice = %d\n", info->subdevice);
+    LOGV("stream = %d\n", info->stream);
+    LOGV("card = %d\n", info->card);
+    LOGV("id = '%s'\n", info->id);
+    LOGV("name = '%s'\n", info->name);
+    LOGV("subname = '%s'\n", info->subname);
+    LOGV("dev_class = %d\n", info->dev_class);
+    LOGV("dev_subclass = %d\n", info->dev_subclass);
+    LOGV("subdevices_count = %d\n", info->subdevices_count);
+    LOGV("subdevices_avail = %d\n", info->subdevices_avail);
+}
+#else
+static void param_dump(struct snd_pcm_hw_params *p) {}
+static void info_dump(struct snd_pcm_info *info) {}
+#endif
+
+#define PCM_ERROR_MAX 128
+
+struct pcm {
+    int fd;
+    unsigned flags;
+    int running:1;
+    int underruns;
+    unsigned buffer_size;
+    char error[PCM_ERROR_MAX];
+};
+
+unsigned pcm_buffer_size(struct pcm *pcm)
+{
+    return pcm->buffer_size;
+}
+
+const char* pcm_error(struct pcm *pcm)
+{
+    return pcm->error;
+}
+
+static int oops(struct pcm *pcm, int e, const char *fmt, ...) __attribute__((format(printf, 3, 4)));
+static int oops(struct pcm *pcm, int e, const char *fmt, ...)
+{
+    va_list ap;
+    int sz;
+
+    va_start(ap, fmt);
+    vsnprintf(pcm->error, PCM_ERROR_MAX, fmt, ap);
+    va_end(ap);
+    sz = strlen(pcm->error);
+
+    if (errno)
+        snprintf(pcm->error + sz, PCM_ERROR_MAX - sz,
+                 ": %s", strerror(e));
+    return -1;
+}
+
+int pcm_write(struct pcm *pcm, void *data, unsigned count)
+{
+    struct snd_xferi x;
+
+    if (pcm->flags & PCM_IN)
+        return -EINVAL;
+
+    x.buf = data;
+    x.frames = (pcm->flags & PCM_MONO) ? (count / 2) : (count / 4);
+
+    for (;;) {
+        if (!pcm->running) {
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE))
+                return oops(pcm, errno, "cannot prepare channel");
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x))
+                return oops(pcm, errno, "cannot write initial data");
+            pcm->running = 1;
+            return 0;
+        }
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x)) {
+            pcm->running = 0;
+            if (errno == EPIPE) {
+                    /* we failed to make our window -- try to restart */
+                pcm->underruns++;
+                continue;
+            }
+            return oops(pcm, errno, "cannot write stream data");
+        }
+        return 0;
+    }
+}
+
+/********************************
+	author:charles chen
+	data:2012.09.27
+	parameter 
+	data: the input data buf point
+	len:   the input data len need consider the pcm_format
+	ret: 0:Left and right channel is valid
+		  1:Left      channel is valid
+		  2:Right    channel is valid
+
+defalt the input signal is like LRLRLR,default pcm_format is 16bit
+*********************************/
+#define SAMPLECOUNT 441*5*2*2
+int channalFlags = -1;//mean the channel is not checked now
+
+int startCheckCount = 0;
+
+int channel_check(void * data,int len )
+{
+	short * pcmLeftChannel = (short *)data;
+	short * pcmRightChannel = pcmLeftChannel+1;
+	unsigned index = 0;
+	int leftValid = 0x0;
+	int rightValid = 0x0;
+	short checkValue = 0;
+	
+	checkValue = *pcmLeftChannel;
+
+	//checkleft first
+	for(index = 0; index < len; index += 2)
+	{
+		
+		if((pcmLeftChannel[index] >= checkValue+50)||(pcmLeftChannel[index] <= checkValue-50))
+		{
+			leftValid++;// = 0x01;
+			ALOGI("-->pcmLeftChannel[%d] = %d checkValue %d leftValid %d",index,pcmLeftChannel[index],checkValue,leftValid);
+			//break;
+		}	
+	}
+
+	if(leftValid >20)
+		leftValid = 0x01;
+	else
+		leftValid = 0;
+	
+	checkValue = *pcmRightChannel;
+
+		//then check right 
+	for(index = 0; index < len; index += 2)
+	{
+		
+		if((pcmRightChannel[index] >= checkValue+50)||(pcmRightChannel[index] <= checkValue-50))
+		{
+			rightValid++;//= 0x02;
+			ALOGI("-->pcmRightChannel[%d] = %d checkValue %d rightValid %d",index,pcmRightChannel[index],checkValue,rightValid);
+			//break;
+		}	
+	}
+
+	if(rightValid >20)
+		rightValid = 0x02;
+	else
+		rightValid = 0;
+	
+	ALOGI("leftValid %d rightValid %d",leftValid,rightValid);
+	return leftValid|rightValid;
+}
+
+void channel_fixed(void * data,int len, int chFlag)
+{
+	//we just fixed when chFlag is 1 or 2.
+	if(chFlag <= 0 || chFlag > 2 )
+		return;
+
+	short * pcmValid = (short *)data;
+	short * pcmInvalid = pcmValid;
+	
+	if(chFlag == 1)
+		pcmInvalid += 1;
+	else if (chFlag == 2)
+		pcmValid += 1;
+	
+	unsigned index ;
+	
+	for(index = 0; index < len; index += 2)
+	{
+		pcmInvalid[index] = pcmValid[index];
+	}
+	return;
+}
+int pcm_read(struct pcm *pcm, void *data, unsigned count, int size)
+{
+    struct snd_xferi x;
+
+    if (!(pcm->flags & PCM_IN))
+        return -EINVAL;
+
+    x.buf = data;
+    x.frames = (pcm->flags & PCM_MONO) ? (count / 2) : (count / 4);
+
+//    LOGV("read() %d frames", x.frames);
+    for (;;) {
+        if (!pcm->running) {
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE))
+                return oops(pcm, errno, "cannot prepare channel");
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_START))
+                return oops(pcm, errno, "cannot start channel");
+            pcm->running = 1;
+        }
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_READI_FRAMES, &x)) {
+            pcm->running = 0;
+            if (errno == EPIPE) {
+                    /* we failed to make our window -- try to restart */
+                pcm->underruns++;
+                continue;
+            }
+            return oops(pcm, errno, "cannot read stream data");
+        }
+
+        /*delay for a bug:sometime no sound*/
+        if(size == 0)
+        	usleep(100000);        
+        
+//        LOGV("read() got %d frames", x.frames);
+		if(!(pcm->flags & PCM_MONO))
+		{
+				//LOGI("read() get %d", x.frames);
+			if(channalFlags == -1 )	
+			{
+				if(startCheckCount < SAMPLECOUNT)
+				{
+					startCheckCount += count;
+				}
+				else
+				{
+					channalFlags = channel_check(data,count/2);
+				}
+			}//if(channalFlags == -1)
+
+			channel_fixed(data,count/2, channalFlags);
+		}
+        return 0;
+    }
+}
+
+static struct pcm bad_pcm = {
+    .fd = -1,
+};
+
+int pcm_close(struct pcm *pcm)
+{
+    if (pcm == &bad_pcm)
+        return 0;
+
+    if (pcm->fd >= 0)
+        close(pcm->fd);
+    pcm->running = 0;
+    pcm->buffer_size = 0;
+    pcm->fd = -1;
+    return 0;
+}
+
+struct pcm *pcm_open(unsigned flags)
+{
+    const char *dname;
+    struct pcm *pcm;
+    struct snd_pcm_info info;
+    struct snd_pcm_hw_params params;
+    struct snd_pcm_sw_params sparams;
+    unsigned period_sz;
+    unsigned period_cnt;
+
+    LOGV("pcm_open(0x%08x)",flags);
+
+    pcm = calloc(1, sizeof(struct pcm));
+    if (!pcm)
+        return &bad_pcm;
+
+__open_again:
+
+    if (flags & PCM_IN) {
+        dname = "/dev/snd/pcmC0D0c";
+    } else {
+        if (flags & PCM_CARD1)
+            dname = "/dev/snd/pcmC1D0p";
+        else
+            dname = "/dev/snd/pcmC0D0p";
+    }
+
+    LOGV("pcm_open() period sz multiplier %d",
+         ((flags & PCM_PERIOD_SZ_MASK) >> PCM_PERIOD_SZ_SHIFT) + 1);
+    period_sz = 128 * (((flags & PCM_PERIOD_SZ_MASK) >> PCM_PERIOD_SZ_SHIFT) + 1);
+    LOGV("pcm_open() period cnt %d",
+         ((flags & PCM_PERIOD_CNT_MASK) >> PCM_PERIOD_CNT_SHIFT) + PCM_PERIOD_CNT_MIN);
+    period_cnt = 4;//((flags & PCM_PERIOD_CNT_MASK) >> PCM_PERIOD_CNT_SHIFT) + PCM_PERIOD_CNT_MIN;
+
+    pcm->flags = flags;
+    pcm->fd = open(dname, O_RDWR|O_CLOEXEC);
+    if (pcm->fd < 0) {
+        oops(pcm, errno, "cannot open device '%s'", dname);
+        if (flags & PCM_CARD1) {
+            LOGV("Open sound card1 for HDMI error, open sound card0");
+            flags &= ~PCM_CARD1;
+            goto __open_again;
+        }
+        return pcm;
+    }
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_INFO, &info)) {
+        oops(pcm, errno, "cannot get info - %s", dname);
+        goto fail;
+    }
+    info_dump(&info);
+
+    LOGV("pcm_open() period_cnt %d period_sz %d channels %d",
+         period_cnt, period_sz, (flags & PCM_MONO) ? 1 : 2);
+
+    param_init(&params);
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                   SNDRV_PCM_ACCESS_RW_INTERLEAVED);
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_FORMAT,
+                   SNDRV_PCM_FORMAT_S16_LE);
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_SUBFORMAT,
+                   SNDRV_PCM_SUBFORMAT_STD);
+	
+    param_set_min(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, period_sz);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS, 16);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
+                  (flags & PCM_MONO) ? 16 : 32);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_CHANNELS,
+                  (flags & PCM_MONO) ? 1 : 2);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, period_cnt);
+    if (flags & PCM_8000HZ) {
+        LOGD("set audio capture 8KHz");
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, 8000);
+    } else
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, 44100);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params)) {
+        oops(pcm, errno, "cannot set hw params");
+        goto fail;
+    }
+    param_dump(&params);
+
+    memset(&sparams, 0, sizeof(sparams));
+    sparams.tstamp_mode = SNDRV_PCM_TSTAMP_NONE;
+    sparams.period_step = 1;
+    sparams.avail_min = 1;
+    sparams.start_threshold = period_cnt * period_sz;
+    sparams.stop_threshold = period_cnt * period_sz;
+    sparams.xfer_align = period_sz / 2; /* needed for old kernels */
+    sparams.silence_size = 0;
+    sparams.silence_threshold = 0;
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SW_PARAMS, &sparams)) {
+        oops(pcm, errno, "cannot set sw params");
+        goto fail;
+    }
+
+    pcm->buffer_size = period_cnt * period_sz;
+    pcm->underruns = 0;
+    return pcm;
+
+fail:
+    close(pcm->fd);
+    pcm->fd = -1;
+    return pcm;
+}
+
+int pcm_ready(struct pcm *pcm)
+{
+    return pcm->fd >= 0;
+}
diff --git a/bootable/recovery/pcba_core/audiodev_test/alsa_route.c b/bootable/recovery/pcba_core/audiodev_test/alsa_route.c
new file mode 100644
index 0000000000..6b0da0adba
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/alsa_route.c
@@ -0,0 +1,510 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+ */
+
+/*
+ * @file alsa_route.c
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#define LOG_TAG "alsa_route"
+
+//#define LOG_NDEBUG 0
+
+#include <cutils/log.h>
+#include <cutils/config_utils.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <math.h>
+
+#include <linux/ioctl.h>
+#include "alsa_audio.h"
+#include "asound.h"
+
+#include "codec_config/config_list.h"
+
+#define DBG 1
+#if DBG
+#define LOGINFO(args...) printf(args)
+#define LOGERR(args...) fprintf(stderr, args)
+#else
+#define LOGINFO(args...)
+#define LOGERR(args...)
+#endif
+struct alsa_route
+{
+    const struct config_route_table *route_table;
+    struct mixer* mMixerPlayback;
+    struct mixer* mMixerCapture;
+};
+
+struct alsa_route *gpalsaroute;
+/**
+ * @brief route_init
+ *
+ * @returns
+ */
+int route_card_init(void **pproute_data, int card)
+{
+    char soundcard[32];
+    char soundCardID[20] = "";
+    static FILE *fp;
+    unsigned i, config_count = sizeof(sound_card_config_list) / sizeof(struct alsa_sound_card_config);
+    size_t read_size;
+    struct alsa_route *palsa_route;
+    const struct config_route_table *route_table = NULL;
+
+    printf("route_card_init(card %d)", card);
+    if (NULL == pproute_data) {
+        LOGERR("route_card_init:pproute_data can not be null\n");
+        return -1;
+    }
+    palsa_route = (struct alsa_route *)malloc(sizeof(*palsa_route));
+    if (!palsa_route) {
+        LOGERR("route_card_init:malloc palsa_route fail");
+        return -1;
+    }
+    memset(palsa_route, 0, sizeof(*palsa_route));
+    sprintf(soundcard, "/proc/asound/card%d/id", card);
+    fp = fopen(soundcard, "rt");
+    if (!fp) {
+        LOGERR("Open %s error!\n", soundcard);
+    } else {
+        read_size = fread(soundCardID, sizeof(char), sizeof(soundCardID), fp);
+        fclose(fp);
+        if (soundCardID[read_size - 1] == '\n') {
+            read_size--;
+            soundCardID[read_size] = '\0';
+        }
+        LOGINFO("Sound card%d is %s\n", card, soundCardID);
+        for (i = 0; i < config_count; i++) {
+            if (!(sound_card_config_list + i) || !sound_card_config_list[i].sound_card_name ||
+                !sound_card_config_list[i].route_table)
+                continue;
+            if (strncmp(sound_card_config_list[i].sound_card_name, soundCardID, read_size) == 0) {
+                route_table = sound_card_config_list[i].route_table;
+                LOGERR("Get route table for sound card0 %s\n", soundCardID);
+            }
+        }
+    }
+    if (!route_table) {
+        route_table = (void *)&default_config_table;
+        LOGERR("Can not get config table for sound card0 %s, so get default config table.\n", soundCardID);
+    }
+    palsa_route->route_table = route_table;
+    *pproute_data = (void *)palsa_route;
+    return 0;
+}
+
+/**
+ * @brief get_route_config 
+ *
+ * @param route
+ *
+ * @returns 
+ */
+const struct config_route *get_route_config(void *proute_data, unsigned route)
+{
+    struct alsa_route *palsa_route = (struct alsa_route *)proute_data;
+    const struct config_route_table *route_table;
+
+    LOGINFO("get_route_config() route %d\n", route);
+    if (NULL == palsa_route) {
+        LOGERR("get_route_config:palsa_route can not be null\n");
+        return NULL;
+    }
+    route_table = palsa_route->route_table;
+    if (!route_table) {
+        LOGERR("get_route_config() route_table is NULL!\n");
+        return NULL;
+    }
+    switch (route) {
+    case SPEAKER_NORMAL_ROUTE:
+        return &(route_table->speaker_normal);
+    case SPEAKER_INCALL_ROUTE:
+        return &(route_table->speaker_incall);
+    case SPEAKER_RINGTONE_ROUTE:
+        return &(route_table->speaker_ringtone);
+    case SPEAKER_VOIP_ROUTE:
+        return &(route_table->speaker_voip);
+    case EARPIECE_NORMAL_ROUTE:
+        return &(route_table->earpiece_normal);
+    case EARPIECE_INCALL_ROUTE:
+        return &(route_table->earpiece_incall);
+    case EARPIECE_RINGTONE_ROUTE:
+        return &(route_table->earpiece_ringtone);
+    case EARPIECE_VOIP_ROUTE:
+        return &(route_table->earpiece_voip);
+    case HEADPHONE_NORMAL_ROUTE:
+        return &(route_table->headphone_normal);
+    case HEADPHONE_INCALL_ROUTE:
+        return &(route_table->headphone_incall);
+    case HEADPHONE_RINGTONE_ROUTE:
+        return &(route_table->headphone_ringtone);
+    case SPEAKER_HEADPHONE_NORMAL_ROUTE:
+        return &(route_table->speaker_headphone_normal);
+    case SPEAKER_HEADPHONE_RINGTONE_ROUTE:
+        return &(route_table->speaker_headphone_ringtone);
+    case HEADPHONE_VOIP_ROUTE:
+        return &(route_table->headphone_voip);
+    case HEADSET_NORMAL_ROUTE:
+        return &(route_table->headset_normal);
+    case HEADSET_INCALL_ROUTE:
+        return &(route_table->headset_incall);
+    case HEADSET_RINGTONE_ROUTE:
+        return &(route_table->headset_ringtone);
+    case HEADSET_VOIP_ROUTE:
+        return &(route_table->headset_voip);
+    case BLUETOOTH_NORMAL_ROUTE:
+        return &(route_table->bluetooth_normal);
+    case BLUETOOTH_INCALL_ROUTE:
+        return &(route_table->bluetooth_incall);
+    case BLUETOOTH_VOIP_ROUTE:
+        return &(route_table->bluetooth_voip);
+    case MAIN_MIC_CAPTURE_ROUTE:
+        return &(route_table->main_mic_capture);
+    case HANDS_FREE_MIC_CAPTURE_ROUTE:
+        return &(route_table->hands_free_mic_capture);
+    case BLUETOOTH_SOC_MIC_CAPTURE_ROUTE:
+        return &(route_table->bluetooth_sco_mic_capture);
+    case PLAYBACK_OFF_ROUTE:
+        return &(route_table->playback_off);
+    case CAPTURE_OFF_ROUTE:
+        return &(route_table->capture_off);
+    case INCALL_OFF_ROUTE:
+        return &(route_table->incall_off);
+    case VOIP_OFF_ROUTE:
+        return &(route_table->voip_off);
+    case HDMI_NORMAL_ROUTE:
+        return &(route_table->hdmi_normal);
+    case USB_NORMAL_ROUTE:
+        return &(route_table->usb_normal);
+    case USB_CAPTURE_ROUTE:
+        return &(route_table->usb_capture);
+    case SPDIF_NORMAL_ROUTE:
+        return &(route_table->spdif_normal);
+    case HDMI_IN_NORMAL_ROUTE:
+        return &(route_table->hdmiin_normal);
+    case HDMI_IN_OFF_ROUTE:
+        return &(route_table->hdmiin_off);
+    case HDMI_IN_CAPTURE_ROUTE:
+        return &(route_table->hdmiin_captrue);
+    case HDMI_IN_CAPTURE_OFF_ROUTE:
+        return &(route_table->hdmiin_captrue_off);
+    default:
+        LOGERR("get_route_config() Error route %d\n", route);
+        return NULL;
+    }
+}
+
+/**
+ * @brief set_controls 
+ *
+ * @param mixer
+ * @param ctls
+ * @param ctls_count
+ *
+ * @returns 
+ */
+int set_controls(struct mixer *mixer, const struct config_control *ctls, const unsigned int ctls_count)
+{
+    struct mixer_ctl *ctl;
+    unsigned i;
+
+    LOGINFO("set_controls() ctls_count %d\n", ctls_count);
+    if (!ctls || ctls_count <= 0) {
+        LOGERR("set_controls() ctls is NULL\n");
+        return 0;
+    }
+    for (i = 0; i < ctls_count; i++) {
+        ctl = mixer_get_control(mixer, ctls[i].ctl_name, 0);
+        if (!ctl) {
+            LOGERR("set_controls() Can not get ctl : %s\n", ctls[i].ctl_name);
+            return -EINVAL;
+        }
+        if (ctl->info->type != SNDRV_CTL_ELEM_TYPE_BOOLEAN &&
+            ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER &&
+            ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER64 &&
+            ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+            LOGERR("set_controls() ctl %s is not a type of INT or ENUMERATED\n", ctls[i].ctl_name);
+            return -EINVAL;
+        }
+        if (ctls[i].str_val) {
+            if (ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+                LOGERR("set_controls() ctl %s is not a type of ENUMERATED\n", ctls[i].ctl_name);
+                return -EINVAL;
+            }
+            if (mixer_ctl_select(ctl, ctls[i].str_val) != 0) {
+                LOGERR("set_controls() Can not set ctl %s to %s\n", ctls[i].ctl_name, ctls[i].str_val);
+                return -EINVAL;
+            }
+            LOGINFO("set_controls() set ctl %s to %s\n", ctls[i].ctl_name, ctls[i].str_val);
+        } else {
+            if (mixer_ctl_set_int_double(ctl, ctls[i].int_val[0], ctls[i].int_val[1]) != 0) {
+                LOGERR("set_controls() can not set ctl %s to %d\n", ctls[i].ctl_name, ctls[i].int_val[0]);
+                return -EINVAL;
+            }
+            LOGINFO("set_controls() set ctl %s to %d\n", ctls[i].ctl_name, ctls[i].int_val[0]);
+        }
+    }
+    return 0;
+}
+
+/**
+ * @brief route_set_controls 
+ *
+ * @param route
+ *
+ * @returns 
+ */
+int route_set_controls(void *proute_data, unsigned route)
+{
+    struct alsa_route *palsa_route = (struct alsa_route *)proute_data;
+    const struct config_route *route_info = NULL;
+    struct mixer *mMixer = NULL;
+
+    if (NULL == palsa_route) {
+        LOGERR("route_set_controls:palsa_route can not be null\n");
+        return 0;
+    }
+    if (route >= MAX_ROUTE) {
+        LOGERR("route_set_controls() route %d error!\n", route);
+        return -EINVAL;
+    }
+#ifdef SUPPORT_USB //usb input maybe used for primary
+    if (route != USB_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != MAIN_MIC_CAPTURE_ROUTE &&
+        route != HANDS_FREE_MIC_CAPTURE_ROUTE &&
+        route != BLUETOOTH_SOC_MIC_CAPTURE_ROUTE) {
+        ALOGV("route %d error for usb sound card!\n", route);
+        return -EINVAL;
+    }
+#else //primary input maybe used for usb
+    if (route > SPDIF_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != HDMI_IN_NORMAL_ROUTE &&
+        route != HDMI_IN_OFF_ROUTE &&
+        route != HDMI_IN_CAPTURE_ROUTE &&
+        route != HDMI_IN_CAPTURE_OFF_ROUTE) {
+        LOGERR("route %d error for codec or hdmi!\n", route);
+        return -EINVAL;
+    }
+#endif
+    LOGINFO("route_set_controls() set route %d\n", route);
+    mMixer = is_playback_route(route) ? palsa_route->mMixerPlayback : palsa_route->mMixerCapture;
+    if (!mMixer) {
+        LOGERR("route_set_controls() mMixer is NULL!\n");
+        return -EINVAL;
+    }
+    route_info = get_route_config(proute_data, route);
+    if (!route_info) {
+        LOGERR("route_set_controls() Can not get config of route\n");
+        return -EINVAL;
+    }
+    if (route_info->controls_count > 0)
+        set_controls(mMixer, route_info->controls, route_info->controls_count);
+    return 0;
+}
+
+/**
+ * @brief route_uninit 
+ */
+void route_uninit(void *proute_data)
+{
+    LOGINFO("route_uninit()\n");
+    route_pcm_close(proute_data, PLAYBACK_OFF_ROUTE);
+    route_pcm_close(proute_data, CAPTURE_OFF_ROUTE);
+}
+
+/**
+ * @brief is_playback_route 
+ *
+ * @param route
+ *
+ * @returns 
+ */
+int is_playback_route(unsigned route)
+{
+    switch (route) {
+    case MAIN_MIC_CAPTURE_ROUTE:
+    case HANDS_FREE_MIC_CAPTURE_ROUTE:
+    case BLUETOOTH_SOC_MIC_CAPTURE_ROUTE:
+    case CAPTURE_OFF_ROUTE:
+    case USB_CAPTURE_ROUTE:
+    case HDMI_IN_NORMAL_ROUTE:
+    case HDMI_IN_OFF_ROUTE:
+    case HDMI_IN_CAPTURE_ROUTE:
+    case HDMI_IN_CAPTURE_OFF_ROUTE:
+        return 0;
+    case SPEAKER_NORMAL_ROUTE:
+    case SPEAKER_INCALL_ROUTE:
+    case SPEAKER_RINGTONE_ROUTE:
+    case SPEAKER_VOIP_ROUTE:
+    case EARPIECE_NORMAL_ROUTE:
+    case EARPIECE_INCALL_ROUTE:
+    case EARPIECE_RINGTONE_ROUTE:
+    case EARPIECE_VOIP_ROUTE:
+    case HEADPHONE_NORMAL_ROUTE:
+    case HEADPHONE_INCALL_ROUTE:
+    case HEADPHONE_RINGTONE_ROUTE:
+    case SPEAKER_HEADPHONE_NORMAL_ROUTE:
+    case SPEAKER_HEADPHONE_RINGTONE_ROUTE:
+    case HEADPHONE_VOIP_ROUTE:
+    case HEADSET_NORMAL_ROUTE:
+    case HEADSET_INCALL_ROUTE:
+    case HEADSET_RINGTONE_ROUTE:
+    case HEADSET_VOIP_ROUTE:
+    case BLUETOOTH_NORMAL_ROUTE:
+    case BLUETOOTH_INCALL_ROUTE:
+    case BLUETOOTH_VOIP_ROUTE:
+    case PLAYBACK_OFF_ROUTE:
+    case INCALL_OFF_ROUTE:
+    case VOIP_OFF_ROUTE:
+    case HDMI_NORMAL_ROUTE:
+    case USB_NORMAL_ROUTE:
+    case SPDIF_NORMAL_ROUTE:
+        return 1;
+    default:
+        LOGERR("is_playback_route() Error route %d\n", route);
+        return -EINVAL;
+    }
+}
+
+/**
+ * @brief route_pcm_open
+ *
+ * @param route
+ */
+void route_pcm_card_open(void **pproute_data, int card, unsigned route)
+{
+    struct alsa_route *palsa_route;
+    const struct config_route *route_info;
+    int is_playback;
+
+    LOGINFO("route_pcm_card_open(card %d, route %d)\n", card, route);
+    if (NULL == pproute_data) {
+        LOGERR("route_pcm_card_open:pproute_data can not be null\n");
+        goto __exit;
+    }
+    if (route >= MAX_ROUTE) {
+        LOGERR("route_pcm_card_open() route %d error!\n", route);
+        goto __exit;
+    }
+    if (card < 0) {
+        LOGERR("route_pcm_card_open() card %d error!\n", card);
+        goto __exit;
+    }
+#ifdef SUPPORT_USB //usb input maybe used for primary
+
+	if (route != USB_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != MAIN_MIC_CAPTURE_ROUTE &&
+        route != HANDS_FREE_MIC_CAPTURE_ROUTE &&
+        route != BLUETOOTH_SOC_MIC_CAPTURE_ROUTE) {
+        ALOGV("route %d error for usb sound card!", route);
+        goto __exit;
+    }
+#else //primary input maybe used for usb
+    if (route > BLUETOOTH_SOC_MIC_CAPTURE_ROUTE &&
+        route != HDMI_NORMAL_ROUTE &&
+        route != SPDIF_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != HDMI_IN_NORMAL_ROUTE &&
+        route != HDMI_IN_OFF_ROUTE &&
+        route != PLAYBACK_OFF_ROUTE) {
+        LOGERR("route %d error for codec or hdmi!\n", route);
+        goto __exit;
+    }
+#endif
+
+
+
+    is_playback = is_playback_route(route);
+
+    if (!pproute_data) {
+        route_card_init(pproute_data, card);
+    }
+    palsa_route = *((struct alsa_route **)pproute_data);
+    if (NULL == palsa_route) {
+        LOGERR("route_pcm_close:palsa_route can not be null\n");
+        goto __exit;
+    }
+    route_info = get_route_config(palsa_route, route);
+    if (!route_info) {
+        LOGERR("route_pcm_open() Can not get config of route\n");
+        goto __exit;
+    }
+    if (is_playback) {
+        //close all route and pcm
+        if (palsa_route->mMixerPlayback) {
+            route_set_controls(palsa_route, INCALL_OFF_ROUTE);
+            route_set_controls(palsa_route, VOIP_OFF_ROUTE);
+        }
+        route_pcm_close(palsa_route, PLAYBACK_OFF_ROUTE);
+    } else {
+        route_pcm_close(palsa_route, CAPTURE_OFF_ROUTE);
+    }
+    if (is_playback) {
+        if (palsa_route->mMixerPlayback == NULL)
+            palsa_route->mMixerPlayback = mixer_open_legacy(card);
+    } else {
+        if (palsa_route->mMixerCapture == NULL)
+            palsa_route->mMixerCapture = mixer_open_legacy(card);
+    }
+    if (route_info->controls_count > 0)
+        route_set_controls(palsa_route, route);
+__exit:
+	LOGINFO("route_pcm_open exit\n");
+
+}
+
+/**
+ * @brief route_pcm_close 
+ *
+ * @param route
+ *
+ * @returns 
+ */
+int route_pcm_close(void *proute_data, unsigned route)
+{
+    struct alsa_route *palsa_route = (struct alsa_route *)proute_data;
+
+    if (NULL == palsa_route) {
+        LOGERR("route_pcm_close:palsa_route can not be null\n");
+        return 0;
+    }
+    if (route != PLAYBACK_OFF_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != INCALL_OFF_ROUTE &&
+        route != VOIP_OFF_ROUTE &&
+        route != HDMI_IN_CAPTURE_OFF_ROUTE) {
+        LOGERR("route_pcm_close() is not a off route\n");
+        return 0;
+    }
+    LOGINFO("route_pcm_close() route %d\n", route);
+    route_set_controls(proute_data, route);
+    if (route == PLAYBACK_OFF_ROUTE) {
+        if (palsa_route->mMixerPlayback) {
+            mixer_close_legacy(palsa_route->mMixerPlayback);
+            palsa_route->mMixerPlayback = NULL;
+        }
+    } else if (route == CAPTURE_OFF_ROUTE) {
+        if (palsa_route->mMixerCapture) {
+            mixer_close_legacy(palsa_route->mMixerCapture);
+            palsa_route->mMixerCapture = NULL;
+        }
+    }
+    return 0;
+}
diff --git a/bootable/recovery/pcba_core/audiodev_test/asound.h b/bootable/recovery/pcba_core/audiodev_test/asound.h
new file mode 100644
index 0000000000..0fdb029686
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/asound.h
@@ -0,0 +1,836 @@
+/****************************************************************************
+ ****************************************************************************
+ ***
+ ***   This header was automatically generated from a Linux kernel header
+ ***   of the same name, to make information necessary for userspace to
+ ***   call into the kernel available to libc.  It contains only constants,
+ ***   structures, and macros generated from the original header, and thus,
+ ***   contains no copyrightable information.
+ ***
+ ****************************************************************************
+ ****************************************************************************/
+#ifndef __SOUND_ASOUND_H
+#define __SOUND_ASOUND_H
+
+#include <linux/types.h>
+
+#define SNDRV_PROTOCOL_VERSION(major, minor, subminor) (((major)<<16)|((minor)<<8)|(subminor))
+#define SNDRV_PROTOCOL_MAJOR(version) (((version)>>16)&0xffff)
+#define SNDRV_PROTOCOL_MINOR(version) (((version)>>8)&0xff)
+#define SNDRV_PROTOCOL_MICRO(version) ((version)&0xff)
+#define SNDRV_PROTOCOL_INCOMPATIBLE(kversion, uversion)   (SNDRV_PROTOCOL_MAJOR(kversion) != SNDRV_PROTOCOL_MAJOR(uversion) ||   (SNDRV_PROTOCOL_MAJOR(kversion) == SNDRV_PROTOCOL_MAJOR(uversion) &&   SNDRV_PROTOCOL_MINOR(kversion) != SNDRV_PROTOCOL_MINOR(uversion)))
+
+struct snd_aes_iec958 {
+ unsigned char status[24];
+ unsigned char subcode[147];
+ unsigned char pad;
+ unsigned char dig_subframe[4];
+};
+
+#define SNDRV_HWDEP_VERSION SNDRV_PROTOCOL_VERSION(1, 0, 1)
+
+enum {
+ SNDRV_HWDEP_IFACE_OPL2 = 0,
+ SNDRV_HWDEP_IFACE_OPL3,
+ SNDRV_HWDEP_IFACE_OPL4,
+ SNDRV_HWDEP_IFACE_SB16CSP,
+ SNDRV_HWDEP_IFACE_EMU10K1,
+ SNDRV_HWDEP_IFACE_YSS225,
+ SNDRV_HWDEP_IFACE_ICS2115,
+ SNDRV_HWDEP_IFACE_SSCAPE,
+ SNDRV_HWDEP_IFACE_VX,
+ SNDRV_HWDEP_IFACE_MIXART,
+ SNDRV_HWDEP_IFACE_USX2Y,
+ SNDRV_HWDEP_IFACE_EMUX_WAVETABLE,
+ SNDRV_HWDEP_IFACE_BLUETOOTH,
+ SNDRV_HWDEP_IFACE_USX2Y_PCM,
+ SNDRV_HWDEP_IFACE_PCXHR,
+ SNDRV_HWDEP_IFACE_SB_RC,
+ SNDRV_HWDEP_IFACE_HDA,
+ SNDRV_HWDEP_IFACE_USB_STREAM,
+
+ SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_USB_STREAM
+};
+
+struct snd_hwdep_info {
+ unsigned int device;
+ int card;
+ unsigned char id[64];
+ unsigned char name[80];
+ int iface;
+ unsigned char reserved[64];
+};
+
+struct snd_hwdep_dsp_status {
+ unsigned int version;
+ unsigned char id[32];
+ unsigned int num_dsps;
+ unsigned int dsp_loaded;
+ unsigned int chip_ready;
+ unsigned char reserved[16];
+};
+
+struct snd_hwdep_dsp_image {
+ unsigned int index;
+ unsigned char name[64];
+ unsigned char __user *image;
+ size_t length;
+ unsigned long driver_data;
+};
+
+#define SNDRV_HWDEP_IOCTL_PVERSION _IOR ('H', 0x00, int)
+#define SNDRV_HWDEP_IOCTL_INFO _IOR ('H', 0x01, struct snd_hwdep_info)
+#define SNDRV_HWDEP_IOCTL_DSP_STATUS _IOR('H', 0x02, struct snd_hwdep_dsp_status)
+#define SNDRV_HWDEP_IOCTL_DSP_LOAD _IOW('H', 0x03, struct snd_hwdep_dsp_image)
+
+#define SNDRV_PCM_VERSION SNDRV_PROTOCOL_VERSION(2, 0, 10)
+
+typedef unsigned long snd_pcm_uframes_t;
+typedef signed long snd_pcm_sframes_t;
+
+enum {
+ SNDRV_PCM_CLASS_GENERIC = 0,
+ SNDRV_PCM_CLASS_MULTI,
+ SNDRV_PCM_CLASS_MODEM,
+ SNDRV_PCM_CLASS_DIGITIZER,
+
+ SNDRV_PCM_CLASS_LAST = SNDRV_PCM_CLASS_DIGITIZER,
+};
+
+enum {
+ SNDRV_PCM_SUBCLASS_GENERIC_MIX = 0,
+ SNDRV_PCM_SUBCLASS_MULTI_MIX,
+
+ SNDRV_PCM_SUBCLASS_LAST = SNDRV_PCM_SUBCLASS_MULTI_MIX,
+};
+
+enum {
+ SNDRV_PCM_STREAM_PLAYBACK = 0,
+ SNDRV_PCM_STREAM_CAPTURE,
+ SNDRV_PCM_STREAM_LAST = SNDRV_PCM_STREAM_CAPTURE,
+};
+
+typedef int __bitwise snd_pcm_access_t;
+#define SNDRV_PCM_ACCESS_MMAP_INTERLEAVED ((__force snd_pcm_access_t) 0)  
+#define SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED ((__force snd_pcm_access_t) 1)  
+#define SNDRV_PCM_ACCESS_MMAP_COMPLEX ((__force snd_pcm_access_t) 2)  
+#define SNDRV_PCM_ACCESS_RW_INTERLEAVED ((__force snd_pcm_access_t) 3)  
+#define SNDRV_PCM_ACCESS_RW_NONINTERLEAVED ((__force snd_pcm_access_t) 4)  
+#define SNDRV_PCM_ACCESS_LAST SNDRV_PCM_ACCESS_RW_NONINTERLEAVED
+
+typedef int __bitwise snd_pcm_format_t;
+#define SNDRV_PCM_FORMAT_S8 ((__force snd_pcm_format_t) 0)
+#define SNDRV_PCM_FORMAT_U8 ((__force snd_pcm_format_t) 1)
+#define SNDRV_PCM_FORMAT_S16_LE ((__force snd_pcm_format_t) 2)
+#define SNDRV_PCM_FORMAT_S16_BE ((__force snd_pcm_format_t) 3)
+#define SNDRV_PCM_FORMAT_U16_LE ((__force snd_pcm_format_t) 4)
+#define SNDRV_PCM_FORMAT_U16_BE ((__force snd_pcm_format_t) 5)
+#define SNDRV_PCM_FORMAT_S24_LE ((__force snd_pcm_format_t) 6)  
+#define SNDRV_PCM_FORMAT_S24_BE ((__force snd_pcm_format_t) 7)  
+#define SNDRV_PCM_FORMAT_U24_LE ((__force snd_pcm_format_t) 8)  
+#define SNDRV_PCM_FORMAT_U24_BE ((__force snd_pcm_format_t) 9)  
+#define SNDRV_PCM_FORMAT_S32_LE ((__force snd_pcm_format_t) 10)
+#define SNDRV_PCM_FORMAT_S32_BE ((__force snd_pcm_format_t) 11)
+#define SNDRV_PCM_FORMAT_U32_LE ((__force snd_pcm_format_t) 12)
+#define SNDRV_PCM_FORMAT_U32_BE ((__force snd_pcm_format_t) 13)
+#define SNDRV_PCM_FORMAT_FLOAT_LE ((__force snd_pcm_format_t) 14)  
+#define SNDRV_PCM_FORMAT_FLOAT_BE ((__force snd_pcm_format_t) 15)  
+#define SNDRV_PCM_FORMAT_FLOAT64_LE ((__force snd_pcm_format_t) 16)  
+#define SNDRV_PCM_FORMAT_FLOAT64_BE ((__force snd_pcm_format_t) 17)  
+#define SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE ((__force snd_pcm_format_t) 18)  
+#define SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE ((__force snd_pcm_format_t) 19)  
+#define SNDRV_PCM_FORMAT_MU_LAW ((__force snd_pcm_format_t) 20)
+#define SNDRV_PCM_FORMAT_A_LAW ((__force snd_pcm_format_t) 21)
+#define SNDRV_PCM_FORMAT_IMA_ADPCM ((__force snd_pcm_format_t) 22)
+#define SNDRV_PCM_FORMAT_MPEG ((__force snd_pcm_format_t) 23)
+#define SNDRV_PCM_FORMAT_GSM ((__force snd_pcm_format_t) 24)
+#define SNDRV_PCM_FORMAT_SPECIAL ((__force snd_pcm_format_t) 31)
+#define SNDRV_PCM_FORMAT_S24_3LE ((__force snd_pcm_format_t) 32)  
+#define SNDRV_PCM_FORMAT_S24_3BE ((__force snd_pcm_format_t) 33)  
+#define SNDRV_PCM_FORMAT_U24_3LE ((__force snd_pcm_format_t) 34)  
+#define SNDRV_PCM_FORMAT_U24_3BE ((__force snd_pcm_format_t) 35)  
+#define SNDRV_PCM_FORMAT_S20_3LE ((__force snd_pcm_format_t) 36)  
+#define SNDRV_PCM_FORMAT_S20_3BE ((__force snd_pcm_format_t) 37)  
+#define SNDRV_PCM_FORMAT_U20_3LE ((__force snd_pcm_format_t) 38)  
+#define SNDRV_PCM_FORMAT_U20_3BE ((__force snd_pcm_format_t) 39)  
+#define SNDRV_PCM_FORMAT_S18_3LE ((__force snd_pcm_format_t) 40)  
+#define SNDRV_PCM_FORMAT_S18_3BE ((__force snd_pcm_format_t) 41)  
+#define SNDRV_PCM_FORMAT_U18_3LE ((__force snd_pcm_format_t) 42)  
+#define SNDRV_PCM_FORMAT_U18_3BE ((__force snd_pcm_format_t) 43)  
+#define SNDRV_PCM_FORMAT_LAST SNDRV_PCM_FORMAT_U18_3BE
+
+#ifdef SNDRV_LITTLE_ENDIAN
+#define SNDRV_PCM_FORMAT_S16 SNDRV_PCM_FORMAT_S16_LE
+#define SNDRV_PCM_FORMAT_U16 SNDRV_PCM_FORMAT_U16_LE
+#define SNDRV_PCM_FORMAT_S24 SNDRV_PCM_FORMAT_S24_LE
+#define SNDRV_PCM_FORMAT_U24 SNDRV_PCM_FORMAT_U24_LE
+#define SNDRV_PCM_FORMAT_S32 SNDRV_PCM_FORMAT_S32_LE
+#define SNDRV_PCM_FORMAT_U32 SNDRV_PCM_FORMAT_U32_LE
+#define SNDRV_PCM_FORMAT_FLOAT SNDRV_PCM_FORMAT_FLOAT_LE
+#define SNDRV_PCM_FORMAT_FLOAT64 SNDRV_PCM_FORMAT_FLOAT64_LE
+#define SNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE
+#endif
+#ifdef SNDRV_BIG_ENDIAN
+#define SNDRV_PCM_FORMAT_S16 SNDRV_PCM_FORMAT_S16_BE
+#define SNDRV_PCM_FORMAT_U16 SNDRV_PCM_FORMAT_U16_BE
+#define SNDRV_PCM_FORMAT_S24 SNDRV_PCM_FORMAT_S24_BE
+#define SNDRV_PCM_FORMAT_U24 SNDRV_PCM_FORMAT_U24_BE
+#define SNDRV_PCM_FORMAT_S32 SNDRV_PCM_FORMAT_S32_BE
+#define SNDRV_PCM_FORMAT_U32 SNDRV_PCM_FORMAT_U32_BE
+#define SNDRV_PCM_FORMAT_FLOAT SNDRV_PCM_FORMAT_FLOAT_BE
+#define SNDRV_PCM_FORMAT_FLOAT64 SNDRV_PCM_FORMAT_FLOAT64_BE
+#define SNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE
+#endif
+
+typedef int __bitwise snd_pcm_subformat_t;
+#define SNDRV_PCM_SUBFORMAT_STD ((__force snd_pcm_subformat_t) 0)
+#define SNDRV_PCM_SUBFORMAT_LAST SNDRV_PCM_SUBFORMAT_STD
+
+#define SNDRV_PCM_INFO_MMAP 0x00000001  
+#define SNDRV_PCM_INFO_MMAP_VALID 0x00000002  
+#define SNDRV_PCM_INFO_DOUBLE 0x00000004  
+#define SNDRV_PCM_INFO_BATCH 0x00000010  
+#define SNDRV_PCM_INFO_INTERLEAVED 0x00000100  
+#define SNDRV_PCM_INFO_NONINTERLEAVED 0x00000200  
+#define SNDRV_PCM_INFO_COMPLEX 0x00000400  
+#define SNDRV_PCM_INFO_BLOCK_TRANSFER 0x00010000  
+#define SNDRV_PCM_INFO_OVERRANGE 0x00020000  
+#define SNDRV_PCM_INFO_RESUME 0x00040000  
+#define SNDRV_PCM_INFO_PAUSE 0x00080000  
+#define SNDRV_PCM_INFO_HALF_DUPLEX 0x00100000  
+#define SNDRV_PCM_INFO_JOINT_DUPLEX 0x00200000  
+#define SNDRV_PCM_INFO_SYNC_START 0x00400000  
+#define SNDRV_PCM_INFO_FIFO_IN_FRAMES 0x80000000  
+
+typedef int __bitwise snd_pcm_state_t;
+#define SNDRV_PCM_STATE_OPEN ((__force snd_pcm_state_t) 0)  
+#define SNDRV_PCM_STATE_SETUP ((__force snd_pcm_state_t) 1)  
+#define SNDRV_PCM_STATE_PREPARED ((__force snd_pcm_state_t) 2)  
+#define SNDRV_PCM_STATE_RUNNING ((__force snd_pcm_state_t) 3)  
+#define SNDRV_PCM_STATE_XRUN ((__force snd_pcm_state_t) 4)  
+#define SNDRV_PCM_STATE_DRAINING ((__force snd_pcm_state_t) 5)  
+#define SNDRV_PCM_STATE_PAUSED ((__force snd_pcm_state_t) 6)  
+#define SNDRV_PCM_STATE_SUSPENDED ((__force snd_pcm_state_t) 7)  
+#define SNDRV_PCM_STATE_DISCONNECTED ((__force snd_pcm_state_t) 8)  
+#define SNDRV_PCM_STATE_LAST SNDRV_PCM_STATE_DISCONNECTED
+
+enum {
+ SNDRV_PCM_MMAP_OFFSET_DATA = 0x00000000,
+ SNDRV_PCM_MMAP_OFFSET_STATUS = 0x80000000,
+ SNDRV_PCM_MMAP_OFFSET_CONTROL = 0x81000000,
+};
+
+union snd_pcm_sync_id {
+ unsigned char id[16];
+ unsigned short id16[8];
+ unsigned int id32[4];
+};
+
+struct snd_pcm_info {
+ unsigned int device;
+ unsigned int subdevice;
+ int stream;
+ int card;
+ unsigned char id[64];
+ unsigned char name[80];
+ unsigned char subname[32];
+ int dev_class;
+ int dev_subclass;
+ unsigned int subdevices_count;
+ unsigned int subdevices_avail;
+ union snd_pcm_sync_id sync;
+ unsigned char reserved[64];
+};
+
+typedef int snd_pcm_hw_param_t;
+#define SNDRV_PCM_HW_PARAM_ACCESS 0  
+#define SNDRV_PCM_HW_PARAM_FORMAT 1  
+#define SNDRV_PCM_HW_PARAM_SUBFORMAT 2  
+#define SNDRV_PCM_HW_PARAM_FIRST_MASK SNDRV_PCM_HW_PARAM_ACCESS
+#define SNDRV_PCM_HW_PARAM_LAST_MASK SNDRV_PCM_HW_PARAM_SUBFORMAT
+
+#define SNDRV_PCM_HW_PARAM_SAMPLE_BITS 8  
+#define SNDRV_PCM_HW_PARAM_FRAME_BITS 9  
+#define SNDRV_PCM_HW_PARAM_CHANNELS 10  
+#define SNDRV_PCM_HW_PARAM_RATE 11  
+#define SNDRV_PCM_HW_PARAM_PERIOD_TIME 12  
+#define SNDRV_PCM_HW_PARAM_PERIOD_SIZE 13  
+#define SNDRV_PCM_HW_PARAM_PERIOD_BYTES 14  
+#define SNDRV_PCM_HW_PARAM_PERIODS 15  
+#define SNDRV_PCM_HW_PARAM_BUFFER_TIME 16  
+#define SNDRV_PCM_HW_PARAM_BUFFER_SIZE 17  
+#define SNDRV_PCM_HW_PARAM_BUFFER_BYTES 18  
+#define SNDRV_PCM_HW_PARAM_TICK_TIME 19  
+#define SNDRV_PCM_HW_PARAM_FIRST_INTERVAL SNDRV_PCM_HW_PARAM_SAMPLE_BITS
+#define SNDRV_PCM_HW_PARAM_LAST_INTERVAL SNDRV_PCM_HW_PARAM_TICK_TIME
+
+#define SNDRV_PCM_HW_PARAMS_NORESAMPLE (1<<0)  
+
+struct snd_interval {
+ unsigned int min, max;
+ unsigned int openmin:1,
+ openmax:1,
+ integer:1,
+ empty:1;
+};
+
+#define SNDRV_MASK_MAX 256
+
+struct snd_mask {
+ __u32 bits[(SNDRV_MASK_MAX+31)/32];
+};
+
+struct snd_pcm_hw_params {
+ unsigned int flags;
+ struct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK -
+ SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];
+ struct snd_mask mres[5];
+ struct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -
+ SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
+ struct snd_interval ires[9];
+ unsigned int rmask;
+ unsigned int cmask;
+ unsigned int info;
+ unsigned int msbits;
+ unsigned int rate_num;
+ unsigned int rate_den;
+ snd_pcm_uframes_t fifo_size;
+ unsigned char reserved[64];
+};
+
+enum {
+ SNDRV_PCM_TSTAMP_NONE = 0,
+ SNDRV_PCM_TSTAMP_ENABLE,
+ SNDRV_PCM_TSTAMP_LAST = SNDRV_PCM_TSTAMP_ENABLE,
+};
+
+struct snd_pcm_sw_params {
+ int tstamp_mode;
+ unsigned int period_step;
+ unsigned int sleep_min;
+ snd_pcm_uframes_t avail_min;
+ snd_pcm_uframes_t xfer_align;
+ snd_pcm_uframes_t start_threshold;
+ snd_pcm_uframes_t stop_threshold;
+ snd_pcm_uframes_t silence_threshold;
+ snd_pcm_uframes_t silence_size;
+ snd_pcm_uframes_t boundary;
+ unsigned char reserved[64];
+};
+
+struct snd_pcm_channel_info {
+ unsigned int channel;
+ __kernel_off_t offset;
+ unsigned int first;
+ unsigned int step;
+};
+
+struct snd_pcm_status {
+ snd_pcm_state_t state;
+ struct timespec trigger_tstamp;
+ struct timespec tstamp;
+ snd_pcm_uframes_t appl_ptr;
+ snd_pcm_uframes_t hw_ptr;
+ snd_pcm_sframes_t delay;
+ snd_pcm_uframes_t avail;
+ snd_pcm_uframes_t avail_max;
+ snd_pcm_uframes_t overrange;
+ snd_pcm_state_t suspended_state;
+ unsigned char reserved[60];
+};
+
+struct snd_pcm_mmap_status {
+ snd_pcm_state_t state;
+ int pad1;
+ snd_pcm_uframes_t hw_ptr;
+ struct timespec tstamp;
+ snd_pcm_state_t suspended_state;
+};
+
+struct snd_pcm_mmap_control {
+ snd_pcm_uframes_t appl_ptr;
+ snd_pcm_uframes_t avail_min;
+};
+
+#define SNDRV_PCM_SYNC_PTR_HWSYNC (1<<0)  
+#define SNDRV_PCM_SYNC_PTR_APPL (1<<1)  
+#define SNDRV_PCM_SYNC_PTR_AVAIL_MIN (1<<2)  
+
+struct snd_pcm_sync_ptr {
+ unsigned int flags;
+ union {
+ struct snd_pcm_mmap_status status;
+ unsigned char reserved[64];
+ } s;
+ union {
+ struct snd_pcm_mmap_control control;
+ unsigned char reserved[64];
+ } c;
+};
+
+struct snd_xferi {
+ snd_pcm_sframes_t result;
+ void __user *buf;
+ snd_pcm_uframes_t frames;
+};
+
+struct snd_xfern {
+ snd_pcm_sframes_t result;
+ void __user * __user *bufs;
+ snd_pcm_uframes_t frames;
+};
+
+enum {
+ SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,
+ SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,
+ SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,
+};
+
+#define SNDRV_PCM_IOCTL_PVERSION _IOR('A', 0x00, int)
+#define SNDRV_PCM_IOCTL_INFO _IOR('A', 0x01, struct snd_pcm_info)
+#define SNDRV_PCM_IOCTL_TSTAMP _IOW('A', 0x02, int)
+#define SNDRV_PCM_IOCTL_TTSTAMP _IOW('A', 0x03, int)
+#define SNDRV_PCM_IOCTL_HW_REFINE _IOWR('A', 0x10, struct snd_pcm_hw_params)
+#define SNDRV_PCM_IOCTL_HW_PARAMS _IOWR('A', 0x11, struct snd_pcm_hw_params)
+#define SNDRV_PCM_IOCTL_HW_FREE _IO('A', 0x12)
+#define SNDRV_PCM_IOCTL_SW_PARAMS _IOWR('A', 0x13, struct snd_pcm_sw_params)
+#define SNDRV_PCM_IOCTL_STATUS _IOR('A', 0x20, struct snd_pcm_status)
+#define SNDRV_PCM_IOCTL_DELAY _IOR('A', 0x21, snd_pcm_sframes_t)
+#define SNDRV_PCM_IOCTL_HWSYNC _IO('A', 0x22)
+#define SNDRV_PCM_IOCTL_SYNC_PTR _IOWR('A', 0x23, struct snd_pcm_sync_ptr)
+#define SNDRV_PCM_IOCTL_CHANNEL_INFO _IOR('A', 0x32, struct snd_pcm_channel_info)
+#define SNDRV_PCM_IOCTL_PREPARE _IO('A', 0x40)
+#define SNDRV_PCM_IOCTL_RESET _IO('A', 0x41)
+#define SNDRV_PCM_IOCTL_START _IO('A', 0x42)
+#define SNDRV_PCM_IOCTL_DROP _IO('A', 0x43)
+#define SNDRV_PCM_IOCTL_DRAIN _IO('A', 0x44)
+#define SNDRV_PCM_IOCTL_PAUSE _IOW('A', 0x45, int)
+#define SNDRV_PCM_IOCTL_REWIND _IOW('A', 0x46, snd_pcm_uframes_t)
+#define SNDRV_PCM_IOCTL_RESUME _IO('A', 0x47)
+#define SNDRV_PCM_IOCTL_XRUN _IO('A', 0x48)
+#define SNDRV_PCM_IOCTL_FORWARD _IOW('A', 0x49, snd_pcm_uframes_t)
+#define SNDRV_PCM_IOCTL_WRITEI_FRAMES _IOW('A', 0x50, struct snd_xferi)
+#define SNDRV_PCM_IOCTL_READI_FRAMES _IOR('A', 0x51, struct snd_xferi)
+#define SNDRV_PCM_IOCTL_WRITEN_FRAMES _IOW('A', 0x52, struct snd_xfern)
+#define SNDRV_PCM_IOCTL_READN_FRAMES _IOR('A', 0x53, struct snd_xfern)
+#define SNDRV_PCM_IOCTL_LINK _IOW('A', 0x60, int)
+#define SNDRV_PCM_IOCTL_UNLINK _IO('A', 0x61)
+
+#define SNDRV_RAWMIDI_VERSION SNDRV_PROTOCOL_VERSION(2, 0, 0)
+
+enum {
+ SNDRV_RAWMIDI_STREAM_OUTPUT = 0,
+ SNDRV_RAWMIDI_STREAM_INPUT,
+ SNDRV_RAWMIDI_STREAM_LAST = SNDRV_RAWMIDI_STREAM_INPUT,
+};
+
+#define SNDRV_RAWMIDI_INFO_OUTPUT 0x00000001
+#define SNDRV_RAWMIDI_INFO_INPUT 0x00000002
+#define SNDRV_RAWMIDI_INFO_DUPLEX 0x00000004
+
+struct snd_rawmidi_info {
+ unsigned int device;
+ unsigned int subdevice;
+ int stream;
+ int card;
+ unsigned int flags;
+ unsigned char id[64];
+ unsigned char name[80];
+ unsigned char subname[32];
+ unsigned int subdevices_count;
+ unsigned int subdevices_avail;
+ unsigned char reserved[64];
+};
+
+struct snd_rawmidi_params {
+ int stream;
+ size_t buffer_size;
+ size_t avail_min;
+ unsigned int no_active_sensing: 1;
+ unsigned char reserved[16];
+};
+
+struct snd_rawmidi_status {
+ int stream;
+ struct timespec tstamp;
+ size_t avail;
+ size_t xruns;
+ unsigned char reserved[16];
+};
+
+#define SNDRV_RAWMIDI_IOCTL_PVERSION _IOR('W', 0x00, int)
+#define SNDRV_RAWMIDI_IOCTL_INFO _IOR('W', 0x01, struct snd_rawmidi_info)
+#define SNDRV_RAWMIDI_IOCTL_PARAMS _IOWR('W', 0x10, struct snd_rawmidi_params)
+#define SNDRV_RAWMIDI_IOCTL_STATUS _IOWR('W', 0x20, struct snd_rawmidi_status)
+#define SNDRV_RAWMIDI_IOCTL_DROP _IOW('W', 0x30, int)
+#define SNDRV_RAWMIDI_IOCTL_DRAIN _IOW('W', 0x31, int)
+
+#define SNDRV_TIMER_VERSION SNDRV_PROTOCOL_VERSION(2, 0, 6)
+
+enum {
+ SNDRV_TIMER_CLASS_NONE = -1,
+ SNDRV_TIMER_CLASS_SLAVE = 0,
+ SNDRV_TIMER_CLASS_GLOBAL,
+ SNDRV_TIMER_CLASS_CARD,
+ SNDRV_TIMER_CLASS_PCM,
+ SNDRV_TIMER_CLASS_LAST = SNDRV_TIMER_CLASS_PCM,
+};
+
+enum {
+ SNDRV_TIMER_SCLASS_NONE = 0,
+ SNDRV_TIMER_SCLASS_APPLICATION,
+ SNDRV_TIMER_SCLASS_SEQUENCER,
+ SNDRV_TIMER_SCLASS_OSS_SEQUENCER,
+ SNDRV_TIMER_SCLASS_LAST = SNDRV_TIMER_SCLASS_OSS_SEQUENCER,
+};
+
+#define SNDRV_TIMER_GLOBAL_SYSTEM 0
+#define SNDRV_TIMER_GLOBAL_RTC 1
+#define SNDRV_TIMER_GLOBAL_HPET 2
+#define SNDRV_TIMER_GLOBAL_HRTIMER 3
+
+#define SNDRV_TIMER_FLG_SLAVE (1<<0)  
+
+struct snd_timer_id {
+ int dev_class;
+ int dev_sclass;
+ int card;
+ int device;
+ int subdevice;
+};
+
+struct snd_timer_ginfo {
+ struct snd_timer_id tid;
+ unsigned int flags;
+ int card;
+ unsigned char id[64];
+ unsigned char name[80];
+ unsigned long reserved0;
+ unsigned long resolution;
+ unsigned long resolution_min;
+ unsigned long resolution_max;
+ unsigned int clients;
+ unsigned char reserved[32];
+};
+
+struct snd_timer_gparams {
+ struct snd_timer_id tid;
+ unsigned long period_num;
+ unsigned long period_den;
+ unsigned char reserved[32];
+};
+
+struct snd_timer_gstatus {
+ struct snd_timer_id tid;
+ unsigned long resolution;
+ unsigned long resolution_num;
+ unsigned long resolution_den;
+ unsigned char reserved[32];
+};
+
+struct snd_timer_select {
+ struct snd_timer_id id;
+ unsigned char reserved[32];
+};
+
+struct snd_timer_info {
+ unsigned int flags;
+ int card;
+ unsigned char id[64];
+ unsigned char name[80];
+ unsigned long reserved0;
+ unsigned long resolution;
+ unsigned char reserved[64];
+};
+
+#define SNDRV_TIMER_PSFLG_AUTO (1<<0)  
+#define SNDRV_TIMER_PSFLG_EXCLUSIVE (1<<1)  
+#define SNDRV_TIMER_PSFLG_EARLY_EVENT (1<<2)  
+
+struct snd_timer_params {
+ unsigned int flags;
+ unsigned int ticks;
+ unsigned int queue_size;
+ unsigned int reserved0;
+ unsigned int filter;
+ unsigned char reserved[60];
+};
+
+struct snd_timer_status {
+ struct timespec tstamp;
+ unsigned int resolution;
+ unsigned int lost;
+ unsigned int overrun;
+ unsigned int queue;
+ unsigned char reserved[64];
+};
+
+#define SNDRV_TIMER_IOCTL_PVERSION _IOR('T', 0x00, int)
+#define SNDRV_TIMER_IOCTL_NEXT_DEVICE _IOWR('T', 0x01, struct snd_timer_id)
+#define SNDRV_TIMER_IOCTL_TREAD _IOW('T', 0x02, int)
+#define SNDRV_TIMER_IOCTL_GINFO _IOWR('T', 0x03, struct snd_timer_ginfo)
+#define SNDRV_TIMER_IOCTL_GPARAMS _IOW('T', 0x04, struct snd_timer_gparams)
+#define SNDRV_TIMER_IOCTL_GSTATUS _IOWR('T', 0x05, struct snd_timer_gstatus)
+#define SNDRV_TIMER_IOCTL_SELECT _IOW('T', 0x10, struct snd_timer_select)
+#define SNDRV_TIMER_IOCTL_INFO _IOR('T', 0x11, struct snd_timer_info)
+#define SNDRV_TIMER_IOCTL_PARAMS _IOW('T', 0x12, struct snd_timer_params)
+#define SNDRV_TIMER_IOCTL_STATUS _IOR('T', 0x14, struct snd_timer_status)
+
+#define SNDRV_TIMER_IOCTL_START _IO('T', 0xa0)
+#define SNDRV_TIMER_IOCTL_STOP _IO('T', 0xa1)
+#define SNDRV_TIMER_IOCTL_CONTINUE _IO('T', 0xa2)
+#define SNDRV_TIMER_IOCTL_PAUSE _IO('T', 0xa3)
+
+struct snd_timer_read {
+ unsigned int resolution;
+ unsigned int ticks;
+};
+
+enum {
+ SNDRV_TIMER_EVENT_RESOLUTION = 0,
+ SNDRV_TIMER_EVENT_TICK,
+ SNDRV_TIMER_EVENT_START,
+ SNDRV_TIMER_EVENT_STOP,
+ SNDRV_TIMER_EVENT_CONTINUE,
+ SNDRV_TIMER_EVENT_PAUSE,
+ SNDRV_TIMER_EVENT_EARLY,
+ SNDRV_TIMER_EVENT_SUSPEND,
+ SNDRV_TIMER_EVENT_RESUME,
+
+ SNDRV_TIMER_EVENT_MSTART = SNDRV_TIMER_EVENT_START + 10,
+ SNDRV_TIMER_EVENT_MSTOP = SNDRV_TIMER_EVENT_STOP + 10,
+ SNDRV_TIMER_EVENT_MCONTINUE = SNDRV_TIMER_EVENT_CONTINUE + 10,
+ SNDRV_TIMER_EVENT_MPAUSE = SNDRV_TIMER_EVENT_PAUSE + 10,
+ SNDRV_TIMER_EVENT_MSUSPEND = SNDRV_TIMER_EVENT_SUSPEND + 10,
+ SNDRV_TIMER_EVENT_MRESUME = SNDRV_TIMER_EVENT_RESUME + 10,
+};
+
+struct snd_timer_tread {
+ int event;
+ struct timespec tstamp;
+ unsigned int val;
+};
+
+#define SNDRV_CTL_VERSION SNDRV_PROTOCOL_VERSION(2, 0, 6)
+
+struct snd_ctl_card_info {
+ int card;
+ int pad;
+ unsigned char id[16];
+ unsigned char driver[16];
+ unsigned char name[32];
+ unsigned char longname[80];
+ unsigned char reserved_[16];
+ unsigned char mixername[80];
+ unsigned char components[128];
+};
+
+typedef int __bitwise snd_ctl_elem_type_t;
+#define SNDRV_CTL_ELEM_TYPE_NONE ((__force snd_ctl_elem_type_t) 0)  
+#define SNDRV_CTL_ELEM_TYPE_BOOLEAN ((__force snd_ctl_elem_type_t) 1)  
+#define SNDRV_CTL_ELEM_TYPE_INTEGER ((__force snd_ctl_elem_type_t) 2)  
+#define SNDRV_CTL_ELEM_TYPE_ENUMERATED ((__force snd_ctl_elem_type_t) 3)  
+#define SNDRV_CTL_ELEM_TYPE_BYTES ((__force snd_ctl_elem_type_t) 4)  
+#define SNDRV_CTL_ELEM_TYPE_IEC958 ((__force snd_ctl_elem_type_t) 5)  
+#define SNDRV_CTL_ELEM_TYPE_INTEGER64 ((__force snd_ctl_elem_type_t) 6)  
+#define SNDRV_CTL_ELEM_TYPE_LAST SNDRV_CTL_ELEM_TYPE_INTEGER64
+
+typedef int __bitwise snd_ctl_elem_iface_t;
+#define SNDRV_CTL_ELEM_IFACE_CARD ((__force snd_ctl_elem_iface_t) 0)  
+#define SNDRV_CTL_ELEM_IFACE_HWDEP ((__force snd_ctl_elem_iface_t) 1)  
+#define SNDRV_CTL_ELEM_IFACE_MIXER ((__force snd_ctl_elem_iface_t) 2)  
+#define SNDRV_CTL_ELEM_IFACE_PCM ((__force snd_ctl_elem_iface_t) 3)  
+#define SNDRV_CTL_ELEM_IFACE_RAWMIDI ((__force snd_ctl_elem_iface_t) 4)  
+#define SNDRV_CTL_ELEM_IFACE_TIMER ((__force snd_ctl_elem_iface_t) 5)  
+#define SNDRV_CTL_ELEM_IFACE_SEQUENCER ((__force snd_ctl_elem_iface_t) 6)  
+#define SNDRV_CTL_ELEM_IFACE_LAST SNDRV_CTL_ELEM_IFACE_SEQUENCER
+
+#define SNDRV_CTL_ELEM_ACCESS_READ (1<<0)
+#define SNDRV_CTL_ELEM_ACCESS_WRITE (1<<1)
+#define SNDRV_CTL_ELEM_ACCESS_READWRITE (SNDRV_CTL_ELEM_ACCESS_READ|SNDRV_CTL_ELEM_ACCESS_WRITE)
+#define SNDRV_CTL_ELEM_ACCESS_VOLATILE (1<<2)  
+#define SNDRV_CTL_ELEM_ACCESS_TIMESTAMP (1<<3)  
+#define SNDRV_CTL_ELEM_ACCESS_TLV_READ (1<<4)  
+#define SNDRV_CTL_ELEM_ACCESS_TLV_WRITE (1<<5)  
+#define SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE (SNDRV_CTL_ELEM_ACCESS_TLV_READ|SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)
+#define SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND (1<<6)  
+#define SNDRV_CTL_ELEM_ACCESS_INACTIVE (1<<8)  
+#define SNDRV_CTL_ELEM_ACCESS_LOCK (1<<9)  
+#define SNDRV_CTL_ELEM_ACCESS_OWNER (1<<10)  
+#define SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK (1<<28)   
+#define SNDRV_CTL_ELEM_ACCESS_USER (1<<29)  
+
+#define SNDRV_CTL_POWER_D0 0x0000  
+#define SNDRV_CTL_POWER_D1 0x0100  
+#define SNDRV_CTL_POWER_D2 0x0200  
+#define SNDRV_CTL_POWER_D3 0x0300  
+#define SNDRV_CTL_POWER_D3hot (SNDRV_CTL_POWER_D3|0x0000)  
+#define SNDRV_CTL_POWER_D3cold (SNDRV_CTL_POWER_D3|0x0001)  
+
+/** TLV type - Container */
+#define SND_CTL_TLVT_CONTAINER		0x0000
+/** TLV type - basic dB scale */
+#define SND_CTL_TLVT_DB_SCALE		0x0001
+/** TLV type - linear volume */
+#define SND_CTL_TLVT_DB_LINEAR		0x0002
+/** TLV type - dB range container */
+#define SND_CTL_TLVT_DB_RANGE		0x0003
+/** TLV type - dB scale specified by min/max values */
+#define SND_CTL_TLVT_DB_MINMAX		0x0004
+/** TLV type - dB scale specified by min/max values (with mute) */
+#define SND_CTL_TLVT_DB_MINMAX_MUTE	0x0005
+
+/** Mute state */
+#define SND_CTL_TLV_DB_GAIN_MUTE	-9999999
+
+struct sndrv_ctl_tlv {
+ unsigned int numid;     /* control element numeric identification */
+ unsigned int length;    /* in bytes aligned to 4 */
+ unsigned int tlv[0];    /* first TLV */
+};
+
+struct snd_ctl_elem_id {
+ unsigned int numid;
+ snd_ctl_elem_iface_t iface;
+ unsigned int device;
+ unsigned int subdevice;
+ unsigned char name[44];
+ unsigned int index;
+};
+
+struct snd_ctl_elem_list {
+ unsigned int offset;
+ unsigned int space;
+ unsigned int used;
+ unsigned int count;
+ struct snd_ctl_elem_id __user *pids;
+ unsigned char reserved[50];
+};
+
+struct snd_ctl_elem_info {
+ struct snd_ctl_elem_id id;
+ snd_ctl_elem_type_t type;
+ unsigned int access;
+ unsigned int count;
+ __kernel_pid_t owner;
+ union {
+ struct {
+ long min;
+ long max;
+ long step;
+ } integer;
+ struct {
+ long long min;
+ long long max;
+ long long step;
+ } integer64;
+ struct {
+ unsigned int items;
+ unsigned int item;
+ char name[64];
+ } enumerated;
+ unsigned char reserved[128];
+ } value;
+ union {
+ unsigned short d[4];
+ unsigned short *d_ptr;
+ } dimen;
+ unsigned char reserved[64-4*sizeof(unsigned short)];
+};
+
+struct snd_ctl_elem_value {
+ struct snd_ctl_elem_id id;
+ unsigned int indirect: 1;
+ union {
+ union {
+ long value[128];
+ long *value_ptr;
+ } integer;
+ union {
+ long long value[64];
+ long long *value_ptr;
+ } integer64;
+ union {
+ unsigned int item[128];
+ unsigned int *item_ptr;
+ } enumerated;
+ union {
+ unsigned char data[512];
+ unsigned char *data_ptr;
+ } bytes;
+ struct snd_aes_iec958 iec958;
+ } value;
+ struct timespec tstamp;
+ unsigned char reserved[128-sizeof(struct timespec)];
+};
+
+struct snd_ctl_tlv {
+ unsigned int numid;
+ unsigned int length;
+ unsigned int tlv[0];
+};
+
+#define SNDRV_CTL_IOCTL_PVERSION _IOR('U', 0x00, int)
+#define SNDRV_CTL_IOCTL_CARD_INFO _IOR('U', 0x01, struct snd_ctl_card_info)
+#define SNDRV_CTL_IOCTL_ELEM_LIST _IOWR('U', 0x10, struct snd_ctl_elem_list)
+#define SNDRV_CTL_IOCTL_ELEM_INFO _IOWR('U', 0x11, struct snd_ctl_elem_info)
+#define SNDRV_CTL_IOCTL_ELEM_READ _IOWR('U', 0x12, struct snd_ctl_elem_value)
+#define SNDRV_CTL_IOCTL_ELEM_WRITE _IOWR('U', 0x13, struct snd_ctl_elem_value)
+#define SNDRV_CTL_IOCTL_ELEM_LOCK _IOW('U', 0x14, struct snd_ctl_elem_id)
+#define SNDRV_CTL_IOCTL_ELEM_UNLOCK _IOW('U', 0x15, struct snd_ctl_elem_id)
+#define SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS _IOWR('U', 0x16, int)
+#define SNDRV_CTL_IOCTL_ELEM_ADD _IOWR('U', 0x17, struct snd_ctl_elem_info)
+#define SNDRV_CTL_IOCTL_ELEM_REPLACE _IOWR('U', 0x18, struct snd_ctl_elem_info)
+#define SNDRV_CTL_IOCTL_ELEM_REMOVE _IOWR('U', 0x19, struct snd_ctl_elem_id)
+#define SNDRV_CTL_IOCTL_TLV_READ _IOWR('U', 0x1a, struct snd_ctl_tlv)
+#define SNDRV_CTL_IOCTL_TLV_WRITE _IOWR('U', 0x1b, struct snd_ctl_tlv)
+#define SNDRV_CTL_IOCTL_TLV_COMMAND _IOWR('U', 0x1c, struct snd_ctl_tlv)
+#define SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE _IOWR('U', 0x20, int)
+#define SNDRV_CTL_IOCTL_HWDEP_INFO _IOR('U', 0x21, struct snd_hwdep_info)
+#define SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE _IOR('U', 0x30, int)
+#define SNDRV_CTL_IOCTL_PCM_INFO _IOWR('U', 0x31, struct snd_pcm_info)
+#define SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE _IOW('U', 0x32, int)
+#define SNDRV_CTL_IOCTL_RAWMIDI_NEXT_DEVICE _IOWR('U', 0x40, int)
+#define SNDRV_CTL_IOCTL_RAWMIDI_INFO _IOWR('U', 0x41, struct snd_rawmidi_info)
+#define SNDRV_CTL_IOCTL_RAWMIDI_PREFER_SUBDEVICE _IOW('U', 0x42, int)
+#define SNDRV_CTL_IOCTL_POWER _IOWR('U', 0xd0, int)
+#define SNDRV_CTL_IOCTL_POWER_STATE _IOR('U', 0xd1, int)
+
+enum sndrv_ctl_event_type {
+ SNDRV_CTL_EVENT_ELEM = 0,
+ SNDRV_CTL_EVENT_LAST = SNDRV_CTL_EVENT_ELEM,
+};
+
+#define SNDRV_CTL_EVENT_MASK_VALUE (1<<0)  
+#define SNDRV_CTL_EVENT_MASK_INFO (1<<1)  
+#define SNDRV_CTL_EVENT_MASK_ADD (1<<2)  
+#define SNDRV_CTL_EVENT_MASK_TLV (1<<3)  
+#define SNDRV_CTL_EVENT_MASK_REMOVE (~0U)  
+
+struct snd_ctl_event {
+ int type;
+ union {
+ struct {
+ unsigned int mask;
+ struct snd_ctl_elem_id id;
+ } elem;
+ unsigned char data8[60];
+ } data;
+};
+
+#define SNDRV_CTL_NAME_NONE ""
+#define SNDRV_CTL_NAME_PLAYBACK "Playback "
+#define SNDRV_CTL_NAME_CAPTURE "Capture "
+
+#define SNDRV_CTL_NAME_IEC958_NONE ""
+#define SNDRV_CTL_NAME_IEC958_SWITCH "Switch"
+#define SNDRV_CTL_NAME_IEC958_VOLUME "Volume"
+#define SNDRV_CTL_NAME_IEC958_DEFAULT "Default"
+#define SNDRV_CTL_NAME_IEC958_MASK "Mask"
+#define SNDRV_CTL_NAME_IEC958_CON_MASK "Con Mask"
+#define SNDRV_CTL_NAME_IEC958_PRO_MASK "Pro Mask"
+#define SNDRV_CTL_NAME_IEC958_PCM_STREAM "PCM Stream"
+#define SNDRV_CTL_NAME_IEC958(expl,direction,what) "IEC958 " expl SNDRV_CTL_NAME_##direction SNDRV_CTL_NAME_IEC958_##what
+
+#endif
+
diff --git a/bootable/recovery/pcba_core/audiodev_test/audio-base.h b/bootable/recovery/pcba_core/audiodev_test/audio-base.h
new file mode 100644
index 0000000000..54b4cb28f2
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/audio-base.h
@@ -0,0 +1,499 @@
+// This file is autogenerated by hidl-gen
+// then manualy edited for retrocompatiblity
+// Source: android.hardware.audio.common@5.0
+// Root: android.hardware:hardware/interfaces
+
+#ifndef HIDL_GENERATED_ANDROID_HARDWARE_AUDIO_COMMON_V4_0_EXPORTED_CONSTANTS_H_
+#define HIDL_GENERATED_ANDROID_HARDWARE_AUDIO_COMMON_V4_0_EXPORTED_CONSTANTS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum {
+    AUDIO_IO_HANDLE_NONE = 0,
+    AUDIO_MODULE_HANDLE_NONE = 0,
+    AUDIO_PORT_HANDLE_NONE = 0,
+    AUDIO_PATCH_HANDLE_NONE = 0,
+};
+
+typedef enum {
+    AUDIO_STREAM_DEFAULT = -1, // (-1)
+    AUDIO_STREAM_MIN = 0,
+    AUDIO_STREAM_VOICE_CALL = 0,
+    AUDIO_STREAM_SYSTEM = 1,
+    AUDIO_STREAM_RING = 2,
+    AUDIO_STREAM_MUSIC = 3,
+    AUDIO_STREAM_ALARM = 4,
+    AUDIO_STREAM_NOTIFICATION = 5,
+    AUDIO_STREAM_BLUETOOTH_SCO = 6,
+    AUDIO_STREAM_ENFORCED_AUDIBLE = 7,
+    AUDIO_STREAM_DTMF = 8,
+    AUDIO_STREAM_TTS = 9,
+    AUDIO_STREAM_ACCESSIBILITY = 10,
+#ifndef AUDIO_NO_SYSTEM_DECLARATIONS
+    /** For dynamic policy output mixes. Only used by the audio policy */
+    AUDIO_STREAM_REROUTING = 11,
+    /** For audio flinger tracks volume. Only used by the audioflinger */
+    AUDIO_STREAM_PATCH = 12,
+#endif // AUDIO_NO_SYSTEM_DECLARATIONS
+} audio_stream_type_t;
+
+typedef enum {
+    AUDIO_SOURCE_DEFAULT = 0,
+    AUDIO_SOURCE_MIC = 1,
+    AUDIO_SOURCE_VOICE_UPLINK = 2,
+    AUDIO_SOURCE_VOICE_DOWNLINK = 3,
+    AUDIO_SOURCE_VOICE_CALL = 4,
+    AUDIO_SOURCE_CAMCORDER = 5,
+    AUDIO_SOURCE_VOICE_RECOGNITION = 6,
+    AUDIO_SOURCE_VOICE_COMMUNICATION = 7,
+    AUDIO_SOURCE_REMOTE_SUBMIX = 8,
+    AUDIO_SOURCE_UNPROCESSED = 9,
+    AUDIO_SOURCE_VOICE_PERFORMANCE = 10,
+    AUDIO_SOURCE_ECHO_REFERENCE = 1997,
+    AUDIO_SOURCE_FM_TUNER = 1998,
+#ifndef AUDIO_NO_SYSTEM_DECLARATIONS
+    /**
+     * A low-priority, preemptible audio source for for background software
+     * hotword detection. Same tuning as VOICE_RECOGNITION.
+     * Used only internally by the framework.
+     */
+    AUDIO_SOURCE_HOTWORD = 1999,
+#endif // AUDIO_NO_SYSTEM_DECLARATIONS
+} audio_source_t;
+
+typedef enum {
+    AUDIO_SESSION_OUTPUT_STAGE = -1, // (-1)
+    AUDIO_SESSION_OUTPUT_MIX = 0,
+    AUDIO_SESSION_ALLOCATE = 0,
+    AUDIO_SESSION_NONE = 0,
+} audio_session_t;
+
+typedef enum {
+    AUDIO_FORMAT_INVALID             = 0xFFFFFFFFu,
+    AUDIO_FORMAT_DEFAULT             = 0,
+    AUDIO_FORMAT_PCM                 = 0x00000000u,
+    AUDIO_FORMAT_MP3                 = 0x01000000u,
+    AUDIO_FORMAT_AMR_NB              = 0x02000000u,
+    AUDIO_FORMAT_AMR_WB              = 0x03000000u,
+    AUDIO_FORMAT_AAC                 = 0x04000000u,
+    AUDIO_FORMAT_HE_AAC_V1           = 0x05000000u,
+    AUDIO_FORMAT_HE_AAC_V2           = 0x06000000u,
+    AUDIO_FORMAT_VORBIS              = 0x07000000u,
+    AUDIO_FORMAT_OPUS                = 0x08000000u,
+    AUDIO_FORMAT_AC3                 = 0x09000000u,
+    AUDIO_FORMAT_E_AC3               = 0x0A000000u,
+    AUDIO_FORMAT_DTS                 = 0x0B000000u,
+    AUDIO_FORMAT_DTS_HD              = 0x0C000000u,
+    AUDIO_FORMAT_IEC61937            = 0x0D000000u,
+    AUDIO_FORMAT_DOLBY_TRUEHD        = 0x0E000000u,
+    AUDIO_FORMAT_EVRC                = 0x10000000u,
+    AUDIO_FORMAT_EVRCB               = 0x11000000u,
+    AUDIO_FORMAT_EVRCWB              = 0x12000000u,
+    AUDIO_FORMAT_EVRCNW              = 0x13000000u,
+    AUDIO_FORMAT_AAC_ADIF            = 0x14000000u,
+    AUDIO_FORMAT_WMA                 = 0x15000000u,
+    AUDIO_FORMAT_WMA_PRO             = 0x16000000u,
+    AUDIO_FORMAT_AMR_WB_PLUS         = 0x17000000u,
+    AUDIO_FORMAT_MP2                 = 0x18000000u,
+    AUDIO_FORMAT_QCELP               = 0x19000000u,
+    AUDIO_FORMAT_DSD                 = 0x1A000000u,
+    AUDIO_FORMAT_FLAC                = 0x1B000000u,
+    AUDIO_FORMAT_ALAC                = 0x1C000000u,
+    AUDIO_FORMAT_APE                 = 0x1D000000u,
+    AUDIO_FORMAT_AAC_ADTS            = 0x1E000000u,
+    AUDIO_FORMAT_SBC                 = 0x1F000000u,
+    AUDIO_FORMAT_APTX                = 0x20000000u,
+    AUDIO_FORMAT_APTX_HD             = 0x21000000u,
+    AUDIO_FORMAT_AC4                 = 0x22000000u,
+    AUDIO_FORMAT_LDAC                = 0x23000000u,
+    AUDIO_FORMAT_MAT                 = 0x24000000u,
+    AUDIO_FORMAT_AAC_LATM            = 0x25000000u,
+    AUDIO_FORMAT_CELT                = 0x26000000u,
+    AUDIO_FORMAT_APTX_ADAPTIVE       = 0x27000000u,
+    AUDIO_FORMAT_LHDC                = 0x28000000u,
+    AUDIO_FORMAT_LHDC_LL             = 0x29000000u,
+    AUDIO_FORMAT_APTX_TWSP           = 0x2A000000u,
+    AUDIO_FORMAT_MAIN_MASK           = 0xFF000000u,
+    AUDIO_FORMAT_SUB_MASK            = 0x00FFFFFFu,
+
+    /* Subformats */
+    AUDIO_FORMAT_PCM_SUB_16_BIT        = 0x1u,
+    AUDIO_FORMAT_PCM_SUB_8_BIT         = 0x2u,
+    AUDIO_FORMAT_PCM_SUB_32_BIT        = 0x3u,
+    AUDIO_FORMAT_PCM_SUB_8_24_BIT      = 0x4u,
+    AUDIO_FORMAT_PCM_SUB_FLOAT         = 0x5u,
+    AUDIO_FORMAT_PCM_SUB_24_BIT_PACKED = 0x6u,
+
+    AUDIO_FORMAT_MP3_SUB_NONE          = 0x0u,
+
+    AUDIO_FORMAT_AMR_SUB_NONE          = 0x0u,
+
+    AUDIO_FORMAT_AAC_SUB_MAIN          = 0x1u,
+    AUDIO_FORMAT_AAC_SUB_LC            = 0x2u,
+    AUDIO_FORMAT_AAC_SUB_SSR           = 0x4u,
+    AUDIO_FORMAT_AAC_SUB_LTP           = 0x8u,
+    AUDIO_FORMAT_AAC_SUB_HE_V1         = 0x10u,
+    AUDIO_FORMAT_AAC_SUB_SCALABLE      = 0x20u,
+    AUDIO_FORMAT_AAC_SUB_ERLC          = 0x40u,
+    AUDIO_FORMAT_AAC_SUB_LD            = 0x80u,
+    AUDIO_FORMAT_AAC_SUB_HE_V2         = 0x100u,
+    AUDIO_FORMAT_AAC_SUB_ELD           = 0x200u,
+    AUDIO_FORMAT_AAC_SUB_XHE           = 0x300u,
+
+    AUDIO_FORMAT_VORBIS_SUB_NONE       = 0x0u,
+
+    AUDIO_FORMAT_E_AC3_SUB_JOC         = 0x1u,
+
+    AUDIO_FORMAT_MAT_SUB_1_0           = 0x1u,
+    AUDIO_FORMAT_MAT_SUB_2_0           = 0x2u,
+    AUDIO_FORMAT_MAT_SUB_2_1           = 0x3u,
+
+    /* Aliases */
+    AUDIO_FORMAT_PCM_16_BIT            = 0x1u,        // (PCM | PCM_SUB_16_BIT)
+    AUDIO_FORMAT_PCM_8_BIT             = 0x2u,        // (PCM | PCM_SUB_8_BIT)
+    AUDIO_FORMAT_PCM_32_BIT            = 0x3u,        // (PCM | PCM_SUB_32_BIT)
+    AUDIO_FORMAT_PCM_8_24_BIT          = 0x4u,        // (PCM | PCM_SUB_8_24_BIT)
+    AUDIO_FORMAT_PCM_FLOAT             = 0x5u,        // (PCM | PCM_SUB_FLOAT)
+    AUDIO_FORMAT_PCM_24_BIT_PACKED     = 0x6u,        // (PCM | PCM_SUB_24_BIT_PACKED)
+    AUDIO_FORMAT_AAC_MAIN              = 0x4000001u,  // (AAC | AAC_SUB_MAIN)
+    AUDIO_FORMAT_AAC_LC                = 0x4000002u,  // (AAC | AAC_SUB_LC)
+    AUDIO_FORMAT_AAC_SSR               = 0x4000004u,  // (AAC | AAC_SUB_SSR)
+    AUDIO_FORMAT_AAC_LTP               = 0x4000008u,  // (AAC | AAC_SUB_LTP)
+    AUDIO_FORMAT_AAC_HE_V1             = 0x4000010u,  // (AAC | AAC_SUB_HE_V1)
+    AUDIO_FORMAT_AAC_SCALABLE          = 0x4000020u,  // (AAC | AAC_SUB_SCALABLE)
+    AUDIO_FORMAT_AAC_ERLC              = 0x4000040u,  // (AAC | AAC_SUB_ERLC)
+    AUDIO_FORMAT_AAC_LD                = 0x4000080u,  // (AAC | AAC_SUB_LD)
+    AUDIO_FORMAT_AAC_HE_V2             = 0x4000100u,  // (AAC | AAC_SUB_HE_V2)
+    AUDIO_FORMAT_AAC_ELD               = 0x4000200u,  // (AAC | AAC_SUB_ELD)
+    AUDIO_FORMAT_AAC_XHE               = 0x4000300u,  // (AAC | AAC_SUB_XHE)
+    AUDIO_FORMAT_AAC_ADTS_MAIN         = 0x1e000001u, // (AAC_ADTS | AAC_SUB_MAIN)
+    AUDIO_FORMAT_AAC_ADTS_LC           = 0x1e000002u, // (AAC_ADTS | AAC_SUB_LC)
+    AUDIO_FORMAT_AAC_ADTS_SSR          = 0x1e000004u, // (AAC_ADTS | AAC_SUB_SSR)
+    AUDIO_FORMAT_AAC_ADTS_LTP          = 0x1e000008u, // (AAC_ADTS | AAC_SUB_LTP)
+    AUDIO_FORMAT_AAC_ADTS_HE_V1        = 0x1e000010u, // (AAC_ADTS | AAC_SUB_HE_V1)
+    AUDIO_FORMAT_AAC_ADTS_SCALABLE     = 0x1e000020u, // (AAC_ADTS | AAC_SUB_SCALABLE)
+    AUDIO_FORMAT_AAC_ADTS_ERLC         = 0x1e000040u, // (AAC_ADTS | AAC_SUB_ERLC)
+    AUDIO_FORMAT_AAC_ADTS_LD           = 0x1e000080u, // (AAC_ADTS | AAC_SUB_LD)
+    AUDIO_FORMAT_AAC_ADTS_HE_V2        = 0x1e000100u, // (AAC_ADTS | AAC_SUB_HE_V2)
+    AUDIO_FORMAT_AAC_ADTS_ELD          = 0x1e000200u, // (AAC_ADTS | AAC_SUB_ELD)
+    AUDIO_FORMAT_AAC_ADTS_XHE          = 0x1e000300u, // (AAC_ADTS | AAC_SUB_XHE)
+    AUDIO_FORMAT_AAC_LATM_LC           = 0x25000002u, // (AAC_LATM | AAC_SUB_LC)
+    AUDIO_FORMAT_AAC_LATM_HE_V1        = 0x25000010u, // (AAC_LATM | AAC_SUB_HE_V1)
+    AUDIO_FORMAT_AAC_LATM_HE_V2        = 0x25000100u, // (AAC_LATM | AAC_SUB_HE_V2)
+    AUDIO_FORMAT_E_AC3_JOC             = 0xA000001u,  // (E_AC3 | E_AC3_SUB_JOC)
+    AUDIO_FORMAT_MAT_1_0               = 0x24000001u, // (MAT | MAT_SUB_1_0)
+    AUDIO_FORMAT_MAT_2_0               = 0x24000002u, // (MAT | MAT_SUB_2_0)
+    AUDIO_FORMAT_MAT_2_1               = 0x24000003u, // (MAT | MAT_SUB_2_1)
+} audio_format_t;
+
+enum {
+    FCC_2 = 2,
+    FCC_8 = 8,
+};
+
+enum {
+    AUDIO_CHANNEL_REPRESENTATION_POSITION   = 0x0u,
+    AUDIO_CHANNEL_REPRESENTATION_INDEX      = 0x2u,
+    AUDIO_CHANNEL_NONE                      = 0x0u,
+    AUDIO_CHANNEL_INVALID                   = 0xC0000000u,
+
+    AUDIO_CHANNEL_OUT_FRONT_LEFT            = 0x1u,
+    AUDIO_CHANNEL_OUT_FRONT_RIGHT           = 0x2u,
+    AUDIO_CHANNEL_OUT_FRONT_CENTER          = 0x4u,
+    AUDIO_CHANNEL_OUT_LOW_FREQUENCY         = 0x8u,
+    AUDIO_CHANNEL_OUT_BACK_LEFT             = 0x10u,
+    AUDIO_CHANNEL_OUT_BACK_RIGHT            = 0x20u,
+    AUDIO_CHANNEL_OUT_FRONT_LEFT_OF_CENTER  = 0x40u,
+    AUDIO_CHANNEL_OUT_FRONT_RIGHT_OF_CENTER = 0x80u,
+    AUDIO_CHANNEL_OUT_BACK_CENTER           = 0x100u,
+    AUDIO_CHANNEL_OUT_SIDE_LEFT             = 0x200u,
+    AUDIO_CHANNEL_OUT_SIDE_RIGHT            = 0x400u,
+    AUDIO_CHANNEL_OUT_TOP_CENTER            = 0x800u,
+    AUDIO_CHANNEL_OUT_TOP_FRONT_LEFT        = 0x1000u,
+    AUDIO_CHANNEL_OUT_TOP_FRONT_CENTER      = 0x2000u,
+    AUDIO_CHANNEL_OUT_TOP_FRONT_RIGHT       = 0x4000u,
+    AUDIO_CHANNEL_OUT_TOP_BACK_LEFT         = 0x8000u,
+    AUDIO_CHANNEL_OUT_TOP_BACK_CENTER       = 0x10000u,
+    AUDIO_CHANNEL_OUT_TOP_BACK_RIGHT        = 0x20000u,
+    AUDIO_CHANNEL_OUT_TOP_SIDE_LEFT         = 0x40000u,
+    AUDIO_CHANNEL_OUT_TOP_SIDE_RIGHT        = 0x80000u,
+    AUDIO_CHANNEL_OUT_HAPTIC_A              = 0x20000000u,
+    AUDIO_CHANNEL_OUT_HAPTIC_B              = 0x10000000u,
+    AUDIO_CHANNEL_OUT_MONO                  = 0x1u,     // OUT_FRONT_LEFT
+    AUDIO_CHANNEL_OUT_STEREO                = 0x3u,     // OUT_FRONT_LEFT | OUT_FRONT_RIGHT
+    AUDIO_CHANNEL_OUT_2POINT1               = 0xBu,     // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_LOW_FREQUENCY
+    AUDIO_CHANNEL_OUT_2POINT0POINT2         = 0xC0003u, // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_TOP_SIDE_LEFT | OUT_TOP_SIDE_RIGHT
+    AUDIO_CHANNEL_OUT_2POINT1POINT2         = 0xC000Bu, // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_TOP_SIDE_LEFT | OUT_TOP_SIDE_RIGHT | OUT_LOW_FREQUENCY
+    AUDIO_CHANNEL_OUT_3POINT0POINT2         = 0xC0007u, // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_FRONT_CENTER | OUT_TOP_SIDE_LEFT | OUT_TOP_SIDE_RIGHT
+    AUDIO_CHANNEL_OUT_3POINT1POINT2         = 0xC000Fu, // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_FRONT_CENTER | OUT_TOP_SIDE_LEFT | OUT_TOP_SIDE_RIGHT | OUT_LOW_FREQUENCY
+    AUDIO_CHANNEL_OUT_QUAD                  = 0x33u,    // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_BACK_LEFT | OUT_BACK_RIGHT
+    AUDIO_CHANNEL_OUT_QUAD_BACK             = 0x33u,    // OUT_QUAD
+    AUDIO_CHANNEL_OUT_QUAD_SIDE             = 0x603u,   // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_SIDE_LEFT | OUT_SIDE_RIGHT
+    AUDIO_CHANNEL_OUT_SURROUND              = 0x107u,   // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_FRONT_CENTER | OUT_BACK_CENTER
+    AUDIO_CHANNEL_OUT_PENTA                 = 0x37u,    // OUT_QUAD | OUT_FRONT_CENTER
+    AUDIO_CHANNEL_OUT_5POINT1               = 0x3Fu,    // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_FRONT_CENTER | OUT_LOW_FREQUENCY | OUT_BACK_LEFT | OUT_BACK_RIGHT
+    AUDIO_CHANNEL_OUT_5POINT1_BACK          = 0x3Fu,    // OUT_5POINT1
+    AUDIO_CHANNEL_OUT_5POINT1_SIDE          = 0x60Fu,   // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_FRONT_CENTER | OUT_LOW_FREQUENCY | OUT_SIDE_LEFT | OUT_SIDE_RIGHT
+    AUDIO_CHANNEL_OUT_5POINT1POINT2         = 0xC003Fu, // OUT_5POINT1 | OUT_TOP_SIDE_LEFT | OUT_TOP_SIDE_RIGHT
+    AUDIO_CHANNEL_OUT_5POINT1POINT4         = 0x2D03Fu, // OUT_5POINT1 | OUT_TOP_FRONT_LEFT | OUT_TOP_FRONT_RIGHT | OUT_TOP_BACK_LEFT | OUT_TOP_BACK_RIGHT
+    AUDIO_CHANNEL_OUT_6POINT1               = 0x13Fu,   // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_FRONT_CENTER | OUT_LOW_FREQUENCY | OUT_BACK_LEFT | OUT_BACK_RIGHT | OUT_BACK_CENTER
+    AUDIO_CHANNEL_OUT_7POINT1               = 0x63Fu,   // OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_FRONT_CENTER | OUT_LOW_FREQUENCY | OUT_BACK_LEFT | OUT_BACK_RIGHT | OUT_SIDE_LEFT | OUT_SIDE_RIGHT
+    AUDIO_CHANNEL_OUT_7POINT1POINT2         = 0xC063Fu, // OUT_7POINT1 | OUT_TOP_SIDE_LEFT | OUT_TOP_SIDE_RIGHT
+    AUDIO_CHANNEL_OUT_7POINT1POINT4         = 0x2D63Fu, // OUT_7POINT1 | OUT_TOP_FRONT_LEFT | OUT_TOP_FRONT_RIGHT | OUT_TOP_BACK_LEFT | OUT_TOP_BACK_RIGHT
+    AUDIO_CHANNEL_OUT_MONO_HAPTIC_A         = 0x20000001u,// OUT_FRONT_LEFT | OUT_HAPTIC_A
+    AUDIO_CHANNEL_OUT_STEREO_HAPTIC_A       = 0x20000003u,// OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_HAPTIC_A
+    AUDIO_CHANNEL_OUT_HAPTIC_AB             = 0x30000000u,// OUT_HAPTIC_A | OUT_HAPTIC_B
+    AUDIO_CHANNEL_OUT_MONO_HAPTIC_AB        = 0x30000001u,// OUT_FRONT_LEFT | OUT_HAPTIC_A | OUT_HAPTIC_B
+    AUDIO_CHANNEL_OUT_STEREO_HAPTIC_AB      = 0x30000003u,// OUT_FRONT_LEFT | OUT_FRONT_RIGHT | OUT_HAPTIC_A | OUT_HAPTIC_B
+
+    AUDIO_CHANNEL_IN_LEFT                   = 0x4u,
+    AUDIO_CHANNEL_IN_RIGHT                  = 0x8u,
+    AUDIO_CHANNEL_IN_FRONT                  = 0x10u,
+    AUDIO_CHANNEL_IN_BACK                   = 0x20u,
+    AUDIO_CHANNEL_IN_LEFT_PROCESSED         = 0x40u,
+    AUDIO_CHANNEL_IN_RIGHT_PROCESSED        = 0x80u,
+    AUDIO_CHANNEL_IN_FRONT_PROCESSED        = 0x100u,
+    AUDIO_CHANNEL_IN_BACK_PROCESSED         = 0x200u,
+    AUDIO_CHANNEL_IN_PRESSURE               = 0x400u,
+    AUDIO_CHANNEL_IN_X_AXIS                 = 0x800u,
+    AUDIO_CHANNEL_IN_Y_AXIS                 = 0x1000u,
+    AUDIO_CHANNEL_IN_Z_AXIS                 = 0x2000u,
+    AUDIO_CHANNEL_IN_BACK_LEFT              = 0x10000u,
+    AUDIO_CHANNEL_IN_BACK_RIGHT             = 0x20000u,
+    AUDIO_CHANNEL_IN_CENTER                 = 0x40000u,
+    AUDIO_CHANNEL_IN_LOW_FREQUENCY          = 0x100000u,
+    AUDIO_CHANNEL_IN_TOP_LEFT               = 0x200000u,
+    AUDIO_CHANNEL_IN_TOP_RIGHT              = 0x400000u,
+    AUDIO_CHANNEL_IN_VOICE_UPLINK           = 0x4000u,
+    AUDIO_CHANNEL_IN_VOICE_DNLINK           = 0x8000u,
+    AUDIO_CHANNEL_IN_MONO                   = 0x10u,     // IN_FRONT
+    AUDIO_CHANNEL_IN_STEREO                 = 0xCu,      // IN_LEFT | IN_RIGHT
+    AUDIO_CHANNEL_IN_FRONT_BACK             = 0x30u,     // IN_FRONT | IN_BACK
+    AUDIO_CHANNEL_IN_6                      = 0xFCu,     // IN_LEFT | IN_RIGHT | IN_FRONT | IN_BACK | IN_LEFT_PROCESSED | IN_RIGHT_PROCESSED
+    AUDIO_CHANNEL_IN_2POINT0POINT2          = 0x60000Cu, // IN_LEFT | IN_RIGHT | IN_TOP_LEFT | IN_TOP_RIGHT
+    AUDIO_CHANNEL_IN_2POINT1POINT2          = 0x70000Cu, // IN_LEFT | IN_RIGHT | IN_TOP_LEFT | IN_TOP_RIGHT | IN_LOW_FREQUENCY
+    AUDIO_CHANNEL_IN_3POINT0POINT2          = 0x64000Cu, // IN_LEFT | IN_CENTER | IN_RIGHT | IN_TOP_LEFT | IN_TOP_RIGHT
+    AUDIO_CHANNEL_IN_3POINT1POINT2          = 0x74000Cu, // IN_LEFT | IN_CENTER | IN_RIGHT | IN_TOP_LEFT | IN_TOP_RIGHT | IN_LOW_FREQUENCY
+    AUDIO_CHANNEL_IN_5POINT1                = 0x17000Cu, // IN_LEFT | IN_CENTER | IN_RIGHT | IN_BACK_LEFT | IN_BACK_RIGHT | IN_LOW_FREQUENCY
+    AUDIO_CHANNEL_IN_VOICE_UPLINK_MONO      = 0x4010u,   // IN_VOICE_UPLINK | IN_MONO
+    AUDIO_CHANNEL_IN_VOICE_DNLINK_MONO      = 0x8010u,   // IN_VOICE_DNLINK | IN_MONO
+    AUDIO_CHANNEL_IN_VOICE_CALL_MONO        = 0xC010u,   // IN_VOICE_UPLINK_MONO | IN_VOICE_DNLINK_MONO
+
+    AUDIO_CHANNEL_COUNT_MAX                 = 30u,
+    AUDIO_CHANNEL_INDEX_HDR                 = 0x80000000u, // REPRESENTATION_INDEX << COUNT_MAX
+    AUDIO_CHANNEL_INDEX_MASK_1              = 0x80000001u, // INDEX_HDR | (1 << 1) - 1
+    AUDIO_CHANNEL_INDEX_MASK_2              = 0x80000003u, // INDEX_HDR | (1 << 2) - 1
+    AUDIO_CHANNEL_INDEX_MASK_3              = 0x80000007u, // INDEX_HDR | (1 << 3) - 1
+    AUDIO_CHANNEL_INDEX_MASK_4              = 0x8000000Fu, // INDEX_HDR | (1 << 4) - 1
+    AUDIO_CHANNEL_INDEX_MASK_5              = 0x8000001Fu, // INDEX_HDR | (1 << 5) - 1
+    AUDIO_CHANNEL_INDEX_MASK_6              = 0x8000003Fu, // INDEX_HDR | (1 << 6) - 1
+    AUDIO_CHANNEL_INDEX_MASK_7              = 0x8000007Fu, // INDEX_HDR | (1 << 7) - 1
+    AUDIO_CHANNEL_INDEX_MASK_8              = 0x800000FFu, // INDEX_HDR | (1 << 8) - 1
+    AUDIO_CHANNEL_INDEX_MASK_9              = 0x800001FFu, // INDEX_HDR | (1 << 9) - 1
+    AUDIO_CHANNEL_INDEX_MASK_10             = 0x800003FFu, // INDEX_HDR | (1 << 10) - 1
+    AUDIO_CHANNEL_INDEX_MASK_11             = 0x800007FFu, // INDEX_HDR | (1 << 11) - 1
+    AUDIO_CHANNEL_INDEX_MASK_12             = 0x80000FFFu, // INDEX_HDR | (1 << 12) - 1
+    AUDIO_CHANNEL_INDEX_MASK_13             = 0x80001FFFu, // INDEX_HDR | (1 << 13) - 1
+    AUDIO_CHANNEL_INDEX_MASK_14             = 0x80003FFFu, // INDEX_HDR | (1 << 14) - 1
+    AUDIO_CHANNEL_INDEX_MASK_15             = 0x80007FFFu, // INDEX_HDR | (1 << 15) - 1
+    AUDIO_CHANNEL_INDEX_MASK_16             = 0x8000FFFFu, // INDEX_HDR | (1 << 16) - 1
+    AUDIO_CHANNEL_INDEX_MASK_17             = 0x8001FFFFu, // INDEX_HDR | (1 << 17) - 1
+    AUDIO_CHANNEL_INDEX_MASK_18             = 0x8003FFFFu, // INDEX_HDR | (1 << 18) - 1
+    AUDIO_CHANNEL_INDEX_MASK_19             = 0x8007FFFFu, // INDEX_HDR | (1 << 19) - 1
+    AUDIO_CHANNEL_INDEX_MASK_20             = 0x800FFFFFu, // INDEX_HDR | (1 << 20) - 1
+    AUDIO_CHANNEL_INDEX_MASK_21             = 0x801FFFFFu, // INDEX_HDR | (1 << 21) - 1
+    AUDIO_CHANNEL_INDEX_MASK_22             = 0x803FFFFFu, // INDEX_HDR | (1 << 22) - 1
+    AUDIO_CHANNEL_INDEX_MASK_23             = 0x807FFFFFu, // INDEX_HDR | (1 << 23) - 1
+    AUDIO_CHANNEL_INDEX_MASK_24             = 0x80FFFFFFu, // INDEX_HDR | (1 << 24) - 1
+};
+
+typedef enum {
+#ifndef AUDIO_NO_SYSTEM_DECLARATIONS
+    AUDIO_MODE_INVALID = -2, // (-2)
+    AUDIO_MODE_CURRENT = -1, // (-1)
+#endif // AUDIO_NO_SYSTEM_DECLARATIONS
+    AUDIO_MODE_NORMAL = 0,
+    AUDIO_MODE_RINGTONE = 1,
+    AUDIO_MODE_IN_CALL = 2,
+    AUDIO_MODE_IN_COMMUNICATION = 3,
+} audio_mode_t;
+
+enum {
+    AUDIO_DEVICE_NONE                          = 0x0u,
+    AUDIO_DEVICE_BIT_IN                        = 0x80000000u,
+    AUDIO_DEVICE_BIT_DEFAULT                   = 0x40000000u,
+
+    AUDIO_DEVICE_OUT_EARPIECE                  = 0x1u,
+    AUDIO_DEVICE_OUT_SPEAKER                   = 0x2u,
+    AUDIO_DEVICE_OUT_WIRED_HEADSET             = 0x4u,
+    AUDIO_DEVICE_OUT_WIRED_HEADPHONE           = 0x8u,
+    AUDIO_DEVICE_OUT_BLUETOOTH_SCO             = 0x10u,
+    AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET     = 0x20u,
+    AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT      = 0x40u,
+    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP            = 0x80u,
+    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES = 0x100u,
+    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER    = 0x200u,
+    AUDIO_DEVICE_OUT_AUX_DIGITAL               = 0x400u,
+    AUDIO_DEVICE_OUT_HDMI                      = 0x400u,      // OUT_AUX_DIGITAL
+    AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET         = 0x800u,
+    AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET         = 0x1000u,
+    AUDIO_DEVICE_OUT_USB_ACCESSORY             = 0x2000u,
+    AUDIO_DEVICE_OUT_USB_DEVICE                = 0x4000u,
+    AUDIO_DEVICE_OUT_REMOTE_SUBMIX             = 0x8000u,
+    AUDIO_DEVICE_OUT_TELEPHONY_TX              = 0x10000u,
+    AUDIO_DEVICE_OUT_LINE                      = 0x20000u,
+    AUDIO_DEVICE_OUT_HDMI_ARC                  = 0x40000u,
+    AUDIO_DEVICE_OUT_SPDIF                     = 0x80000u,
+    AUDIO_DEVICE_OUT_FM                        = 0x100000u,
+    AUDIO_DEVICE_OUT_AUX_LINE                  = 0x200000u,
+    AUDIO_DEVICE_OUT_SPEAKER_SAFE              = 0x400000u,
+    AUDIO_DEVICE_OUT_IP                        = 0x800000u,
+    AUDIO_DEVICE_OUT_BUS                       = 0x1000000u,
+    AUDIO_DEVICE_OUT_PROXY                     = 0x2000000u,
+    AUDIO_DEVICE_OUT_USB_HEADSET               = 0x4000000u,
+    AUDIO_DEVICE_OUT_HEARING_AID               = 0x8000000u,
+    AUDIO_DEVICE_OUT_ECHO_CANCELLER            = 0x10000000u,
+    AUDIO_DEVICE_OUT_DEFAULT                   = 0x40000000u, // BIT_DEFAULT
+
+    AUDIO_DEVICE_IN_COMMUNICATION              = 0x80000001u, // BIT_IN | 0x1
+    AUDIO_DEVICE_IN_AMBIENT                    = 0x80000002u, // BIT_IN | 0x2
+    AUDIO_DEVICE_IN_BUILTIN_MIC                = 0x80000004u, // BIT_IN | 0x4
+    AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET      = 0x80000008u, // BIT_IN | 0x8
+    AUDIO_DEVICE_IN_WIRED_HEADSET              = 0x80000010u, // BIT_IN | 0x10
+    AUDIO_DEVICE_IN_AUX_DIGITAL                = 0x80000020u, // BIT_IN | 0x20
+    AUDIO_DEVICE_IN_HDMI                       = 0x80000020u, // IN_AUX_DIGITAL
+    AUDIO_DEVICE_IN_VOICE_CALL                 = 0x80000040u, // BIT_IN | 0x40
+    AUDIO_DEVICE_IN_TELEPHONY_RX               = 0x80000040u, // IN_VOICE_CALL
+    AUDIO_DEVICE_IN_BACK_MIC                   = 0x80000080u, // BIT_IN | 0x80
+    AUDIO_DEVICE_IN_REMOTE_SUBMIX              = 0x80000100u, // BIT_IN | 0x100
+    AUDIO_DEVICE_IN_ANLG_DOCK_HEADSET          = 0x80000200u, // BIT_IN | 0x200
+    AUDIO_DEVICE_IN_DGTL_DOCK_HEADSET          = 0x80000400u, // BIT_IN | 0x400
+    AUDIO_DEVICE_IN_USB_ACCESSORY              = 0x80000800u, // BIT_IN | 0x800
+    AUDIO_DEVICE_IN_USB_DEVICE                 = 0x80001000u, // BIT_IN | 0x1000
+    AUDIO_DEVICE_IN_FM_TUNER                   = 0x80002000u, // BIT_IN | 0x2000
+    AUDIO_DEVICE_IN_TV_TUNER                   = 0x80004000u, // BIT_IN | 0x4000
+    AUDIO_DEVICE_IN_LINE                       = 0x80008000u, // BIT_IN | 0x8000
+    AUDIO_DEVICE_IN_SPDIF                      = 0x80010000u, // BIT_IN | 0x10000
+    AUDIO_DEVICE_IN_BLUETOOTH_A2DP             = 0x80020000u, // BIT_IN | 0x20000
+    AUDIO_DEVICE_IN_LOOPBACK                   = 0x80040000u, // BIT_IN | 0x40000
+    AUDIO_DEVICE_IN_IP                         = 0x80080000u, // BIT_IN | 0x80000
+    AUDIO_DEVICE_IN_BUS                        = 0x80100000u, // BIT_IN | 0x100000
+    AUDIO_DEVICE_IN_PROXY                      = 0x81000000u, // BIT_IN | 0x1000000
+    AUDIO_DEVICE_IN_USB_HEADSET                = 0x82000000u, // BIT_IN | 0x2000000
+    AUDIO_DEVICE_IN_BLUETOOTH_BLE              = 0x84000000u, // BIT_IN | 0x4000000
+    AUDIO_DEVICE_IN_HDMI_ARC                   = 0x88000000u, // BIT_IN | 0x8000000
+    AUDIO_DEVICE_IN_ECHO_REFERENCE             = 0x90000000u, // BIT_IN | 0x10000000
+    AUDIO_DEVICE_IN_DEFAULT                    = 0xC0000000u, // BIT_IN | BIT_DEFAULT
+};
+
+typedef enum {
+    AUDIO_OUTPUT_FLAG_NONE             = 0x0,
+    AUDIO_OUTPUT_FLAG_DIRECT           = 0x1,
+    AUDIO_OUTPUT_FLAG_PRIMARY          = 0x2,
+    AUDIO_OUTPUT_FLAG_FAST             = 0x4,
+    AUDIO_OUTPUT_FLAG_DEEP_BUFFER      = 0x8,
+    AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD = 0x10,
+    AUDIO_OUTPUT_FLAG_NON_BLOCKING     = 0x20,
+    AUDIO_OUTPUT_FLAG_HW_AV_SYNC       = 0x40,
+    AUDIO_OUTPUT_FLAG_TTS              = 0x80,
+    AUDIO_OUTPUT_FLAG_RAW              = 0x100,
+    AUDIO_OUTPUT_FLAG_SYNC             = 0x200,
+    AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO  = 0x400,
+    AUDIO_OUTPUT_FLAG_DIRECT_PCM       = 0x2000,
+    AUDIO_OUTPUT_FLAG_MMAP_NOIRQ       = 0x4000,
+    AUDIO_OUTPUT_FLAG_VOIP_RX          = 0x8000,
+    AUDIO_OUTPUT_FLAG_INCALL_MUSIC     = 0x10000,
+} audio_output_flags_t;
+
+typedef enum {
+    AUDIO_INPUT_FLAG_NONE       = 0x0,
+    AUDIO_INPUT_FLAG_FAST       = 0x1,
+    AUDIO_INPUT_FLAG_HW_HOTWORD = 0x2,
+    AUDIO_INPUT_FLAG_RAW        = 0x4,
+    AUDIO_INPUT_FLAG_SYNC       = 0x8,
+    AUDIO_INPUT_FLAG_MMAP_NOIRQ = 0x10,
+    AUDIO_INPUT_FLAG_VOIP_TX    = 0x20,
+    AUDIO_INPUT_FLAG_HW_AV_SYNC = 0x40,
+#ifndef AUDIO_NO_SYSTEM_DECLARATIONS  // TODO: Expose at HAL interface, remove FRAMEWORK_FLAGS mask
+    AUDIO_INPUT_FLAG_DIRECT     = 0x80,
+    AUDIO_INPUT_FRAMEWORK_FLAGS = AUDIO_INPUT_FLAG_DIRECT,
+#endif
+} audio_input_flags_t;
+
+typedef enum {
+    AUDIO_USAGE_UNKNOWN = 0,
+    AUDIO_USAGE_MEDIA = 1,
+    AUDIO_USAGE_VOICE_COMMUNICATION = 2,
+    AUDIO_USAGE_VOICE_COMMUNICATION_SIGNALLING = 3,
+    AUDIO_USAGE_ALARM = 4,
+    AUDIO_USAGE_NOTIFICATION = 5,
+    AUDIO_USAGE_NOTIFICATION_TELEPHONY_RINGTONE = 6,
+#ifndef AUDIO_NO_SYSTEM_DECLARATIONS
+    AUDIO_USAGE_NOTIFICATION_COMMUNICATION_REQUEST = 7,
+    AUDIO_USAGE_NOTIFICATION_COMMUNICATION_INSTANT = 8,
+    AUDIO_USAGE_NOTIFICATION_COMMUNICATION_DELAYED = 9,
+    AUDIO_USAGE_NOTIFICATION_EVENT = 10,
+#endif // AUDIO_NO_SYSTEM_DECLARATIONS
+    AUDIO_USAGE_ASSISTANCE_ACCESSIBILITY = 11,
+    AUDIO_USAGE_ASSISTANCE_NAVIGATION_GUIDANCE = 12,
+    AUDIO_USAGE_ASSISTANCE_SONIFICATION = 13,
+    AUDIO_USAGE_GAME = 14,
+    AUDIO_USAGE_VIRTUAL_SOURCE = 15,
+    AUDIO_USAGE_ASSISTANT = 16,
+} audio_usage_t;
+
+typedef enum {
+    AUDIO_CONTENT_TYPE_UNKNOWN = 0u,
+    AUDIO_CONTENT_TYPE_SPEECH = 1u,
+    AUDIO_CONTENT_TYPE_MUSIC = 2u,
+    AUDIO_CONTENT_TYPE_MOVIE = 3u,
+    AUDIO_CONTENT_TYPE_SONIFICATION = 4u,
+} audio_content_type_t;
+
+enum {
+    AUDIO_GAIN_MODE_JOINT    = 0x1u,
+    AUDIO_GAIN_MODE_CHANNELS = 0x2u,
+    AUDIO_GAIN_MODE_RAMP     = 0x4u,
+};
+
+typedef enum {
+    AUDIO_PORT_ROLE_NONE = 0,
+    AUDIO_PORT_ROLE_SOURCE = 1, // (::android::hardware::audio::common::V4_0::AudioPortRole.NONE implicitly + 1)
+    AUDIO_PORT_ROLE_SINK = 2, // (::android::hardware::audio::common::V4_0::AudioPortRole.SOURCE implicitly + 1)
+} audio_port_role_t;
+
+typedef enum {
+    AUDIO_PORT_TYPE_NONE = 0,
+    AUDIO_PORT_TYPE_DEVICE = 1, // (::android::hardware::audio::common::V4_0::AudioPortType.NONE implicitly + 1)
+    AUDIO_PORT_TYPE_MIX = 2, // (::android::hardware::audio::common::V4_0::AudioPortType.DEVICE implicitly + 1)
+    AUDIO_PORT_TYPE_SESSION = 3, // (::android::hardware::audio::common::V4_0::AudioPortType.MIX implicitly + 1)
+} audio_port_type_t;
+
+enum {
+    AUDIO_PORT_CONFIG_SAMPLE_RATE  = 0x1u,
+    AUDIO_PORT_CONFIG_CHANNEL_MASK = 0x2u,
+    AUDIO_PORT_CONFIG_FORMAT       = 0x4u,
+    AUDIO_PORT_CONFIG_GAIN         = 0x8u,
+#ifndef AUDIO_NO_SYSTEM_DECLARATIONS
+    AUDIO_PORT_CONFIG_FLAGS        = 0x10u,  // Absent from AudioPortConfigMask, framework only.
+#endif
+};
+
+typedef enum {
+    AUDIO_LATENCY_LOW = 0,
+    AUDIO_LATENCY_NORMAL = 1, // (::android::hardware::audio::common::V4_0::AudioMixLatencyClass.LOW implicitly + 1)
+} audio_mix_latency_class_t;
+
+typedef enum {
+    MIC_DIRECTION_UNSPECIFIED = 0,
+    MIC_DIRECTION_FRONT = 1,
+    MIC_DIRECTION_BACK = 2,
+    MIC_DIRECTION_EXTERNAL = 3,
+} audio_microphone_direction_t;
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // HIDL_GENERATED_ANDROID_HARDWARE_AUDIO_COMMON_V4_0_EXPORTED_CONSTANTS_H_
diff --git a/bootable/recovery/pcba_core/audiodev_test/audio_hw.c b/bootable/recovery/pcba_core/audiodev_test/audio_hw.c
new file mode 100644
index 0000000000..4f1f66d9ce
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/audio_hw.c
@@ -0,0 +1,703 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file    audio_hw.c
+ * @brief
+ *                 ALSA Audio Git Log
+ * - V0.1.0:add alsa audio hal,just support 312x now.
+ * - V0.2.0:remove unused variable.
+ * - V0.3.0:turn off device when do_standby.
+ * - V0.4.0:turn off device before open pcm.
+ * - V0.4.1:Need to re-open the control to fix no sound when suspend.
+ * - V0.5.0:Merge the mixer operation from legacy_alsa.
+ * - V0.6.0:Merge speex denoise from legacy_alsa.
+ * - V0.7.0:add copyright.
+ * - V0.7.1:add support for box audio
+ * - V0.7.2:add support for dircet output
+ * - V0.8.0:update the direct output for box, add the DVI mode
+ * - V1.0.0:stable version
+ *
+ * @author  RkAudio
+ * @version 1.0.5
+ * @date    2015-08-24
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "AudioHardwareTiny"
+
+#include "alsa_audio.h"
+#include "audio_hw.h"
+#include <system/audio.h>
+#include "codec_config/config.h"
+//#include "audio_bitstream.h"
+//#include "audio_setting.h"
+#include <dirent.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+#define SNDRV_CARDS 8
+#define SNDRV_DEVICES 8
+
+#define DBG 1
+#if DBG
+#define LOGINFO(args...) printf(args)
+#define LOGERR(args...) fprintf(stderr, args)
+#else
+#define LOGINFO(args...)
+#define LOGERR(args...)
+#endif
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+#define SND_CARDS_NODE          "/proc/asound/cards"
+struct dev_proc_info SPEAKER_OUT_NAME[] = /* add codes& dai name here*/
+{
+    {"realtekrt5616c", NULL,},
+    {"realtekrt5651co", "rt5651-aif1",},
+    {"realtekrt5670c", NULL,},
+    {"realtekrt5672c", NULL,},
+    {"realtekrt5678co", NULL,},
+    {"rkhdmianalogsnd", NULL,},
+    {"rockchipcx2072x", NULL,},
+    {"rockchipes8316c", NULL,},
+    {"rockchipes8323c", NULL,},
+    {"rockchipes8388c", NULL,},
+    {"rockchipes8396c", NULL,},
+    {"rockchiprk", NULL, },
+    {"rockchiprk809co", NULL,},
+    {"rockchiprk817co", NULL,},
+    {"rockchiprt5640c", "rt5640-aif1",},
+    {"rockchiprt5670c", NULL,},
+    {"rockchiprt5672c", NULL,},
+    {NULL, NULL}, /* Note! Must end with NULL, else will cause crash */
+};
+
+struct dev_proc_info HDMI_OUT_NAME[] =
+{
+    {"realtekrt5651co", "i2s-hifi",},
+    {"realtekrt5670co", "i2s-hifi",},
+    {"rkhdmidpsound", NULL,},
+    {"rockchiphdmi", NULL,},
+    {"rockchiprt5640c", "i2s-hifi",},
+    {NULL, NULL}, /* Note! Must end with NULL, else will cause crash */
+};
+
+
+struct dev_proc_info SPDIF_OUT_NAME[] =
+{
+    {"ROCKCHIPSPDIF", "dit-hifi",},
+    {"rockchipcdndp", NULL,},
+    {NULL, NULL}, /* Note! Must end with NULL, else will cause crash */
+};
+
+struct dev_proc_info BT_OUT_NAME[] =
+{
+    {"rockchipbt", NULL,},
+    {NULL, NULL}, /* Note! Must end with NULL, else will cause crash */
+};
+
+struct dev_proc_info MIC_IN_NAME[] =
+{
+    {"realtekrt5616c", NULL,},
+    {"realtekrt5651co", "rt5651-aif1",},
+    {"realtekrt5670c", NULL,},
+    {"realtekrt5672c", NULL,},
+    {"realtekrt5678co", NULL,},
+    {"rockchipes8316c", NULL,},
+    {"rockchipes8323c", NULL,},
+    {"rockchipes8396c", NULL,},
+    {"rockchipes7210", NULL,},
+    {"rockchipes7243", NULL,},
+    {"rockchiprk", NULL, },
+    {"rockchiprk809co", NULL,},
+    {"rockchiprk817co", NULL,},
+    {"rockchiprt5640c", NULL,},
+    {"rockchiprt5670c", NULL,},
+    {"rockchiprt5672c", NULL,},
+    {NULL, NULL}, /* Note! Must end with NULL, else will cause crash */
+};
+
+
+struct dev_proc_info HDMI_IN_NAME[] =
+{
+    {"realtekrt5651co", "tc358749x-audio"},
+    {"hdmiin", NULL},
+    {NULL, NULL}, /* Note! Must end with NULL, else will cause crash */
+};
+
+struct dev_proc_info BT_IN_NAME[] =
+{
+    {"rockchipbt", NULL},
+    {NULL, NULL}, /* Note! Must end with NULL, else will cause crash */
+};
+
+static bool is_specified_out_sound_card(char *id, struct dev_proc_info *match)
+{
+    int i = 0;
+
+    if (!match)
+	return true; /* match any */
+
+    while (match[i].cid) {
+	if (!strcmp(id, match[i].cid)) {
+	    return true;
+    }
+	i++;
+    }
+    return false;
+}
+
+static bool dev_id_match(char *info, const char *did)
+{
+    const char *deli = "id:";
+    char *id;
+    int idx = 0;
+
+    if (!did)
+	return true;
+    if (!info)
+	return false;
+    /* find str like-> id: ff880000.i2s-rt5651-aif1 rt5651-aif1-0 */
+    id = strstr(info, deli);
+    if (!id)
+	return false;
+    id += strlen(deli);
+    while(id[idx] != '\0') {
+	if (id[idx] == '\r' ||id[idx] == '\n') {
+	    id[idx] = '\0';
+	    break;
+    	}
+	idx ++;
+    }
+    if (strstr(id, did)) {
+	fprintf(stderr, "match dai!!!: %s <-> %s", id, did);
+	return true;
+    }
+    return false;
+}
+
+static bool get_specified_out_dev(struct dev_info *devinfo,
+				  int card,
+				  const char *id,
+				  struct dev_proc_info *match)
+{
+    int i = 0;
+    int device;
+    char str_device[32];
+    char info[256];
+    size_t len;
+    FILE* file = NULL;
+
+    /* parse card id */
+    if (!match)
+	return true; /* match any */
+    while (match[i].cid) {
+        if (!strcmp(id, match[i].cid)) {
+            break;
+        }
+        i++;
+    }
+    if (!match[i].cid)
+        return false;
+    if (!match[i].did) { /* no exist dai info, exit */
+        devinfo->card = card;
+        devinfo->device = 0;
+        devinfo->info = &match[i];
+        fprintf(stderr, "%s card, got card=%d,device=%d", devinfo->id,
+                devinfo->card, devinfo->device);
+        return true;
+    }
+
+    /* parse device id */
+    for (device = 0; device < SNDRV_DEVICES; device++) {
+        sprintf(str_device, "proc/asound/card%d/pcm%dp/info", card, device);
+        if (access(str_device, 0)) {
+            fprintf(stderr, "No exist %s, break and finish parsing", str_device);
+            break;
+        }
+        file = fopen(str_device, "r");
+        if (!file) {
+            fprintf(stderr, "Could reading %s property", str_device);
+            continue;
+        }
+        len = fread(info, sizeof(char), sizeof(info)/sizeof(char), file);
+        fclose(file);
+        if (len == 0 || len > sizeof(info)/sizeof(char))
+            continue;
+        if (info[len - 1] == '\n') {
+            len--;
+            info[len] = '\0';
+        }
+        /* parse device dai */
+        if (dev_id_match(info, match[i].did)) {
+            devinfo->card = card;
+            devinfo->device = device;
+            devinfo->info = &match[i];
+            fprintf(stderr, "%s card, got card=%d,device=%d", devinfo->id,
+                devinfo->card, devinfo->device);
+        return true;
+        }
+    }
+    return false;
+}
+
+static bool get_specified_in_dev(struct dev_info *devinfo,
+				 int card,
+				 const char *id,
+				 struct dev_proc_info *match)
+{
+    int i = 0;
+    int device;
+    char str_device[32];
+    char info[256];
+    size_t len;
+    FILE* file = NULL;
+
+    /* parse card id */
+    if (!match)
+	return true; /* match any */
+    while (match[i].cid) {
+	if (!strcmp(id, match[i].cid)) {
+	    break;
+	}
+	i++;
+    }
+    if (!match[i].cid)
+	return false;
+    if (!match[i].did) { /* no exist dai info, exit */
+	devinfo->card = card;
+	devinfo->device = 0;
+	fprintf(stderr, "%s card, got card=%d,device=%d", devinfo->id,
+	      devinfo->card, devinfo->device);
+	return true;
+    }
+
+    /* parse device id */
+    for (device = 0; device < SNDRV_DEVICES; device++) {
+        sprintf(str_device, "proc/asound/card%d/pcm%dc/info", card, device);
+        if (access(str_device, 0)) {
+            fprintf(stderr, "No exist %s, break and finish parsing", str_device);
+            break;
+        }
+        file = fopen(str_device, "r");
+        if (!file) {
+            fprintf(stderr, "Could reading %s property", str_device);
+            continue;
+        }
+        len = fread(info, sizeof(char), sizeof(info)/sizeof(char), file);
+        fclose(file);
+        if (len == 0 || len > sizeof(info)/sizeof(char))
+            continue;
+        if (info[len - 1] == '\n') {
+            len--;
+            info[len] = '\0';
+        }
+        /* parse device dai */
+        if (dev_id_match(info, match[i].did)) {
+            devinfo->card = card;
+            devinfo->device = device;
+            fprintf(stderr, "%s card, got card=%d,device=%d", devinfo->id,
+                devinfo->card, devinfo->device);
+            return true;
+        }
+    }
+    return false;
+}
+
+static bool is_specified_in_sound_card(char *id, struct dev_proc_info *match)
+{
+    int i = 0;
+
+    /*
+     * mic: diffrent product may have diffrent card name,modify codes here
+     * for example: 0 [rockchiprk3328 ]: rockchip-rk3328 - rockchip-rk3328
+     */
+    if (!match)
+	return true;/* match any */
+    while (match[i].cid) {
+	if (!strcmp(id, match[i].cid)) {
+	    return true;
+  }
+	i++;
+    }
+    return false;
+}
+
+static void set_default_dev_info( struct dev_info *info, int size, int rid)
+{
+    for(int i =0; i < size; i++) {
+	if (rid) {
+	    info[i].id = NULL;
+	}
+	info[i].card = (int)SND_OUT_SOUND_CARD_UNKNOWN;
+    }
+}
+
+static void dumpdev_info(const char *tag, struct dev_info  *devinfo, int count)
+{
+    LOGINFO("dump %s device info\n", tag);
+    for(int i = 0; i < count; i++) {
+	if (devinfo[i].id && devinfo[i].card != SND_OUT_SOUND_CARD_UNKNOWN)
+	    LOGERR("dev_info %s  card=%d, device:%d\n", devinfo[i].id,
+		  devinfo[i].card,
+		  devinfo[i].device);
+    }
+}
+
+/*
+ * get sound card infor by parser node: /proc/asound/cards
+ * the sound card number is not always the same value
+ */
+void read_out_sound_card(struct stream_out *out)
+{
+
+    struct audio_device *device = NULL;
+    int card = 0;
+    char str[32];
+    char id[20];
+    size_t len;
+    FILE* file = NULL;
+
+    if((out == NULL) || (out->dev == NULL)) {
+	return ;
+    }
+    device = out->dev;
+    set_default_dev_info(device->dev_out, SND_OUT_SOUND_CARD_UNKNOWN, 0);
+    for (card = 0; card < SNDRV_CARDS; card++) {
+	sprintf(str, "proc/asound/card%d/id", card);
+	if (access(str, 0)) {
+	    fprintf(stderr, "No exist %s, break and finish parsing\n", str);
+	    break;
+	}
+	file = fopen(str, "r");
+	if (!file) {
+	    fprintf(stderr, "Could reading %s property\n", str);
+	    continue;
+	}
+	len = fread(id, sizeof(char), sizeof(id)/sizeof(char), file);
+	fclose(file);
+	if (len == 0 || len > sizeof(id)/sizeof(char))
+	    continue;
+	if (id[len - 1] == '\n') {
+	    len--;
+	    id[len] = '\0';
+	}
+	fprintf(stderr, "card%d id:%s\n", card, id);
+	get_specified_out_dev(&device->dev_out[SND_OUT_SOUND_CARD_SPEAKER], card, id, SPEAKER_OUT_NAME);
+	get_specified_out_dev(&device->dev_out[SND_OUT_SOUND_CARD_HDMI], card, id, HDMI_OUT_NAME);
+	get_specified_out_dev(&device->dev_out[SND_OUT_SOUND_CARD_SPDIF], card, id, SPDIF_OUT_NAME);
+	get_specified_out_dev(&device->dev_out[SND_OUT_SOUND_CARD_BT], card, id, BT_OUT_NAME);
+    }
+    dumpdev_info("out", device->dev_out, SND_OUT_SOUND_CARD_MAX);
+    return ;
+}
+
+/*
+ * get sound card infor by parser node: /proc/asound/cards
+ * the sound card number is not always the same value
+ */
+void read_in_sound_card(struct stream_in *in)
+{
+    struct audio_device *device = NULL;
+    int card = 0;
+    char str[32];
+    char id[20];
+    size_t len;
+    FILE* file = NULL;
+
+    if((in == NULL) || (in->dev == NULL)){
+	return ;
+    }
+    device = in->dev;
+    set_default_dev_info(device->dev_in, SND_IN_SOUND_CARD_UNKNOWN, 0);
+    for (card = 0; card < SNDRV_CARDS; card++) {
+	sprintf(str, "proc/asound/card%d/id", card);
+	if(access(str, 0)) {
+	    fprintf(stderr, "No exist %s, break and finish parsing\n", str);
+		break;
+	}
+	file = fopen(str, "r");
+	if (!file) {
+	    fprintf(stderr, "Could reading %s property\n", str);
+	    continue;
+	}
+	len = fread(id, sizeof(char), sizeof(id)/sizeof(char), file);
+	fclose(file);
+	if (len == 0 || len > sizeof(id)/sizeof(char))
+	    continue;
+	if (id[len - 1] == '\n') {
+	    len--;
+	   id[len] = '\0';
+	}
+	get_specified_in_dev(&device->dev_in[SND_IN_SOUND_CARD_MIC], card, id, MIC_IN_NAME);
+	/* set HDMI audio input info if need hdmi audio input */
+	get_specified_in_dev(&device->dev_in[SND_IN_SOUND_CARD_HDMI], card, id, HDMI_IN_NAME);
+	get_specified_in_dev(&device->dev_in[SND_IN_SOUND_CARD_BT], card, id, BT_IN_NAME);
+    }
+    dumpdev_info("in", device->dev_in, SND_IN_SOUND_CARD_MAX);
+    return ;
+}
+
+
+
+static void updateBit(int *maskAndState, int position, const char *state, const char *name) 
+{
+	char namestate1[64];
+	char namestate0[64];
+
+	sprintf(namestate1, "%s=1", name);
+	sprintf(namestate0, "%s=0", name);
+	if (strstr(state, namestate1)) {
+		maskAndState[0] |= position;
+		maskAndState[1] |= position;
+	} else if (strstr(state, namestate0)) {
+		maskAndState[0] |= position;
+		maskAndState[1] &= ~position;
+	}
+}
+
+int parseState(struct StatePair *pPair, const char *status)
+{
+    int maskAndState[2] = {0};
+    if (!pPair) {
+        LOGINFO("pPair cannot be NULL\n");
+        return -1;
+    }
+    LOGINFO("parseState %s\n", status);
+    // extcon event state changes from kernel4.9
+    // new state will be like STATE=MICROPHONE=1\nHEADPHONE=0
+    updateBit(maskAndState, BIT_HEADSET_NO_MIC, status, "HEADPHONE") ;
+    updateBit(maskAndState, BIT_HEADSET, status,"MICROPHONE") ;
+    updateBit(maskAndState, BIT_HDMI_AUDIO, status,"HDMI") ;
+    updateBit(maskAndState, BIT_LINEOUT, status,"LINE-OUT") ;
+    LOGINFO("mask %08X state %08X\n", maskAndState[0], maskAndState[1]);
+    pPair->mask = maskAndState[0];
+    pPair->state = maskAndState[1];
+    return 0;
+}
+
+void updateLocked(struct audio_device *adev, const char *newName, int newState)
+{
+    // Retain only relevant bits
+    int headsetState = newState & SUPPORTED_HEADSETS;
+    int usb_headset_anlg = headsetState & BIT_USB_HEADSET_ANLG;
+    int usb_headset_dgtl = headsetState & BIT_USB_HEADSET_DGTL;
+    int h2w_headset = headsetState & (BIT_HEADSET | BIT_HEADSET_NO_MIC | BIT_LINEOUT);
+    bool h2wStateChange = true;
+    bool usbStateChange = true;
+    int mHeadsetState;
+
+    if (NULL == adev) {
+        LOGERR("adev can not be null\n");
+    }
+    mHeadsetState = adev->mHeadsetState;
+    LOGINFO("newName=%s newState=%d headsetState=%d prev headsetState=%d\n",
+            newName, newState, headsetState, mHeadsetState);
+    if (mHeadsetState == headsetState) {
+        LOGINFO("No state change.\n");
+        return;
+    }
+    // reject all suspect transitions: only accept state changes from:
+    // - a: 0 headset to 1 headset
+    // - b: 1 headset to 0 headset
+    if (h2w_headset == (BIT_HEADSET | BIT_HEADSET_NO_MIC | BIT_LINEOUT)) {
+        LOGINFO("Invalid combination, unsetting h2w flag\n");
+        h2wStateChange = false;
+    }
+    // - c: 0 usb headset to 1 usb headset
+    // - d: 1 usb headset to 0 usb headset
+    if (usb_headset_anlg == BIT_USB_HEADSET_ANLG && usb_headset_dgtl == BIT_USB_HEADSET_DGTL) {
+        LOGINFO("Invalid combination, unsetting usb flag\n");
+        usbStateChange = false;
+    }
+    if (!h2wStateChange && !usbStateChange) {
+        LOGINFO("invalid transition, returning ...\n");
+        return;
+    }
+    //mHeadsetState = headsetState;
+    adev->mHeadsetState = headsetState;
+}
+
+
+
+void adev_open_init(struct audio_device *adev)
+{
+    struct stream_out tout;
+    struct stream_in tin;
+
+    printf("adev_open_init in\n");
+    if (NULL == adev) {
+        printf("adev_open_init:adev can not be NULL\n");
+        return;
+    }
+    set_default_dev_info(adev->dev_out, SND_OUT_SOUND_CARD_UNKNOWN, 1);
+    set_default_dev_info(adev->dev_in, SND_IN_SOUND_CARD_UNKNOWN, 1);
+    adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].id = "SPEAKER";
+    adev->dev_out[SND_OUT_SOUND_CARD_HDMI].id = "HDMI";
+    adev->dev_out[SND_OUT_SOUND_CARD_SPDIF].id = "SPDIF";
+    adev->dev_out[SND_OUT_SOUND_CARD_BT].id = "BT";
+    adev->dev_in[SND_IN_SOUND_CARD_MIC].id = "MIC";
+    adev->dev_in[SND_IN_SOUND_CARD_BT].id = "BT";
+    tout.dev = adev;
+    tin.dev = adev;
+    read_out_sound_card(&tout);
+    read_in_sound_card(&tin);
+    printf("adev_open_init out\n");
+}
+
+void adev_wired_init(struct audio_device *adev)
+{
+    DIR *dir;
+    struct dirent *de;
+    const char *extcon = "/sys/class/extcon";
+    const char *matchs = "extcon";
+    char file_name[128];
+    char buf[128];
+    FILE *file;
+    int read_size;
+    struct StatePair Pair;
+    int mask;
+    int state;
+
+    LOGINFO("adev_wired_init\n");
+    if (NULL == adev) {
+        LOGERR("adev_wired_init:adev can not be null\n");
+    }
+    dir = opendir(extcon);
+    if (NULL == dir) {
+        LOGERR("can not open %s\n", extcon);
+    }
+    while ((de = readdir(dir))) {
+        if(strstr(de->d_name, matchs)){
+            LOGINFO("name: [%s]\n", de->d_name);
+            snprintf(file_name, 128, "%s/%s/state", extcon, de->d_name);
+            LOGINFO("open: [%s]\n", file_name);
+            file = fopen(file_name, "rt");
+            if (file == NULL) {
+                LOGERR("open fail\n");
+                continue;
+            }
+            memset(buf, 0, sizeof(buf));
+            read_size = fread(buf, sizeof(char), sizeof(buf)/sizeof(buf[0]), file);
+            if (read_size > 0 ) {
+                parseState(&Pair, buf);
+                mask = Pair.mask;
+                state = Pair.state;
+                updateLocked(adev, "h2w", (adev->mHeadsetState & ~(mask & ~state)) | (mask & state));
+            }
+            fclose(file);
+        }
+    }
+    LOGINFO("adev_wired_init: 0x%08X\n", adev->mHeadsetState);
+}
+
+
+/**
+ * @brief getOutputRouteFromDevice
+ *
+ * @param device
+ *
+ * @returns
+ */
+unsigned getOutputRouteFromDevice(uint32_t device)
+{
+    /*if (mMode != AudioSystem::MODE_RINGTONE && mMode != AudioSystem::MODE_NORMAL)
+        return PLAYBACK_OFF_ROUTE;
+    */
+    switch (device) {
+    case AUDIO_DEVICE_OUT_SPEAKER:
+        return SPEAKER_NORMAL_ROUTE;
+    case AUDIO_DEVICE_OUT_WIRED_HEADSET:
+        return HEADSET_NORMAL_ROUTE;
+    case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:
+        return HEADPHONE_NORMAL_ROUTE;
+    case (AUDIO_DEVICE_OUT_SPEAKER|AUDIO_DEVICE_OUT_WIRED_HEADPHONE):
+    case (AUDIO_DEVICE_OUT_SPEAKER|AUDIO_DEVICE_OUT_WIRED_HEADSET):
+        return SPEAKER_HEADPHONE_NORMAL_ROUTE;
+    case AUDIO_DEVICE_OUT_BLUETOOTH_SCO:
+    case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
+    case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT:
+        return BLUETOOTH_NORMAL_ROUTE;
+    case AUDIO_DEVICE_OUT_AUX_DIGITAL:
+	return HDMI_NORMAL_ROUTE;
+        //case AudioSystem::DEVICE_OUT_EARPIECE:
+        //	return EARPIECE_NORMAL_ROUTE;
+        //case AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET:
+        //case AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET:
+        //	return USB_NORMAL_ROUTE;
+    default:
+        return PLAYBACK_OFF_ROUTE;
+    }
+}
+
+/**
+ * @brief getVoiceRouteFromDevice
+ *
+ * @param device
+ *
+ * @returns
+ */
+uint32_t getVoiceRouteFromDevice(uint32_t device)
+{
+    LOGINFO("not support now\n");
+
+    device = 0;
+    return 0;
+}
+
+/**
+ * @brief getInputRouteFromDevice
+ *
+ * @param device
+ *
+ * @returns
+ */
+uint32_t getInputRouteFromDevice(uint32_t device)
+{
+    /*if (mMicMute) {
+        return CAPTURE_OFF_ROUTE;
+    }*/
+    LOGINFO("%s:device:%x\n", __FUNCTION__, device);
+    switch (device) {
+    case AUDIO_DEVICE_IN_BUILTIN_MIC:
+        return MAIN_MIC_CAPTURE_ROUTE;
+    case AUDIO_DEVICE_IN_WIRED_HEADSET:
+        return HANDS_FREE_MIC_CAPTURE_ROUTE;
+    case AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET:
+        return BLUETOOTH_SOC_MIC_CAPTURE_ROUTE;
+    case AUDIO_DEVICE_IN_ANLG_DOCK_HEADSET:
+        return USB_CAPTURE_ROUTE;
+    case AUDIO_DEVICE_IN_HDMI:
+        return HDMI_IN_CAPTURE_ROUTE;
+    default:
+        return CAPTURE_OFF_ROUTE;
+    }
+}
+
+/**
+ * @brief getRouteFromDevice
+ *
+ * @param device
+ *
+ * @returns
+ */
+uint32_t getRouteFromDevice(uint32_t device)
+{
+    if (device & AUDIO_DEVICE_BIT_IN)
+        return getInputRouteFromDevice(device);
+    else
+        return getOutputRouteFromDevice(device);
+}
diff --git a/bootable/recovery/pcba_core/audiodev_test/audio_hw.h b/bootable/recovery/pcba_core/audiodev_test/audio_hw.h
new file mode 100644
index 0000000000..52a8db9931
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/audio_hw.h
@@ -0,0 +1,90 @@
+#ifndef __AUDIO_HW_H_
+#define __AUDIO_HW_H_
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <poll.h>
+#include <unistd.h>
+#include <stdint.h>
+#ifdef __cplusplus
+extern "C"{
+#endif
+/* note: those codec copy from hardware/rockchip/audio/tinyalsa_hal 
+ * So if error, pls update from audiohal then try again
+ */
+struct dev_proc_info
+{
+    const char *cid; /* cardX/id match */
+    const char *did; /* dai id match */
+};
+
+struct dev_info
+{
+    const char *id;
+    struct dev_proc_info *info;
+    int card;
+    int device;
+};
+
+enum snd_out_sound_cards {
+    SND_OUT_SOUND_CARD_UNKNOWN = -1,
+    SND_OUT_SOUND_CARD_SPEAKER = 0,
+    SND_OUT_SOUND_CARD_HDMI,
+    SND_OUT_SOUND_CARD_SPDIF,
+    SND_OUT_SOUND_CARD_BT,
+    SND_OUT_SOUND_CARD_MAX,
+};
+
+enum snd_in_sound_cards {
+    SND_IN_SOUND_CARD_UNKNOWN = -1,
+    SND_IN_SOUND_CARD_MIC = 0,
+    SND_IN_SOUND_CARD_BT,
+    SND_IN_SOUND_CARD_HDMI,
+    SND_IN_SOUND_CARD_MAX,
+};
+
+struct audio_device {
+    int mHeadsetState;
+    void *route;
+    struct dev_info dev_out[SND_OUT_SOUND_CARD_MAX];
+    struct dev_info dev_in[SND_IN_SOUND_CARD_MAX];
+};
+
+struct stream_out {
+    unsigned int device;
+    struct pcm_config *config;
+    struct pcm *pcm[SND_OUT_SOUND_CARD_MAX];
+    struct audio_device *dev;
+};
+
+struct stream_in {
+    unsigned int device;
+    struct pcm_config *config;
+    struct pcm *pcm[SND_IN_SOUND_CARD_MAX];
+    struct audio_device *dev;
+};
+
+#define BIT_HEADSET (1 << 0)
+#define BIT_HEADSET_NO_MIC (1 << 1)
+#define BIT_USB_HEADSET_ANLG (1 << 2)
+#define BIT_USB_HEADSET_DGTL (1 << 3)
+#define BIT_HDMI_AUDIO (1 << 4)
+#define BIT_LINEOUT (1 << 5)
+#define SUPPORTED_HEADSETS (BIT_HEADSET | BIT_HEADSET_NO_MIC | \
+                            BIT_USB_HEADSET_ANLG | BIT_USB_HEADSET_DGTL |\
+                            BIT_HDMI_AUDIO | BIT_LINEOUT)
+
+struct StatePair
+{
+    int mask;
+    int state;
+};
+
+void adev_open_init(struct audio_device *adev);
+void adev_wired_init(struct audio_device *adev);
+uint32_t getRouteFromDevice(uint32_t device);
+#ifdef __cplusplus
+}
+#endif
+#endif
\ No newline at end of file
diff --git a/bootable/recovery/pcba_core/audiodev_test/codec_config b/bootable/recovery/pcba_core/audiodev_test/codec_config
new file mode 120000
index 0000000000..bd1bf28524
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/codec_config
@@ -0,0 +1 @@
+../../../../hardware/rockchip/audio/tinyalsa_hal/codec_config
\ No newline at end of file
diff --git a/bootable/recovery/pcba_core/audiodev_test/codec_main.cpp b/bootable/recovery/pcba_core/audiodev_test/codec_main.cpp
new file mode 100644
index 0000000000..81890ce80d
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/codec_main.cpp
@@ -0,0 +1,68 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "codec_test.h"
+#include "script.h"
+#include <thread>
+
+#define DBG 1
+#if DBG
+#define LOGINFO(args...) printf(args)
+#define LOGERR(args...) fprintf(stderr, args)
+#else
+#define LOGINFO(args...)
+#define LOGERR(args...)
+#endif
+
+struct test_context {
+    int sync;
+};
+
+static void *test_thread_loop(void *context)
+{
+    struct test_context *pcontext = (struct test_context *)context;
+    int sync = 0;
+
+    if (pcontext)
+        sync = pcontext->sync;
+    if(sync) {
+        LOGINFO ("test_thread_loop:start sync test\n");
+        rec_play_test_sync();
+    } else {
+        LOGINFO ("test_thread_loop:start async test\n");
+        rec_play_test_async();
+    }
+    LOGINFO ("test_thread_loop:test exit\n");
+    return 0;
+}
+
+int main(int argc, char **argv)
+{
+    struct test_context context = {0};
+    pthread_t ptest_thread;
+    int err;
+
+    LOGINFO("enter audio device test....\n");
+    if(argc > 1) {
+        context.sync = !strcmp(argv[1], "case2");
+    }
+    set_exit(0);
+    err = pthread_create(&ptest_thread,
+                         (const pthread_attr_t *) NULL,
+                         test_thread_loop,
+                         &context);
+    if (err != 0) {
+        LOGERR("pthread_create() returned %d %s", err, strerror(err));
+        return -1;
+    } 
+    /* wait 20s */
+    usleep(1000*1000*20);
+    set_exit(1);
+    LOGERR("pthread_join()....");
+    err = pthread_join(ptest_thread, NULL);
+    if (err != 0) {
+        LOGERR("pthread_join() returned %d %s", err, strerror(err));
+    }
+    LOGINFO("exit audio device test....\n");
+    return 0;
+}
diff --git a/bootable/recovery/pcba_core/audiodev_test/codec_test.cpp b/bootable/recovery/pcba_core/audiodev_test/codec_test.cpp
new file mode 100644
index 0000000000..06ebaca146
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/codec_test.cpp
@@ -0,0 +1,421 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <poll.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <thread>
+#include "codec_test.h"
+#include "language.h"
+#include "common.h"
+#include "extra-functions.h"
+#include "audiodev_test/audio_hw.h"
+#include "audiodev_test/alsa_audio.h"
+#include "audiodev_test/audio-base.h"
+
+extern "C" {
+    #include "tinyalsa/include/tinyalsa/asoundlib.h"
+    #include "script.h"
+    #include "test_case.h"
+}
+
+#define NOTIFY_AUDIO_PATH "/pcba/codectest.pcm"
+#define REC_DUR 3 //the unit is second
+
+#define DBG 1
+#if DBG
+#define LOGINFO(args...) printf(args)
+#define LOGERR(args...) fprintf(stderr, args)
+#else
+#define LOGINFO(args...)
+#define LOGERR(args...)
+#endif
+
+static struct testcase_info  *tc_info = NULL;
+
+struct pcm_config pcm_config = {
+    .channels = 2,
+    .rate = 44100,
+    .period_size = 512,
+    .period_count = 6,
+    .format = PCM_FORMAT_S16_LE,
+    //.flag = HW_PARAMS_FLAG_LPCM,
+};
+
+struct pcm_config pcm_config_in = {
+    .channels = 2,
+    .rate = 44100,
+#ifdef SPEEX_DENOISE_ENABLE
+    .period_size = 1024,
+#else
+    .period_size = 256,
+#endif
+    .period_count = 4,
+    .format = PCM_FORMAT_S16_LE,
+    //.flag = HW_PARAMS_FLAG_LPCM,
+};
+struct audio_device g_adev = {0};
+struct stream_out g_strout = {.dev =&g_adev };
+struct stream_in g_strin = {.dev =&g_adev };
+
+static int maxRecPcm = 0;
+static int maxRecPcmPeriod = 0;
+static int nTime = 0;
+static int fexit = 0;
+
+void set_exit(int exit)
+{
+    LOGINFO("set_exit %d\n", exit);
+    fexit = exit;
+}
+static void calcAndDispRecAudioStrenth(short *pcm, int len)
+{	
+    short i, data;
+
+    // calc mac rec value
+    for(i = 0; i < len/2; i++) {
+        data = abs(*pcm++);
+        if(maxRecPcmPeriod < data) {
+            maxRecPcmPeriod = data;
+        }
+    }
+    if(nTime++ >= 10) {
+        nTime = 0;
+        maxRecPcm = maxRecPcmPeriod;
+        maxRecPcmPeriod = 0;
+    }
+}
+/* 
+ * first capture then play
+ */
+int rec_play_test_async()
+{
+    struct audio_device *adev;
+    struct stream_out *out;
+    struct stream_in *in;
+    unsigned bufsize = 0;
+    int headsetState = 0;
+    unsigned isNeedChangeRate = 0;
+    int out_card = -1, in_card = -1;
+    int out_device = -1, in_device = -1;
+    int id_out = 0;
+    int id_in = 0;
+    int ret = -1;
+    FILE *fp = NULL;
+    int durationbytes;
+    int recLen = 4*REC_DUR*44100;
+    char *recData = NULL;
+
+    adev = &g_adev;
+    out = &g_strout;
+    in = &g_strin;
+    /* read sound card info */
+    adev_open_init(adev);
+    /* read wired status */
+    adev_wired_init(adev);
+    out->config = &pcm_config;
+    in->config =&pcm_config_in;
+    out_card = adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].card;
+    out_device = adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].device;
+    in_card = adev->dev_in[SND_IN_SOUND_CARD_MIC].card;
+    in_device = adev->dev_in[SND_IN_SOUND_CARD_MIC].device;
+    if (adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].info && 0 ==
+        strncmp("RKRK616", adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].info->cid, 7)) {
+        fprintf(stderr, "sound card is RK616, audio capture uses rate change.\n");
+        isNeedChangeRate = 1;
+    }
+    /* default in & out */
+    in->device = AUDIO_DEVICE_IN_BUILTIN_MIC;
+    out->device = AUDIO_DEVICE_OUT_SPEAKER;
+    if (adev->mHeadsetState & BIT_HEADSET) {
+        LOGINFO("headset is in\n");
+        headsetState = 1;
+        in->device = HANDS_FREE_MIC_CAPTURE_ROUTE;
+        out->device = AUDIO_DEVICE_OUT_WIRED_HEADSET;
+    } else if (adev->mHeadsetState & BIT_HEADSET_NO_MIC) {
+        LOGINFO("headset without mic is in\n");
+        headsetState = 1;
+        out->device = AUDIO_DEVICE_OUT_WIRED_HEADSET;
+    }
+    if (adev->mHeadsetState & BIT_HDMI_AUDIO) {
+        LOGINFO("HDMI is in\n");
+        out->device = AUDIO_DEVICE_OUT_AUX_DIGITAL;
+    }
+    if(route_card_init(&adev->route, out_card)) {
+        fprintf(stderr, "rec_play_test_2:route_card_init fail\n");
+    }   
+    route_pcm_card_open(&adev->route, in_card, getRouteFromDevice(in->device | AUDIO_DEVICE_BIT_IN));
+    route_pcm_card_open(&adev->route, out_card, getRouteFromDevice(out->device));
+    out->pcm[id_out] = pcm_open(out_card, out_device, PCM_OUT | PCM_MONOTONIC, out->config);
+    if (out->pcm[id_out] && !pcm_is_ready(out->pcm[id_out])) {
+        fprintf(stderr, "pcm_open() failed: %s, card number = %d", pcm_get_error(out->pcm[id_out]), out_card);
+        pcm_close(out->pcm[id_out]);
+        ret = -EIO;
+        goto fail;
+    }
+    in->pcm[id_in] = pcm_open(in_card, in_device, PCM_IN, in->config);
+    if (in->pcm[id_in] && !pcm_is_ready(in->pcm[id_in])) {
+        fprintf(stderr, "pcm_open() failed: %scard number = %d", pcm_get_error(in->pcm[id_in]), in_card);
+        pcm_close(in->pcm[id_in]);
+        ret = -EIO;
+        goto fail;
+    }
+    fp = fopen(NOTIFY_AUDIO_PATH, "rb");
+    if(NULL == fp) {
+        fprintf(stderr,"could not open %s file, will go to fail\n", NOTIFY_AUDIO_PATH);
+        goto fail;
+    }
+    recData = (char *)malloc(recLen);
+    if (!recData) {
+        LOGERR("codec_test_async: malloc memory fail recData\n");
+        ret = -ENOMEM;
+        goto fail;
+    }
+    durationbytes = recLen;
+    do {
+        int dataLen = 0;
+        char *data = NULL;
+
+        fseek(fp,0,SEEK_SET);
+        bufsize = pcm_get_buffer_size(out->pcm[id_out]);
+        usleep(10000);
+        while(bufsize == fread(recData, 1, bufsize, fp)) {
+            if (pcm_write(out->pcm[id_out], recData, bufsize)) {
+                LOGERR("the pcmOut could not write %d bytes file data, will go to fail\n", bufsize);
+                goto fail;
+            }
+        }
+        /* pcm read */
+        usleep(10000);
+        bufsize = pcm_get_buffer_size(in->pcm[id_in]);
+        data = recData;
+        dataLen = 0;
+        do {
+            int left = 0;
+            int len = 0;
+
+            left = durationbytes - dataLen;
+            if (left <= 0 ) {
+                LOGERR("pcm_read: %d complete, break\n", dataLen);
+                break;
+            }
+            len = left > bufsize ? bufsize : left;
+            if(pcm_read(in->pcm[id_in], data, len)) {
+                if (dataLen > bufsize) {
+                    LOGERR("pcm_read: %d, fail(>%d) break\n", dataLen, bufsize);
+                    break;
+                } else {
+                    LOGERR("pcm_read: %d, fail, exit\n", dataLen);
+                    goto fail;
+                }
+            }
+            data += len;
+            dataLen += len;
+        } while (1);
+        /* pcm write */
+        usleep(10000);
+        bufsize = pcm_get_buffer_size(out->pcm[id_out]);
+        data = recData;
+        dataLen = 0;
+        do {
+            int left = 0;
+            int len = 0;
+
+            left = durationbytes - dataLen;
+            if (left <= 0 ) {
+                LOGERR("pcm_write: %d complete, break\n", dataLen);
+                break;
+            }
+            len = left > bufsize ? bufsize : left;
+            if(pcm_write(out->pcm[id_out], data, len)) {
+                if (dataLen > bufsize) {
+                    LOGERR("pcm_write: %d, fail(>%d) break\n", dataLen, bufsize);
+                    break;
+                } else {
+                    LOGERR("pcm_write: %d, fail, exit\n", dataLen);
+                    goto fail;
+                }
+            }
+            data += len;
+            dataLen += len;
+        } while (1);
+        LOGINFO("test finish without error, repeat now\n");
+    } while(!fexit);
+    ret = 0;
+fail:
+    LOGINFO("rec_play_test_async exit %d\n", ret);
+    if (in->pcm[id_in]) {
+        pcm_close(in->pcm[id_in]);
+        in->pcm[id_in] = NULL;
+    }
+    if (out->pcm[id_out]) {
+        pcm_close(out->pcm[id_out]);
+        out->pcm[id_out] = NULL;
+    }
+    if (fp){
+        fclose(fp);
+    }
+    route_pcm_close(adev->route, PLAYBACK_OFF_ROUTE);
+    route_pcm_close(adev->route, PLAYBACK_OFF_ROUTE);
+    if (recData) {
+        free(recData);
+    }
+    return ret;
+}
+
+/* 
+ * paly sync with capture
+ */
+int rec_play_test_sync()
+{	
+    struct audio_device *adev;
+    struct stream_out *out;
+    struct stream_in *in;
+    unsigned bufsize = 0;;
+    char *data = NULL;
+    int headsetState = 0;
+    unsigned isNeedChangeRate = 0;
+    int out_card = -1, in_card = -1;
+    int out_device = -1, in_device = -1;
+    int id_out = 0;
+    int id_in = 0;
+    int ret = -1;
+
+    adev = &g_adev;
+    out = &g_strout;
+    in = &g_strin;
+    /* read sound card info */
+    adev_open_init(adev);
+    /* read wired status */
+    adev_wired_init(adev);
+    out->config = &pcm_config;
+    in->config =&pcm_config_in;
+    out_card = adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].card;
+    out_device = adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].device;
+    in_card = adev->dev_in[SND_IN_SOUND_CARD_MIC].card;
+    in_device = adev->dev_in[SND_IN_SOUND_CARD_MIC].device;
+    if (adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].info && 0 ==
+        strncmp("RKRK616", adev->dev_out[SND_OUT_SOUND_CARD_SPEAKER].info->cid, 7)) {
+        fprintf(stderr, "sound card is RK616, audio capture uses rate change.\n");
+        isNeedChangeRate = 1;
+    }
+    /* default in & out */
+    in->device = AUDIO_DEVICE_IN_BUILTIN_MIC;
+    out->device = AUDIO_DEVICE_OUT_SPEAKER;
+    if (adev->mHeadsetState & BIT_HEADSET) {
+        LOGINFO("headset is in\n");
+        headsetState = 1;
+        in->device = HANDS_FREE_MIC_CAPTURE_ROUTE;
+        out->device = AUDIO_DEVICE_OUT_WIRED_HEADSET;
+    } else if (adev->mHeadsetState & BIT_HEADSET_NO_MIC) {
+        LOGINFO("headset without mic is in\n");
+        headsetState = 1;
+        out->device = AUDIO_DEVICE_OUT_WIRED_HEADSET;
+    }
+    if (adev->mHeadsetState & BIT_HDMI_AUDIO) {
+        LOGINFO("HDMI is in\n");
+        out->device = AUDIO_DEVICE_OUT_AUX_DIGITAL;
+    }
+    if(route_card_init(&adev->route, out_card)) {
+        fprintf(stderr, "rec_play_test_2:route_card_init fail\n");
+    }   
+    route_pcm_card_open(&adev->route, in_card, getRouteFromDevice(in->device | AUDIO_DEVICE_BIT_IN));
+    route_pcm_card_open(&adev->route, out_card, getRouteFromDevice(out->device));
+
+    out->pcm[id_out] = pcm_open(out_card, out_device, PCM_OUT | PCM_MONOTONIC, out->config);
+    if (out->pcm[id_out] && !pcm_is_ready(out->pcm[id_out])) {
+        fprintf(stderr, "pcm_open() failed: %s, card number = %d", pcm_get_error(out->pcm[id_out]), out_card);
+        pcm_close(out->pcm[id_out]);
+        ret = -EIO;
+        goto fail;
+    }
+    in->pcm[id_in] = pcm_open(in_card, in_device, PCM_IN, in->config);
+    if (in->pcm[id_in] && !pcm_is_ready(in->pcm[id_in])) {
+        fprintf(stderr, "pcm_open() failed: %scard number = %d", pcm_get_error(in->pcm[id_in]), in_card);
+        pcm_close(in->pcm[id_in]);
+        ret = -EIO;
+        goto fail;
+    }
+    bufsize = pcm_get_buffer_size(in->pcm[id_in]);
+    data = (char *)malloc(bufsize);
+    printf("alloc buffer %p with %d bytes\n", data, bufsize);
+    if (!data) {
+        fprintf(stderr, "could not allocate %d bytes\n", bufsize);
+        ret = -ENOMEM;
+        goto fail;
+    }
+    while (!fexit && !pcm_read(in->pcm[id_in], data, bufsize)) {
+        calcAndDispRecAudioStrenth((short *)data, bufsize);
+        if (pcm_write(out->pcm[id_out], data, bufsize)) {
+            fprintf(stderr, "could not write %d bytes\n", bufsize);
+            ret = -EIO;
+            goto fail;
+        }
+    }
+    ret = 0;
+fail:
+    LOGINFO("rec_play_test_sync exit %d\n", ret);
+    if (in->pcm[id_in]) {
+        pcm_close(in->pcm[id_in]);
+        in->pcm[id_in] = NULL;
+    }
+    if (out->pcm[id_out]) {
+        pcm_close(out->pcm[id_out]);
+        out->pcm[id_out] = NULL;
+    }
+    route_pcm_close(adev->route, PLAYBACK_OFF_ROUTE);
+    route_pcm_close(adev->route, PLAYBACK_OFF_ROUTE);
+    if(data) {
+        free(data);
+    }
+    return 0;
+}
+
+void rec_volum_display(int idx, display_callback *hook)
+{
+    int volume;
+    int y_offset = tc_info->y;
+    char msg[50] = {0};
+
+    printf("enter rec_volum_display thread.\n");
+    while(1) {
+        usleep(300000);
+        volume = 20 + ((maxRecPcm*100)/32768);
+        if(volume > 100)
+            volume = 100;
+        snprintf(msg, sizeof(msg), "%s:[%s:%d%%]", PCBA_RECORD, PCBA_VOLUME, volume);
+        hook->handle_refresh_screen(idx, msg);
+    }
+}
+
+void* codec_test(void *argv, display_callback *hook)
+{
+    int ret = -1;
+    char dt[32] = {0};
+    char msg[50] = {0};
+
+    tc_info = (struct testcase_info *)argv;
+    snprintf(msg, sizeof(msg), "%s", PCBA_RECORD);
+    hook->handle_refresh_screen(tc_info->y, msg);
+    sleep(3);
+    if(script_fetch("Codec", "program", (int *)dt, 8) == 0) {
+        printf("script_fetch program = %s.\n", dt);
+    }
+    std::thread *volume_display_thread = new std::thread(&rec_volum_display, tc_info->y, hook);
+    if(volume_display_thread) {
+        printf ("\r\nBEGIN CODEC TEST ---------------- \r\n");
+        if(strcmp(dt, "case2") == 0) {
+            rec_play_test_sync();
+        } else {
+            rec_play_test_async();
+        }
+    }
+    volume_display_thread->join();
+    printf ("\r\nEND CODEC TEST\r\n");
+    return NULL;
+}
+
+
diff --git a/bootable/recovery/pcba_core/audiodev_test/codec_test.h b/bootable/recovery/pcba_core/audiodev_test/codec_test.h
new file mode 100644
index 0000000000..c2575c4b2a
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/codec_test.h
@@ -0,0 +1,11 @@
+#ifndef __CODEC_TEST_H_
+#define __CODEC_TEST_H_
+/* note: those codec copy from hardware/rockchip/audio/tinyalsa_hal 
+ * So if error, pls update from audiohal then try again
+ */
+#include "display_callback.h"
+int rec_play_test_async();
+int rec_play_test_sync();
+void *codec_test(void *argc, display_callback *hook);
+void set_exit(int exit);
+#endif
diff --git a/bootable/recovery/pcba_core/audiodev_test/tinyalsa b/bootable/recovery/pcba_core/audiodev_test/tinyalsa
new file mode 120000
index 0000000000..99d690af74
--- /dev/null
+++ b/bootable/recovery/pcba_core/audiodev_test/tinyalsa
@@ -0,0 +1 @@
+../../../../external/tinyalsa
\ No newline at end of file
diff --git a/bootable/recovery/pcba_core/battery_test.cpp b/bootable/recovery/pcba_core/battery_test.cpp
new file mode 100644
index 0000000000..8b3f58aa57
--- /dev/null
+++ b/bootable/recovery/pcba_core/battery_test.cpp
@@ -0,0 +1,306 @@
+#define LOG_TAG "Battery"
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <linux/ioctl.h>
+#include <pthread.h>
+#include "language.h"
+#include "test_case.h"
+#include "battery_test.h"
+
+static  int BATTERY_STATUS_UNKNOWN = 1;
+static  int BATTERY_STATUS_CHARGING = 2;
+static  int BATTERY_STATUS_DISCHARGING = 3;
+static  int BATTERY_STATUS_NOT_CHARGING = 4;
+static  int BATTERY_STATUS_FULL = 5;
+
+#define POWER_SUPPLY_PATH "/sys/class/power_supply"
+
+struct PowerSupplyPaths {
+    char* acOnlinePath;
+    char* usbOnlinePath;
+    char* wirelessOnlinePath;
+    char* batteryStatusPath;
+    char* batteryHealthPath;
+    char* batteryPresentPath;
+    char* batteryCapacityPath;
+    char* batteryVoltagePath;
+    char* batteryTemperaturePath;
+    char* batteryTechnologyPath;
+};
+
+struct PowerSupplyPaths gPaths;
+
+int getBatteryVoltage(const char* status)
+{
+    return atoi(status);
+}
+
+int getBatteryStatus(const char* status)
+{    
+    switch (status[0]) 
+    {        
+        case 'C': return BATTERY_STATUS_CHARGING;         // Charging        
+        case 'D': return BATTERY_STATUS_DISCHARGING;      // Discharging        
+        case 'F': return BATTERY_STATUS_FULL;             // Full        
+        case 'N': return BATTERY_STATUS_NOT_CHARGING;      // Not charging        
+        case 'U': return BATTERY_STATUS_UNKNOWN;          // Unknown                    
+        default: {            
+            printf("Unknown battery status '%s'", status);            
+            return -1;        
+        }    
+    }
+}
+
+static int readFromFile(const char* path, char* buf, size_t size)
+{    
+    if (!path) {
+        printf("Invalid path!");
+        return -1;
+    }
+    int fd = open(path, O_RDONLY, 0);    
+    if (fd == -1) 
+    {        
+        printf("Could not open '%s'", path);        
+        return -1;    
+    }        
+    ssize_t count = read(fd, buf, size);    
+    if (count > 0) 
+    {        
+        while (count > 0 && buf[count-1] == '\n') {
+            count--;
+            buf[count] = '\0';
+        }
+    } else {        
+        buf[0] = '\0';   
+    }     
+    close(fd);   
+    return count;
+}
+
+int BatteryPathInit()
+{
+    char    path[PATH_MAX];
+    struct dirent* entry;
+
+    DIR* dir = opendir(POWER_SUPPLY_PATH);
+    if (dir == NULL) {
+        printf("Could not open %s\n", POWER_SUPPLY_PATH);
+        return -1;
+    } else {
+        while ((entry = readdir(dir))) {
+            const char* name = entry->d_name;
+            // ignore "." and ".."
+            if (name[0] == '.' && (name[1] == 0 || (name[1] == '.' && name[2] == 0))) {
+                continue;
+            }
+            char buf[20];
+            // Look for "type" file in each subdirectory
+            snprintf(path, sizeof(path), "%s/%s/type", POWER_SUPPLY_PATH, name);
+            int length = readFromFile(path, buf, sizeof(buf));
+            if (length > 0) {
+                if (buf[length - 1] == '\n') buf[length - 1] = 0;
+                if (strcmp(buf, "Mains") == 0) {
+                    snprintf(path, sizeof(path), "%s/%s/online", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) gPaths.acOnlinePath = strdup(path);
+                } else if (strcmp(buf, "USB") == 0) {
+                    snprintf(path, sizeof(path), "%s/%s/online", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) gPaths.usbOnlinePath = strdup(path);
+                } else if (strcmp(buf, "Wireless") == 0) {
+                    snprintf(path, sizeof(path), "%s/%s/online", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) gPaths.wirelessOnlinePath = strdup(path);
+                } else if (strcmp(buf, "Battery") == 0) {
+                    snprintf(path, sizeof(path), "%s/%s/status", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) gPaths.batteryStatusPath = strdup(path);
+
+                    snprintf(path, sizeof(path), "%s/%s/health", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) gPaths.batteryHealthPath = strdup(path);
+
+                    snprintf(path, sizeof(path), "%s/%s/present", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) gPaths.batteryPresentPath = strdup(path);
+
+                    snprintf(path, sizeof(path), "%s/%s/capacity", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) gPaths.batteryCapacityPath = strdup(path);
+
+                    snprintf(path, sizeof(path), "%s/%s/voltage_now", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) {
+                        gPaths.batteryVoltagePath = strdup(path);   
+                    } else {
+                        snprintf(path, sizeof(path), "%s/%s/batt_vol", POWER_SUPPLY_PATH, name);
+                        if (access(path, R_OK) == 0) gPaths.batteryVoltagePath = strdup(path);
+                    }
+
+                    snprintf(path, sizeof(path), "%s/%s/temp", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) {
+                        gPaths.batteryTemperaturePath = strdup(path);
+                    } else {
+                        snprintf(path, sizeof(path), "%s/%s/batt_temp", POWER_SUPPLY_PATH, name);
+                        if (access(path, R_OK) == 0) gPaths.batteryTemperaturePath = strdup(path);
+                    }
+
+                    snprintf(path, sizeof(path), "%s/%s/technology", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0) gPaths.batteryTechnologyPath = strdup(path);
+                }
+            }
+        }
+        closedir(dir);
+    }
+    if (!gPaths.batteryStatusPath) {
+        printf("%s is not Exist\n", gPaths.batteryStatusPath);
+        return -1;
+    }
+    if (!gPaths.batteryVoltagePath) {
+        printf("%s is not Exist\n", gPaths.batteryVoltagePath);
+        return -1;
+    }
+    return 0;
+}
+
+void* battery_test(void *argv, display_callback *hook){
+    char Voltagebuf[20];
+    char Statusbuf[20];
+    char Capacity[20];
+    char Present[20];
+    char ACOnline[20];
+    char USBOnline[20];
+    char usb_status[20];
+
+    int ret;
+    int result;
+    int result_tmp;
+    int yello_color = 255;
+    int curprint;
+    char *strbatstatus;
+    char *strbatVoltage;
+    char failed_msg[80];
+    struct testcase_info *tc_info = (struct testcase_info*)argv;
+
+    snprintf(failed_msg, sizeof(failed_msg), "%s:[%s]",PCBA_BATTERY, PCBA_FAILED);
+    hook->handle_refresh_screen(tc_info->y, PCBA_BATTERY);
+
+    if (BatteryPathInit() < 0)
+    {
+        printf("Failed to init Battery\n");
+        hook->handle_refresh_screen_hl(tc_info->y, failed_msg, true);
+        tc_info->result = -1;
+        return argv;
+    }
+    /* Kernel 4.19 do not have present.
+    memset(Present, 0, sizeof(Present));
+    ret = readFromFile(gPaths.batteryPresentPath,
+                       Present, sizeof(Present));
+    if ((ret < 0) || (Present[0] == '0')) goto err;
+    */
+
+    memset(Voltagebuf, 0, sizeof(Voltagebuf));
+    ret = readFromFile(gPaths.batteryVoltagePath,
+                       Voltagebuf, sizeof(Voltagebuf));
+    if (ret < 0 || (atoi(Voltagebuf) < 0)) goto err;
+
+    memset(Capacity, 0, sizeof(Capacity));
+    ret = readFromFile(gPaths.batteryCapacityPath,
+                       Capacity, sizeof(Capacity));
+    if (ret < 0 || (atoi(Capacity) < 0)) goto err;
+
+    memset(Statusbuf, 0, sizeof(Statusbuf));
+    ret = readFromFile(gPaths.batteryStatusPath,
+                       Statusbuf, sizeof(Statusbuf));
+    if ((ret < 0) || (getBatteryStatus(Statusbuf) < 0)) goto err;
+
+    result = getBatteryStatus(Statusbuf);
+    memset(ACOnline, 0, sizeof(ACOnline));
+    ret = readFromFile(gPaths.acOnlinePath, ACOnline, sizeof(ACOnline));
+    if (ret < 0) goto err;
+
+    memset(USBOnline, 0, sizeof(USBOnline));
+    ret = readFromFile(gPaths.usbOnlinePath,
+                       USBOnline, sizeof(USBOnline));
+    if (ret < 0) goto err;
+
+    result_tmp = !(atoi(ACOnline) || atoi(USBOnline));
+    usleep(200);
+
+    for (;;)
+    {
+        memset(ACOnline, 0, sizeof(ACOnline));
+        ret = readFromFile(gPaths.acOnlinePath,
+                           ACOnline, sizeof(ACOnline));
+        if (ret < 0) goto err;
+
+        memset(USBOnline, 0, sizeof(USBOnline));
+        ret = readFromFile(gPaths.usbOnlinePath,
+                           USBOnline, sizeof(USBOnline));
+        if(ret<0) goto err;
+        if ((atoi(ACOnline) || atoi(USBOnline)) != result_tmp) {
+            if (atoi(ACOnline) || atoi(USBOnline)) {
+                memcpy(usb_status, PCBA_AC_ONLINE,
+                       sizeof(PCBA_AC_ONLINE));
+            } else {
+                memcpy(usb_status, PCBA_AC_OFFLINE,
+                       sizeof(PCBA_AC_OFFLINE));
+            }
+            memset(Statusbuf, 0, sizeof(Statusbuf));
+            ret = readFromFile(gPaths.batteryStatusPath,
+                               Statusbuf, sizeof(Statusbuf));
+            if ((ret < 0) || (getBatteryStatus(Statusbuf) < 0)) break;
+
+            result = getBatteryStatus(Statusbuf);
+            memset(Voltagebuf, 0, sizeof(Voltagebuf));
+            ret = readFromFile(gPaths.batteryVoltagePath,
+                               Voltagebuf, sizeof(Voltagebuf));
+            if (ret < 0 || (atoi(Voltagebuf) < 0)) goto err;
+
+            memset(Capacity, 0, sizeof(Capacity));
+            ret = readFromFile(gPaths.batteryCapacityPath,
+                               Capacity, sizeof(Capacity));
+            if (ret < 0 || (atoi(Capacity) < 0)) goto err;
+
+            if (result == BATTERY_STATUS_CHARGING) {
+                snprintf(failed_msg, sizeof(failed_msg), "%s:[%s] { %s,%s:%.1fV,%s:%d }",
+                         PCBA_BATTERY, usb_status,
+                         PCBA_BATTERY_CHARGE,
+                         PCBA_BATTERY_VOLTAGE,
+                         (double)(atoi(Voltagebuf))/1000/1000,
+                         PCBA_BATTERY_CAPACITY, atoi(Capacity));
+                tc_info->result = 0;
+                /*return argv;*/
+            } else if (result == BATTERY_STATUS_FULL) {
+                snprintf(failed_msg, sizeof(failed_msg), "%s:[%s] { %s,%s:%.1fV,%s:%d }",
+                         PCBA_BATTERY, usb_status,
+                         PCBA_BATTERY_FULLCHARGE,
+                         PCBA_BATTERY_VOLTAGE,
+                         (double)(atoi(Voltagebuf))/1000/1000,
+                         PCBA_BATTERY_CAPACITY, atoi(Capacity));
+                tc_info->result = 0;
+                /*return argv;*/
+            } else {
+                snprintf(failed_msg, sizeof(failed_msg), "%s:[%s] { %s,%s:%.1fV,%s:%d }",
+                         PCBA_BATTERY, usb_status,
+                         PCBA_BATTERY_DISCHARGE,
+                         PCBA_BATTERY_VOLTAGE,
+                         (double)(atoi(Voltagebuf))/1000/1000,
+                         PCBA_BATTERY_CAPACITY, atoi(Capacity));
+                tc_info->result = 0;
+                /*return argv;*/
+            }
+            hook->handle_refresh_screen(tc_info->y, failed_msg);
+            yello_color = 0;
+            result_tmp = (atoi(ACOnline) || atoi(USBOnline));
+        }
+        usleep(200);
+    }
+err:
+    hook->handle_refresh_screen_hl(tc_info->y, failed_msg, true);
+    tc_info->result = -1;
+    return argv;
+ }
+
diff --git a/bootable/recovery/pcba_core/battery_test.h b/bootable/recovery/pcba_core/battery_test.h
new file mode 100644
index 0000000000..f8ec172f19
--- /dev/null
+++ b/bootable/recovery/pcba_core/battery_test.h
@@ -0,0 +1,7 @@
+#ifndef __BAT_TEST_H_
+#define __BAT_TEST_H_
+
+#include "display_callback.h"
+
+void* battery_test(void *argc, display_callback *hook);
+#endif
diff --git a/bootable/recovery/pcba_core/bt_test.cpp b/bootable/recovery/pcba_core/bt_test.cpp
new file mode 100644
index 0000000000..da1a4fa9b9
--- /dev/null
+++ b/bootable/recovery/pcba_core/bt_test.cpp
@@ -0,0 +1,1169 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+#include <sys/time.h>
+
+#include <termios.h>
+#include <string>
+#include <thread>
+
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include "common.h"
+#include "language.h"
+#include "test_case.h"
+
+#include "display_callback.h"
+
+#define BLUETOOTH_TTY_TEST
+//#define SOFIA3GR_PCBA
+//#define BLUEDROID_TEST
+
+#ifdef BLUEDROID_TEST
+#include "libbluetooth/bluetooth/bluetooth.h"
+#include "libbluetooth/bluetooth/hci.h"
+#include "libbluetooth/bluetooth/hci_lib.h"
+
+#ifndef HCI_DEV_ID
+#define HCI_DEV_ID 0
+#endif
+
+#define HCID_START_DELAY_SEC   3
+#define HCID_STOP_DELAY_USEC 500000
+
+#define LOG(x...) printf(x)
+
+#define MIN(x,y) (((x)<(y))?(x):(y))
+
+#define BTHWCTL_DEV_NAME             "/dev/bthwctl"
+#define BTHWCTL_IOC_MAGIC            0xf6
+#define BTHWCTL_IOCTL_SET_POWER      _IOWR(BTHWCTL_IOC_MAGIC, 0, uint32_t)	
+
+#define TCC_BT_DEVICE_PATH                      "/dev/tcc_bt_dev"
+#define BT_DEV_MAJOR_NUM                        234
+#define IOCTL_BT_DEV_POWER              _IO(BT_DEV_MAJOR_NUM, 100)
+
+enum WIFI_CHIP_TYPE_LIST{
+    BT_UNKNOWN = -1,
+    BCM4329 = 0,
+    RTL8188CU,
+    RTL8188EU,
+    BCM4330,
+    RK901,
+    RK903,
+    MT6620,
+    RT5370,
+    MT5931,
+    RDA587x,
+    RDA5990,
+    RTK8723AS,
+    RTK8723BS,
+    RTK8723AU,
+    RTK8723BU,
+    BK3515,
+    SOFIA_3GR, 
+};
+
+static int rfkill_id = -1;
+static char *rfkill_state_path = NULL;
+static int bluetooth_power_status = 0;
+static int chip_type;
+
+#define WIFI_CHIP_TYPE_PATH "/sys/class/rkwifi/chip"
+int getChipType(void) {
+    int wififd;
+    char buf[64];
+    int chip_type = RTL8188EU;
+
+    wififd = open(WIFI_CHIP_TYPE_PATH, O_RDONLY);
+    if( wififd < 0 ){
+        printf("Can't open %s, errno = %d\n", WIFI_CHIP_TYPE_PATH, errno);
+        goto done;
+    }
+
+    memset(buf, 0, 64);
+    if( 0 == read(wififd, buf, 10) ){
+        printf("read failed\n");
+        close(wififd);
+        goto done;
+    }
+    close(wififd);
+
+    if(0 == strncmp(buf, "BCM4329", strlen("BCM4329")) ) {
+        chip_type = BCM4329;
+        printf("Read wifi chip type OK ! chip_type = BCM4329\n");
+    }
+    else if (0 == strncmp(buf, "RTL8188CU", strlen("RTL8188CU")) ) {
+        chip_type = RTL8188CU;
+        printf("Read wifi chip type OK ! chip_type = RTL8188CU\n");
+    }
+    else if (0 == strncmp(buf, "RTL8188EU", strlen("RTL8188EU")) ) {
+        chip_type = RTL8188EU;
+        printf("Read wifi chip type OK ! chip_type = RTL8188EU\n");
+    }
+    else if (0 == strncmp(buf, "BCM4330", strlen("BCM4330")) ) {
+        chip_type = BCM4330;
+        printf("Read wifi chip type OK ! chip_type = BCM4330\n");
+    }
+    else if (0 == strncmp(buf, "RK901", strlen("RK901")) ) {
+        chip_type = RK901;
+        printf("Read wifi chip type OK ! chip_type = RK901\n");
+    }
+    else if (0 == strncmp(buf, "RK903", strlen("RK903")) ) {
+        chip_type = RK903;
+        printf("Read wifi chip type OK ! chip_type = RK903\n");
+    }
+    else if (0 == strncmp(buf, "MT6620", strlen("MT6620")) ) {
+        chip_type = MT6620;
+        printf("Read wifi chip type OK ! chip_type = MT6620\n");
+    }
+    else if (0 == strncmp(buf, "RT5370", strlen("RT5370")) ) {
+        chip_type = RT5370;
+        printf("Read wifi chip type OK ! chip_type = RT5370\n");
+    }
+      else if (0 == strncmp(buf, "MT5931", strlen("MT5931")) ) {
+          chip_type = MT5931;
+          printf("Read wifi chip type OK ! chip_type = MT5931\n");
+      }
+
+done:
+    return chip_type;
+}
+
+static int init_rfkill() {
+    char path[64];
+    char buf[16];
+    int fd;
+    int sz;
+    int id;
+    for (id = 0; ; id++) {
+        snprintf(path, sizeof(path), "/sys/class/rfkill/rfkill%d/type", id);
+        fd = open(path, O_RDONLY);
+        if (fd < 0) {
+            LOGW("open(%s) failed: %s (%d)\n", path, strerror(errno), errno);
+            return -1;
+        }
+        sz = read(fd, &buf, sizeof(buf));
+        close(fd);
+        if (sz >= 9 && memcmp(buf, "bluetooth", 9) == 0) {
+            rfkill_id = id;
+            break;
+        }
+    }
+
+    asprintf(&rfkill_state_path, "/sys/class/rfkill/rfkill%d/state", rfkill_id);
+    return 0;
+}
+
+static int broadcom_set_bluetooth_power(int on) {
+    int sz;
+    int fd = -1;
+    int ret = -1;
+    const char buffer = (on ? '1' : '0');
+
+    if (rfkill_id == -1) {
+        if (init_rfkill()) goto out;
+    }
+
+    fd = open(rfkill_state_path, O_WRONLY);
+    if (fd < 0) {
+        printf("open(%s) for write failed: %s (%d)\n", rfkill_state_path,
+               strerror(errno), errno);
+        goto out;
+    }
+    sz = write(fd, &buffer, 1);
+    if (sz < 0) {
+        printf("write(%s) failed: %s (%d)\n", rfkill_state_path, strerror(errno),
+               errno);
+        goto out;
+    }
+    ret = 0;
+
+    out:
+    if (fd >= 0) close(fd);
+    return ret;	
+}
+
+static int mtk_set_bluetooth_power(int on) {
+    int sz;
+    int fd = -1;
+    int ret = -1;
+    const uint32_t buf = (on ? 1 : 0);
+
+    fd = open(BTHWCTL_DEV_NAME, O_RDWR);
+    if (fd < 0) {
+        LOGE("Open %s to set BT power fails: %s(%d)", BTHWCTL_DEV_NAME,
+             strerror(errno), errno);
+        goto out1;
+    }
+
+    ret = ioctl(fd, BTHWCTL_IOCTL_SET_POWER, &buf);
+    if(ret < 0) {
+        LOGE("Set BT power %d fails: %s(%d)\n", buf, 
+             strerror(errno), errno);
+        goto out1;
+    }
+
+    bluetooth_power_status = on ? 1 : 0;
+
+    out1:
+    if (fd >= 0) close(fd);
+    return ret;	
+}
+
+static int rda587x_set_bluetooth_power(int on) {
+    int fd = -1;
+    int bt_on_off = -1;
+
+    fd = open(TCC_BT_DEVICE_PATH, O_RDWR);
+    if( fd < 0 )
+    {
+        printf("[###### TCC BT #######] [%s] open error[%d]\n", TCC_BT_DEVICE_PATH, fd);
+        return -1;
+    }
+    else
+    {
+        bt_on_off = 0;
+        ioctl(fd, IOCTL_BT_DEV_POWER, &bt_on_off);//make sure bt is disabled
+        printf("[##### TCC BT #####] set_bluetooth_power [%d]\n", bt_on_off);
+        bt_on_off = 1;
+        ioctl(fd, IOCTL_BT_DEV_POWER, &bt_on_off);
+        printf("[##### TCC BT #####] set_bluetooth_power [%d]\n", bt_on_off);
+        close(fd);
+        return 0;
+    }
+}
+
+static int rda5990_set_bluetooth_power(int on) {
+    return 0;
+}
+
+static int set_bluetooth_power(int on) {
+    if(chip_type == MT5931) {
+        return mtk_set_bluetooth_power(on);
+    } else if(chip_type == RDA587x) {
+        return rda587x_set_bluetooth_power(on);
+    } else if(chip_type == RDA5990) {
+        return rda5990_set_bluetooth_power(on);
+    } else {
+        return broadcom_set_bluetooth_power(on);
+    }
+}
+
+/**
+@ret:
+>=0 , socket created ok;
+<0, socket created fail;
+*/
+static inline int bt_test_create_sock() {
+    int sock = 0;
+    sock = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
+    if (sock < 0) {
+        printf("bluetooth_test Failed to create bluetooth hci socket: %s (%d)\n",
+               strerror(errno), errno);
+        return -1;
+    }
+    return sock;
+}
+
+#if 1
+static int start_hciattach() {
+    int ret;
+    if(chip_type == MT5931) {
+        ret = __system("/system/bin/hciattach_mtk -n -t 10 -s 115200 /dev/ttyS0 mtk 1500000 noflow &");
+    } else if(chip_type == RDA587x) {	
+        ret = __system("/system/bin/hciattach_5876 -n -s 115200 /dev/ttyS0 rda 1500000 noflow &");
+    } else if(chip_type == RDA5990) {	
+        ret = __system("/system/bin/hciattach_5990 -n -s 115200 /dev/ttyS0 rda 921600 noflow &");
+    } else if(chip_type == RTK8723AS) {
+        ret = __system("/system/bin/hciattach_8723 -n -s 115200  /dev/ttyS0 rtk_h5 &");
+    } else if(chip_type == RTK8723AU) {
+        ret = __system("insmod /res/rtk_btusb.ko");      
+    } else {
+        ret = __system("/system/bin/brcm_patchram_plus --patchram bychip --baudrate 1500000 --enable_lpm --enable_hci /dev/ttyS0 &");
+    }
+    return ret;
+}
+#else
+static int start_hciattach() {
+    int ret;
+    char service_name[32];
+
+    if(chip_type == MT5931) {	
+        strcpy(service_name, "hciattach_mtk");
+    } else if(chip_type == RDA587x) {	
+        strcpy(service_name, "hciattach_587x");
+    } else if(chip_type == RDA5990) {	
+        strcpy(service_name, "hciattach_5990");  
+    } else {
+        strcpy(service_name, "hciattach_brm");
+    }	
+
+    if (property_set("ctl.start", service_name) < 0) {
+        printf("bluetooth_test Failed to start %s\n", service_name);
+        return -1;
+    }	
+
+    return ret;
+}
+#endif
+
+static int bt_test_enable() {
+    int ret = -1;
+    int hci_sock = -1;
+    int attempt;
+
+    if (set_bluetooth_power(1) < 0) goto out;
+
+    printf("Starting hciattach daemon\n");
+    if (start_hciattach() != 0) {
+        printf("Failed to start hciattach\n");
+        set_bluetooth_power(0);
+        goto out;
+    }
+
+    // Try for 10 seconds, this can only succeed once hciattach has sent the
+    // firmware and then turned on hci device via HCIUARTSETPROTO ioctl
+    printf("Waiting for HCI device present...\n");
+    for (attempt = 50; attempt > 0;  attempt--) {
+        printf("..%d..\n", attempt);
+        hci_sock = bt_test_create_sock();
+        if (hci_sock < 0) goto out;
+
+        ret = ioctl(hci_sock, HCIDEVUP, HCI_DEV_ID);
+
+        if (!ret) {
+            break;
+        } else if (errno == EALREADY) {
+            printf("Bluetoothd already started, unexpectedly!\n");
+            break;
+        }
+
+        close(hci_sock);
+        usleep(200000);  // 200 ms retry delay
+    }
+    if (attempt == 0) {
+        printf("%s: Timeout waiting for HCI device to come up, ret=%d\n",
+               __FUNCTION__, ret);
+        set_bluetooth_power(0);
+        goto out;
+    }
+
+    printf("bt_enable success.\n");
+    ret = 0;
+
+    out:
+    if (hci_sock >= 0) close(hci_sock);
+    return ret;
+}
+
+static int my_ba2str(const bdaddr_t *ba, char *str) {
+    return sprintf(str, "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
+                   ba->b[5], ba->b[4], ba->b[3], ba->b[2], ba->b[1], ba->b[0]);
+}
+
+int bt_get_chipname(char* name, int len)
+{
+    int ret = -1;
+    int fd = -1;
+    int sz = 0;
+    char* rfkill_name_path = NULL;
+
+    if (rfkill_id == -1) {
+        if (init_rfkill()) goto out;
+    }
+
+    asprintf(&rfkill_name_path, "/sys/class/rfkill/rfkill%d/name", rfkill_id);
+
+    fd = open(rfkill_name_path, O_RDONLY);
+    if (fd < 0) {
+        printf("open(%s) failed: %s (%d)", rfkill_name_path, strerror(errno),
+               errno);
+        goto out;
+    }
+
+    sz = read(fd, name, len);
+    if (sz < 0) {
+        printf("read(%s) failed: %s (%d)", rfkill_name_path, strerror(errno),
+               errno);
+        goto out;
+    }
+    name[sz] = '\0';
+    if (name[sz-1]=='\n')
+    name[sz-1] = '\0';
+
+    ret = 0;
+
+    out:
+    if (fd >= 0) close(fd);
+    return ret;
+}
+
+int check_bluedroid_test()
+{
+    FILE *fp;
+
+    fp = fopen("/data/bt_success.txt", "r");
+    if(fp != NULL) {
+        printf("check_bluedroid_test: success.\n");
+        fclose(fp);
+        fp = NULL;
+        return 1;
+    }
+
+    //fp = fopen("/data/bt_fail.txt", "r");
+    //if(fp != NULL) {
+    //	printf("check_bluedroid_test: fail.\n");
+    //	fclose(fp);
+    //	fp = NULL;
+    //	return -1;
+    //}	
+
+    return 0; // wait
+}
+
+int bluedroid_test()
+{
+    int ret, counts = 10;
+
+    if (chmod(BTHWCTL_DEV_NAME, 0660) < 0) {
+        printf("Error changing permissions of %s to 0660: %s",
+               BTHWCTL_DEV_NAME, strerror(errno));
+        unlink(BTHWCTL_DEV_NAME);
+    }
+
+    if (chmod("/sys/class/rfkill/rfkill0/state", 0775) < 0) {
+        printf("Error changing permissions of %s to 0660: %s",
+               "/sys/class/rfkill/rfkill0/state", strerror(errno));
+        unlink("/sys/class/rfkill/rfkill0/state");
+    }
+
+    if (chmod("/sys/class/rfkill/rfkill0/type", 0775) < 0) {
+        printf("Error changing permissions of %s to 0660: %s",
+               "/sys/class/rfkill/rfkill0/type", strerror(errno));
+        unlink("/sys/class/rfkill/rfkill0/type");
+    }
+
+    if (chmod("/data", 0775) < 0) {
+        printf("Error changing permissions of %s to 0660: %s",
+               "/data", strerror(errno));
+        unlink("/data");
+    }
+
+    if (chmod("/dev/ttyS0", 0775) < 0) {
+        printf("Error changing permissions of %s to 0775 %s",
+               "/dev/ttyS0", strerror(errno));
+    }
+
+    printf("bluedroid_test: start bdt test:\n");
+
+    ret = __system("/system/bin/bdt &");
+    if(ret != 0) {
+        printf("bluedroid_test: start bdt failed.\n");
+        return -1;
+    }
+
+    while(counts-- > 0) {
+        ret = check_bluedroid_test();
+        if(ret == 1) {
+            break;
+        }
+        usleep(1000000);
+    }
+    if (counts == 0) {
+        printf("bluedroid_test: waitting for bt test ready timeout!\n");
+        ret = -1;
+    }
+
+    return ret;
+}
+
+static char bt_chip[64] = "";
+
+int bt_test_bluez()
+{
+    int dev_id = 0;
+    int sock = 0;
+    int i = 0;
+    int ret = 0;
+    char dt[32] = {0};
+    chip_type = RK903; 
+    if(script_fetch("bluetooth", "chip_type", (int *)dt, 8) == 0) {
+        printf("script_fetch chip_type = %s.\n", dt);
+    }
+    if(strcmp(dt, "rk903") == 0) {
+        chip_type = RK903; 
+    } else if(strcmp(dt, "mt6622") == 0) {
+        chip_type = MT5931; 
+    } else if(strcmp(dt, "rda587x") == 0) {
+        chip_type = RDA587x; 
+    } else if(strcmp(dt, "rda5990") == 0) {
+        chip_type = RDA5990; 
+    } else if(strcmp(dt, "rtk8723as") == 0) {
+        chip_type = RTK8723AS; 
+    } else if(strcmp(dt, "rtk8723bs") == 0) {
+        chip_type = RTK8723BS; 
+    } else if(strcmp(dt, "rtk8723au") == 0) {
+        chip_type = RTK8723AU; 
+    } else if(strcmp(dt, "rtk8723bu") == 0) {
+        chip_type = RTK8723BU; 
+    } else if(strcmp(dt, "bk3515") == 0) {
+        chip_type = BK3515;
+        sleep(5);
+    } else {
+        if (bt_get_chipname(bt_chip, 63) != 0) {
+
+            printf("Can't read BT chip name\n");
+            goto fail;
+        }
+
+        if (!strcmp(bt_chip, "rk903_26M"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "rk903"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "ap6210"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "ap6330"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "ap6476"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "ap6493"))
+        chip_type = RK903; 
+        else {
+            printf("Not support BT chip, skip bt test.\n");
+            goto fail;
+        }		
+    }
+
+    printf("bluetooth_test main function started: chip_type = %d\n", chip_type);
+
+    if(chip_type == RTK8723BS || chip_type == BK3515) {
+        ret = bluedroid_test();
+        if(ret == 1) {
+            printf("bluetooth_test success.\n");
+            goto success;
+        } else {
+            printf("bluetooth_test fail.\n");
+            goto fail;
+        }
+    }
+
+    if(chip_type == RTK8723AU || chip_type == RTK8723BU) {
+        int ret;
+        ret = __system("busybox dmesg | busybox grep 'hci_register_dev success'");
+        printf("a:ret = %d.\n", ret);
+        if (ret != 0) {
+            ret = __system("insmod /res/rtk_btusb.ko"); 
+            ret = __system("busybox dmesg | busybox grep 'hci_register_dev success'");
+        }
+        printf("b:ret = %d.\n", ret);
+        if(ret != 0) {
+            printf("bluetooth_test fail.\n");
+            goto fail;
+        }
+        printf("bluetooth_test success.\n");
+        goto success;
+    }
+
+    ret = bt_test_enable();
+    if(ret < 0){
+        printf("bluetooth_test main function fail to enable \n");
+        goto fail;
+    }
+
+    dev_id = hci_get_route(NULL);
+
+    if(dev_id < 0){
+        printf("bluetooth_test main function fail to get dev id\n");
+        goto fail;
+    }
+
+    printf("bluetooth_test main function hci_get_route dev_id=%d\n",dev_id);
+
+    sock = hci_open_dev( dev_id );
+    if(sock < 0){
+        printf("bluetooth_test main function fail to open bluetooth sock\n");
+        goto fail;
+    }
+
+    printf("bluetooth_test main function hci_open_dev ok\n");
+
+    if(sock >= 0){
+        close( sock );
+    }
+
+    /*ret = bt_test_disable();
+    if(ret < 0){
+    printf("bluetooth_test main function fail to disable\n");
+    ui_print_xy_rgba(0,tc_info->y,255,0,0,255,"bluetooth test error\n");
+    return 0;
+}*/
+
+success:
+    printf("bluetooth_test main function end\n");
+    return 0;
+
+fail:
+    printf("bluetooth_test main function end\n");
+    return -1;
+}
+
+#define LOG(x...)   printf("[BT_TEST] "x)
+
+static int get_chip_type()
+{
+    char dt[32] = {0};
+    chip_type = RK903; 
+    if(script_fetch("bluetooth", "chip_type", (int *)dt, 8) == 0) {
+        LOG("script_fetch chip_type = %s.\n", dt);
+    }
+    if(strcmp(dt, "rk903") == 0) {
+        chip_type = RK903; 
+    } else if(strcmp(dt, "mt6622") == 0) {
+        chip_type = MT5931; 
+    } else if(strcmp(dt, "rda587x") == 0) {
+        chip_type = RDA587x; 
+    } else if(strcmp(dt, "rda5990") == 0) {
+        chip_type = RDA5990; 
+    } else if(strcmp(dt, "rtk8723as") == 0) {
+        chip_type = RTK8723AS; 
+    } else if(strcmp(dt, "rtk8723bs") == 0) {
+        chip_type = RTK8723BS; 
+    } else if(strcmp(dt, "rtk8723au") == 0) {
+        chip_type = RTK8723AU; 
+    } else if(strcmp(dt, "rtk8723bu") == 0) {
+        chip_type = RTK8723BU; 
+    } else if(strcmp(dt, "bk3515") == 0) {
+        chip_type = BK3515;
+    } else if(strcmp(dt, "Sofia-3gr") == 0) {
+        chip_type = SOFIA_3GR;
+    } else {
+        if (bt_get_chipname(bt_chip, 63) != 0) {
+            LOG("Can't read BT chip name\n");
+            chip_type = BT_UNKNOWN;
+        }
+
+        if (!strcmp(bt_chip, "rk903_26M"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "rk903"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "ap6210"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "ap6330"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "ap6476"))
+        chip_type = RK903; 
+        else if (!strcmp(bt_chip, "ap6493"))
+        chip_type = RK903; 
+        else {
+            LOG("Not support BT chip, skip bt test.\n");
+            chip_type = BT_UNKNOWN;
+        }		
+    }
+
+    LOG("chip type is: %d\n", chip_type);
+
+    return chip_type;
+}
+
+static void change_mode()
+{
+    if (chmod(BTHWCTL_DEV_NAME, 0660) < 0) {
+        LOG("Error changing permissions of %s to 0660: %s\n",
+            BTHWCTL_DEV_NAME, strerror(errno));
+        unlink(BTHWCTL_DEV_NAME);
+    }
+
+    if (chmod("/sys/class/rfkill/rfkill0/state", 0775) < 0) {
+        LOG("Error changing permissions of %s to 0660: %s\n",
+            "/sys/class/rfkill/rfkill0/state", strerror(errno));
+        unlink("/sys/class/rfkill/rfkill0/state");
+    }
+
+    if (chmod("/sys/class/rfkill/rfkill0/type", 0775) < 0) {
+        LOG("Error changing permissions of %s to 0660: %s\n",
+            "/sys/class/rfkill/rfkill0/type", strerror(errno));
+        unlink("/sys/class/rfkill/rfkill0/type");
+    }
+
+    if (chmod("/dev/rtk_btusb", 0775) < 0) {
+        LOG("Error changing permissions of %s to 0660: %s\n",
+            "/dev/rtk_btusb", strerror(errno));
+    }
+
+    if (chmod("/dev/ttyS0", 0775) < 0) {
+        LOG("Error changing permissions of %s to 0775 %s\n",
+            "/dev/ttyS0", strerror(errno));
+    }
+
+    LOG("Change mode finish\n");
+
+}
+
+static int bt_test_bluedroid()
+{
+    int ret = -1;
+    FILE *fp=NULL;
+    int try = 20, bytes_for_second = 10*1024;
+    char *result_buf, *buf;
+    int result_size = try * bytes_for_second; 
+
+    result_buf = malloc(result_size);
+    if (result_buf == NULL) {
+        LOG("malloc result_buf fail\n");
+        return ret;
+    }
+    buf = result_buf;
+
+    change_mode();
+
+    fp = popen("echo \"enable\" | bdt", "r");
+    if (fp != NULL) {
+        int fd = fileno(fp);
+        int flags = fcntl(fd, F_GETFL, 0);
+        int len = 0;
+        fcntl(fd, F_SETFL, flags|O_NONBLOCK);
+
+        LOG("running bdt for bluetooth test...\n");
+        while (try-->0) {
+            buf += len;
+            len = fread(buf, sizeof(char), bytes_for_second, fp);
+            if (len) {
+                //LOG("read: %s\n", buf);
+                if (strstr(result_buf, "ADAPTER STATE UPDATED : ON")) {
+                    LOG("bt test success!\n");
+                    ret = 0;
+                    break;
+                }
+            }
+            LOG("wait %d\n", try);
+            sleep(1);
+        }
+        pclose(fp);
+        if (try<=0)
+        LOG("bt test timeout!\n");
+    } else
+    LOG("run bdt fail!\n");
+
+    free(result_buf);
+    return ret;
+}
+
+#elif defined(SOFIA3GR_PCBA)
+int check_Sofia3gr_bluedroid_test()//add by wjh
+{	
+    LOG("Sofia3gr_bluedroid_test: start check bdt test result.\n");
+
+    int ret = -1;
+    FILE *fp=NULL;
+    int try = 10, bytes_for_second = 10*1024;
+    char *result_buf, *buf;
+    int result_size = try * bytes_for_second; 
+
+    result_buf = malloc(result_size);
+    if (result_buf == NULL) {
+        LOG("malloc result_buf fail\n");
+        return ret;
+    }
+    buf = result_buf;
+
+    fp = popen("echo \"enable\" | bdt", "r");
+    if (fp != NULL) {
+        int fd = fileno(fp);
+        int flags = fcntl(fd, F_GETFL, 0);
+        int len = 0;
+        fcntl(fd, F_SETFL, flags|O_NONBLOCK);
+
+        LOG("running bdt for bluetooth test...\n");
+        while (try-->0) {
+            buf += len;
+            len = fread(buf, sizeof(char), bytes_for_second, fp);
+            if (len) {
+                //LOG("read: %s\n", buf);
+                if (strstr(result_buf, "ADAPTER STATE UPDATED : ON")) {
+                    LOG("bt test success!\n");
+                    ret = 0;
+                    break;
+                }
+            }
+            LOG("wait %d\n", try);
+            sleep(1);
+        }
+        pclose(fp);
+        if (try<=0)
+        LOG("bt test timeout!\n");
+    } else
+    LOG("run bdt fail!\n");
+
+    free(result_buf);
+    popen("echo \"quite\" | bdt", "r");
+    return ret;
+}
+
+
+int Sofia3gr_bluedroid_test()//add by wjh
+{	
+    int ret, counts = 3;
+
+    LOG("Sofia3gr_bluedroid_test: start bdt.\n");
+    while(counts-- > 0) 
+    {		 	
+        ret = check_Sofia3gr_bluedroid_test();    	
+        if(ret == 0) 
+        {    		
+            break;    	
+        }    	   
+    }        
+    return ret;
+}
+
+#else
+int uart_fd = -1;
+struct termios termios;
+unsigned char  buffer[1024];
+int ttytestResult= -1;
+unsigned char hci_reset[] = { 0x01, 0x03, 0x0c, 0x00 };
+unsigned char hci_rtksyc[] = { 0xc0, 0x00, 0x2f, 0x00,0xd0, 0x01,0x7e,0xc0};
+
+
+void
+init_uart_brcm()
+{
+    tcflush(uart_fd, TCIOFLUSH);
+    int n = tcgetattr(uart_fd, &termios);
+    printf("tcgetattr %d\n",n);
+
+    #ifndef __CYGWIN__
+    cfmakeraw(&termios);
+    #else
+    termios.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP
+                         | INLCR | IGNCR | ICRNL | IXON);
+    termios.c_oflag &= ~OPOST;
+    termios.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
+    termios.c_cflag &= ~(CSIZE | PARENB);
+    termios.c_cflag |= CS8;
+    #endif
+
+    //termios.c_cflag |= CRTSCTS;
+    tcsetattr(uart_fd, TCSANOW, &termios);
+    tcflush(uart_fd, TCIOFLUSH);
+    tcsetattr(uart_fd, TCSANOW, &termios);
+    tcflush(uart_fd, TCIOFLUSH);
+    tcflush(uart_fd, TCIOFLUSH);
+    cfsetospeed(&termios, B115200);
+    cfsetispeed(&termios, B115200);
+    tcsetattr(uart_fd, TCSANOW, &termios);
+}
+
+
+void
+init_uart_rtk()
+{
+    tcflush(uart_fd, TCIOFLUSH);
+    int n = tcgetattr(uart_fd, &termios);
+    printf("tcgetattr %d\n",n);
+
+    #ifndef __CYGWIN__
+    cfmakeraw(&termios);
+    #else
+    termios.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP
+                         | INLCR | IGNCR | ICRNL | IXON);
+    termios.c_oflag &= ~OPOST;
+    termios.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
+    termios.c_cflag &= ~(CSIZE | PARENB);
+    termios.c_cflag |= CS8;
+    #endif
+    termios.c_cflag &= ~CRTSCTS;
+
+    termios.c_cflag |= PARENB;
+
+    //termios.c_cflag |= CRTSCTS;
+    tcsetattr(uart_fd, TCSANOW, &termios);
+    tcflush(uart_fd, TCIOFLUSH);
+    tcsetattr(uart_fd, TCSANOW, &termios);
+    tcflush(uart_fd, TCIOFLUSH);
+    tcflush(uart_fd, TCIOFLUSH);
+    cfsetospeed(&termios, B115200);
+    cfsetispeed(&termios, B115200);
+    tcsetattr(uart_fd, TCSANOW, &termios);
+}
+
+void
+dump(unsigned char *out, int len)
+{
+    int i;
+
+    for (i = 0; i < len; i++) {
+        if (i && !(i % 16)) {
+            printf("\n");
+        }
+
+        printf("%02x ", out[i]);
+    }
+
+    printf("\n");
+}
+
+
+#define READTTY_TIMEOUT  30//3s
+int readttyLen(int fd,unsigned char *buffer,int len)
+{
+    int count;
+    int i= 0;
+    int timeout=0;
+    while(len){
+        count = read(fd,&buffer[i],1);
+        if(count == 1){
+            i += count;
+            len -= count;
+        }
+        else{
+            usleep(100000);//100ms
+            timeout ++;
+            //printf("timeout %d\n", timeout);
+            if(timeout >= READTTY_TIMEOUT)
+            return -1;
+        }
+    }
+    return i;
+}
+void readBrcmTty(int fd, unsigned char  *buffer)
+{
+    int i=0;
+    int count;
+    int len;
+    count = readttyLen(fd,buffer,3);
+    printf("readBrcmTty count11 %d\n", count);
+    if(count < 3)
+    return;
+    i += count;
+    len = buffer[2];
+
+    count = readttyLen(fd,&buffer[i],len);
+    if(count<len)
+    return;
+    i += count;
+
+    //if (debug)
+    {
+
+        printf("readBrcmTty received %d\n", i);
+        dump(buffer, i);
+    }
+
+    ttytestResult = 0;
+    printf("bt ttytest read_event succ\n");
+}
+
+void readRtkTty(int fd, unsigned char  *buffer)
+{
+    int i=0;
+    int count;
+    int len;
+
+    count = readttyLen(fd,buffer,16);
+    if(count < 16)
+    return;
+    i += count;
+
+    //if (debug)
+    {
+
+        printf("received %d\n", i);
+        dump(buffer, i);
+    }
+
+    ttytestResult = 0;
+    printf("bt ttytest read_event succ\n");
+}
+
+
+void
+hci_send_cmd(unsigned char *buf, int len)
+{
+    //if (debug) 
+    {
+        printf("writing\n");
+        dump(buf, len);
+    }
+
+    int writelen=write(uart_fd, buf, len);
+    printf("writelen %d\n",writelen);
+}
+
+
+void
+expired(int sig)
+{
+    ttytestResult = -1;
+    printf("bt ttytest expired\n");
+}
+
+/*
+void
+proc_reset()
+{
+    signal(SIGALRM, expired);
+
+    printf( "proc_reset");
+    alarm(8);
+
+    hci_send_buf(hci_reset, sizeof(hci_reset));
+
+    read_event(uart_fd, buffer);
+
+    alarm(0);
+}*/
+
+#define CONF_COMMENT '#'
+#define CONF_DELIMITERS " =\n\r\t"
+#define CONF_VALUES_DELIMITERS "=\n\r\t"
+#define CONF_MAX_LINE_LEN 255
+void get_tty_conf(const char *p_path,char *ttyPort)
+{
+    FILE    *p_file;
+    char    *p_name;
+    char    *p_value;
+    char    line[CONF_MAX_LINE_LEN+1]; /* add 1 for \0 char */
+
+    printf( "Attempt to load conf from %s", p_path);
+
+    if ((p_file = fopen(p_path, "r")) != NULL)
+    {
+        /* read line by line */
+        while (fgets(line, CONF_MAX_LINE_LEN+1, p_file) != NULL)
+        {
+            if (line[0] == CONF_COMMENT)
+            continue;
+
+            p_name = strtok(line, CONF_DELIMITERS);
+
+            if (NULL == p_name)
+            {
+                continue;
+            }
+
+            p_value = strtok(NULL, CONF_DELIMITERS);
+
+            if (NULL == p_value)
+            {
+                printf( "vnd_load_conf: missing value for name: %s", p_name);
+                continue;
+            }
+
+            if (strcmp("UartPort", (const char *)p_name) == 0){
+                printf("get ttyPort %s", p_value);
+                strcpy(ttyPort,p_value);
+                fclose(p_file);
+                return;
+            }
+
+        }
+
+        fclose(p_file);
+    }
+    else
+    {
+        printf( "vnd_load_conf file >%s< not found", p_path);
+    }
+    strcpy(ttyPort,"/dev/ttyS1");
+}
+
+int test_rtktty()
+{
+    init_uart_rtk();
+    hci_send_cmd(hci_rtksyc, sizeof(hci_rtksyc));
+    readRtkTty(uart_fd, buffer);
+    return ttytestResult;
+}
+int test_brcmtty()
+{
+    init_uart_brcm();
+    hci_send_cmd(hci_reset, sizeof(hci_reset));
+    readBrcmTty(uart_fd, buffer);
+    return ttytestResult;
+}
+
+void ttytestThread()
+{
+    char ttyPort[30]={0};
+    int i;
+    system("echo 1 > /sys/class/rfkill/rfkill0/state");
+    sleep(1);
+    get_tty_conf("/pcba/bt_vendor.conf",ttyPort);
+    if ((uart_fd = open(ttyPort, O_RDWR | O_NOCTTY | O_NONBLOCK)) == -1) {
+        printf( "port could not be opened, error %d\n", errno);
+    }
+
+    for(i=0; i<3; i++){
+        if (test_brcmtty() >= 0) return;
+        if (test_rtktty() >= 0) return;
+    }
+}
+
+int bluetoothtty_test()
+{
+    int i;
+
+    std::thread *temp = new std::thread(&ttytestThread);
+    if (!temp) {
+        printf("failed to create bt_test thread.\n");
+        return -1;
+    }
+    for(i=10; i>0; i--){
+        sleep(1);
+        if (ttytestResult == 0)
+        return 0;
+    }
+    return -1;	
+}
+#endif
+
+void *bt_test(void *argv, display_callback *hook)
+{
+    struct testcase_info *tc_info = (struct testcase_info *)argv;
+    int ret = 0;
+
+    char content[50];
+    snprintf(content, sizeof(content), "%s:[%s..]", PCBA_BLUETOOTH, PCBA_TESTING);
+    hook->handle_refresh_screen(tc_info->y, content);
+    #if defined(SOFIA3GR_PCBA)
+    ret = Sofia3gr_bluedroid_test();
+    #elif defined (BLUETOOTH_TTY_TEST)
+    ret = bluetoothtty_test();
+    #else
+    switch (get_chip_type()) {
+        case RK903:
+        case RTK8723BS:
+        case BK3515:
+        ret = bt_test_bluedroid();
+        break;
+        /*case SOFIA_3GR:
+        ret = Sofia3gr_bluedroid_test();
+        break;*/
+        default:
+        ret = bt_test_bluedroid();//bt_test_bluez();
+        break;
+    }
+    #endif
+
+    if (ret==0) {
+        snprintf(content, sizeof(content), "%s:[%s]",PCBA_BLUETOOTH, PCBA_SECCESS);
+        tc_info->result = 0;
+    }
+    else {
+        snprintf(content, sizeof(content), "%s:[%s]",PCBA_BLUETOOTH, PCBA_FAILED);
+        tc_info->result = -1;
+    }
+    hook->handle_refresh_screen_hl(tc_info->y, content, tc_info->result != 0);
+    return 0;
+}
+
diff --git a/bootable/recovery/pcba_core/bt_test.h b/bootable/recovery/pcba_core/bt_test.h
new file mode 100644
index 0000000000..a20c7d69ce
--- /dev/null
+++ b/bootable/recovery/pcba_core/bt_test.h
@@ -0,0 +1,16 @@
+#ifndef __BT_TEST_H_
+#define __BT_TEST_H_
+
+#include "display_callback.h"
+
+void* bt_test(void* argv, display_callback *hook);
+struct bt_msg {
+	int result;
+	int x;
+	int y;
+	int w;
+	int h;
+	char *ssid;
+};
+
+#endif
diff --git a/bootable/recovery/pcba_core/common.h b/bootable/recovery/pcba_core/common.h
new file mode 100644
index 0000000000..bebb8f2b8e
--- /dev/null
+++ b/bootable/recovery/pcba_core/common.h
@@ -0,0 +1,221 @@
+#ifndef RECOVERY_COMMON_H
+#define RECOVERY_COMMON_H
+
+#include <stdio.h>
+enum { INSTALL_SUCCESS, INSTALL_ERROR, INSTALL_CORRUPT };
+
+// These are just the defines for the non-const internal variables
+#include "variables.h"
+
+#if (defined ROTATE_SCREEN_90) || (defined ROTATE_SCREEN_270)
+#define MAX_COLS 66
+#define MAX_ROWS 96
+#else
+#define MAX_COLS 96
+#define MAX_ROWS 66
+#endif
+
+#define  kMaxTiles  50
+
+#if (defined ROTATE_SCREEN_90) || (defined ROTATE_SCREEN_270)
+#define MENU_MAX_COLS 500
+#define MENU_MAX_ROWS 50
+#else
+#define MENU_MAX_COLS 50
+#define MENU_MAX_ROWS 500
+#endif
+
+
+
+#ifdef RK3288_PCBA
+#define CHAR_WIDTH 30
+#define CHAR_HEIGHT 60
+#else
+#define CHAR_WIDTH 18
+#define CHAR_HEIGHT 32
+#endif
+
+int ensure_path_mounted(const char* path);
+char** prepend_title(const char** headers);
+static const char *SDCARD_ROOT = "/sdcard";
+
+// Initialize the graphics system.
+void ui_init();
+void ui_print_init(void);
+void ui_print_xy_rgba(int t_col,int t_row,int r,int g,int b,int a,const char * fmt,...);
+void ui_display_sync(int t_col,int t_row,int r,int g,int b,int a,const char* fmt,...);
+void FillColor(int r,int g,int b,int a,int left,int top,int width,int height);
+
+struct display_info {
+	int col;
+	int row;
+	int r;
+	int g;
+	int b;
+	int a;
+	char string[128];
+};
+
+void ui_print_xy_rgba_multi(struct display_info *info, int count);
+
+extern int notError;
+
+// Use KEY_* codes from <linux/input.h> or KEY_DREAM_* from "minui/minui.h".
+int ui_wait_key();            // waits for a key/button press, returns the code
+int ui_key_pressed(int key);  // returns >0 if the code is currently pressed
+int ui_text_visible();        // returns >0 if text log is currently visible
+void ui_show_text(int visible);
+void ui_clear_key_queue();
+
+// Write a message to the on-screen log shown with Alt-L (also to stderr).
+// The screen is small, and users may need to report these messages to support,
+// so keep the output short and not too cryptic.
+void ui_print(const char *fmt, ...) __attribute__((format(printf, 1, 2)));
+void ui_print_overwrite(const char *fmt, ...) __attribute__((format(printf, 1, 2)));
+
+// Display some header text followed by a menu of items, which appears
+// at the top of the screen (in place of any scrolling ui_print()
+// output, if necessary).
+void ui_start_menu(char** headers, char** items, int initial_selection);
+// Set the menu highlight to the given index, and return it (capped to
+// the range [0..numitems).
+int ui_menu_select(int sel);
+// End menu mode, resetting the text overlay so that ui_print()
+// statements will be displayed.
+void ui_end_menu();
+
+// Set the icon (normally the only thing visible besides the progress bar).
+enum {
+  BACKGROUND_ICON_NONE,
+  BACKGROUND_ICON_MAIN,
+  BACKGROUND_ICON_WIPE,
+  BACKGROUND_ICON_WIPE_CHOOSE,
+  BACKGROUND_ICON_FLASH_ZIP,
+  BACKGROUND_ICON_INSTALLING,
+  BACKGROUND_ICON_NANDROID,
+  BACKGROUND_ICON_ERROR,
+  NUM_BACKGROUND_ICONS
+};
+void ui_set_background(int icon);
+
+// Show a progress bar and define the scope of the next operation:
+//   portion - fraction of the progress bar the next operation will use
+//   seconds - expected time interval (progress bar moves at this minimum rate)
+void ui_show_progress(float portion, int seconds);
+void ui_set_progress(float fraction);  // 0.0 - 1.0 within the defined scope
+
+// Default allocation of progress bar segments to operations
+static const int VERIFICATION_PROGRESS_TIME = 60;
+static const float VERIFICATION_PROGRESS_FRACTION = 0.25;
+static const float DEFAULT_FILES_PROGRESS_FRACTION = 0.4;
+static const float DEFAULT_IMAGE_PROGRESS_FRACTION = 0.1;
+
+// Show a rotating "barberpole" for ongoing operations.  Updates automatically.
+void ui_show_indeterminate_progress();
+
+// Hide and reset the progress bar.
+void ui_reset_progress();
+
+#define LOGE(...) fprintf(stdout, "E:" __VA_ARGS__)
+#define LOGW(...) fprintf(stdout, "W:" __VA_ARGS__)
+#define LOGI(...) fprintf(stdout, "I:" __VA_ARGS__)
+
+#if 0
+#define LOGV(...) fprintf(stdout, "V:" __VA_ARGS__)
+#define LOGD(...) fprintf(stdout, "D:" __VA_ARGS__)
+#else
+#define LOGV(...) do {} while (0)
+#define LOGD(...) do {} while (0)
+#endif
+
+#define STRINGIFY(x) #x
+#define EXPAND(x) STRINGIFY(x)
+
+typedef struct {
+    const char* mount_point;  // eg. "/cache".  must live in the root directory.
+
+    const char* fs_type;      // "yaffs2" or "ext4" or "vfat"
+
+    const char* device;       // MTD partition name if fs_type == "yaffs"
+                              // block device if fs_type == "ext4" or "vfat"
+
+    const char* device2;      // alternative device to try if fs_type
+                              // == "ext4" or "vfat" and mounting
+                              // 'device' fails
+
+    long long length;         // (ext4 partition only) when
+                              // formatting, size to use for the
+                              // partition.  0 or negative number
+                              // means to format all but the last
+                              // (that much).
+} Volume;
+
+void wipe_data(int confirm);
+
+int gui_set_variable(const char*, const char*);
+
+
+// From ICS common, allows building custom recovery_ui.c files
+typedef struct {
+    // number of frames in indeterminate progress bar animation
+    int indeterminate_frames;
+
+    // number of frames per second to try to maintain when animating
+    int update_fps;
+
+    // number of frames in installing animation.  may be zero for a
+    // static installation icon.
+    int installing_frames;
+
+    // the install icon is animated by drawing images containing the
+    // changing part over the base icon.  These specify the
+    // coordinates of the upper-left corner.
+    int install_overlay_offset_x;
+    int install_overlay_offset_y;
+
+} UIParameters;
+
+
+
+// This handles the special partitions
+#ifndef SP1_NAME
+#define SP1_NAME
+#define SP1_BACKUP_METHOD none
+#define SP1_MOUNTABLE 0
+#endif
+#ifndef SP1_DISPLAY_NAME
+#define SP1_DISPLAY_NAME SP1_NAME
+#endif
+#ifndef SP2_NAME
+#define SP2_NAME
+#define SP2_BACKUP_METHOD none
+#define SP2_MOUNTABLE 0
+#endif
+#ifndef SP2_DISPLAY_NAME
+#define SP2_DISPLAY_NAME SP2_NAME
+#endif
+#ifndef SP3_NAME
+#define SP3_NAME
+#define SP3_BACKUP_METHOD none
+#define SP3_MOUNTABLE 0
+#endif
+#ifndef SP3_DISPLAY_NAME
+#define SP3_DISPLAY_NAME SP3_NAME
+#endif
+
+
+struct manual_item
+{
+	const char *name;
+	const int x;
+	const int y;
+	const int w;
+	const int h;
+	void *argc;
+	int (*func)(void *argv);
+};
+int start_manual_test_item(int x,int y);
+int get_cur_print_y(void);
+
+
+#endif  // RECOVERY_COMMON_H
diff --git a/bootable/recovery/pcba_core/ddr_emmc_test.cpp b/bootable/recovery/pcba_core/ddr_emmc_test.cpp
new file mode 100644
index 0000000000..ebe0cc5a8c
--- /dev/null
+++ b/bootable/recovery/pcba_core/ddr_emmc_test.cpp
@@ -0,0 +1,159 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <fcntl.h>
+
+#include "math.h"
+#include "test_case.h"
+#include "Language/language.h"
+#include "ddr_emmc_test.h"
+
+#if defined(RK3399_PCBA) || defined(RK3368_PCBA) || defined(rk3326_PCBA)
+#define READ_DDR_COMMAND "cat /proc/zoneinfo | busybox grep present | \
+        busybox awk '{print $2}'"
+#else
+#define READ_DDR_COMMAND "cat /proc/zoneinfo | busybox grep present | \
+        busybox awk 'BEGIN{a=0}{a+=$2}END{print a}'"
+#endif
+
+static char *emmc_path_name[] = {"/sys/block/rknand0/size",
+                                 "/sys/bus/mmc/devices/mmc0:0001/block/mmcblk0/size",
+                                 "/sys/bus/mmc/devices/mmc1:0001/block/mmcblk1/size",
+                                 "/sys/bus/mmc/devices/mmc2:0001/block/mmcblk2/size"
+                                };
+
+/* for ddr  */
+int ddr_exec(const char *cmd, char *tmp, unsigned int length)
+{
+    FILE *pp = popen(cmd, "r");
+
+    if (!pp)
+    return -1;
+    if (fgets(tmp, length, pp) == NULL) {
+        printf("popen read from cmd is NULL!\n");
+        pclose(pp);
+        return -1;
+    }
+    pclose(pp);
+    return 0;
+}
+
+/* for emmc  */
+static int readFromFile(const char *path, char *buf, size_t size)
+{
+    if (!path)
+    return -1;
+    FILE* fd = fopen(path,"r");
+    printf("%s:%d\n", __func__,__LINE__);
+    if (!fd) {
+        printf("Could not open '%s'", path);
+        return -1;
+    }
+    printf("%s:%d\n", __func__,__LINE__);
+    fseek(fd, 0, SEEK_SET);
+    ssize_t count = fread(buf, size,1,fd);
+    printf("%s:%d buf:%s,count=%d\n", __func__,__LINE__,buf,(int)count);
+    /*
+    if (count == 1) {
+    while (size > 0 && buf[size-1] == '\n')
+    size--;
+    buf[size] = '\0';
+} else {
+    buf[0] = '\0';
+}
+    */
+    printf("%s:%d buf:%s\n", __func__,__LINE__,buf);
+    fclose(fd);
+    return count;
+}
+
+int get_emmc_size(char *size_data)
+{
+    char i;
+    double size = (double)(atoi(size_data))/2/1024/1024;
+
+    if (size > 0 && size <= 1)  /*1 GB */
+    return 1;
+    for (i = 0; i < 10; i++) {
+        if (size > pow(2, i) && size <= pow(2, i+1))  /*2 - 512 GB*/
+        return pow(2, i+1);
+    }
+    return -1;
+}
+
+void *ddr_test(void *argv, display_callback *hook)
+{
+    int ddr_ret = 0;
+    char ddrsize_char[20];
+    int ddr_size = 0;
+    char out_string[128];
+    struct testcase_info *tc_info = (struct testcase_info *)argv;
+    int index = tc_info->y;
+
+    memset(out_string, 0, sizeof(out_string));
+    memset(ddrsize_char, 0, sizeof(ddrsize_char));
+    ddr_ret = ddr_exec(READ_DDR_COMMAND,
+                       ddrsize_char, sizeof(ddrsize_char));
+    if (ddr_ret >= 0) {
+        ddr_size = (int)(atoi(ddrsize_char)*4/1024);
+        printf("=========== ddr_zize is : %dGB==========\n",ddr_size);
+        snprintf(out_string, sizeof(out_string), "%s:[%s] { %s:%dMB }",
+                 PCBA_DDR_EMMC, PCBA_SECCESS,
+                 PCBA_DDR, ddr_size);
+        hook->handle_refresh_screen_hl(index, out_string, false);
+    } else {
+        snprintf(out_string, sizeof(out_string), "%s:[%s] { %s:%s }",
+                 PCBA_DDR_EMMC, PCBA_FAILED,
+                 PCBA_DDR, PCBA_FAILED);
+        hook->handle_refresh_screen_hl(index, out_string, true);
+    }
+    return argv;
+}
+
+void *flash_test(void *argv, display_callback *hook) {
+    int emmc_ret = 0;
+    char emmcsize_char[20];
+    int emmc_size = 0;
+    int emmc_path_size = 0;
+    int i = 0;
+    char flash_type_name[20] = "null";
+    char out_string[128];
+    struct testcase_info *tc_info = (struct testcase_info *)argv;
+    int index = tc_info->y;
+
+    memset(out_string, 0, sizeof(out_string));
+    memset(emmcsize_char, 0, sizeof(emmcsize_char));
+    emmc_path_size = sizeof(emmc_path_name)/sizeof(*emmc_path_name);
+    for (i=0; i < emmc_path_size ;i++) {
+        printf("%s:%d,%s\n", __func__,__LINE__,emmc_path_name[i]);
+        emmc_ret = readFromFile(emmc_path_name[i], emmcsize_char, sizeof(emmcsize_char));
+        printf("%s:%d emmc_ret=%d\n", __func__,__LINE__,emmc_ret);
+        if (emmc_ret >= 0) {  /*read back normal*/
+                            emmc_size = get_emmc_size(emmcsize_char);
+                            printf("%s:%d\n", __func__,__LINE__);
+                            if (emmc_size < 0) {
+                                emmc_ret = -1;
+                            }
+                            if (i==0) {
+                                strcpy(flash_type_name, PCBA_NAND);
+                            }else {
+                                strcpy(flash_type_name, PCBA_EMMC);
+                            }
+                            printf("%s:%d\n", __func__,__LINE__);
+                            break;
+                           }
+    }
+
+    if(emmc_ret >= 0){
+        snprintf(out_string, sizeof(out_string), "%s:[%s] { %s:%dGB }",
+                 PCBA_DDR_EMMC, PCBA_SECCESS,
+                 flash_type_name, emmc_size);
+        hook->handle_refresh_screen_hl(index, out_string, false);
+    }else{
+        snprintf(out_string, sizeof(out_string), "%s:[%s] { %s:%dGB }",
+                 PCBA_DDR_EMMC, PCBA_FAILED,
+                 flash_type_name, emmc_size);
+        hook->handle_refresh_screen_hl(index, out_string, true);
+    }
+    return argv;
+}
diff --git a/bootable/recovery/pcba_core/ddr_emmc_test.h b/bootable/recovery/pcba_core/ddr_emmc_test.h
new file mode 100644
index 0000000000..3d1c65f1e3
--- /dev/null
+++ b/bootable/recovery/pcba_core/ddr_emmc_test.h
@@ -0,0 +1,9 @@
+#ifndef __DDR_EMMC_TEST_H_
+#define __DDR_EMMC_TEST_H_
+
+#include "display_callback.h"
+
+void *flash_test(void *argv, display_callback *hook);
+void *ddr_test(void *argv, display_callback *hook);
+
+#endif
diff --git a/bootable/recovery/pcba_core/debug.h b/bootable/recovery/pcba_core/debug.h
new file mode 100644
index 0000000000..b214ef4d38
--- /dev/null
+++ b/bootable/recovery/pcba_core/debug.h
@@ -0,0 +1,75 @@
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+
+#define PCBA_VERSION             	0x00010300
+#define COPYRIGHT                       "PCBA V1.3.0 Copyright (C) 2012 Rockchip"
+
+
+#define CMD_PIPE_NAME                   "/tmp/cmd_pipe"
+#define VOLUME_PIPE_NAME                "/tmp/volume_pipe"
+#define CAMERA_PIPE_NAME                "/tmp/camera_pipe"
+
+#define TEST_COMPLETION                 "done"
+
+#define DB_LOG_LEVEL                    4
+
+#if   DB_LOG_LEVEL == 1
+#define DB_ERROR
+#elif DB_LOG_LEVEL == 2
+#define DB_ERROR
+#define DB_WARN
+#elif DB_LOG_LEVEL == 3
+#define DB_ERROR
+#define DB_WARN
+#define DB_MSG
+#elif DB_LOG_LEVEL == 4
+#define DB_ERROR
+#define DB_WARN
+#define DB_MSG
+#define DB_DEBUG
+#elif DB_LOG_LEVEL == 5
+#define DB_ERROR
+#define DB_WARN
+#define DB_MSG
+#define DB_DEBUG
+#define DB_DUMP
+#endif
+
+#ifdef DB_ERROR
+#define db_error(fmt, ...) \
+    do { fprintf(stderr, "(error): "); fprintf(stderr, fmt, ##__VA_ARGS__); } while (0)
+#else
+#define db_error(fmt, ...)
+#endif /* DB_ERROR */
+
+#ifdef DB_WARN
+#define db_warn(fmt, ...) \
+    do { fprintf(stdout, "(warn): "); fprintf(stdout, fmt, ##__VA_ARGS__); } while (0)
+#else
+#define db_warn(fmt, ...)
+#endif /* DB_WARN */
+
+#ifdef DB_MSG
+#define db_msg(fmt, ...) \
+    do { fprintf(stdout, "(msg): "); fprintf(stdout, fmt, ##__VA_ARGS__); } while (0)
+#else
+#define db_msg(fmt, ...)
+#endif /* DB_MSG */
+
+#ifdef DB_DEBUG
+#define db_debug(fmt, ...) \
+    do { fprintf(stdout, "(debug): "); fprintf(stdout, fmt, ##__VA_ARGS__); } while (0)
+#else
+#define db_debug(fmt, ...)
+#endif /* DB_DEBUG */
+
+#ifdef DB_DUMP
+#define db_dump(fmt, ...) \
+    do { fprintf(stdout, "(dump): "); fprintf(stdout, fmt, ##__VA_ARGS__); } while (0)
+#else
+#define db_dump(fmt, ...)
+#endif
+
+#endif 
+
diff --git a/bootable/recovery/pcba_core/display_callback.h b/bootable/recovery/pcba_core/display_callback.h
new file mode 100644
index 0000000000..82d4026258
--- /dev/null
+++ b/bootable/recovery/pcba_core/display_callback.h
@@ -0,0 +1,11 @@
+#ifndef _DISPLAY_CALLBACK_H_
+#define _DISPLAY_CALLBACK_H_
+
+#include <string>
+
+typedef struct display_callback {
+    void (*handle_refresh_screen)(int idx, std::string msg);
+    void (*handle_refresh_screen_hl)(int idx, std::string msg, bool highlight);
+} display_callback;
+
+#endif
diff --git a/bootable/recovery/pcba_core/extra-functions.h b/bootable/recovery/pcba_core/extra-functions.h
new file mode 100644
index 0000000000..5a9f04dbf1
--- /dev/null
+++ b/bootable/recovery/pcba_core/extra-functions.h
@@ -0,0 +1,93 @@
+#ifndef _EXTRAFUNCTIONS_HEADER
+#define _EXTRAFUNCTIONS_HEADER
+
+int __system(const char *command);
+FILE * __popen(const char *program, const char *type);
+int __pclose(FILE *iop);
+
+// Device ID variable / function
+extern char device_id[64];
+void get_device_id();
+static char* copy_sideloaded_package(const char* original_path);
+int install_zip_package(const char* zip_path_filename);
+
+// Menus
+void install_zip_menu(int pIdx);
+void advanced_menu();
+
+void show_fake_main_menu();
+
+void usb_storage_toggle();
+void wipe_dalvik_cache();
+void wipe_battery_stats();
+void wipe_rotate_data();
+int format_data_media();
+
+void format_menu();
+void main_wipe_menu();
+
+// Format Menu Stuff
+int erase_volume(const char *volume);
+static long tmplog_offset = 0;
+
+// Battery level
+char* print_batt_cap();
+
+void confirm_format(char* volume_name, char* volume_path);
+
+int get_menu_selection(char** headers, char** items, int menu_only, int initial_selection);
+
+char* zip_verify();
+char* reboot_after_flash();
+
+char* save_reboot_setting();
+void all_settings_menu(int pIdx);
+void time_zone_menu();
+void time_zone_minus();
+void time_zone_plus();
+void time_zone_offset();
+extern char time_zone_offset_string[5];
+extern char time_zone_dst_string[10];
+void time_zone_dst();
+void update_tz_environment_variables();
+
+// Menu Stuff
+#define GO_HOME 69
+extern int go_home;
+extern int go_menu;
+extern int go_restart;
+extern int go_reboot;
+extern int menu_loc_idx;
+extern int menu_loc[255];
+
+void inc_menu_loc(int bInt);
+void dec_menu_loc();
+
+char* isMounted(int mInt);
+void mount_menu(int pIdx);
+void chkMounts();
+extern int sysIsMounted;
+extern int datIsMounted;
+extern int cacIsMounted;
+extern int sdcIsMounted;
+extern int sdeIsMounted;
+extern char multi_zip_array[10][255];
+extern int multi_zip_index;
+
+extern int get_new_zip_dir;
+
+char* checkTheme(int tw_theme);
+
+void fix_perms();
+char* toggle_spam();
+
+static void show_menu_partition();
+void run_script(const char *str1, const char *str2, const char *str3, const char *str4, const char *str5, const char *str6, const char *str7, int request_confirm);
+
+void install_htc_dumlock(void);
+void htc_dumlock_restore_original_boot(void);
+void htc_dumlock_reflash_recovery_to_boot(void);
+
+void check_and_run_script(const char* script_file, const char* display_name);
+
+#endif // _EXTRAFUNCTIONS_HEADER
\ No newline at end of file
diff --git a/bootable/recovery/pcba_core/gsensor_test.cpp b/bootable/recovery/pcba_core/gsensor_test.cpp
new file mode 100644
index 0000000000..4ad091c455
--- /dev/null
+++ b/bootable/recovery/pcba_core/gsensor_test.cpp
@@ -0,0 +1,220 @@
+#define LOG_TAG "Sensors"
+
+#include <android-base/properties.h>
+#include <hardware/sensors.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <dirent.h>
+#include <math.h>
+#include <poll.h>
+#include <pthread.h>
+#include <linux/input.h>
+
+#include "gsensor_test.h"
+#include "../../../../hardware/rockchip/sensor/st/mma8452_kernel.h"              // Ϊ HAL ṩĹܽӿ. Ӧøӳļ.
+#include "common.h"
+#include "test_case.h"
+#include "language.h"
+
+extern "C" {
+    #include "script.h"
+}
+
+#define EVENT_TYPE_ACCEL_X          ABS_X
+#define EVENT_TYPE_ACCEL_Y          ABS_Y
+#define EVENT_TYPE_ACCEL_Z          ABS_Z
+#define ACCELERATION_RATIO_ANDROID_TO_HW        (9.80665f / 16384)
+#define  CTL_DEV_PATH    "/dev/mma8452_daemon"
+
+static float g_x = 0;
+static float g_y = 0;
+static float g_z = 0;
+
+static int openInput(const char* inputName)
+{
+    int fd = -1;
+    const char *dirname = "/dev/input";
+    char devname[512];
+    char *filename;
+    DIR *dir;
+    struct dirent *de;
+
+    //return getInput(inputName);
+
+    dir = opendir(dirname);
+    if(dir == NULL)
+        return -1;
+    strcpy(devname, dirname);
+    filename = devname + strlen(devname);
+    *filename++ = '/';
+    while((de = readdir(dir))) {
+        if(de->d_name[0] == '.' &&
+                (de->d_name[1] == '\0' ||
+                        (de->d_name[1] == '.' && de->d_name[2] == '\0')))
+            continue;
+        strcpy(filename, de->d_name);
+        fd = open(devname, O_RDONLY);
+        if (fd>=0) {
+            char name[80];
+            if (ioctl(fd, EVIOCGNAME(sizeof(name) - 1), &name) < 1) {
+                name[0] = '\0';
+            }
+            if (!strcmp(name, inputName)) {
+                break;
+            } else {
+                close(fd);
+                fd = -1;
+            }
+        }
+    }
+    closedir(dir);
+   
+    return fd;
+}
+
+static int  processEvent(int code, int value)
+{
+    float v;
+
+    switch (code) 
+    {
+        case EVENT_TYPE_ACCEL_X:
+            g_x = value * ACCELERATION_RATIO_ANDROID_TO_HW;
+            break;
+        case EVENT_TYPE_ACCEL_Y:
+            g_y = value * ACCELERATION_RATIO_ANDROID_TO_HW;
+            break;
+        case EVENT_TYPE_ACCEL_Z:
+            g_z = value * ACCELERATION_RATIO_ANDROID_TO_HW;
+            break;
+    }
+
+    return 0;
+}
+
+static int readEvents(int fd)
+{
+    int i;
+    struct input_event  event;
+
+    for (i=0; i<6; i++) {
+        ssize_t n = read(fd, &event,sizeof(struct input_event));
+        if (n < 0)
+        {
+            printf("gsensor read fail!\n");
+            return n;
+        }
+
+        int type = event.type;
+        if (type == EV_ABS)
+            processEvent(event.code, event.value);
+    }
+
+    return 0;
+}
+
+void* gsensor_test(void *argv, display_callback *hook)
+{
+    int do_calibration;
+    int is_calibration = 0;
+    int tempFd;
+    int ret;
+    int fd;
+    short delay = 20; // 20ms
+    struct gsensor_msg g_msg;
+    struct testcase_info *tc_info = (struct testcase_info*)argv;
+    int fps = android::base::GetIntProperty("ro.recovery.ui.animation_fps", 30);
+
+    g_msg.y = tc_info->y;
+    char msg[50];
+    snprintf(msg, sizeof(msg), "%s:[%s..]", PCBA_GSENSOR, PCBA_TESTING);
+    hook->handle_refresh_screen(tc_info->y, msg);
+    tc_info->result = 0;
+
+    fd = openInput("gsensor");
+    if (fd < 0)
+    {
+        hook->handle_refresh_screen_hl(tc_info->y, "Device GSensor:[Failed to open driver!]", true);
+        g_msg.result = -1;
+        tc_info->result = -1;
+        return argv;
+    }
+
+    int fd_dev = open(CTL_DEV_PATH, O_RDONLY);
+    if (fd_dev<0)
+    {
+        printf("open gsensor demon fail\n");
+        hook->handle_refresh_screen_hl(tc_info->y, "Device GSensor:[Failed to open daemon!]", true);
+        g_msg.result = -1;
+        tc_info->result = -1;
+        close(fd);
+        return argv;
+    }
+
+    ret = ioctl(fd_dev, GSENSOR_IOCTL_APP_SET_RATE, &delay);
+    if (ret < 0)
+    {
+        printf("set sensor rate fail!\n");
+        hook->handle_refresh_screen_hl(tc_info->y, "Device GSensor:[Failed to set rate!]", true);
+        g_msg.result = -1;
+        tc_info->result = -1;
+        close(fd_dev);
+        close(fd);
+        return argv;
+    }
+
+    ret = ioctl(fd_dev, MMA_IOCTL_START);
+    if (ret < 0)
+    {
+        printf("start sensor fail!\n");
+        hook->handle_refresh_screen_hl(tc_info->y, "Device GSensor:[Failed to start!]", true);
+        g_msg.result = -1;
+        tc_info->result = -1;
+        close(fd_dev);
+        close(fd);
+        return argv;
+    }
+
+    tempFd = open("/sys/class/sensor_class/accel_calibration", O_RDWR);
+    if (tempFd > 0)
+        printf("open /sys/class/sensor_class/accel_calibration success\n");
+
+    script_fetch("gsensor", "calibrate", &do_calibration, 1);
+    printf("gsensor do calibration = %d\n", do_calibration);
+    for (;;)
+    {
+        readEvents(fd);
+        if (tempFd && do_calibration && !is_calibration) {
+            char c = '1';
+            ret = write(tempFd, &c, 1);
+            if (ret >= 0) {
+                printf("gsensor calibrate success\n");
+                is_calibration = 1;
+            } else {
+                printf("gsensor calibrate failed, ret = %d, %s\n", ret, strerror(errno));
+            }
+        }
+        char current_data[50];
+        if (do_calibration) {
+            snprintf(current_data, sizeof(current_data), "%s:[%s] %s[%s] { %4f %4f %4f }",
+                     PCBA_GSENSOR, PCBA_SECCESS, PCBA_GSENSOR_CALIBRATE,
+                     is_calibration ? PCBA_SECCESS: PCBA_FAILED,
+                     g_x, g_y, g_z);
+            hook->handle_refresh_screen_hl(tc_info->y, current_data, !is_calibration);
+        } else {
+            snprintf(current_data, sizeof(current_data), "%s:[%s] { %4f %4f %4f }", PCBA_GSENSOR, PCBA_SECCESS, g_x, g_y, g_z);
+            hook->handle_refresh_screen_hl(tc_info->y, current_data, false);
+        }
+        usleep((1 * 1000 * 1000)/fps);
+    }
+    if (tempFd)
+        close(tempFd);
+    close(fd);
+    close(fd_dev);
+
+    snprintf(msg, sizeof(msg), "%s:[%s]", PCBA_GSENSOR, PCBA_SECCESS);
+    hook->handle_refresh_screen_hl(tc_info->y, msg, false);
+    tc_info->result = 0;
+    return argv;
+}
diff --git a/bootable/recovery/pcba_core/gsensor_test.h b/bootable/recovery/pcba_core/gsensor_test.h
new file mode 100644
index 0000000000..1d8d87c5af
--- /dev/null
+++ b/bootable/recovery/pcba_core/gsensor_test.h
@@ -0,0 +1,16 @@
+#ifndef _RK_GSENSOR_H
+#define _RK_GSENSOR_H
+
+#include "display_callback.h"
+
+void* gsensor_test(void *argv, display_callback *hook);
+void* gsensor_test_mpu(void *argv, display_callback *hook);
+void* compass_test_mpu(void *argv, display_callback *hook);
+
+struct gsensor_msg
+{
+	int result;
+	int y;
+};
+
+#endif
diff --git a/bootable/recovery/pcba_core/gsensor_test_mpu.cpp b/bootable/recovery/pcba_core/gsensor_test_mpu.cpp
new file mode 100644
index 0000000000..dbf620ef31
--- /dev/null
+++ b/bootable/recovery/pcba_core/gsensor_test_mpu.cpp
@@ -0,0 +1,792 @@
+#define LOG_TAG "Sensors"
+
+#include <hardware/sensors.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+#include <math.h>
+#include <poll.h>
+#include <pthread.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include <linux/input.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include "gsensor_test.h"
+#include "common.h"
+#include "test_case.h"
+#include "language.h"
+
+struct sysfs_attrbs {
+       char *chip_enable;
+       char *power_state;
+       char *dmp_firmware;
+       char *firmware_loaded;
+       char *dmp_on;
+       char *dmp_int_on;
+       char *dmp_event_int_on;
+       char *dmp_output_rate;
+       char *tap_on;
+       char *key;
+       char *self_test;
+       char *temperature;
+
+       char *gyro_enable;
+       char *gyro_fifo_rate;
+       char *gyro_fsr;
+       char *gyro_orient;
+       char *gyro_x_fifo_enable;
+       char *gyro_y_fifo_enable;
+       char *gyro_z_fifo_enable;
+
+       char *accel_enable;
+       char *accel_fifo_rate;
+       char *accel_fsr;
+       char *accel_bias;
+       char *accel_orient;
+       char *accel_x_fifo_enable;
+       char *accel_y_fifo_enable;
+       char *accel_z_fifo_enable;
+
+       char *quaternion_on;
+       char *in_quat_r_en;
+       char *in_quat_x_en;
+       char *in_quat_y_en;
+       char *in_quat_z_en;
+
+       char *in_timestamp_en;
+       char *trigger_name;
+       char *current_trigger;
+       char *buffer_length;
+
+       char *display_orientation_on;
+       char *event_display_orientation;
+
+	   char *compass_enable;
+       char *compass_x_fifo_enable;
+       char *compass_y_fifo_enable;
+       char *compass_z_fifo_enable;
+       char *compass_rate;
+       char *compass_scale;
+       char *compass_orient;
+} ;
+
+#define EVENT_TYPE_ACCEL_X          ABS_X
+#define EVENT_TYPE_ACCEL_Y          ABS_Z
+#define EVENT_TYPE_ACCEL_Z          ABS_Y
+#define ACCELERATION_RATIO_ANDROID_TO_HW        (9.80665f / 1000000)
+
+
+
+//static long lg_x = 0;
+//static long lg_y = 0;
+//static long lg_z = 0;
+
+static long g_x = 0;
+static long g_y = 0;
+static long g_z = 0;
+
+static long c_x = 0;
+static long c_y = 0;
+static long c_z = 0;
+
+
+
+#define MAX_CHIP_ID_LEN			(20)
+#define MAX_SYSFS_NAME_LEN		(100)
+#define IIO_BUFFER_LENGTH		(480)
+
+
+#define IIO_DEVICE_NODE			"/dev/iio:device0"
+
+static char* sysfs_names_ptr;
+
+#define MAX_SYSFS_ATTRB (sizeof(struct sysfs_attrbs) / sizeof(char*))
+
+struct sysfs_attrbs mpu;
+int iio_fd = -1;
+
+char mIIOBuffer[(16 + 8 * 3 + 8) * IIO_BUFFER_LENGTH];
+
+static int int_flag = 0;
+
+
+static int inv_init_sysfs_attributes(void)
+{
+    unsigned char i = 0;
+    char sysfs_path[MAX_SYSFS_NAME_LEN];
+    char iio_trigger_path[MAX_SYSFS_NAME_LEN], tbuf[2];
+    char *sptr;
+    char **dptr;
+    int num;
+
+    memset(sysfs_path, 0, sizeof(sysfs_path));
+    memset(iio_trigger_path, 0, sizeof(iio_trigger_path));
+
+    sysfs_names_ptr =
+            (char*)malloc(sizeof(char[MAX_SYSFS_ATTRB][MAX_SYSFS_NAME_LEN]));
+    sptr = sysfs_names_ptr;
+    if (sptr != NULL) {
+        dptr = (char**)&mpu;
+        do {
+            *dptr++ = sptr;
+            memset(sptr, 0, sizeof(sptr));
+            sptr += sizeof(char[MAX_SYSFS_NAME_LEN]);
+        } while (++i < MAX_SYSFS_ATTRB);
+    } else {
+        printf("%s line=%d:couldn't alloc mem for sysfs paths \n", __FUNCTION__, __LINE__);
+        return -1;
+    }
+
+    // get proper (in absolute/relative) IIO path & build MPU's sysfs paths
+    //inv_get_sysfs_path(sysfs_path);
+    //inv_get_iio_trigger_path(iio_trigger_path);
+	strcpy(sysfs_path,"/sys/bus/iio/devices/iio:device0");
+	strcpy(iio_trigger_path,"/sys/bus/iio/devices/trigger0");
+
+    if (strcmp(sysfs_path, "") == 0  || strcmp(iio_trigger_path, "") == 0)
+        return 0;
+
+    sprintf(mpu.key, "%s%s", sysfs_path, "/key");
+    sprintf(mpu.chip_enable, "%s%s", sysfs_path, "/buffer/enable");
+    sprintf(mpu.buffer_length, "%s%s", sysfs_path, "/buffer/length");
+    sprintf(mpu.power_state, "%s%s", sysfs_path, "/power_state");
+    sprintf(mpu.in_timestamp_en, "%s%s", sysfs_path, 
+            "/scan_elements/in_timestamp_en");
+    sprintf(mpu.trigger_name, "%s%s", iio_trigger_path, "/name");
+    sprintf(mpu.current_trigger, "%s%s", sysfs_path, "/trigger/current_trigger");
+
+    sprintf(mpu.dmp_firmware, "%s%s", sysfs_path,"/dmp_firmware");
+    sprintf(mpu.firmware_loaded,"%s%s", sysfs_path, "/firmware_loaded");
+    sprintf(mpu.dmp_on,"%s%s", sysfs_path, "/dmp_on");
+    sprintf(mpu.dmp_int_on,"%s%s", sysfs_path, "/dmp_int_on");
+    sprintf(mpu.dmp_event_int_on,"%s%s", sysfs_path, "/dmp_event_int_on");
+    sprintf(mpu.dmp_output_rate,"%s%s", sysfs_path, "/dmp_output_rate");
+    sprintf(mpu.tap_on, "%s%s", sysfs_path, "/tap_on");
+
+    sprintf(mpu.self_test, "%s%s", sysfs_path, "/self_test");
+
+    sprintf(mpu.temperature, "%s%s", sysfs_path, "/temperature");
+    sprintf(mpu.gyro_enable, "%s%s", sysfs_path, "/gyro_enable");
+    sprintf(mpu.gyro_fifo_rate, "%s%s", sysfs_path, "/sampling_frequency");
+    sprintf(mpu.gyro_orient, "%s%s", sysfs_path, "/gyro_matrix");
+    sprintf(mpu.gyro_x_fifo_enable, "%s%s", sysfs_path, 
+            "/scan_elements/in_anglvel_x_en");
+    sprintf(mpu.gyro_y_fifo_enable, "%s%s", sysfs_path, 
+            "/scan_elements/in_anglvel_y_en");
+    sprintf(mpu.gyro_z_fifo_enable, "%s%s", sysfs_path, 
+            "/scan_elements/in_anglvel_z_en");
+    sprintf(mpu.gyro_fsr, "%s%s", sysfs_path, "/in_anglvel_scale");
+
+    sprintf(mpu.accel_enable, "%s%s", sysfs_path, "/accl_enable");
+    sprintf(mpu.accel_fifo_rate, "%s%s", sysfs_path, "/sampling_frequency");
+    sprintf(mpu.accel_orient, "%s%s", sysfs_path, "/accl_matrix");
+
+#ifndef THIRD_PARTY_ACCEL
+    sprintf(mpu.accel_fsr, "%s%s", sysfs_path, "/in_accel_scale");
+    sprintf(mpu.accel_bias, "%s%s", sysfs_path, "/accl_bias");
+#endif
+
+    sprintf(mpu.accel_x_fifo_enable, "%s%s", sysfs_path, 
+            "/scan_elements/in_accel_x_en");
+    sprintf(mpu.accel_y_fifo_enable, "%s%s", sysfs_path, 
+            "/scan_elements/in_accel_y_en");
+    sprintf(mpu.accel_z_fifo_enable, "%s%s", sysfs_path, 
+            "/scan_elements/in_accel_z_en");
+
+    sprintf(mpu.quaternion_on, "%s%s", sysfs_path, "/quaternion_on");
+    sprintf(mpu.in_quat_r_en, "%s%s", sysfs_path, 
+            "/scan_elements/in_quaternion_r_en");
+    sprintf(mpu.in_quat_x_en, "%s%s", sysfs_path, 
+            "/scan_elements/in_quaternion_x_en");
+    sprintf(mpu.in_quat_y_en, "%s%s", sysfs_path, 
+            "/scan_elements/in_quaternion_y_en");
+    sprintf(mpu.in_quat_z_en, "%s%s", sysfs_path, 
+            "/scan_elements/in_quaternion_z_en");
+
+    sprintf(mpu.display_orientation_on, "%s%s", sysfs_path, 
+            "/display_orientation_on");
+    sprintf(mpu.event_display_orientation, "%s%s", sysfs_path, 
+            "/event_display_orientation");
+
+	sprintf(mpu.compass_enable, "%s%s", sysfs_path, "/compass_enable");
+    sprintf(mpu.compass_x_fifo_enable, "%s%s", sysfs_path, "/scan_elements/in_magn_x_en");
+    sprintf(mpu.compass_y_fifo_enable, "%s%s", sysfs_path, "/scan_elements/in_magn_y_en");
+    sprintf(mpu.compass_z_fifo_enable, "%s%s", sysfs_path, "/scan_elements/in_magn_z_en");
+    sprintf(mpu.compass_rate, "%s%s", sysfs_path, "/sampling_frequency");
+    sprintf(mpu.compass_scale, "%s%s", sysfs_path, "/in_magn_scale");
+    sprintf(mpu.compass_orient, "%s%s", sysfs_path, "/compass_matrix");
+
+    return 0;
+}
+
+
+
+static void enable_iio_sysfs()
+{
+
+
+    char iio_trigger_name[MAX_CHIP_ID_LEN];
+    FILE *tempFp = NULL;
+
+
+    // fopen()/open() would both be okay for sysfs access
+    // developers could choose what they want
+    // with fopen(), benefits from fprintf()/fscanf() would be available
+    tempFp = fopen(mpu.in_timestamp_en, "w");
+    if (tempFp == NULL) {
+        printf("%s line=%d:could not open timestamp enable \n", __FUNCTION__, __LINE__);
+    } else {
+        if(fprintf(tempFp, "%d", 1) < 0) {
+            printf("%s line=%d:could not enable timestamp \n", __FUNCTION__, __LINE__);
+        }
+        fclose(tempFp);
+    }
+
+
+    tempFp = fopen(mpu.trigger_name, "r");
+    if (tempFp == NULL) {
+        printf("%s line=%d :could not open trigger name \n", __FUNCTION__, __LINE__);
+    } else {
+        if (fscanf(tempFp, "%s", iio_trigger_name) < 0) {
+            printf("%s line=%d:could not read trigger name \n", __FUNCTION__, __LINE__);
+        }
+        fclose(tempFp);
+    }
+
+
+    tempFp = fopen(mpu.current_trigger, "w");
+    if (tempFp == NULL) {
+        printf("%s line=%d:could not open current trigger \n", __FUNCTION__, __LINE__);
+    } else {
+        if (fprintf(tempFp, "%s", iio_trigger_name) < 0) {
+            printf("%s line=%d :could not write current trigger \n", __FUNCTION__, __LINE__);
+        }
+        fclose(tempFp);
+    }
+
+
+    tempFp = fopen(mpu.buffer_length, "w");
+    if (tempFp == NULL) {
+        printf("%s line=%d:could not open buffer length \n", __FUNCTION__, __LINE__);
+    } else {
+        if (fprintf(tempFp, "%d", IIO_BUFFER_LENGTH) < 0) {
+            printf("%s line=%d:could not write buffer length \n", __FUNCTION__, __LINE__);
+        }
+        fclose(tempFp);
+    }
+
+   
+    iio_fd = open(IIO_DEVICE_NODE, O_RDONLY);
+    if (iio_fd < 0) {
+        printf("%s line=%d:could not open iio device node \n", __FUNCTION__, __LINE__);
+    } else {
+        printf("%s line=%d:iio iio_fd opened : %d \n", __FUNCTION__, __LINE__,  iio_fd);
+    }
+}
+
+
+
+/* This one DOES NOT close FDs for you */
+static int read_attribute_sensor(int fd, char* data, unsigned int size)
+{
+    int count = 0;
+    if (fd > 0) {
+        count = pread(fd, data, size, 0);
+        if(count < 1) {
+            printf("%s line=%d:read fails with error code=%d", __FUNCTION__, __LINE__, count);
+        }
+    }
+    return count;
+}
+
+
+static int enable_sysfs_sensor(int fd, int en)
+{
+    int nb;
+    int err = 0;
+
+    char c = en ? '1' : '0';
+    nb = write(fd, &c, 1);
+
+    if (nb <= 0) {
+        err = errno;
+        printf("%s line=%d:enable_sysfs_sensor - write %c returned %d (%s / %d) \n", __FUNCTION__, __LINE__, 
+             c, nb, strerror(err), err);
+    }
+    close(fd);
+
+
+    return -err;
+}
+
+
+
+static int onPower(int en)
+{
+    int res = 0;
+    char buf[sizeof(int)+1];
+    int count, curr_power_state;
+
+
+    int tempFd = open(mpu.power_state, O_RDWR);
+    res = errno;
+    if(tempFd < 0){
+        printf("%s line=%d :Open of %s failed with '%s' (%d)\n", __FUNCTION__, __LINE__, 
+             mpu.power_state, strerror(res), res);
+    } else {
+        // check and set new power state
+        count = read_attribute_sensor(tempFd, buf, sizeof(buf));
+        if(count < 1) {
+            printf("%s line=%d:Error reading power state \n", __FUNCTION__, __LINE__);
+            // will set power_state anyway
+            curr_power_state= -1;
+        } else {
+            sscanf(buf, "%d", &curr_power_state);
+        }
+
+        if (en!=curr_power_state) {
+            if((res=enable_sysfs_sensor(tempFd, en)) < 0) {
+                printf("%s line=%d:Couldn't write power state \n", __FUNCTION__, __LINE__);
+            }
+        } else {
+            printf("%s line=%d:Power state already enable/disable curr=%d new=%d", __FUNCTION__, __LINE__,
+                    curr_power_state, en);
+            close(tempFd);
+        }
+    }
+    return res;
+}
+
+
+
+static int masterEnable(int en)
+{
+
+    int res = 0;
+;
+    int tempFd = open(mpu.chip_enable, O_RDWR);
+    res = errno;
+    if(tempFd < 0){
+        printf("%s line=%d:open of %s failed with '%s' (%d)", __FUNCTION__, __LINE__, 
+             mpu.chip_enable, strerror(res), res);
+        return res;
+    }
+    res = enable_sysfs_sensor(tempFd, en);
+    return res;
+}
+
+
+static int enableAccel(int en)
+{
+    int res;
+
+    /* need to also turn on/off the master enable */
+    printf("%s line=%d :sysfs:echo %d > %s \n", __FUNCTION__, __LINE__, en, mpu.accel_enable);
+    int tempFd = open(mpu.accel_enable, O_RDWR);
+    res = errno;
+    if (tempFd > 0) {
+        res = enable_sysfs_sensor(tempFd, en);
+    } else {
+        printf("%s line=%d :open of %s failed with '%s' (%d) \n", __FUNCTION__, __LINE__,
+             mpu.accel_enable, strerror(res), res);
+    }
+
+    if (!en) {
+        printf("%s line=%d :MPL:inv_accel_was_turned_off \n", __FUNCTION__, __LINE__);
+        //inv_accel_was_turned_off();
+    } else {
+        tempFd = open(mpu.accel_x_fifo_enable, O_RDWR);
+        res = errno;
+        if (tempFd > 0) {
+            res = enable_sysfs_sensor(tempFd, en);
+        } else {
+            printf("%s line=%d :open of %s failed with '%s' (%d) \n", __FUNCTION__, __LINE__,
+                 mpu.accel_x_fifo_enable, strerror(res), res);
+        }
+
+        tempFd = open(mpu.accel_y_fifo_enable, O_RDWR);
+        res = errno;
+        if (tempFd > 0) {
+            res = enable_sysfs_sensor(tempFd, en);
+        } else {
+            printf("%s line=%d :open of %s failed with '%s' (%d) \n", __FUNCTION__, __LINE__, 
+                 mpu.accel_y_fifo_enable, strerror(res), res);
+        }
+
+
+        tempFd = open(mpu.accel_z_fifo_enable, O_RDWR);
+        res = errno;
+        if (tempFd > 0) {
+            res = enable_sysfs_sensor(tempFd, en);
+        } else {
+            printf("%s line=%d :open of %s failed with '%s' (%d) \n", __FUNCTION__, __LINE__,
+                 mpu.accel_z_fifo_enable, strerror(res), res);
+        }
+    }
+
+    return res;
+}
+
+
+
+static int disableGyro(/*int en*/)
+{
+
+
+    int res = 0;
+
+    /* need to also turn on/off the master enable */
+;
+    int tempFd = open(mpu.gyro_enable, O_RDWR);
+    res = errno;
+    if (tempFd > 0) {
+        res = enable_sysfs_sensor(tempFd, 0);
+    } else {
+        printf("%s line=%d :open of %s failed with '%s' (%d) \n", __FUNCTION__, __LINE__,
+             mpu.gyro_enable, strerror(res), res);
+    }
+
+    
+    return res;
+}
+
+
+
+static int enableCompass(int en) 
+{
+    int tempFd;
+    int res = 0;
+
+
+    tempFd = open(mpu.compass_enable, O_RDWR);
+    if(tempFd < 0) {
+        printf("%s line=%d open of %s failed with '%s' (%d) \n", __FUNCTION__, __LINE__,
+             mpu.compass_enable, strerror(res), res);
+        return res;
+    }
+    res = enable_sysfs_sensor(tempFd, en);
+	if(res < 0)
+	{
+		printf("%s line=%d enable compass failed \n", __FUNCTION__, __LINE__);
+	}
+    close(tempFd);
+
+    if (en) {
+        tempFd = open(mpu.compass_x_fifo_enable, O_RDWR);
+        if (tempFd > 0) {
+            res = enable_sysfs_sensor(tempFd, en);
+            close(tempFd);
+        } else {
+            printf("%s line=%d:open of %s failed with '%s' (%d) \n", __FUNCTION__, __LINE__,
+                 mpu.compass_x_fifo_enable, strerror(res), res);
+        }
+
+
+        tempFd = open(mpu.compass_y_fifo_enable, O_RDWR);
+        if (tempFd > 0) {
+            res = enable_sysfs_sensor(tempFd, en);
+            close(tempFd);
+        } else {
+            printf("%s line=%d:open of %s failed with '%s' (%d) \n",  __FUNCTION__, __LINE__, 
+                 mpu.compass_y_fifo_enable, strerror(res), res);
+        }
+
+
+        tempFd = open(mpu.compass_z_fifo_enable, O_RDWR);
+        res = errno;
+        if (tempFd > 0) {
+            res = enable_sysfs_sensor(tempFd, en);
+            close(tempFd);
+        } else {
+            printf("%s line=%d :open of %s failed with '%s' (%d) \n", __FUNCTION__, __LINE__, 
+                 mpu.compass_z_fifo_enable, strerror(res), res);
+        }
+    }
+
+    return res;
+}
+
+
+
+static int mpu_int(void)
+{
+	int result= 0;
+	
+	printf("%s line=%d \n", __FUNCTION__, __LINE__);
+
+	
+	if(int_flag)
+	{
+		printf("%s line=%d int_flag=%d already call.\n", __FUNCTION__, __LINE__, int_flag);
+		return 0;
+	}
+
+	memset(mIIOBuffer, 0, sizeof(mIIOBuffer));
+
+	
+	inv_init_sysfs_attributes();
+
+
+
+	enable_iio_sysfs();
+
+
+
+    /* turn on power state */
+    onPower(1);
+    /* reset driver master enable */
+    masterEnable(0);
+	disableGyro(0);
+	enableAccel(0);
+	enableCompass(0);
+	onPower(0);
+
+
+	onPower(1);
+	masterEnable(0);
+	result = enableAccel(1);
+	enableCompass(1);
+
+	masterEnable(1);//shall open
+	printf("%s line=%d result=%d \n", __FUNCTION__, __LINE__, result);
+
+	if(result < 0)
+		return -1;
+
+	int_flag = 1;
+	return 0;
+}
+ 
+#if 0
+static int build_event(void)
+{
+	int nbyte;
+	int i, nb;
+	int sensors;
+	ssize_t rsize;
+
+	char *rdata = mIIOBuffer;
+
+	sensors = 1;
+	
+	nbyte= /*(8 * sensors + 8) * 1*/16;
+
+	memset(mIIOBuffer, 0, sizeof(mIIOBuffer));
+
+	//printf("%s line=%d iio_fd=%d nbyte=%d \n", __FUNCTION__, __LINE__, iio_fd, nbyte);
+	rsize = read(iio_fd, rdata, nbyte);
+	//printf("%s line=%d iio_fd=%d, rsize=%d \n", __FUNCTION__, __LINE__, iio_fd, rsize);
+
+	g_x = *((short *) (rdata + 0 ));
+	g_y = *((short *) (rdata + 2 ));
+	g_z = *((short *) (rdata + 4 ));
+
+	//g_x = lg_x*ACCELERATION_RATIO_ANDROID_TO_HW;
+	//g_y = lg_y*ACCELERATION_RATIO_ANDROID_TO_HW;
+	//g_z = lg_z*ACCELERATION_RATIO_ANDROID_TO_HW;
+
+	//printf("%s line=%d x=%d y=%d z=%d \n", __FUNCTION__, __LINE__, g_x, g_y, g_z);
+
+	return 0;
+}
+#else
+static int build_event(void)
+{
+	int nbyte;
+	int i, nb;
+	int sensors;
+	ssize_t rsize;
+
+	char *rdata = mIIOBuffer;
+
+	sensors = 2;
+	
+	nbyte= (8 * sensors + 8) * 1;
+
+	memset(mIIOBuffer, 0, sizeof(mIIOBuffer));
+
+	//printf("%s line=%d iio_fd=%d nbyte=%d \n", __FUNCTION__, __LINE__, iio_fd, nbyte);
+	rsize = read(iio_fd, rdata, nbyte);
+	//printf("%s line=%d iio_fd=%d, rsize=%d \n", __FUNCTION__, __LINE__, iio_fd, rsize);
+
+	g_x = *((short *) (rdata + 0 ));
+	g_y = *((short *) (rdata + 2 ));
+	g_z = *((short *) (rdata + 4 ));
+
+	c_x = *((short *) (rdata + 0 + 6));
+	c_y = *((short *) (rdata + 2 + 6));
+	c_z = *((short *) (rdata + 4 + 6));
+
+	//g_x = lg_x*ACCELERATION_RATIO_ANDROID_TO_HW;
+	//g_y = lg_y*ACCELERATION_RATIO_ANDROID_TO_HW;
+	//g_z = lg_z*ACCELERATION_RATIO_ANDROID_TO_HW;
+
+	//printf("%s line=%d x=%d y=%d z=%d \n", __FUNCTION__, __LINE__, g_x, g_y, g_z);
+
+	return 0;
+}
+
+#endif
+
+ void* gsensor_test_mpu(void *argv)
+ {
+
+	int ret;
+	int fd;
+ 	//struct gsensor_msg *g_msg =  (struct gsensor_msg *)malloc(sizeof(struct gsensor_msg));
+        struct gsensor_msg g_msg;
+	struct testcase_info *tc_info = (struct testcase_info*)argv;
+		
+	/*remind ddr test*/
+	if(tc_info->y <= 0)
+		tc_info->y  = get_cur_print_y();	
+
+	g_msg.y = tc_info->y;
+	ui_print_xy_rgba(0,g_msg.y,255,255,0,255,"%s:[%s..] \n",PCBA_GSENSOR,PCBA_TESTING);
+	tc_info->result = 0;
+
+    if (mpu_int() < 0)
+	{
+ 		ui_print_xy_rgba(0,g_msg.y,255,0,0,255,"%s:[%s]\n",PCBA_GSENSOR,PCBA_FAILED);
+		g_msg.result = -1;
+		tc_info->result = -1;
+		int_flag = 0;
+		if(iio_fd > 0)
+	    {
+	    	close(iio_fd);
+	    }
+
+		if(sysfs_names_ptr)
+			free(sysfs_names_ptr);
+		return argv;
+ 	}
+        
+ 	if(iio_fd < 0)
+ 	{
+ 		ui_print_xy_rgba(0,g_msg.y,255,0,0,255,"%s:[%s]\n",PCBA_GSENSOR,PCBA_FAILED);
+		g_msg.result = -1;
+		tc_info->result = -1;
+		int_flag = 0;
+		if(iio_fd > 0)
+	    {
+	    	close(iio_fd);
+	    }
+
+		if(sysfs_names_ptr)
+			free(sysfs_names_ptr);
+		return argv;
+ 	}
+	
+	for(;;)
+	{
+		//printf("%s line=%d \n", __FUNCTION__, __LINE__);
+		build_event();
+		//printf("%s line=%d \n", __FUNCTION__, __LINE__);
+		//readEvents(fd);
+		//ui_print_xy_rgba(0,g_msg.y,0,255,0,255,"%s:[%s] { %2d,%2d,%2d }\n",PCBA_GSENSOR,PCBA_SECCESS,(int)g_x,(int)g_y,(int)g_z);
+		ui_display_sync(0,g_msg.y,0,255,0,255,"%s:[%s] { %2d,%2d,%2d }\n",PCBA_GSENSOR,PCBA_SECCESS,(int)g_x,(int)g_y,(int)g_z);
+		//ui_print_xy_rgba(0,g_msg->y,0,0,255,255,"gsensor x:%f y:%f z:%f\n",g_x,g_y,g_z);
+		usleep(100000);
+	}
+
+    //close(fd);
+    //close(fd_dev);
+    if(iio_fd > 0)
+    {
+    	close(iio_fd);
+    }
+
+	if(sysfs_names_ptr)
+		free(sysfs_names_ptr);
+
+    ui_print_xy_rgba(0,g_msg.y,0,255,0,255,"%s:[%s]\n",PCBA_GSENSOR,PCBA_SECCESS);
+	tc_info->result = 0;
+	int_flag = 0;
+	return argv;
+ }
+
+
+ void* compass_test_mpu(void *argv)
+ {
+
+	int ret;
+	int fd;
+ 	//struct gsensor_msg *g_msg =  (struct gsensor_msg *)malloc(sizeof(struct gsensor_msg));
+        struct gsensor_msg g_msg;
+	struct testcase_info *tc_info = (struct testcase_info*)argv;
+		
+	/*remind ddr test*/
+	if(tc_info->y <= 0)
+		tc_info->y  = get_cur_print_y();	
+
+	g_msg.y = tc_info->y;
+	ui_print_xy_rgba(0,g_msg.y,255,255,0,255,"%s:[%s..] \n",PCBA_COMPASS,PCBA_TESTING);
+	tc_info->result = 0;
+
+	printf("%s line=%d MPU compass \n", __FUNCTION__, __LINE__);
+
+    if (mpu_int() < 0)
+	{
+ 		ui_print_xy_rgba(0,g_msg.y,255,0,0,255,"%s:[%s]\n",PCBA_COMPASS,PCBA_FAILED);
+		g_msg.result = -1;
+		tc_info->result = -1;
+		int_flag = 0;
+		if(iio_fd > 0)
+	    {
+	    	close(iio_fd);
+	    }
+
+		if(sysfs_names_ptr)
+			free(sysfs_names_ptr);
+		return argv;
+ 	}
+        
+ 	if(iio_fd < 0)
+ 	{
+ 		ui_print_xy_rgba(0,g_msg.y,255,0,0,255,"%s:[%s]\n",PCBA_COMPASS,PCBA_FAILED);
+		g_msg.result = -1;
+		tc_info->result = -1;
+		int_flag = 0;
+		if(iio_fd > 0)
+	    {
+	    	close(iio_fd);
+	    }
+
+		if(sysfs_names_ptr)
+			free(sysfs_names_ptr);
+		return argv;
+ 	}
+	
+	for(;;)
+	{
+		//printf("%s line=%d \n", __FUNCTION__, __LINE__);
+		build_event();
+		//printf("%s line=%d \n", __FUNCTION__, __LINE__);
+		//readEvents(fd);
+		//ui_print_xy_rgba(0,g_msg.y,0,255,0,255,"%s:[%s] { %2d,%2d,%2d }\n",PCBA_GSENSOR,PCBA_SECCESS,(int)g_x,(int)g_y,(int)g_z);
+		ui_display_sync(0,g_msg.y,0,255,0,255,"%s:[%s] { %2d,%2d,%2d }\n",PCBA_COMPASS,PCBA_SECCESS,(int)c_x,(int)c_y,(int)c_z);
+		//ui_print_xy_rgba(0,g_msg->y,0,0,255,255,"gsensor x:%f y:%f z:%f\n",g_x,g_y,g_z);
+		usleep(100000);
+	}
+
+    //close(fd);
+    //close(fd_dev);
+    if(iio_fd > 0)
+    {
+    	close(iio_fd);
+    }
+
+	if(sysfs_names_ptr)
+		free(sysfs_names_ptr);
+
+    ui_print_xy_rgba(0,g_msg.y,0,255,0,255,"%s:[%s]\n",PCBA_COMPASS,PCBA_SECCESS);
+	tc_info->result = 0;
+	int_flag = 0;
+	return argv;
+ }
+
+ 
diff --git a/bootable/recovery/pcba_core/language.h b/bootable/recovery/pcba_core/language.h
new file mode 100644
index 0000000000..4c730dedd5
--- /dev/null
+++ b/bootable/recovery/pcba_core/language.h
@@ -0,0 +1,12 @@
+#ifndef __LANGUAGE_H_
+#define __LANGUAGE_H_
+
+#define LANGUAGE_COFIG      0
+
+#if LANGUAGE_COFIG
+	#include "language_cn.h"
+#else
+	#include "language_en.h"
+#endif
+
+#endif
diff --git a/bootable/recovery/pcba_core/language_cn.h b/bootable/recovery/pcba_core/language_cn.h
new file mode 100644
index 0000000000..93b84f5fe7
--- /dev/null
+++ b/bootable/recovery/pcba_core/language_cn.h
@@ -0,0 +1,73 @@
+#ifndef __LANGUAGE_CN_H_
+#define __LANGUAGE_CN_H_
+
+#define PCBA_VERSION_NAME "ROCKCHIP PCBA TEST V2.3"
+#define PCBA_MANUAL_TEST  "手动测试"
+#define PCBA_AUTO_TEST  "自动测试"
+#define PCBA_SECCESS "通过"
+#define PCBA_FAILED "失败"
+#define PCBA_BLUETOOTH "蓝牙"
+#define PCBA_GSENSOR "重力传感器"
+#define PCBA_KEY "按键"
+#define PCBA_RTC "时钟"
+#define PCBA_NAND "NandFlash"
+#define PCBA_EMMC "eMMC"
+#define PCBA_SIM "SIM卡"
+#define PCBA_SIM2 "SIM卡2"
+#define PCBA_SDCARD  "SD卡"
+#define PCBA_VIBRATOR  "马达震动"
+#define PCBA_FM  "收音机"
+#define PCBA_UCARD  "U盘"
+#define PCBA_WIFI   "网络"
+#define PCBA_WIFI_SIGNAL "信号"
+#define PCBA_WIFI_SIGNAL1 "格"
+#define PCBA_BATTERY   "电池"
+#define PCBA_BATTERY_CHARGE   "充电"
+#define PCBA_BATTERY_DISCHARGE   "放电"
+#define PCBA_BATTERY_FULLCHARGE   "满电"
+#define PCBA_BATTERY_VOLTAGE  "电压"
+#define PCBA_BATTERY_CAPACITY  "电量"
+#define PCBA_AC_ONLINE "电源连接"
+#define PCBA_AC_OFFLINE "电源断开"
+#define PCBA_RECORD "录音"
+#define PCBA_VOLUME "音量"
+#define PCBA_CODEC "声音"
+#define PCBA_WITHOUT_EP_CODEC_INFO "Vol+:录音和扬声器 Vol-:耳机录音和播放"
+#define PCBA_CODEC_INFO "Vol+:录音和扬声器 Vol-:耳机录音和播放 Power:听筒"
+#define PCBA_CODEC_VOL_UP "录音和扬声器测试中..."
+#define PCBA_CODEC_VOL_DOWN "耳机录音和播放测试中..."
+#define PCBA_CODEC_VOL_POWER "听筒测试中..."
+#define PCBA_RINGMIC "MIC阵列"
+#define PCBA_DDR	"内存"
+#define PCBA_DDR_EMMC "设备内存"
+#define PCBA_LCD "屏幕"
+#define PCBA_TESTED "已测试"
+#define PCBA_FLASHLIGHT "闪光灯"
+#define PCBA_CAMERA "相机"
+#define PCBA_FRONT_CAMERA "前置摄像头"
+#define PCBA_BACK_CAMERA "后置摄像头"
+#define PCBA_TESTING "测试中"
+#define PCBA_ERR_CHECK "检测错误"
+#define PCBA_ERR_FREQ "变频错误"
+#define PCBA_SDCARD_NOINSERT "没有插入sd卡"
+#define PCBA_INTEL_PTEST_MODE "ptest模式"
+#define PCBA_BOOT_IN_ANDROID_FUCTION "连续按5次power键，退出ptest模式!"
+#define PCBA_BOOT_IN_CORE_FUNCTION	"power, vol+, vol- 各按一次进入PCBA模式"
+#define PCBA_BOOT_IN_TOUCH_FUNCTION	"在该界面画线进行触摸屏测试"
+#define PCBA_TIP_IN_PCBA_FUNCTION	"按VOL+或VOL-超5秒松开退出PTEST模式"
+#define PCBA_LSENSOR	"光传感器"
+#define PCBA_GNSS		"GPS"
+#define PCBA_PSENSOR	"距离传感器"
+#define PCBA_COMPASS	"电子罗盘"
+#define PCBA_POWER_KEY  "按下电源键"
+#define PCBA_VOLUME_UP_KEY  "按下音量+键"
+#define PCBA_VOLUME_DOWN_KEY   "按下音量-键"
+#define PCBA_RF_CAL   "RF校准:"
+#define PCBA_WIFI_CAL   "WIFI校准:"
+#define PCBA_IMEI_NO   "IMEI号:"
+#define PCBA_CAL_YES   "已校准"
+#define PCBA_CAL_NO   "未校准"
+#define PCBA_LAN	"以太网"
+#define PCBA_GYRO	"陀螺仪"
+#define PCBA_GSENSOR_CALIBRATE	"重力校准"
+#endif
diff --git a/bootable/recovery/pcba_core/language_en.h b/bootable/recovery/pcba_core/language_en.h
new file mode 100644
index 0000000000..43936a7d1d
--- /dev/null
+++ b/bootable/recovery/pcba_core/language_en.h
@@ -0,0 +1,73 @@
+#ifndef __LANGUAGE_EN_H_
+#define __LANGUAGE_EN_H_
+
+#define PCBA_VERSION_NAME "RockChip Pcba Test V2.1"
+#define PCBA_MANUAL_TEST  "Manual Test"
+#define PCBA_AUTO_TEST  "Automatic Test"
+#define PCBA_SECCESS "Pass"
+#define PCBA_FAILED "Failed"
+#define PCBA_BLUETOOTH "BlueTooth"
+#define PCBA_GSENSOR "Gsensor"
+#define PCBA_KEY "Key"
+#define PCBA_RTC "Rtc"
+#define PCBA_SIM "Sim"
+#define PCBA_SIM2 "Sim2"
+#define PCBA_SDCARD  "SDCard"
+#define PCBA_VIBRATOR  "VIBRATOR"
+#define PCBA_FM  "FM"
+#define PCBA_UCARD  "UDisk"
+#define PCBA_LAN	"Ethernet"
+#define PCBA_WIFI   "Wifi"
+#define PCBA_WIFI_SIGNAL "Level"
+#define PCBA_WIFI_SIGNAL1 ""
+#define PCBA_BATTERY   "Battery"
+#define PCBA_BATTERY_CHARGE   "Charge"
+#define PCBA_BATTERY_DISCHARGE   "DisCharge"
+#define PCBA_BATTERY_FULLCHARGE   "FullCharge"
+#define PCBA_BATTERY_VOLTAGE  "Voltage"
+#define PCBA_BATTERY_CAPACITY  "Capacity"
+#define PCBA_RECORD "Record Volum"
+#define PCBA_VOLUME "Volume"
+#define PCBA_CODEC "Codec"
+#define PCBA_CODEC_INFO "Vol+:INT_MIC/LS Vol-:EXT_MIC/HS Power:EP"
+#define PCBA_WITHOUT_EP_CODEC_INFO "Vol+:INT_MIC/LS Vol-:EXT_MIC/HS"
+#define PCBA_CODEC_VOL_UP "INT_MIC/LS testing"
+#define PCBA_CODEC_VOL_DOWN "EXT_MIC/HS testing"
+#define PCBA_CODEC_VOL_POWER "EP testing"
+#define PCBA_RINGMIC "RIingMic"
+#define PCBA_DDR "DDR"
+#define PCBA_EMMC "eMMC"
+#define PCBA_NAND "Nand"
+#define PCBA_FLASHLIGHT "FLASHLIGHT"
+#define PCBA_CAMERA "Camera"
+#define PCBA_FRONT_CAMERA "Front Camera"
+#define PCBA_BACK_CAMERA "Back Camera"
+#define PCBA_TESTING "Testing..."
+#define PCBA_ERR_CHECK "Detect errors"
+#define PCBA_ERR_FREQ "Frequency conversion error"
+#define PCBA_SDCARD_NOINSERT "no sdcard"
+#define PCBA_INTEL_PTEST_MODE "PTEST MODE"
+#define PCBA_BOOT_IN_ANDROID_FUCTION "Click power button 5 times to exit ptest!"
+#define PCBA_BOOT_IN_CORE_FUNCTION	"Clik each key(power, vol+, vol-) 1 time to go to pcba core"
+#define PCBA_BOOT_IN_TOUCH_FUNCTION	"Please draw line in this screen to execute TP test"
+#define PCBA_TIP_IN_PCBA_FUNCTION	"Press VOL+ or VOL- longer than 5 seconds to exit PTEST mode"
+#define PCBA_LSENSOR	"LSensor"
+#define PCBA_GNSS		"GPS"
+#define PCBA_PSENSOR	"PSensor"
+#define PCBA_COMPASS	"ECompass"
+#define PCBA_POWER_KEY  "press down power key"
+#define PCBA_VOLUME_UP_KEY  "press down volume+ key"
+#define PCBA_VOLUME_DOWN_KEY   "press down volume- key"
+#define PCBA_RF_CAL   "RF calibration:"
+#define PCBA_WIFI_CAL   "WIFI calibration:"
+#define PCBA_IMEI_NO   "IMEI number:"
+#define PCBA_CAL_YES   "YES"
+#define PCBA_CAL_NO   "NO"
+#define PCBA_GYRO   "Gyro"
+#define PCBA_GSENSOR_CALIBRATE   "Gsensor Cal"
+#define PCBA_DDR_EMMC "Device memory"
+#define PCBA_LCD "LCD"
+#define PCBA_TESTED "Tested"
+#define PCBA_AC_ONLINE "Power Online"
+#define PCBA_AC_OFFLINE "Power OFFline"
+#endif
diff --git a/bootable/recovery/pcba_core/libbluetooth/Android.mk b/bootable/recovery/pcba_core/libbluetooth/Android.mk
new file mode 100644
index 0000000000..eda8e2fd22
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/Android.mk
@@ -0,0 +1,21 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+	bluetooth.c \
+	sdp.c \
+	hci.c \
+	uuid.c \
+
+LOCAL_C_INCLUDES:= \
+	$(LOCAL_PATH)/bluetooth \
+
+LOCAL_SHARED_LIBRARIES := \
+	libcutils \
+	liblog \
+
+LOCAL_MODULE:= libbluetooth
+
+LOCAL_CFLAGS+=-O3 -w
+
+include $(BUILD_STATIC_LIBRARY)
diff --git a/bootable/recovery/pcba_core/libbluetooth/MODULE_LICENSE_GPL b/bootable/recovery/pcba_core/libbluetooth/MODULE_LICENSE_GPL
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/bootable/recovery/pcba_core/libbluetooth/NOTICE b/bootable/recovery/pcba_core/libbluetooth/NOTICE
new file mode 100644
index 0000000000..08e442af63
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/NOTICE
@@ -0,0 +1,370 @@
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2001-2002  Nokia Corporation
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2003  Stephen Crane <steve.crane@rococosoft.com>
+ *  Copyright (C) 2002-2009  Marcel Holtmann <marcel@holtmann.org>
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2001-2002  Nokia Corporation
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2009  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2002-2003  Stephen Crane <steve.crane@rococosoft.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth.c b/bootable/recovery/pcba_core/libbluetooth/bluetooth.c
new file mode 100644
index 0000000000..72ee456f8b
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth.c
@@ -0,0 +1,470 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+
+#include "bluetooth.h"
+#include "hci.h"
+
+void baswap(bdaddr_t *dst, const bdaddr_t *src)
+{
+	register unsigned char *d = (unsigned char *) dst;
+	register const unsigned char *s = (const unsigned char *) src;
+	register int i;
+
+	for (i = 0; i < 6; i++)
+		d[i] = s[5-i];
+}
+
+char *batostr(const bdaddr_t *ba)
+{
+	char *str = bt_malloc(18);
+	if (!str)
+		return NULL;
+
+	sprintf(str, "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
+		ba->b[0], ba->b[1], ba->b[2],
+		ba->b[3], ba->b[4], ba->b[5]);
+
+	return str;
+}
+
+bdaddr_t *strtoba(const char *str)
+{
+	bdaddr_t b;
+	bdaddr_t *ba = bt_malloc(sizeof(*ba));
+
+	if (ba) {
+		str2ba(str, &b);
+		baswap(ba, &b);
+	}
+
+	return ba;
+}
+
+int ba2str(const bdaddr_t *ba, char *str)
+{
+	return sprintf(str, "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
+		ba->b[5], ba->b[4], ba->b[3], ba->b[2], ba->b[1], ba->b[0]);
+}
+
+int str2ba(const char *str, bdaddr_t *ba)
+{
+	bdaddr_t b;
+	int i;
+
+	if (bachk(str) < 0) {
+		memset(ba, 0, sizeof(*ba));
+		return -1;
+	}
+
+	for (i = 0; i < 6; i++, str += 3)
+		b.b[i] = strtol(str, NULL, 16);
+
+	baswap(ba, &b);
+
+	return 0;
+}
+
+int ba2oui(const bdaddr_t *ba, char *str)
+{
+	return sprintf(str, "%2.2X-%2.2X-%2.2X", ba->b[5], ba->b[4], ba->b[3]);
+}
+
+int bachk(const char *str)
+{
+	if (!str)
+		return -1;
+
+	if (strlen(str) != 17)
+		return -1;
+
+	while (*str) {
+		if (!isxdigit(*str++))
+			return -1;
+
+		if (!isxdigit(*str++))
+			return -1;
+
+		if (*str == 0)
+			break;
+
+		if (*str++ != ':')
+			return -1;
+	}
+
+	return 0;
+}
+
+int baprintf(const char *format, ...)
+{
+	va_list ap;
+	int len;
+
+	va_start(ap, format);
+	len = vprintf(format, ap);
+	va_end(ap);
+
+	return len;
+}
+
+int bafprintf(FILE *stream, const char *format, ...)
+{
+	va_list ap;
+	int len;
+
+	va_start(ap, format);
+	len = vfprintf(stream, format, ap);
+	va_end(ap);
+
+	return len;
+}
+
+int basprintf(char *str, const char *format, ...)
+{
+	va_list ap;
+	int len;
+
+	va_start(ap, format);
+	len = vsnprintf(str, (~0U) >> 1, format, ap);
+	va_end(ap);
+
+	return len;
+}
+
+int basnprintf(char *str, size_t size, const char *format, ...)
+{
+	va_list ap;
+	int len;
+
+	va_start(ap, format);
+	len = vsnprintf(str, size, format, ap);
+	va_end(ap);
+
+	return len;
+}
+
+void *bt_malloc(size_t size)
+{
+	return malloc(size);
+}
+
+void bt_free(void *ptr)
+{
+	free(ptr);
+}
+
+/* Bluetooth error codes to Unix errno mapping */
+int bt_error(uint16_t code)
+{
+	switch (code) {
+	case 0:
+		return 0;
+	case HCI_UNKNOWN_COMMAND:
+		return EBADRQC;
+	case HCI_NO_CONNECTION:
+		return ENOTCONN;
+	case HCI_HARDWARE_FAILURE:
+		return EIO;
+	case HCI_PAGE_TIMEOUT:
+		return EHOSTDOWN;
+	case HCI_AUTHENTICATION_FAILURE:
+		return EACCES;
+	case HCI_PIN_OR_KEY_MISSING:
+		return EINVAL;
+	case HCI_MEMORY_FULL:
+		return ENOMEM;
+	case HCI_CONNECTION_TIMEOUT:
+		return ETIMEDOUT;
+	case HCI_MAX_NUMBER_OF_CONNECTIONS:
+	case HCI_MAX_NUMBER_OF_SCO_CONNECTIONS:
+		return EMLINK;
+	case HCI_ACL_CONNECTION_EXISTS:
+		return EALREADY;
+	case HCI_COMMAND_DISALLOWED:
+	case HCI_TRANSACTION_COLLISION:
+	case HCI_ROLE_SWITCH_PENDING:
+		return EBUSY;
+	case HCI_REJECTED_LIMITED_RESOURCES:
+	case HCI_REJECTED_PERSONAL:
+	case HCI_QOS_REJECTED:
+		return ECONNREFUSED;
+	case HCI_HOST_TIMEOUT:
+		return ETIMEDOUT;
+	case HCI_UNSUPPORTED_FEATURE:
+	case HCI_QOS_NOT_SUPPORTED:
+	case HCI_PAIRING_NOT_SUPPORTED:
+	case HCI_CLASSIFICATION_NOT_SUPPORTED:
+	case HCI_UNSUPPORTED_LMP_PARAMETER_VALUE:
+	case HCI_PARAMETER_OUT_OF_RANGE:
+	case HCI_QOS_UNACCEPTABLE_PARAMETER:
+		return EOPNOTSUPP;
+	case HCI_INVALID_PARAMETERS:
+	case HCI_SLOT_VIOLATION:
+		return EINVAL;
+	case HCI_OE_USER_ENDED_CONNECTION:
+	case HCI_OE_LOW_RESOURCES:
+	case HCI_OE_POWER_OFF:
+		return ECONNRESET;
+	case HCI_CONNECTION_TERMINATED:
+		return ECONNABORTED;
+	case HCI_REPEATED_ATTEMPTS:
+		return ELOOP;
+	case HCI_REJECTED_SECURITY:
+	case HCI_PAIRING_NOT_ALLOWED:
+	case HCI_INSUFFICIENT_SECURITY:
+		return EACCES;
+	case HCI_UNSUPPORTED_REMOTE_FEATURE:
+		return EPROTONOSUPPORT;
+	case HCI_SCO_OFFSET_REJECTED:
+		return ECONNREFUSED;
+	case HCI_UNKNOWN_LMP_PDU:
+	case HCI_INVALID_LMP_PARAMETERS:
+	case HCI_LMP_ERROR_TRANSACTION_COLLISION:
+	case HCI_LMP_PDU_NOT_ALLOWED:
+	case HCI_ENCRYPTION_MODE_NOT_ACCEPTED:
+		return EPROTO;
+	default:
+		return ENOSYS;
+	}
+}
+
+char *bt_compidtostr(int compid)
+{
+	switch (compid) {
+	case 0:
+		return "Ericsson Technology Licensing";
+	case 1:
+		return "Nokia Mobile Phones";
+	case 2:
+		return "Intel Corp.";
+	case 3:
+		return "IBM Corp.";
+	case 4:
+		return "Toshiba Corp.";
+	case 5:
+		return "3Com";
+	case 6:
+		return "Microsoft";
+	case 7:
+		return "Lucent";
+	case 8:
+		return "Motorola";
+	case 9:
+		return "Infineon Technologies AG";
+	case 10:
+		return "Cambridge Silicon Radio";
+	case 11:
+		return "Silicon Wave";
+	case 12:
+		return "Digianswer A/S";
+	case 13:
+		return "Texas Instruments Inc.";
+	case 14:
+		return "Parthus Technologies Inc.";
+	case 15:
+		return "Broadcom Corporation";
+	case 16:
+		return "Mitel Semiconductor";
+	case 17:
+		return "Widcomm, Inc.";
+	case 18:
+		return "Zeevo, Inc.";
+	case 19:
+		return "Atmel Corporation";
+	case 20:
+		return "Mitsubishi Electric Corporation";
+	case 21:
+		return "RTX Telecom A/S";
+	case 22:
+		return "KC Technology Inc.";
+	case 23:
+		return "Newlogic";
+	case 24:
+		return "Transilica, Inc.";
+	case 25:
+		return "Rohde & Schwartz GmbH & Co. KG";
+	case 26:
+		return "TTPCom Limited";
+	case 27:
+		return "Signia Technologies, Inc.";
+	case 28:
+		return "Conexant Systems Inc.";
+	case 29:
+		return "Qualcomm";
+	case 30:
+		return "Inventel";
+	case 31:
+		return "AVM Berlin";
+	case 32:
+		return "BandSpeed, Inc.";
+	case 33:
+		return "Mansella Ltd";
+	case 34:
+		return "NEC Corporation";
+	case 35:
+		return "WavePlus Technology Co., Ltd.";
+	case 36:
+		return "Alcatel";
+	case 37:
+		return "Philips Semiconductors";
+	case 38:
+		return "C Technologies";
+	case 39:
+		return "Open Interface";
+	case 40:
+		return "R F Micro Devices";
+	case 41:
+		return "Hitachi Ltd";
+	case 42:
+		return "Symbol Technologies, Inc.";
+	case 43:
+		return "Tenovis";
+	case 44:
+		return "Macronix International Co. Ltd.";
+	case 45:
+		return "GCT Semiconductor";
+	case 46:
+		return "Norwood Systems";
+	case 47:
+		return "MewTel Technology Inc.";
+	case 48:
+		return "ST Microelectronics";
+	case 49:
+		return "Synopsys";
+	case 50:
+		return "Red-M (Communications) Ltd";
+	case 51:
+		return "Commil Ltd";
+	case 52:
+		return "Computer Access Technology Corporation (CATC)";
+	case 53:
+		return "Eclipse (HQ Espana) S.L.";
+	case 54:
+		return "Renesas Technology Corp.";
+	case 55:
+		return "Mobilian Corporation";
+	case 56:
+		return "Terax";
+	case 57:
+		return "Integrated System Solution Corp.";
+	case 58:
+		return "Matsushita Electric Industrial Co., Ltd.";
+	case 59:
+		return "Gennum Corporation";
+	case 60:
+		return "Research In Motion";
+	case 61:
+		return "IPextreme, Inc.";
+	case 62:
+		return "Systems and Chips, Inc";
+	case 63:
+		return "Bluetooth SIG, Inc";
+	case 64:
+		return "Seiko Epson Corporation";
+	case 65:
+		return "Integrated Silicon Solution Taiwain, Inc.";
+	case 66:
+		return "CONWISE Technology Corporation Ltd";
+	case 67:
+		return "PARROT SA";
+	case 68:
+		return "Socket Communications";
+	case 69:
+		return "Atheros Communications, Inc.";
+	case 70:
+		return "MediaTek, Inc.";
+	case 71:
+		return "Bluegiga";
+	case 72:
+		return "Marvell Technology Group Ltd.";
+	case 73:
+		return "3DSP Corporation";
+	case 74:
+		return "Accel Semiconductor Ltd.";
+	case 75:
+		return "Continental Automotive Systems";
+	case 76:
+		return "Apple, Inc.";
+	case 77:
+		return "Staccato Communications, Inc.";
+	case 78:
+		return "Avago Technologies";
+	case 79:
+		return "APT Ltd.";
+	case 80:
+		return "SiRF Technology, Inc.";
+	case 81:
+		return "Tzero Technologies, Inc.";
+	case 82:
+		return "J&M Corporation";
+	case 83:
+		return "Free2move AB";
+	case 84:
+		return "3DiJoy Corporation";
+	case 85:
+		return "Plantronics, Inc.";
+	case 86:
+		return "Sony Ericsson Mobile Communications";
+	case 87:
+		return "Harman International Industries, Inc.";
+	case 88:
+		return "Vizio, Inc.";
+	case 89:
+		return "Nordic Semiconductor ASA";
+	case 90:
+		return "EM Microelectronic-Marin SA";
+	case 91:
+		return "Ralink Technology Corporation";
+	case 92:
+		return "Belkin International, Inc.";
+	case 93:
+		return "Realtek Semiconductor Corporation";
+	case 94:
+		return "Stonestreet One, LLC";
+	case 95:
+		return "Wicentric, Inc.";
+	case 96:
+		return "RivieraWaves S.A.S";
+	case 97:
+		return "RDA Microelectronics";
+	case 98:
+		return "Gibson Guitars";
+	case 65535:
+		return "internal use";
+	default:
+		return "not assigned";
+	}
+}
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/bluetooth.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/bluetooth.h
new file mode 100644
index 0000000000..1c65a37fb2
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/bluetooth.h
@@ -0,0 +1,224 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __BLUETOOTH_H
+#define __BLUETOOTH_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <endian.h>
+#include <byteswap.h>
+#include <netinet/in.h>
+
+#ifndef AF_BLUETOOTH
+#define AF_BLUETOOTH	31
+#define PF_BLUETOOTH	AF_BLUETOOTH
+#endif
+
+#define BTPROTO_L2CAP	0
+#define BTPROTO_HCI	1
+#define BTPROTO_SCO	2
+#define BTPROTO_RFCOMM	3
+#define BTPROTO_BNEP	4
+#define BTPROTO_CMTP	5
+#define BTPROTO_HIDP	6
+#define BTPROTO_AVDTP	7
+
+#define SOL_HCI		0
+#define SOL_L2CAP	6
+#define SOL_SCO		17
+#define SOL_RFCOMM	18
+
+#ifndef SOL_BLUETOOTH
+#define SOL_BLUETOOTH	274
+#endif
+
+#define BT_SECURITY	4
+struct bt_security {
+	uint8_t level;
+};
+#define BT_SECURITY_SDP		0
+#define BT_SECURITY_LOW		1
+#define BT_SECURITY_MEDIUM	2
+#define BT_SECURITY_HIGH	3
+
+#define BT_DEFER_SETUP	7
+
+#define BT_FLUSHABLE	8
+
+#define BT_FLUSHABLE_OFF	0
+#define BT_FLUSHABLE_ON		1
+
+#define BT_POWER	9
+struct bt_power {
+	uint8_t force_active;
+};
+
+/* Connection and socket states */
+enum {
+	BT_CONNECTED = 1, /* Equal to TCP_ESTABLISHED to make net code happy */
+	BT_OPEN,
+	BT_BOUND,
+	BT_LISTEN,
+	BT_CONNECT,
+	BT_CONNECT2,
+	BT_CONFIG,
+	BT_DISCONN,
+	BT_CLOSED
+};
+
+/* Byte order conversions */
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define htobs(d)  (d)
+#define htobl(d)  (d)
+#define btohs(d)  (d)
+#define btohl(d)  (d)
+#elif __BYTE_ORDER == __BIG_ENDIAN
+#define htobs(d)  bswap_16(d)
+#define htobl(d)  bswap_32(d)
+#define btohs(d)  bswap_16(d)
+#define btohl(d)  bswap_32(d)
+#else
+#error "Unknown byte order"
+#endif
+
+/* Bluetooth unaligned access */
+#define bt_get_unaligned(ptr)			\
+({						\
+	struct __attribute__((packed)) {	\
+		typeof(*(ptr)) __v;		\
+	} *__p = (void *) (ptr);		\
+	__p->__v;				\
+})
+
+#define bt_put_unaligned(val, ptr)		\
+do {						\
+	struct __attribute__((packed)) {	\
+		typeof(*(ptr)) __v;		\
+	} *__p = (void *) (ptr);		\
+	__p->__v = (val);			\
+} while(0)
+
+/* BD Address */
+typedef struct {
+	uint8_t b[6];
+} __attribute__((packed)) bdaddr_t;
+
+#define BDADDR_ANY   (&(bdaddr_t) {{0, 0, 0, 0, 0, 0}})
+#define BDADDR_ALL   (&(bdaddr_t) {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}})
+#define BDADDR_LOCAL (&(bdaddr_t) {{0, 0, 0, 0xff, 0xff, 0xff}})
+
+/* Copy, swap, convert BD Address */
+static inline int bacmp(const bdaddr_t *ba1, const bdaddr_t *ba2)
+{
+	return memcmp(ba1, ba2, sizeof(bdaddr_t));
+}
+static inline void bacpy(bdaddr_t *dst, const bdaddr_t *src)
+{
+	memcpy(dst, src, sizeof(bdaddr_t));
+}
+
+void baswap(bdaddr_t *dst, const bdaddr_t *src);
+bdaddr_t *strtoba(const char *str);
+char *batostr(const bdaddr_t *ba);
+int ba2str(const bdaddr_t *ba, char *str);
+int str2ba(const char *str, bdaddr_t *ba);
+int ba2oui(const bdaddr_t *ba, char *oui);
+int bachk(const char *str);
+
+int baprintf(const char *format, ...);
+int bafprintf(FILE *stream, const char *format, ...);
+int basprintf(char *str, const char *format, ...);
+int basnprintf(char *str, size_t size, const char *format, ...);
+
+void *bt_malloc(size_t size);
+void bt_free(void *ptr);
+
+int bt_error(uint16_t code);
+char *bt_compidtostr(int id);
+
+typedef struct {
+	uint8_t data[16];
+} uint128_t;
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+
+#define ntoh64(x) (x)
+
+static inline void ntoh128(const uint128_t *src, uint128_t *dst)
+{
+	memcpy(dst, src, sizeof(uint128_t));
+}
+
+static inline void btoh128(const uint128_t *src, uint128_t *dst)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		dst->data[15 - i] = src->data[i];
+}
+
+#else
+
+static inline uint64_t ntoh64(uint64_t n)
+{
+	uint64_t h;
+	uint64_t tmp = ntohl(n & 0x00000000ffffffff);
+
+	h = ntohl(n >> 32);
+	h |= tmp << 32;
+
+	return h;
+}
+
+static inline void ntoh128(const uint128_t *src, uint128_t *dst)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		dst->data[15 - i] = src->data[i];
+}
+
+static inline void btoh128(const uint128_t *src, uint128_t *dst)
+{
+	memcpy(dst, src, sizeof(uint128_t));
+}
+
+#endif
+
+#define hton64(x)     ntoh64(x)
+#define hton128(x, y) ntoh128(x, y)
+#define htob128(x, y) btoh128(x, y)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BLUETOOTH_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/bnep.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/bnep.h
new file mode 100644
index 0000000000..2bbfb177f8
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/bnep.h
@@ -0,0 +1,153 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __BNEP_H
+#define __BNEP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <bluetooth/bluetooth.h>
+
+#ifndef ETH_ALEN
+#define ETH_ALEN	6		/* from <net/ethernet.h> */
+#endif
+
+/* BNEP UUIDs */
+#define BNEP_BASE_UUID 0x0000000000001000800000805F9B34FB
+#define BNEP_UUID16    0x02
+#define BNEP_UUID32    0x04
+#define BNEP_UUID128   0x16
+
+#define BNEP_SVC_PANU  0x1115
+#define BNEP_SVC_NAP   0x1116
+#define BNEP_SVC_GN    0x1117
+
+/* BNEP packet types */
+#define BNEP_GENERAL               0x00
+#define BNEP_CONTROL               0x01
+#define BNEP_COMPRESSED            0x02
+#define BNEP_COMPRESSED_SRC_ONLY   0x03
+#define BNEP_COMPRESSED_DST_ONLY   0x04
+
+/* BNEP control types */
+#define BNEP_CMD_NOT_UNDERSTOOD    0x00
+#define BNEP_SETUP_CONN_REQ        0x01
+#define BNEP_SETUP_CONN_RSP        0x02
+#define BNEP_FILTER_NET_TYPE_SET   0x03
+#define BNEP_FILTER_NET_TYPE_RSP   0x04
+#define BNEP_FILTER_MULT_ADDR_SET  0x05
+#define BNEP_FILTER_MULT_ADDR_RSP  0x06
+
+/* BNEP response messages */
+#define BNEP_SUCCESS               0x00
+
+#define BNEP_CONN_INVALID_DST      0x01
+#define BNEP_CONN_INVALID_SRC      0x02
+#define BNEP_CONN_INVALID_SVC      0x03
+#define BNEP_CONN_NOT_ALLOWED      0x04
+
+#define BNEP_FILTER_UNSUPPORTED_REQ    0x01
+#define BNEP_FILTER_INVALID_RANGE      0x02
+#define BNEP_FILTER_INVALID_MCADDR     0x02
+#define BNEP_FILTER_LIMIT_REACHED      0x03
+#define BNEP_FILTER_DENIED_SECURITY    0x04
+
+/* L2CAP settings */
+#define BNEP_MTU         1691
+#define BNEP_FLUSH_TO    0xffff
+#define BNEP_CONNECT_TO  15
+#define BNEP_FILTER_TO   15
+
+#ifndef BNEP_PSM
+#define BNEP_PSM	 0x0f
+#endif
+
+/* BNEP headers */
+#define BNEP_TYPE_MASK	 0x7f
+#define BNEP_EXT_HEADER	 0x80
+
+struct bnep_setup_conn_req {
+	uint8_t  type;
+	uint8_t  ctrl;
+	uint8_t  uuid_size;
+	uint8_t  service[0];
+} __attribute__((packed));
+
+struct bnep_set_filter_req {
+	uint8_t  type;
+	uint8_t  ctrl;
+	uint16_t len;
+	uint8_t  list[0];
+} __attribute__((packed));
+
+struct bnep_control_rsp {
+	uint8_t  type;
+	uint8_t  ctrl;
+	uint16_t resp;
+} __attribute__((packed));
+
+struct bnep_ext_hdr {
+	uint8_t  type;
+	uint8_t  len;
+	uint8_t  data[0];
+} __attribute__((packed));
+
+/* BNEP ioctl defines */
+#define BNEPCONNADD	_IOW('B', 200, int)
+#define BNEPCONNDEL	_IOW('B', 201, int)
+#define BNEPGETCONNLIST	_IOR('B', 210, int)
+#define BNEPGETCONNINFO	_IOR('B', 211, int)
+
+struct bnep_connadd_req {
+	int      sock;		/* Connected socket */
+	uint32_t flags;
+	uint16_t role;
+	char     device[16];	/* Name of the Ethernet device */
+};
+
+struct bnep_conndel_req {
+	uint32_t flags;
+	uint8_t  dst[ETH_ALEN];
+};
+
+struct bnep_conninfo {
+	uint32_t flags;
+	uint16_t role;
+	uint16_t state;
+	uint8_t  dst[ETH_ALEN];
+	char     device[16];
+};
+
+struct bnep_connlist_req {
+	uint32_t cnum;
+	struct bnep_conninfo *ci;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BNEP_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/cmtp.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/cmtp.h
new file mode 100644
index 0000000000..ce937bd0da
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/cmtp.h
@@ -0,0 +1,69 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CMTP_H
+#define __CMTP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* CMTP defaults */
+#define CMTP_MINIMUM_MTU 152
+#define CMTP_DEFAULT_MTU 672
+
+/* CMTP ioctl defines */
+#define CMTPCONNADD	_IOW('C', 200, int)
+#define CMTPCONNDEL	_IOW('C', 201, int)
+#define CMTPGETCONNLIST	_IOR('C', 210, int)
+#define CMTPGETCONNINFO	_IOR('C', 211, int)
+
+#define CMTP_LOOPBACK	0
+
+struct cmtp_connadd_req {
+	int sock;	/* Connected socket */
+	uint32_t flags;
+};
+
+struct cmtp_conndel_req {
+	bdaddr_t bdaddr;
+	uint32_t flags;
+};
+
+struct cmtp_conninfo {
+	bdaddr_t bdaddr;
+	uint32_t flags;
+	uint16_t state;
+	int      num;
+};
+
+struct cmtp_connlist_req {
+	uint32_t cnum;
+	struct cmtp_conninfo *ci;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CMTP_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/hci.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/hci.h
new file mode 100644
index 0000000000..c3bebe9c1d
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/hci.h
@@ -0,0 +1,2391 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __HCI_H
+#define __HCI_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/socket.h>
+
+#define HCI_MAX_DEV	16
+
+#define HCI_MAX_ACL_SIZE	1024
+#define HCI_MAX_SCO_SIZE	255
+#define HCI_MAX_EVENT_SIZE	260
+#define HCI_MAX_FRAME_SIZE	(HCI_MAX_ACL_SIZE + 4)
+
+/* HCI dev events */
+#define HCI_DEV_REG	1
+#define HCI_DEV_UNREG	2
+#define HCI_DEV_UP	3
+#define HCI_DEV_DOWN	4
+#define HCI_DEV_SUSPEND	5
+#define HCI_DEV_RESUME	6
+
+/* HCI bus types */
+#define HCI_VIRTUAL	0
+#define HCI_USB		1
+#define HCI_PCCARD	2
+#define HCI_UART	3
+#define HCI_RS232	4
+#define HCI_PCI		5
+#define HCI_SDIO	6
+
+/* HCI controller types */
+#define HCI_BREDR	0x00
+#define HCI_AMP		0x01
+
+/* HCI device flags */
+enum {
+	HCI_UP,
+	HCI_INIT,
+	HCI_RUNNING,
+
+	HCI_PSCAN,
+	HCI_ISCAN,
+	HCI_AUTH,
+	HCI_ENCRYPT,
+	HCI_INQUIRY,
+
+	HCI_RAW,
+};
+
+/* LE address type */
+enum {
+	LE_PUBLIC_ADDRESS = 0x00,
+	LE_RANDOM_ADDRESS = 0x01
+};
+
+/* HCI ioctl defines */
+#define HCIDEVUP	_IOW('H', 201, int)
+#define HCIDEVDOWN	_IOW('H', 202, int)
+#define HCIDEVRESET	_IOW('H', 203, int)
+#define HCIDEVRESTAT	_IOW('H', 204, int)
+
+#define HCIGETDEVLIST	_IOR('H', 210, int)
+#define HCIGETDEVINFO	_IOR('H', 211, int)
+#define HCIGETCONNLIST	_IOR('H', 212, int)
+#define HCIGETCONNINFO	_IOR('H', 213, int)
+#define HCIGETAUTHINFO	_IOR('H', 215, int)
+
+#define HCISETRAW	_IOW('H', 220, int)
+#define HCISETSCAN	_IOW('H', 221, int)
+#define HCISETAUTH	_IOW('H', 222, int)
+#define HCISETENCRYPT	_IOW('H', 223, int)
+#define HCISETPTYPE	_IOW('H', 224, int)
+#define HCISETLINKPOL	_IOW('H', 225, int)
+#define HCISETLINKMODE	_IOW('H', 226, int)
+#define HCISETACLMTU	_IOW('H', 227, int)
+#define HCISETSCOMTU	_IOW('H', 228, int)
+
+#define HCIBLOCKADDR	_IOW('H', 230, int)
+#define HCIUNBLOCKADDR	_IOW('H', 231, int)
+
+#define HCIINQUIRY	_IOR('H', 240, int)
+
+#ifndef __NO_HCI_DEFS
+
+/* HCI Packet types */
+#define HCI_COMMAND_PKT		0x01
+#define HCI_ACLDATA_PKT		0x02
+#define HCI_SCODATA_PKT		0x03
+#define HCI_EVENT_PKT		0x04
+#define HCI_VENDOR_PKT		0xff
+
+/* HCI Packet types */
+#define HCI_2DH1	0x0002
+#define HCI_3DH1	0x0004
+#define HCI_DM1		0x0008
+#define HCI_DH1		0x0010
+#define HCI_2DH3	0x0100
+#define HCI_3DH3	0x0200
+#define HCI_DM3		0x0400
+#define HCI_DH3		0x0800
+#define HCI_2DH5	0x1000
+#define HCI_3DH5	0x2000
+#define HCI_DM5		0x4000
+#define HCI_DH5		0x8000
+
+#define HCI_HV1		0x0020
+#define HCI_HV2		0x0040
+#define HCI_HV3		0x0080
+
+#define HCI_EV3		0x0008
+#define HCI_EV4		0x0010
+#define HCI_EV5		0x0020
+#define HCI_2EV3	0x0040
+#define HCI_3EV3	0x0080
+#define HCI_2EV5	0x0100
+#define HCI_3EV5	0x0200
+
+#define SCO_PTYPE_MASK	(HCI_HV1 | HCI_HV2 | HCI_HV3)
+#define ACL_PTYPE_MASK	(HCI_DM1 | HCI_DH1 | HCI_DM3 | HCI_DH3 | HCI_DM5 | HCI_DH5)
+
+/* eSCO packet types */
+#define ESCO_HV1	0x0001
+#define ESCO_HV2	0x0002
+#define ESCO_HV3	0x0004
+#define ESCO_EV3	0x0008
+#define ESCO_EV4	0x0010
+#define ESCO_EV5	0x0020
+#define ESCO_2EV3	0x0040
+#define ESCO_3EV3	0x0080
+#define ESCO_2EV5	0x0100
+#define ESCO_3EV5	0x0200
+
+#define SCO_ESCO_MASK	(ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
+#define EDR_ESCO_MASK	(ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
+#define ALL_ESCO_MASK	(SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
+				EDR_ESCO_MASK)
+
+/* HCI Error codes */
+#define HCI_UNKNOWN_COMMAND			0x01
+#define HCI_NO_CONNECTION			0x02
+#define HCI_HARDWARE_FAILURE			0x03
+#define HCI_PAGE_TIMEOUT			0x04
+#define HCI_AUTHENTICATION_FAILURE		0x05
+#define HCI_PIN_OR_KEY_MISSING			0x06
+#define HCI_MEMORY_FULL				0x07
+#define HCI_CONNECTION_TIMEOUT			0x08
+#define HCI_MAX_NUMBER_OF_CONNECTIONS		0x09
+#define HCI_MAX_NUMBER_OF_SCO_CONNECTIONS	0x0a
+#define HCI_ACL_CONNECTION_EXISTS		0x0b
+#define HCI_COMMAND_DISALLOWED			0x0c
+#define HCI_REJECTED_LIMITED_RESOURCES		0x0d
+#define HCI_REJECTED_SECURITY			0x0e
+#define HCI_REJECTED_PERSONAL			0x0f
+#define HCI_HOST_TIMEOUT			0x10
+#define HCI_UNSUPPORTED_FEATURE			0x11
+#define HCI_INVALID_PARAMETERS			0x12
+#define HCI_OE_USER_ENDED_CONNECTION		0x13
+#define HCI_OE_LOW_RESOURCES			0x14
+#define HCI_OE_POWER_OFF			0x15
+#define HCI_CONNECTION_TERMINATED		0x16
+#define HCI_REPEATED_ATTEMPTS			0x17
+#define HCI_PAIRING_NOT_ALLOWED			0x18
+#define HCI_UNKNOWN_LMP_PDU			0x19
+#define HCI_UNSUPPORTED_REMOTE_FEATURE		0x1a
+#define HCI_SCO_OFFSET_REJECTED			0x1b
+#define HCI_SCO_INTERVAL_REJECTED		0x1c
+#define HCI_AIR_MODE_REJECTED			0x1d
+#define HCI_INVALID_LMP_PARAMETERS		0x1e
+#define HCI_UNSPECIFIED_ERROR			0x1f
+#define HCI_UNSUPPORTED_LMP_PARAMETER_VALUE	0x20
+#define HCI_ROLE_CHANGE_NOT_ALLOWED		0x21
+#define HCI_LMP_RESPONSE_TIMEOUT		0x22
+#define HCI_LMP_ERROR_TRANSACTION_COLLISION	0x23
+#define HCI_LMP_PDU_NOT_ALLOWED			0x24
+#define HCI_ENCRYPTION_MODE_NOT_ACCEPTED	0x25
+#define HCI_UNIT_LINK_KEY_USED			0x26
+#define HCI_QOS_NOT_SUPPORTED			0x27
+#define HCI_INSTANT_PASSED			0x28
+#define HCI_PAIRING_NOT_SUPPORTED		0x29
+#define HCI_TRANSACTION_COLLISION		0x2a
+#define HCI_QOS_UNACCEPTABLE_PARAMETER		0x2c
+#define HCI_QOS_REJECTED			0x2d
+#define HCI_CLASSIFICATION_NOT_SUPPORTED	0x2e
+#define HCI_INSUFFICIENT_SECURITY		0x2f
+#define HCI_PARAMETER_OUT_OF_RANGE		0x30
+#define HCI_ROLE_SWITCH_PENDING			0x32
+#define HCI_SLOT_VIOLATION			0x34
+#define HCI_ROLE_SWITCH_FAILED			0x35
+#define HCI_EIR_TOO_LARGE			0x36
+#define HCI_SIMPLE_PAIRING_NOT_SUPPORTED	0x37
+#define HCI_HOST_BUSY_PAIRING			0x38
+
+/* ACL flags */
+#define ACL_START_NO_FLUSH	0x00
+#define ACL_CONT		0x01
+#define ACL_START		0x02
+#define ACL_ACTIVE_BCAST	0x04
+#define ACL_PICO_BCAST		0x08
+
+/* Baseband links */
+#define SCO_LINK	0x00
+#define ACL_LINK	0x01
+#define ESCO_LINK	0x02
+
+/* LMP features */
+#define LMP_3SLOT	0x01
+#define LMP_5SLOT	0x02
+#define LMP_ENCRYPT	0x04
+#define LMP_SOFFSET	0x08
+#define LMP_TACCURACY	0x10
+#define LMP_RSWITCH	0x20
+#define LMP_HOLD	0x40
+#define LMP_SNIFF	0x80
+
+#define LMP_PARK	0x01
+#define LMP_RSSI	0x02
+#define LMP_QUALITY	0x04
+#define LMP_SCO		0x08
+#define LMP_HV2		0x10
+#define LMP_HV3		0x20
+#define LMP_ULAW	0x40
+#define LMP_ALAW	0x80
+
+#define LMP_CVSD	0x01
+#define LMP_PSCHEME	0x02
+#define LMP_PCONTROL	0x04
+#define LMP_TRSP_SCO	0x08
+#define LMP_BCAST_ENC	0x80
+
+#define LMP_EDR_ACL_2M	0x02
+#define LMP_EDR_ACL_3M	0x04
+#define LMP_ENH_ISCAN	0x08
+#define LMP_ILACE_ISCAN	0x10
+#define LMP_ILACE_PSCAN	0x20
+#define LMP_RSSI_INQ	0x40
+#define LMP_ESCO	0x80
+
+#define LMP_EV4		0x01
+#define LMP_EV5		0x02
+#define LMP_AFH_CAP_SLV	0x08
+#define LMP_AFH_CLS_SLV	0x10
+#define LMP_NO_BREDR	0x20
+#define LMP_LE		0x40
+#define LMP_EDR_3SLOT	0x80
+
+#define LMP_EDR_5SLOT	0x01
+#define LMP_SNIFF_SUBR	0x02
+#define LMP_PAUSE_ENC	0x04
+#define LMP_AFH_CAP_MST	0x08
+#define LMP_AFH_CLS_MST	0x10
+#define LMP_EDR_ESCO_2M	0x20
+#define LMP_EDR_ESCO_3M	0x40
+#define LMP_EDR_3S_ESCO	0x80
+
+#define LMP_EXT_INQ	0x01
+#define LMP_LE_BREDR	0x02
+#define LMP_SIMPLE_PAIR	0x08
+#define LMP_ENCAPS_PDU	0x10
+#define LMP_ERR_DAT_REP	0x20
+#define LMP_NFLUSH_PKTS	0x40
+
+#define LMP_LSTO	0x01
+#define LMP_INQ_TX_PWR	0x02
+#define LMP_EPC		0x04
+#define LMP_EXT_FEAT	0x80
+
+/* Extended LMP features */
+#define LMP_HOST_LE	0x02
+
+/* Link policies */
+#define HCI_LP_RSWITCH	0x0001
+#define HCI_LP_HOLD	0x0002
+#define HCI_LP_SNIFF	0x0004
+#define HCI_LP_PARK	0x0008
+
+/* Link mode */
+#define HCI_LM_ACCEPT	0x8000
+#define HCI_LM_MASTER	0x0001
+#define HCI_LM_AUTH	0x0002
+#define HCI_LM_ENCRYPT	0x0004
+#define HCI_LM_TRUSTED	0x0008
+#define HCI_LM_RELIABLE	0x0010
+#define HCI_LM_SECURE	0x0020
+
+/* -----  HCI Commands ----- */
+
+/* Link Control */
+#define OGF_LINK_CTL		0x01
+
+#define OCF_INQUIRY			0x0001
+typedef struct {
+	uint8_t		lap[3];
+	uint8_t		length;		/* 1.28s units */
+	uint8_t		num_rsp;
+} __attribute__ ((packed)) inquiry_cp;
+#define INQUIRY_CP_SIZE 5
+
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) status_bdaddr_rp;
+#define STATUS_BDADDR_RP_SIZE 7
+
+#define OCF_INQUIRY_CANCEL		0x0002
+
+#define OCF_PERIODIC_INQUIRY		0x0003
+typedef struct {
+	uint16_t	max_period;	/* 1.28s units */
+	uint16_t	min_period;	/* 1.28s units */
+	uint8_t		lap[3];
+	uint8_t		length;		/* 1.28s units */
+	uint8_t		num_rsp;
+} __attribute__ ((packed)) periodic_inquiry_cp;
+#define PERIODIC_INQUIRY_CP_SIZE 9
+
+#define OCF_EXIT_PERIODIC_INQUIRY	0x0004
+
+#define OCF_CREATE_CONN			0x0005
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint16_t	pkt_type;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_mode;
+	uint16_t	clock_offset;
+	uint8_t		role_switch;
+} __attribute__ ((packed)) create_conn_cp;
+#define CREATE_CONN_CP_SIZE 13
+
+#define OCF_DISCONNECT			0x0006
+typedef struct {
+	uint16_t	handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) disconnect_cp;
+#define DISCONNECT_CP_SIZE 3
+
+#define OCF_ADD_SCO			0x0007
+typedef struct {
+	uint16_t	handle;
+	uint16_t	pkt_type;
+} __attribute__ ((packed)) add_sco_cp;
+#define ADD_SCO_CP_SIZE 4
+
+#define OCF_CREATE_CONN_CANCEL		0x0008
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) create_conn_cancel_cp;
+#define CREATE_CONN_CANCEL_CP_SIZE 6
+
+#define OCF_ACCEPT_CONN_REQ		0x0009
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		role;
+} __attribute__ ((packed)) accept_conn_req_cp;
+#define ACCEPT_CONN_REQ_CP_SIZE	7
+
+#define OCF_REJECT_CONN_REQ		0x000A
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		reason;
+} __attribute__ ((packed)) reject_conn_req_cp;
+#define REJECT_CONN_REQ_CP_SIZE	7
+
+#define OCF_LINK_KEY_REPLY		0x000B
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		link_key[16];
+} __attribute__ ((packed)) link_key_reply_cp;
+#define LINK_KEY_REPLY_CP_SIZE 22
+
+#define OCF_LINK_KEY_NEG_REPLY		0x000C
+
+#define OCF_PIN_CODE_REPLY		0x000D
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pin_len;
+	uint8_t		pin_code[16];
+} __attribute__ ((packed)) pin_code_reply_cp;
+#define PIN_CODE_REPLY_CP_SIZE 23
+
+#define OCF_PIN_CODE_NEG_REPLY		0x000E
+
+#define OCF_SET_CONN_PTYPE		0x000F
+typedef struct {
+	uint16_t	 handle;
+	uint16_t	 pkt_type;
+} __attribute__ ((packed)) set_conn_ptype_cp;
+#define SET_CONN_PTYPE_CP_SIZE 4
+
+#define OCF_AUTH_REQUESTED		0x0011
+typedef struct {
+	uint16_t	 handle;
+} __attribute__ ((packed)) auth_requested_cp;
+#define AUTH_REQUESTED_CP_SIZE 2
+
+#define OCF_SET_CONN_ENCRYPT		0x0013
+typedef struct {
+	uint16_t	handle;
+	uint8_t		encrypt;
+} __attribute__ ((packed)) set_conn_encrypt_cp;
+#define SET_CONN_ENCRYPT_CP_SIZE 3
+
+#define OCF_CHANGE_CONN_LINK_KEY	0x0015
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) change_conn_link_key_cp;
+#define CHANGE_CONN_LINK_KEY_CP_SIZE 2
+
+#define OCF_MASTER_LINK_KEY		0x0017
+typedef struct {
+	uint8_t		key_flag;
+} __attribute__ ((packed)) master_link_key_cp;
+#define MASTER_LINK_KEY_CP_SIZE 1
+
+#define OCF_REMOTE_NAME_REQ		0x0019
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_mode;
+	uint16_t	clock_offset;
+} __attribute__ ((packed)) remote_name_req_cp;
+#define REMOTE_NAME_REQ_CP_SIZE 10
+
+#define OCF_REMOTE_NAME_REQ_CANCEL	0x001A
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) remote_name_req_cancel_cp;
+#define REMOTE_NAME_REQ_CANCEL_CP_SIZE 6
+
+#define OCF_READ_REMOTE_FEATURES	0x001B
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) read_remote_features_cp;
+#define READ_REMOTE_FEATURES_CP_SIZE 2
+
+#define OCF_READ_REMOTE_EXT_FEATURES	0x001C
+typedef struct {
+	uint16_t	handle;
+	uint8_t		page_num;
+} __attribute__ ((packed)) read_remote_ext_features_cp;
+#define READ_REMOTE_EXT_FEATURES_CP_SIZE 3
+
+#define OCF_READ_REMOTE_VERSION		0x001D
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) read_remote_version_cp;
+#define READ_REMOTE_VERSION_CP_SIZE 2
+
+#define OCF_READ_CLOCK_OFFSET		0x001F
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) read_clock_offset_cp;
+#define READ_CLOCK_OFFSET_CP_SIZE 2
+
+#define OCF_READ_LMP_HANDLE		0x0020
+
+#define OCF_SETUP_SYNC_CONN		0x0028
+typedef struct {
+	uint16_t	handle;
+	uint32_t	tx_bandwith;
+	uint32_t	rx_bandwith;
+	uint16_t	max_latency;
+	uint16_t	voice_setting;
+	uint8_t		retrans_effort;
+	uint16_t	pkt_type;
+} __attribute__ ((packed)) setup_sync_conn_cp;
+#define SETUP_SYNC_CONN_CP_SIZE 17
+
+#define OCF_ACCEPT_SYNC_CONN_REQ	0x0029
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint32_t	tx_bandwith;
+	uint32_t	rx_bandwith;
+	uint16_t	max_latency;
+	uint16_t	voice_setting;
+	uint8_t		retrans_effort;
+	uint16_t	pkt_type;
+} __attribute__ ((packed)) accept_sync_conn_req_cp;
+#define ACCEPT_SYNC_CONN_REQ_CP_SIZE 21
+
+#define OCF_REJECT_SYNC_CONN_REQ	0x002A
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		reason;
+} __attribute__ ((packed)) reject_sync_conn_req_cp;
+#define REJECT_SYNC_CONN_REQ_CP_SIZE 7
+
+#define OCF_IO_CAPABILITY_REPLY		0x002B
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		capability;
+	uint8_t		oob_data;
+	uint8_t		authentication;
+} __attribute__ ((packed)) io_capability_reply_cp;
+#define IO_CAPABILITY_REPLY_CP_SIZE 9
+
+#define OCF_USER_CONFIRM_REPLY		0x002C
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) user_confirm_reply_cp;
+#define USER_CONFIRM_REPLY_CP_SIZE 6
+
+#define OCF_USER_CONFIRM_NEG_REPLY	0x002D
+
+#define OCF_USER_PASSKEY_REPLY		0x002E
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint32_t	passkey;
+} __attribute__ ((packed)) user_passkey_reply_cp;
+#define USER_PASSKEY_REPLY_CP_SIZE 10
+
+#define OCF_USER_PASSKEY_NEG_REPLY	0x002F
+
+#define OCF_REMOTE_OOB_DATA_REPLY	0x0030
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		hash[16];
+	uint8_t		randomizer[16];
+} __attribute__ ((packed)) remote_oob_data_reply_cp;
+#define REMOTE_OOB_DATA_REPLY_CP_SIZE 38
+
+#define OCF_REMOTE_OOB_DATA_NEG_REPLY	0x0033
+
+#define OCF_IO_CAPABILITY_NEG_REPLY	0x0034
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		reason;
+} __attribute__ ((packed)) io_capability_neg_reply_cp;
+#define IO_CAPABILITY_NEG_REPLY_CP_SIZE 7
+
+#define OCF_CREATE_PHYSICAL_LINK		0x0035
+typedef struct {
+	uint8_t		handle;
+	uint8_t		key_length;
+	uint8_t		key_type;
+	uint8_t		key[32];
+} __attribute__ ((packed)) create_physical_link_cp;
+#define CREATE_PHYSICAL_LINK_CP_SIZE 35
+
+#define OCF_ACCEPT_PHYSICAL_LINK		0x0036
+
+#define OCF_DISCONNECT_PHYSICAL_LINK		0x0037
+typedef struct {
+	uint8_t		handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) disconnect_physical_link_cp;
+#define DISCONNECT_PHYSICAL_LINK_CP_SIZE 2
+
+#define OCF_CREATE_LOGICAL_LINK		0x0038
+typedef struct {
+	uint8_t		handle;
+	uint8_t		tx_flow[16];
+	uint8_t		rx_flow[16];
+} __attribute__ ((packed)) create_logical_link_cp;
+#define CREATE_LOGICAL_LINK_CP_SIZE 33
+
+#define OCF_ACCEPT_LOGICAL_LINK		0x0039
+
+#define OCF_DISCONNECT_LOGICAL_LINK		0x003A
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) disconnect_logical_link_cp;
+#define DISCONNECT_LOGICAL_LINK_CP_SIZE 2
+
+#define OCF_LOGICAL_LINK_CANCEL		0x003B
+typedef struct {
+	uint8_t		handle;
+	uint8_t		tx_flow_id;
+} __attribute__ ((packed)) cancel_logical_link_cp;
+#define LOGICAL_LINK_CANCEL_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+	uint8_t		tx_flow_id;
+} __attribute__ ((packed)) cancel_logical_link_rp;
+#define LOGICAL_LINK_CANCEL_RP_SIZE 3
+
+#define OCF_FLOW_SPEC_MODIFY		0x003C
+
+/* Link Policy */
+#define OGF_LINK_POLICY		0x02
+
+#define OCF_HOLD_MODE			0x0001
+typedef struct {
+	uint16_t	handle;
+	uint16_t	max_interval;
+	uint16_t	min_interval;
+} __attribute__ ((packed)) hold_mode_cp;
+#define HOLD_MODE_CP_SIZE 6
+
+#define OCF_SNIFF_MODE			0x0003
+typedef struct {
+	uint16_t	handle;
+	uint16_t	max_interval;
+	uint16_t	min_interval;
+	uint16_t	attempt;
+	uint16_t	timeout;
+} __attribute__ ((packed)) sniff_mode_cp;
+#define SNIFF_MODE_CP_SIZE 10
+
+#define OCF_EXIT_SNIFF_MODE		0x0004
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) exit_sniff_mode_cp;
+#define EXIT_SNIFF_MODE_CP_SIZE 2
+
+#define OCF_PARK_MODE			0x0005
+typedef struct {
+	uint16_t	handle;
+	uint16_t	max_interval;
+	uint16_t	min_interval;
+} __attribute__ ((packed)) park_mode_cp;
+#define PARK_MODE_CP_SIZE 6
+
+#define OCF_EXIT_PARK_MODE		0x0006
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) exit_park_mode_cp;
+#define EXIT_PARK_MODE_CP_SIZE 2
+
+#define OCF_QOS_SETUP			0x0007
+typedef struct {
+	uint8_t		service_type;		/* 1 = best effort */
+	uint32_t	token_rate;		/* Byte per seconds */
+	uint32_t	peak_bandwidth;		/* Byte per seconds */
+	uint32_t	latency;		/* Microseconds */
+	uint32_t	delay_variation;	/* Microseconds */
+} __attribute__ ((packed)) hci_qos;
+#define HCI_QOS_CP_SIZE 17
+typedef struct {
+	uint16_t 	handle;
+	uint8_t 	flags;			/* Reserved */
+	hci_qos 	qos;
+} __attribute__ ((packed)) qos_setup_cp;
+#define QOS_SETUP_CP_SIZE (3 + HCI_QOS_CP_SIZE)
+
+#define OCF_ROLE_DISCOVERY		0x0009
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) role_discovery_cp;
+#define ROLE_DISCOVERY_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		role;
+} __attribute__ ((packed)) role_discovery_rp;
+#define ROLE_DISCOVERY_RP_SIZE 4
+
+#define OCF_SWITCH_ROLE			0x000B
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		role;
+} __attribute__ ((packed)) switch_role_cp;
+#define SWITCH_ROLE_CP_SIZE 7
+
+#define OCF_READ_LINK_POLICY		0x000C
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) read_link_policy_cp;
+#define READ_LINK_POLICY_CP_SIZE 2
+typedef struct {
+	uint8_t 	status;
+	uint16_t	handle;
+	uint16_t	policy;
+} __attribute__ ((packed)) read_link_policy_rp;
+#define READ_LINK_POLICY_RP_SIZE 5
+
+#define OCF_WRITE_LINK_POLICY		0x000D
+typedef struct {
+	uint16_t	handle;
+	uint16_t	policy;
+} __attribute__ ((packed)) write_link_policy_cp;
+#define WRITE_LINK_POLICY_CP_SIZE 4
+typedef struct {
+	uint8_t 	status;
+	uint16_t	handle;
+} __attribute__ ((packed)) write_link_policy_rp;
+#define WRITE_LINK_POLICY_RP_SIZE 3
+
+#define OCF_READ_DEFAULT_LINK_POLICY	0x000E
+
+#define OCF_WRITE_DEFAULT_LINK_POLICY	0x000F
+
+#define OCF_FLOW_SPECIFICATION		0x0010
+
+#define OCF_SNIFF_SUBRATING		0x0011
+typedef struct {
+	uint16_t	handle;
+	uint16_t	max_latency;
+	uint16_t	min_remote_timeout;
+	uint16_t	min_local_timeout;
+} __attribute__ ((packed)) sniff_subrating_cp;
+#define SNIFF_SUBRATING_CP_SIZE 8
+
+/* Host Controller and Baseband */
+#define OGF_HOST_CTL		0x03
+
+#define OCF_SET_EVENT_MASK		0x0001
+typedef struct {
+	uint8_t		mask[8];
+} __attribute__ ((packed)) set_event_mask_cp;
+#define SET_EVENT_MASK_CP_SIZE 8
+
+#define OCF_RESET			0x0003
+
+#define OCF_SET_EVENT_FLT		0x0005
+typedef struct {
+	uint8_t		flt_type;
+	uint8_t		cond_type;
+	uint8_t		condition[0];
+} __attribute__ ((packed)) set_event_flt_cp;
+#define SET_EVENT_FLT_CP_SIZE 2
+
+/* Filter types */
+#define FLT_CLEAR_ALL			0x00
+#define FLT_INQ_RESULT			0x01
+#define FLT_CONN_SETUP			0x02
+/* INQ_RESULT Condition types */
+#define INQ_RESULT_RETURN_ALL		0x00
+#define INQ_RESULT_RETURN_CLASS		0x01
+#define INQ_RESULT_RETURN_BDADDR	0x02
+/* CONN_SETUP Condition types */
+#define CONN_SETUP_ALLOW_ALL		0x00
+#define CONN_SETUP_ALLOW_CLASS		0x01
+#define CONN_SETUP_ALLOW_BDADDR		0x02
+/* CONN_SETUP Conditions */
+#define CONN_SETUP_AUTO_OFF		0x01
+#define CONN_SETUP_AUTO_ON		0x02
+
+#define OCF_FLUSH			0x0008
+
+#define OCF_READ_PIN_TYPE		0x0009
+typedef struct {
+	uint8_t		status;
+	uint8_t		pin_type;
+} __attribute__ ((packed)) read_pin_type_rp;
+#define READ_PIN_TYPE_RP_SIZE 2
+
+#define OCF_WRITE_PIN_TYPE		0x000A
+typedef struct {
+	uint8_t		pin_type;
+} __attribute__ ((packed)) write_pin_type_cp;
+#define WRITE_PIN_TYPE_CP_SIZE 1
+
+#define OCF_CREATE_NEW_UNIT_KEY		0x000B
+
+#define OCF_READ_STORED_LINK_KEY	0x000D
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		read_all;
+} __attribute__ ((packed)) read_stored_link_key_cp;
+#define READ_STORED_LINK_KEY_CP_SIZE 7
+typedef struct {
+	uint8_t		status;
+	uint16_t	max_keys;
+	uint16_t	num_keys;
+} __attribute__ ((packed)) read_stored_link_key_rp;
+#define READ_STORED_LINK_KEY_RP_SIZE 5
+
+#define OCF_WRITE_STORED_LINK_KEY	0x0011
+typedef struct {
+	uint8_t		num_keys;
+	/* variable length part */
+} __attribute__ ((packed)) write_stored_link_key_cp;
+#define WRITE_STORED_LINK_KEY_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+	uint8_t		num_keys;
+} __attribute__ ((packed)) write_stored_link_key_rp;
+#define READ_WRITE_LINK_KEY_RP_SIZE 2
+
+#define OCF_DELETE_STORED_LINK_KEY	0x0012
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		delete_all;
+} __attribute__ ((packed)) delete_stored_link_key_cp;
+#define DELETE_STORED_LINK_KEY_CP_SIZE 7
+typedef struct {
+	uint8_t		status;
+	uint16_t	num_keys;
+} __attribute__ ((packed)) delete_stored_link_key_rp;
+#define DELETE_STORED_LINK_KEY_RP_SIZE 3
+
+#define HCI_MAX_NAME_LENGTH		248
+
+#define OCF_CHANGE_LOCAL_NAME		0x0013
+typedef struct {
+	uint8_t		name[HCI_MAX_NAME_LENGTH];
+} __attribute__ ((packed)) change_local_name_cp;
+#define CHANGE_LOCAL_NAME_CP_SIZE 248
+
+#define OCF_READ_LOCAL_NAME		0x0014
+typedef struct {
+	uint8_t		status;
+	uint8_t		name[HCI_MAX_NAME_LENGTH];
+} __attribute__ ((packed)) read_local_name_rp;
+#define READ_LOCAL_NAME_RP_SIZE 249
+
+#define OCF_READ_CONN_ACCEPT_TIMEOUT	0x0015
+typedef struct {
+	uint8_t		status;
+	uint16_t	timeout;
+} __attribute__ ((packed)) read_conn_accept_timeout_rp;
+#define READ_CONN_ACCEPT_TIMEOUT_RP_SIZE 3
+
+#define OCF_WRITE_CONN_ACCEPT_TIMEOUT	0x0016
+typedef struct {
+	uint16_t	timeout;
+} __attribute__ ((packed)) write_conn_accept_timeout_cp;
+#define WRITE_CONN_ACCEPT_TIMEOUT_CP_SIZE 2
+
+#define OCF_READ_PAGE_TIMEOUT		0x0017
+typedef struct {
+	uint8_t		status;
+	uint16_t	timeout;
+} __attribute__ ((packed)) read_page_timeout_rp;
+#define READ_PAGE_TIMEOUT_RP_SIZE 3
+
+#define OCF_WRITE_PAGE_TIMEOUT		0x0018
+typedef struct {
+	uint16_t	timeout;
+} __attribute__ ((packed)) write_page_timeout_cp;
+#define WRITE_PAGE_TIMEOUT_CP_SIZE 2
+
+#define OCF_READ_SCAN_ENABLE		0x0019
+typedef struct {
+	uint8_t		status;
+	uint8_t		enable;
+} __attribute__ ((packed)) read_scan_enable_rp;
+#define READ_SCAN_ENABLE_RP_SIZE 2
+
+#define OCF_WRITE_SCAN_ENABLE		0x001A
+	#define SCAN_DISABLED		0x00
+	#define SCAN_INQUIRY		0x01
+	#define SCAN_PAGE		0x02
+
+#define OCF_READ_PAGE_ACTIVITY		0x001B
+typedef struct {
+	uint8_t		status;
+	uint16_t	interval;
+	uint16_t	window;
+} __attribute__ ((packed)) read_page_activity_rp;
+#define READ_PAGE_ACTIVITY_RP_SIZE 5
+
+#define OCF_WRITE_PAGE_ACTIVITY		0x001C
+typedef struct {
+	uint16_t	interval;
+	uint16_t	window;
+} __attribute__ ((packed)) write_page_activity_cp;
+#define WRITE_PAGE_ACTIVITY_CP_SIZE 4
+
+#define OCF_READ_INQ_ACTIVITY		0x001D
+typedef struct {
+	uint8_t		status;
+	uint16_t	interval;
+	uint16_t	window;
+} __attribute__ ((packed)) read_inq_activity_rp;
+#define READ_INQ_ACTIVITY_RP_SIZE 5
+
+#define OCF_WRITE_INQ_ACTIVITY		0x001E
+typedef struct {
+	uint16_t	interval;
+	uint16_t	window;
+} __attribute__ ((packed)) write_inq_activity_cp;
+#define WRITE_INQ_ACTIVITY_CP_SIZE 4
+
+#define OCF_READ_AUTH_ENABLE		0x001F
+
+#define OCF_WRITE_AUTH_ENABLE		0x0020
+	#define AUTH_DISABLED		0x00
+	#define AUTH_ENABLED		0x01
+
+#define OCF_READ_ENCRYPT_MODE		0x0021
+
+#define OCF_WRITE_ENCRYPT_MODE		0x0022
+	#define ENCRYPT_DISABLED	0x00
+	#define ENCRYPT_P2P		0x01
+	#define ENCRYPT_BOTH		0x02
+
+#define OCF_READ_CLASS_OF_DEV		0x0023
+typedef struct {
+	uint8_t		status;
+	uint8_t		dev_class[3];
+} __attribute__ ((packed)) read_class_of_dev_rp;
+#define READ_CLASS_OF_DEV_RP_SIZE 4
+
+#define OCF_WRITE_CLASS_OF_DEV		0x0024
+typedef struct {
+	uint8_t		dev_class[3];
+} __attribute__ ((packed)) write_class_of_dev_cp;
+#define WRITE_CLASS_OF_DEV_CP_SIZE 3
+
+#define OCF_READ_VOICE_SETTING		0x0025
+typedef struct {
+	uint8_t		status;
+	uint16_t	voice_setting;
+} __attribute__ ((packed)) read_voice_setting_rp;
+#define READ_VOICE_SETTING_RP_SIZE 3
+
+#define OCF_WRITE_VOICE_SETTING		0x0026
+typedef struct {
+	uint16_t	voice_setting;
+} __attribute__ ((packed)) write_voice_setting_cp;
+#define WRITE_VOICE_SETTING_CP_SIZE 2
+
+#define OCF_READ_AUTOMATIC_FLUSH_TIMEOUT	0x0027
+
+#define OCF_WRITE_AUTOMATIC_FLUSH_TIMEOUT	0x0028
+
+#define OCF_READ_NUM_BROADCAST_RETRANS	0x0029
+
+#define OCF_WRITE_NUM_BROADCAST_RETRANS	0x002A
+
+#define OCF_READ_HOLD_MODE_ACTIVITY	0x002B
+
+#define OCF_WRITE_HOLD_MODE_ACTIVITY	0x002C
+
+#define OCF_READ_TRANSMIT_POWER_LEVEL	0x002D
+typedef struct {
+	uint16_t	handle;
+	uint8_t		type;
+} __attribute__ ((packed)) read_transmit_power_level_cp;
+#define READ_TRANSMIT_POWER_LEVEL_CP_SIZE 3
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	int8_t		level;
+} __attribute__ ((packed)) read_transmit_power_level_rp;
+#define READ_TRANSMIT_POWER_LEVEL_RP_SIZE 4
+
+#define OCF_READ_SYNC_FLOW_ENABLE	0x002E
+
+#define OCF_WRITE_SYNC_FLOW_ENABLE	0x002F
+
+#define OCF_SET_CONTROLLER_TO_HOST_FC	0x0031
+
+#define OCF_HOST_BUFFER_SIZE		0x0033
+typedef struct {
+	uint16_t	acl_mtu;
+	uint8_t		sco_mtu;
+	uint16_t	acl_max_pkt;
+	uint16_t	sco_max_pkt;
+} __attribute__ ((packed)) host_buffer_size_cp;
+#define HOST_BUFFER_SIZE_CP_SIZE 7
+
+#define OCF_HOST_NUM_COMP_PKTS		0x0035
+typedef struct {
+	uint8_t		num_hndl;
+	/* variable length part */
+} __attribute__ ((packed)) host_num_comp_pkts_cp;
+#define HOST_NUM_COMP_PKTS_CP_SIZE 1
+
+#define OCF_READ_LINK_SUPERVISION_TIMEOUT	0x0036
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	timeout;
+} __attribute__ ((packed)) read_link_supervision_timeout_rp;
+#define READ_LINK_SUPERVISION_TIMEOUT_RP_SIZE 5
+
+#define OCF_WRITE_LINK_SUPERVISION_TIMEOUT	0x0037
+typedef struct {
+	uint16_t	handle;
+	uint16_t	timeout;
+} __attribute__ ((packed)) write_link_supervision_timeout_cp;
+#define WRITE_LINK_SUPERVISION_TIMEOUT_CP_SIZE 4
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) write_link_supervision_timeout_rp;
+#define WRITE_LINK_SUPERVISION_TIMEOUT_RP_SIZE 3
+
+#define OCF_READ_NUM_SUPPORTED_IAC	0x0038
+
+#define MAX_IAC_LAP 0x40
+#define OCF_READ_CURRENT_IAC_LAP	0x0039
+typedef struct {
+	uint8_t		status;
+	uint8_t		num_current_iac;
+	uint8_t		lap[MAX_IAC_LAP][3];
+} __attribute__ ((packed)) read_current_iac_lap_rp;
+#define READ_CURRENT_IAC_LAP_RP_SIZE 2+3*MAX_IAC_LAP
+
+#define OCF_WRITE_CURRENT_IAC_LAP	0x003A
+typedef struct {
+	uint8_t		num_current_iac;
+	uint8_t		lap[MAX_IAC_LAP][3];
+} __attribute__ ((packed)) write_current_iac_lap_cp;
+#define WRITE_CURRENT_IAC_LAP_CP_SIZE 1+3*MAX_IAC_LAP
+
+#define OCF_READ_PAGE_SCAN_PERIOD_MODE	0x003B
+
+#define OCF_WRITE_PAGE_SCAN_PERIOD_MODE	0x003C
+
+#define OCF_READ_PAGE_SCAN_MODE		0x003D
+
+#define OCF_WRITE_PAGE_SCAN_MODE	0x003E
+
+#define OCF_SET_AFH_CLASSIFICATION	0x003F
+typedef struct {
+	uint8_t		map[10];
+} __attribute__ ((packed)) set_afh_classification_cp;
+#define SET_AFH_CLASSIFICATION_CP_SIZE 10
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) set_afh_classification_rp;
+#define SET_AFH_CLASSIFICATION_RP_SIZE 1
+
+#define OCF_READ_INQUIRY_SCAN_TYPE	0x0042
+typedef struct {
+	uint8_t		status;
+	uint8_t		type;
+} __attribute__ ((packed)) read_inquiry_scan_type_rp;
+#define READ_INQUIRY_SCAN_TYPE_RP_SIZE 2
+
+#define OCF_WRITE_INQUIRY_SCAN_TYPE	0x0043
+typedef struct {
+	uint8_t		type;
+} __attribute__ ((packed)) write_inquiry_scan_type_cp;
+#define WRITE_INQUIRY_SCAN_TYPE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_inquiry_scan_type_rp;
+#define WRITE_INQUIRY_SCAN_TYPE_RP_SIZE 1
+
+#define OCF_READ_INQUIRY_MODE		0x0044
+typedef struct {
+	uint8_t		status;
+	uint8_t		mode;
+} __attribute__ ((packed)) read_inquiry_mode_rp;
+#define READ_INQUIRY_MODE_RP_SIZE 2
+
+#define OCF_WRITE_INQUIRY_MODE		0x0045
+typedef struct {
+	uint8_t		mode;
+} __attribute__ ((packed)) write_inquiry_mode_cp;
+#define WRITE_INQUIRY_MODE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_inquiry_mode_rp;
+#define WRITE_INQUIRY_MODE_RP_SIZE 1
+
+#define OCF_READ_PAGE_SCAN_TYPE		0x0046
+
+#define OCF_WRITE_PAGE_SCAN_TYPE	0x0047
+	#define PAGE_SCAN_TYPE_STANDARD		0x00
+	#define PAGE_SCAN_TYPE_INTERLACED	0x01
+
+#define OCF_READ_AFH_MODE		0x0048
+typedef struct {
+	uint8_t		status;
+	uint8_t		mode;
+} __attribute__ ((packed)) read_afh_mode_rp;
+#define READ_AFH_MODE_RP_SIZE 2
+
+#define OCF_WRITE_AFH_MODE		0x0049
+typedef struct {
+	uint8_t		mode;
+} __attribute__ ((packed)) write_afh_mode_cp;
+#define WRITE_AFH_MODE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_afh_mode_rp;
+#define WRITE_AFH_MODE_RP_SIZE 1
+
+#define HCI_MAX_EIR_LENGTH		240
+
+#define OCF_READ_EXT_INQUIRY_RESPONSE	0x0051
+typedef struct {
+	uint8_t		status;
+	uint8_t		fec;
+	uint8_t		data[HCI_MAX_EIR_LENGTH];
+} __attribute__ ((packed)) read_ext_inquiry_response_rp;
+#define READ_EXT_INQUIRY_RESPONSE_RP_SIZE 242
+
+#define OCF_WRITE_EXT_INQUIRY_RESPONSE	0x0052
+typedef struct {
+	uint8_t		fec;
+	uint8_t		data[HCI_MAX_EIR_LENGTH];
+} __attribute__ ((packed)) write_ext_inquiry_response_cp;
+#define WRITE_EXT_INQUIRY_RESPONSE_CP_SIZE 241
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_ext_inquiry_response_rp;
+#define WRITE_EXT_INQUIRY_RESPONSE_RP_SIZE 1
+
+#define OCF_REFRESH_ENCRYPTION_KEY	0x0053
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) refresh_encryption_key_cp;
+#define REFRESH_ENCRYPTION_KEY_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) refresh_encryption_key_rp;
+#define REFRESH_ENCRYPTION_KEY_RP_SIZE 1
+
+#define OCF_READ_SIMPLE_PAIRING_MODE	0x0055
+typedef struct {
+	uint8_t		status;
+	uint8_t		mode;
+} __attribute__ ((packed)) read_simple_pairing_mode_rp;
+#define READ_SIMPLE_PAIRING_MODE_RP_SIZE 2
+
+#define OCF_WRITE_SIMPLE_PAIRING_MODE	0x0056
+typedef struct {
+	uint8_t		mode;
+} __attribute__ ((packed)) write_simple_pairing_mode_cp;
+#define WRITE_SIMPLE_PAIRING_MODE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_simple_pairing_mode_rp;
+#define WRITE_SIMPLE_PAIRING_MODE_RP_SIZE 1
+
+#define OCF_READ_LOCAL_OOB_DATA		0x0057
+typedef struct {
+	uint8_t		status;
+	uint8_t		hash[16];
+	uint8_t		randomizer[16];
+} __attribute__ ((packed)) read_local_oob_data_rp;
+#define READ_LOCAL_OOB_DATA_RP_SIZE 33
+
+#define OCF_READ_INQ_RESPONSE_TX_POWER_LEVEL	0x0058
+typedef struct {
+	uint8_t		status;
+	int8_t		level;
+} __attribute__ ((packed)) read_inq_response_tx_power_level_rp;
+#define READ_INQ_RESPONSE_TX_POWER_LEVEL_RP_SIZE 2
+
+#define OCF_READ_INQUIRY_TRANSMIT_POWER_LEVEL	0x0058
+typedef struct {
+	uint8_t		status;
+	int8_t		level;
+} __attribute__ ((packed)) read_inquiry_transmit_power_level_rp;
+#define READ_INQUIRY_TRANSMIT_POWER_LEVEL_RP_SIZE 2
+
+#define OCF_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL	0x0059
+typedef struct {
+	int8_t		level;
+} __attribute__ ((packed)) write_inquiry_transmit_power_level_cp;
+#define WRITE_INQUIRY_TRANSMIT_POWER_LEVEL_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_inquiry_transmit_power_level_rp;
+#define WRITE_INQUIRY_TRANSMIT_POWER_LEVEL_RP_SIZE 1
+
+#define OCF_READ_DEFAULT_ERROR_DATA_REPORTING	0x005A
+typedef struct {
+	uint8_t		status;
+	uint8_t		reporting;
+} __attribute__ ((packed)) read_default_error_data_reporting_rp;
+#define READ_DEFAULT_ERROR_DATA_REPORTING_RP_SIZE 2
+
+#define OCF_WRITE_DEFAULT_ERROR_DATA_REPORTING	0x005B
+typedef struct {
+	uint8_t		reporting;
+} __attribute__ ((packed)) write_default_error_data_reporting_cp;
+#define WRITE_DEFAULT_ERROR_DATA_REPORTING_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_default_error_data_reporting_rp;
+#define WRITE_DEFAULT_ERROR_DATA_REPORTING_RP_SIZE 1
+
+#define OCF_ENHANCED_FLUSH		0x005F
+typedef struct {
+	uint16_t	handle;
+	uint8_t		type;
+} __attribute__ ((packed)) enhanced_flush_cp;
+#define ENHANCED_FLUSH_CP_SIZE 3
+
+#define OCF_SEND_KEYPRESS_NOTIFY	0x0060
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		type;
+} __attribute__ ((packed)) send_keypress_notify_cp;
+#define SEND_KEYPRESS_NOTIFY_CP_SIZE 7
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) send_keypress_notify_rp;
+#define SEND_KEYPRESS_NOTIFY_RP_SIZE 1
+
+#define OCF_READ_LOGICAL_LINK_ACCEPT_TIMEOUT	 0x0061
+typedef struct {
+	uint8_t		status;
+	uint16_t	timeout;
+} __attribute__ ((packed)) read_log_link_accept_timeout_rp;
+#define READ_LOGICAL_LINK_ACCEPT_TIMEOUT_RP_SIZE 3
+
+#define OCF_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT	0x0062
+typedef struct {
+	uint16_t	timeout;
+} __attribute__ ((packed)) write_log_link_accept_timeout_cp;
+#define WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT_CP_SIZE 2
+
+#define OCF_SET_EVENT_MASK_PAGE_2	0x0063
+
+#define OCF_READ_LOCATION_DATA		0x0064
+
+#define OCF_WRITE_LOCATION_DATA	0x0065
+
+#define OCF_READ_FLOW_CONTROL_MODE	0x0066
+
+#define OCF_WRITE_FLOW_CONTROL_MODE	0x0067
+
+#define OCF_READ_ENHANCED_TRANSMIT_POWER_LEVEL	0x0068
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	int8_t		level_gfsk;
+	int8_t		level_dqpsk;
+	int8_t		level_8dpsk;
+} __attribute__ ((packed)) read_enhanced_transmit_power_level_rp;
+#define READ_ENHANCED_TRANSMIT_POWER_LEVEL_RP_SIZE 6
+
+#define OCF_READ_BEST_EFFORT_FLUSH_TIMEOUT	0x0069
+typedef struct {
+	uint8_t		status;
+	uint32_t	timeout;
+} __attribute__ ((packed)) read_best_effort_flush_timeout_rp;
+#define READ_BEST_EFFORT_FLUSH_TIMEOUT_RP_SIZE 5
+
+#define OCF_WRITE_BEST_EFFORT_FLUSH_TIMEOUT	0x006A
+typedef struct {
+	uint16_t	handle;
+	uint32_t	timeout;
+} __attribute__ ((packed)) write_best_effort_flush_timeout_cp;
+#define WRITE_BEST_EFFORT_FLUSH_TIMEOUT_CP_SIZE 6
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_best_effort_flush_timeout_rp;
+#define WRITE_BEST_EFFORT_FLUSH_TIMEOUT_RP_SIZE 1
+
+#define OCF_WRITE_LE_HOST_SUPPORTED	0x006D
+typedef struct {
+	uint8_t		le;
+	uint8_t		simul;
+} __attribute__ ((packed)) write_le_host_supported_cp;
+#define WRITE_LE_HOST_SUPPORTED_CP_SIZE 2
+
+/* Informational Parameters */
+#define OGF_INFO_PARAM		0x04
+
+#define OCF_READ_LOCAL_VERSION		0x0001
+typedef struct {
+	uint8_t		status;
+	uint8_t		hci_ver;
+	uint16_t	hci_rev;
+	uint8_t		lmp_ver;
+	uint16_t	manufacturer;
+	uint16_t	lmp_subver;
+} __attribute__ ((packed)) read_local_version_rp;
+#define READ_LOCAL_VERSION_RP_SIZE 9
+
+#define OCF_READ_LOCAL_COMMANDS		0x0002
+typedef struct {
+	uint8_t		status;
+	uint8_t		commands[64];
+} __attribute__ ((packed)) read_local_commands_rp;
+#define READ_LOCAL_COMMANDS_RP_SIZE 65
+
+#define OCF_READ_LOCAL_FEATURES		0x0003
+typedef struct {
+	uint8_t		status;
+	uint8_t		features[8];
+} __attribute__ ((packed)) read_local_features_rp;
+#define READ_LOCAL_FEATURES_RP_SIZE 9
+
+#define OCF_READ_LOCAL_EXT_FEATURES	0x0004
+typedef struct {
+	uint8_t		page_num;
+} __attribute__ ((packed)) read_local_ext_features_cp;
+#define READ_LOCAL_EXT_FEATURES_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+	uint8_t		page_num;
+	uint8_t		max_page_num;
+	uint8_t		features[8];
+} __attribute__ ((packed)) read_local_ext_features_rp;
+#define READ_LOCAL_EXT_FEATURES_RP_SIZE 11
+
+#define OCF_READ_BUFFER_SIZE		0x0005
+typedef struct {
+	uint8_t		status;
+	uint16_t	acl_mtu;
+	uint8_t		sco_mtu;
+	uint16_t	acl_max_pkt;
+	uint16_t	sco_max_pkt;
+} __attribute__ ((packed)) read_buffer_size_rp;
+#define READ_BUFFER_SIZE_RP_SIZE 8
+
+#define OCF_READ_COUNTRY_CODE		0x0007
+
+#define OCF_READ_BD_ADDR		0x0009
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) read_bd_addr_rp;
+#define READ_BD_ADDR_RP_SIZE 7
+
+/* Status params */
+#define OGF_STATUS_PARAM	0x05
+
+#define OCF_READ_FAILED_CONTACT_COUNTER		0x0001
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		counter;
+} __attribute__ ((packed)) read_failed_contact_counter_rp;
+#define READ_FAILED_CONTACT_COUNTER_RP_SIZE 4
+
+#define OCF_RESET_FAILED_CONTACT_COUNTER	0x0002
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) reset_failed_contact_counter_rp;
+#define RESET_FAILED_CONTACT_COUNTER_RP_SIZE 4
+
+#define OCF_READ_LINK_QUALITY		0x0003
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		link_quality;
+} __attribute__ ((packed)) read_link_quality_rp;
+#define READ_LINK_QUALITY_RP_SIZE 4
+
+#define OCF_READ_RSSI			0x0005
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	int8_t		rssi;
+} __attribute__ ((packed)) read_rssi_rp;
+#define READ_RSSI_RP_SIZE 4
+
+#define OCF_READ_AFH_MAP		0x0006
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		mode;
+	uint8_t		map[10];
+} __attribute__ ((packed)) read_afh_map_rp;
+#define READ_AFH_MAP_RP_SIZE 14
+
+#define OCF_READ_CLOCK			0x0007
+typedef struct {
+	uint16_t	handle;
+	uint8_t		which_clock;
+} __attribute__ ((packed)) read_clock_cp;
+#define READ_CLOCK_CP_SIZE 3
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint32_t	clock;
+	uint16_t	accuracy;
+} __attribute__ ((packed)) read_clock_rp;
+#define READ_CLOCK_RP_SIZE 9
+
+#define OCF_READ_LOCAL_AMP_INFO	0x0009
+typedef struct {
+	uint8_t		status;
+	uint8_t		amp_status;
+	uint32_t	total_bandwidth;
+	uint32_t	max_guaranteed_bandwidth;
+	uint32_t	min_latency;
+	uint32_t	max_pdu_size;
+	uint8_t		controller_type;
+	uint16_t	pal_caps;
+	uint16_t	max_amp_assoc_length;
+	uint32_t	max_flush_timeout;
+	uint32_t	best_effort_flush_timeout;
+} __attribute__ ((packed)) read_local_amp_info_rp;
+#define READ_LOCAL_AMP_INFO_RP_SIZE 31
+
+#define OCF_READ_LOCAL_AMP_ASSOC	0x000A
+typedef struct {
+	uint8_t		handle;
+	uint16_t	length_so_far;
+	uint16_t	assoc_length;
+} __attribute__ ((packed)) read_local_amp_assoc_cp;
+#define READ_LOCAL_AMP_ASSOC_CP_SIZE 5
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+	uint16_t	length;
+	uint8_t		fragment[HCI_MAX_NAME_LENGTH];
+} __attribute__ ((packed)) read_local_amp_assoc_rp;
+#define READ_LOCAL_AMP_ASSOC_RP_SIZE 252
+
+#define OCF_WRITE_REMOTE_AMP_ASSOC	0x000B
+typedef struct {
+	uint8_t		handle;
+	uint16_t	length_so_far;
+	uint16_t	assoc_length;
+	uint8_t		fragment[HCI_MAX_NAME_LENGTH];
+} __attribute__ ((packed)) write_remote_amp_assoc_cp;
+#define WRITE_REMOTE_AMP_ASSOC_CP_SIZE 253
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+} __attribute__ ((packed)) write_remote_amp_assoc_rp;
+#define WRITE_REMOTE_AMP_ASSOC_RP_SIZE 2
+
+/* Testing commands */
+#define OGF_TESTING_CMD		0x3e
+
+#define OCF_READ_LOOPBACK_MODE			0x0001
+
+#define OCF_WRITE_LOOPBACK_MODE			0x0002
+
+#define OCF_ENABLE_DEVICE_UNDER_TEST_MODE	0x0003
+
+#define OCF_WRITE_SIMPLE_PAIRING_DEBUG_MODE	0x0004
+typedef struct {
+	uint8_t		mode;
+} __attribute__ ((packed)) write_simple_pairing_debug_mode_cp;
+#define WRITE_SIMPLE_PAIRING_DEBUG_MODE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_simple_pairing_debug_mode_rp;
+#define WRITE_SIMPLE_PAIRING_DEBUG_MODE_RP_SIZE 1
+
+/* LE commands */
+#define OGF_LE_CTL		0x08
+
+#define OCF_LE_SET_EVENT_MASK			0x0001
+typedef struct {
+	uint8_t		mask[8];
+} __attribute__ ((packed)) le_set_event_mask_cp;
+#define LE_SET_EVENT_MASK_CP_SIZE 8
+
+#define OCF_LE_READ_BUFFER_SIZE			0x0002
+typedef struct {
+	uint8_t		status;
+	uint16_t	pkt_len;
+	uint8_t		max_pkt;
+} __attribute__ ((packed)) le_read_buffer_size_rp;
+#define LE_READ_BUFFER_SIZE_RP_SIZE 4
+
+#define OCF_LE_READ_LOCAL_SUPPORTED_FEATURES	0x0003
+typedef struct {
+	uint8_t		status;
+	uint8_t		features[8];
+} __attribute__ ((packed)) le_read_local_supported_features_rp;
+#define LE_READ_LOCAL_SUPPORTED_FEATURES_RP_SIZE 9
+
+#define OCF_LE_SET_RANDOM_ADDRESS		0x0005
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) le_set_random_address_cp;
+#define LE_SET_RANDOM_ADDRESS_CP_SIZE 6
+
+#define OCF_LE_SET_ADVERTISING_PARAMETERS	0x0006
+typedef struct {
+	uint16_t	min_interval;
+	uint16_t	max_interval;
+	uint8_t		advtype;
+	uint8_t		own_bdaddr_type;
+	uint8_t		direct_bdaddr_type;
+	bdaddr_t	direct_bdaddr;
+	uint8_t		chan_map;
+	uint8_t		filter;
+} __attribute__ ((packed)) le_set_advertising_parameters_cp;
+#define LE_SET_ADVERTISING_PARAMETERS_CP_SIZE 15
+
+#define OCF_LE_READ_ADVERTISING_CHANNEL_TX_POWER	0x0007
+typedef struct {
+	uint8_t		status;
+	uint8_t		level;
+} __attribute__ ((packed)) le_read_advertising_channel_tx_power_rp;
+#define LE_READ_ADVERTISING_CHANNEL_TX_POWER_RP_SIZE 2
+
+#define OCF_LE_SET_ADVERTISING_DATA		0x0008
+typedef struct {
+	uint8_t		length;
+	uint8_t		data[31];
+} __attribute__ ((packed)) le_set_advertising_data_cp;
+#define LE_SET_ADVERTISING_DATA_CP_SIZE 32
+
+#define OCF_LE_SET_SCAN_RESPONSE_DATA		0x0009
+typedef struct {
+	uint8_t		length;
+	uint8_t		data[31];
+} __attribute__ ((packed)) le_set_scan_response_data_cp;
+#define LE_SET_SCAN_RESPONSE_DATA_CP_SIZE 32
+
+#define OCF_LE_SET_ADVERTISE_ENABLE		0x000A
+typedef struct {
+	uint8_t		enable;
+} __attribute__ ((packed)) le_set_advertise_enable_cp;
+#define LE_SET_ADVERTISE_ENABLE_CP_SIZE 1
+
+#define OCF_LE_SET_SCAN_PARAMETERS		0x000B
+typedef struct {
+	uint8_t		type;
+	uint16_t	interval;
+	uint16_t	window;
+	uint8_t		own_bdaddr_type;
+	uint8_t		filter;
+} __attribute__ ((packed)) le_set_scan_parameters_cp;
+#define LE_SET_SCAN_PARAMETERS_CP_SIZE 7
+
+#define OCF_LE_SET_SCAN_ENABLE			0x000C
+typedef struct {
+	uint8_t		enable;
+	uint8_t		filter_dup;
+} __attribute__ ((packed)) le_set_scan_enable_cp;
+#define LE_SET_SCAN_ENABLE_CP_SIZE 2
+
+#define OCF_LE_CREATE_CONN			0x000D
+typedef struct {
+	uint16_t	interval;
+	uint16_t	window;
+	uint8_t		initiator_filter;
+	uint8_t		peer_bdaddr_type;
+	bdaddr_t	peer_bdaddr;
+	uint8_t		own_bdaddr_type;
+	uint16_t	min_interval;
+	uint16_t	max_interval;
+	uint16_t	latency;
+	uint16_t	supervision_timeout;
+	uint16_t	min_ce_length;
+	uint16_t	max_ce_length;
+} __attribute__ ((packed)) le_create_connection_cp;
+#define LE_CREATE_CONN_CP_SIZE 25
+
+#define OCF_LE_CREATE_CONN_CANCEL		0x000E
+
+#define OCF_LE_READ_WHITE_LIST_SIZE		0x000F
+typedef struct {
+	uint8_t		status;
+	uint8_t		size;
+} __attribute__ ((packed)) le_read_white_list_size_rp;
+#define LE_READ_WHITE_LIST_SIZE_RP_SIZE 2
+
+#define OCF_LE_CLEAR_WHITE_LIST			0x0010
+
+#define OCF_LE_ADD_DEVICE_TO_WHITE_LIST		0x0011
+typedef struct {
+	uint8_t		bdaddr_type;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) le_add_device_to_white_list_cp;
+#define LE_ADD_DEVICE_TO_WHITE_LIST_CP_SIZE 7
+
+#define OCF_LE_REMOVE_DEVICE_FROM_WHITE_LIST	0x0012
+typedef struct {
+	uint8_t		bdaddr_type;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) le_remove_device_from_white_list_cp;
+#define LE_REMOVE_DEVICE_FROM_WHITE_LIST_CP_SIZE 7
+
+#define OCF_LE_CONN_UPDATE			0x0013
+typedef struct {
+	uint16_t	handle;
+	uint16_t	min_interval;
+	uint16_t	max_interval;
+	uint16_t	latency;
+	uint16_t	supervision_timeout;
+	uint16_t	min_ce_length;
+	uint16_t	max_ce_length;
+} __attribute__ ((packed)) le_connection_update_cp;
+#define LE_CONN_UPDATE_CP_SIZE 14
+
+#define OCF_LE_SET_HOST_CHANNEL_CLASSIFICATION	0x0014
+typedef struct {
+	uint8_t		map[5];
+} __attribute__ ((packed)) le_set_host_channel_classification_cp;
+#define LE_SET_HOST_CHANNEL_CLASSIFICATION_CP_SIZE 5
+
+#define OCF_LE_READ_CHANNEL_MAP			0x0015
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) le_read_channel_map_cp;
+#define LE_READ_CHANNEL_MAP_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		map[5];
+} __attribute__ ((packed)) le_read_channel_map_rp;
+#define LE_READ_CHANNEL_MAP_RP_SIZE 8
+
+#define OCF_LE_READ_REMOTE_USED_FEATURES	0x0016
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) le_read_remote_used_features_cp;
+#define LE_READ_REMOTE_USED_FEATURES_CP_SIZE 2
+
+#define OCF_LE_ENCRYPT				0x0017
+typedef struct {
+	uint8_t		key[16];
+	uint8_t		plaintext[16];
+} __attribute__ ((packed)) le_encrypt_cp;
+#define LE_ENCRYPT_CP_SIZE 32
+typedef struct {
+	uint8_t		status;
+	uint8_t		data[16];
+} __attribute__ ((packed)) le_encrypt_rp;
+#define LE_ENCRYPT_RP_SIZE 17
+
+#define OCF_LE_RAND				0x0018
+typedef struct {
+	uint8_t		status;
+	uint64_t	random;
+} __attribute__ ((packed)) le_rand_rp;
+#define LE_RAND_RP_SIZE 9
+
+#define OCF_LE_START_ENCRYPTION			0x0019
+typedef struct {
+	uint16_t	handle;
+	uint64_t	random;
+	uint16_t	diversifier;
+	uint8_t		key[16];
+} __attribute__ ((packed)) le_start_encryption_cp;
+#define LE_START_ENCRYPTION_CP_SIZE 28
+
+#define OCF_LE_LTK_REPLY			0x001A
+typedef struct {
+	uint16_t	handle;
+	uint8_t		key[16];
+} __attribute__ ((packed)) le_ltk_reply_cp;
+#define LE_LTK_REPLY_CP_SIZE 18
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) le_ltk_reply_rp;
+#define LE_LTK_REPLY_RP_SIZE 3
+
+#define OCF_LE_LTK_NEG_REPLY			0x001B
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) le_ltk_neg_reply_cp;
+#define LE_LTK_NEG_REPLY_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) le_ltk_neg_reply_rp;
+#define LE_LTK_NEG_REPLY_RP_SIZE 3
+
+#define OCF_LE_READ_SUPPORTED_STATES		0x001C
+typedef struct {
+	uint8_t		status;
+	uint64_t	states;
+} __attribute__ ((packed)) le_read_supported_states_rp;
+#define LE_READ_SUPPORTED_STATES_RP_SIZE 9
+
+#define OCF_LE_RECEIVER_TEST			0x001D
+typedef struct {
+	uint8_t		frequency;
+} __attribute__ ((packed)) le_receiver_test_cp;
+#define LE_RECEIVER_TEST_CP_SIZE 1
+
+#define OCF_LE_TRANSMITTER_TEST			0x001E
+typedef struct {
+	uint8_t		frequency;
+	uint8_t		length;
+	uint8_t		payload;
+} __attribute__ ((packed)) le_transmitter_test_cp;
+#define LE_TRANSMITTER_TEST_CP_SIZE 3
+
+#define OCF_LE_TEST_END				0x001F
+typedef struct {
+	uint8_t		status;
+	uint16_t	num_pkts;
+} __attribute__ ((packed)) le_test_end_rp;
+#define LE_TEST_END_RP_SIZE 3
+
+/* Vendor specific commands */
+#define OGF_VENDOR_CMD		0x3f
+
+/* ---- HCI Events ---- */
+
+#define EVT_INQUIRY_COMPLETE		0x01
+
+#define EVT_INQUIRY_RESULT		0x02
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_period_mode;
+	uint8_t		pscan_mode;
+	uint8_t		dev_class[3];
+	uint16_t	clock_offset;
+} __attribute__ ((packed)) inquiry_info;
+#define INQUIRY_INFO_SIZE 14
+
+#define EVT_CONN_COMPLETE		0x03
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	bdaddr_t	bdaddr;
+	uint8_t		link_type;
+	uint8_t		encr_mode;
+} __attribute__ ((packed)) evt_conn_complete;
+#define EVT_CONN_COMPLETE_SIZE 13
+
+#define EVT_CONN_REQUEST		0x04
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		dev_class[3];
+	uint8_t		link_type;
+} __attribute__ ((packed)) evt_conn_request;
+#define EVT_CONN_REQUEST_SIZE 10
+
+#define EVT_DISCONN_COMPLETE		0x05
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) evt_disconn_complete;
+#define EVT_DISCONN_COMPLETE_SIZE 4
+
+#define EVT_AUTH_COMPLETE		0x06
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_auth_complete;
+#define EVT_AUTH_COMPLETE_SIZE 3
+
+#define EVT_REMOTE_NAME_REQ_COMPLETE	0x07
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+	uint8_t		name[HCI_MAX_NAME_LENGTH];
+} __attribute__ ((packed)) evt_remote_name_req_complete;
+#define EVT_REMOTE_NAME_REQ_COMPLETE_SIZE 255
+
+#define EVT_ENCRYPT_CHANGE		0x08
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		encrypt;
+} __attribute__ ((packed)) evt_encrypt_change;
+#define EVT_ENCRYPT_CHANGE_SIZE 5
+
+#define EVT_CHANGE_CONN_LINK_KEY_COMPLETE	0x09
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+}  __attribute__ ((packed)) evt_change_conn_link_key_complete;
+#define EVT_CHANGE_CONN_LINK_KEY_COMPLETE_SIZE 3
+
+#define EVT_MASTER_LINK_KEY_COMPLETE		0x0A
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		key_flag;
+} __attribute__ ((packed)) evt_master_link_key_complete;
+#define EVT_MASTER_LINK_KEY_COMPLETE_SIZE 4
+
+#define EVT_READ_REMOTE_FEATURES_COMPLETE	0x0B
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		features[8];
+} __attribute__ ((packed)) evt_read_remote_features_complete;
+#define EVT_READ_REMOTE_FEATURES_COMPLETE_SIZE 11
+
+#define EVT_READ_REMOTE_VERSION_COMPLETE	0x0C
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		lmp_ver;
+	uint16_t	manufacturer;
+	uint16_t	lmp_subver;
+} __attribute__ ((packed)) evt_read_remote_version_complete;
+#define EVT_READ_REMOTE_VERSION_COMPLETE_SIZE 8
+
+#define EVT_QOS_SETUP_COMPLETE		0x0D
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		flags;			/* Reserved */
+	hci_qos		qos;
+} __attribute__ ((packed)) evt_qos_setup_complete;
+#define EVT_QOS_SETUP_COMPLETE_SIZE (4 + HCI_QOS_CP_SIZE)
+
+#define EVT_CMD_COMPLETE 		0x0E
+typedef struct {
+	uint8_t		ncmd;
+	uint16_t	opcode;
+} __attribute__ ((packed)) evt_cmd_complete;
+#define EVT_CMD_COMPLETE_SIZE 3
+
+#define EVT_CMD_STATUS 			0x0F
+typedef struct {
+	uint8_t		status;
+	uint8_t		ncmd;
+	uint16_t	opcode;
+} __attribute__ ((packed)) evt_cmd_status;
+#define EVT_CMD_STATUS_SIZE 4
+
+#define EVT_HARDWARE_ERROR		0x10
+typedef struct {
+	uint8_t		code;
+} __attribute__ ((packed)) evt_hardware_error;
+#define EVT_HARDWARE_ERROR_SIZE 1
+
+#define EVT_FLUSH_OCCURRED		0x11
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_flush_occured;
+#define EVT_FLUSH_OCCURRED_SIZE 2
+
+#define EVT_ROLE_CHANGE			0x12
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+	uint8_t		role;
+} __attribute__ ((packed)) evt_role_change;
+#define EVT_ROLE_CHANGE_SIZE 8
+
+#define EVT_NUM_COMP_PKTS		0x13
+typedef struct {
+	uint8_t		num_hndl;
+	/* variable length part */
+} __attribute__ ((packed)) evt_num_comp_pkts;
+#define EVT_NUM_COMP_PKTS_SIZE 1
+
+#define EVT_MODE_CHANGE			0x14
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		mode;
+	uint16_t	interval;
+} __attribute__ ((packed)) evt_mode_change;
+#define EVT_MODE_CHANGE_SIZE 6
+
+#define EVT_RETURN_LINK_KEYS		0x15
+typedef struct {
+	uint8_t		num_keys;
+	/* variable length part */
+} __attribute__ ((packed)) evt_return_link_keys;
+#define EVT_RETURN_LINK_KEYS_SIZE 1
+
+#define EVT_PIN_CODE_REQ		0x16
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_pin_code_req;
+#define EVT_PIN_CODE_REQ_SIZE 6
+
+#define EVT_LINK_KEY_REQ		0x17
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_link_key_req;
+#define EVT_LINK_KEY_REQ_SIZE 6
+
+#define EVT_LINK_KEY_NOTIFY		0x18
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		link_key[16];
+	uint8_t		key_type;
+} __attribute__ ((packed)) evt_link_key_notify;
+#define EVT_LINK_KEY_NOTIFY_SIZE 23
+
+#define EVT_LOOPBACK_COMMAND		0x19
+
+#define EVT_DATA_BUFFER_OVERFLOW	0x1A
+typedef struct {
+	uint8_t		link_type;
+} __attribute__ ((packed)) evt_data_buffer_overflow;
+#define EVT_DATA_BUFFER_OVERFLOW_SIZE 1
+
+#define EVT_MAX_SLOTS_CHANGE		0x1B
+typedef struct {
+	uint16_t	handle;
+	uint8_t		max_slots;
+} __attribute__ ((packed)) evt_max_slots_change;
+#define EVT_MAX_SLOTS_CHANGE_SIZE 3
+
+#define EVT_READ_CLOCK_OFFSET_COMPLETE	0x1C
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	clock_offset;
+} __attribute__ ((packed)) evt_read_clock_offset_complete;
+#define EVT_READ_CLOCK_OFFSET_COMPLETE_SIZE 5
+
+#define EVT_CONN_PTYPE_CHANGED		0x1D
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	ptype;
+} __attribute__ ((packed)) evt_conn_ptype_changed;
+#define EVT_CONN_PTYPE_CHANGED_SIZE 5
+
+#define EVT_QOS_VIOLATION		0x1E
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_qos_violation;
+#define EVT_QOS_VIOLATION_SIZE 2
+
+#define EVT_PSCAN_REP_MODE_CHANGE	0x20
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+} __attribute__ ((packed)) evt_pscan_rep_mode_change;
+#define EVT_PSCAN_REP_MODE_CHANGE_SIZE 7
+
+#define EVT_FLOW_SPEC_COMPLETE		0x21
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		flags;
+	uint8_t		direction;
+	hci_qos		qos;
+} __attribute__ ((packed)) evt_flow_spec_complete;
+#define EVT_FLOW_SPEC_COMPLETE_SIZE (5 + HCI_QOS_CP_SIZE)
+
+#define EVT_INQUIRY_RESULT_WITH_RSSI	0x22
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_period_mode;
+	uint8_t		dev_class[3];
+	uint16_t	clock_offset;
+	int8_t		rssi;
+} __attribute__ ((packed)) inquiry_info_with_rssi;
+#define INQUIRY_INFO_WITH_RSSI_SIZE 14
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_period_mode;
+	uint8_t		pscan_mode;
+	uint8_t		dev_class[3];
+	uint16_t	clock_offset;
+	int8_t		rssi;
+} __attribute__ ((packed)) inquiry_info_with_rssi_and_pscan_mode;
+#define INQUIRY_INFO_WITH_RSSI_AND_PSCAN_MODE_SIZE 15
+
+#define EVT_READ_REMOTE_EXT_FEATURES_COMPLETE	0x23
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		page_num;
+	uint8_t		max_page_num;
+	uint8_t		features[8];
+} __attribute__ ((packed)) evt_read_remote_ext_features_complete;
+#define EVT_READ_REMOTE_EXT_FEATURES_COMPLETE_SIZE 13
+
+#define EVT_SYNC_CONN_COMPLETE		0x2C
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	bdaddr_t	bdaddr;
+	uint8_t		link_type;
+	uint8_t		trans_interval;
+	uint8_t		retrans_window;
+	uint16_t	rx_pkt_len;
+	uint16_t	tx_pkt_len;
+	uint8_t		air_mode;
+} __attribute__ ((packed)) evt_sync_conn_complete;
+#define EVT_SYNC_CONN_COMPLETE_SIZE 17
+
+#define EVT_SYNC_CONN_CHANGED		0x2D
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		trans_interval;
+	uint8_t		retrans_window;
+	uint16_t	rx_pkt_len;
+	uint16_t	tx_pkt_len;
+} __attribute__ ((packed)) evt_sync_conn_changed;
+#define EVT_SYNC_CONN_CHANGED_SIZE 9
+
+#define EVT_SNIFF_SUBRATING		0x2E
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	max_tx_latency;
+	uint16_t	max_rx_latency;
+	uint16_t	min_remote_timeout;
+	uint16_t	min_local_timeout;
+} __attribute__ ((packed)) evt_sniff_subrating;
+#define EVT_SNIFF_SUBRATING_SIZE 11
+
+#define EVT_EXTENDED_INQUIRY_RESULT	0x2F
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_period_mode;
+	uint8_t		dev_class[3];
+	uint16_t	clock_offset;
+	int8_t		rssi;
+	uint8_t		data[HCI_MAX_EIR_LENGTH];
+} __attribute__ ((packed)) extended_inquiry_info;
+#define EXTENDED_INQUIRY_INFO_SIZE 254
+
+#define EVT_ENCRYPTION_KEY_REFRESH_COMPLETE	0x30
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_encryption_key_refresh_complete;
+#define EVT_ENCRYPTION_KEY_REFRESH_COMPLETE_SIZE 3
+
+#define EVT_IO_CAPABILITY_REQUEST	0x31
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_io_capability_request;
+#define EVT_IO_CAPABILITY_REQUEST_SIZE 6
+
+#define EVT_IO_CAPABILITY_RESPONSE	0x32
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		capability;
+	uint8_t		oob_data;
+	uint8_t		authentication;
+} __attribute__ ((packed)) evt_io_capability_response;
+#define EVT_IO_CAPABILITY_RESPONSE_SIZE 9
+
+#define EVT_USER_CONFIRM_REQUEST	0x33
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint32_t	passkey;
+} __attribute__ ((packed)) evt_user_confirm_request;
+#define EVT_USER_CONFIRM_REQUEST_SIZE 10
+
+#define EVT_USER_PASSKEY_REQUEST	0x34
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_user_passkey_request;
+#define EVT_USER_PASSKEY_REQUEST_SIZE 6
+
+#define EVT_REMOTE_OOB_DATA_REQUEST	0x35
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_remote_oob_data_request;
+#define EVT_REMOTE_OOB_DATA_REQUEST_SIZE 6
+
+#define EVT_SIMPLE_PAIRING_COMPLETE	0x36
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_simple_pairing_complete;
+#define EVT_SIMPLE_PAIRING_COMPLETE_SIZE 7
+
+#define EVT_LINK_SUPERVISION_TIMEOUT_CHANGED	0x38
+typedef struct {
+	uint16_t	handle;
+	uint16_t	timeout;
+} __attribute__ ((packed)) evt_link_supervision_timeout_changed;
+#define EVT_LINK_SUPERVISION_TIMEOUT_CHANGED_SIZE 4
+
+#define EVT_ENHANCED_FLUSH_COMPLETE	0x39
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_enhanced_flush_complete;
+#define EVT_ENHANCED_FLUSH_COMPLETE_SIZE 2
+
+#define EVT_USER_PASSKEY_NOTIFY		0x3B
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint32_t	passkey;
+} __attribute__ ((packed)) evt_user_passkey_notify;
+#define EVT_USER_PASSKEY_NOTIFY_SIZE 10
+
+#define EVT_KEYPRESS_NOTIFY		0x3C
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		type;
+} __attribute__ ((packed)) evt_keypress_notify;
+#define EVT_KEYPRESS_NOTIFY_SIZE 7
+
+#define EVT_REMOTE_HOST_FEATURES_NOTIFY	0x3D
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		features[8];
+} __attribute__ ((packed)) evt_remote_host_features_notify;
+#define EVT_REMOTE_HOST_FEATURES_NOTIFY_SIZE 14
+
+#define EVT_LE_META_EVENT	0x3E
+typedef struct {
+	uint8_t		subevent;
+	uint8_t		data[0];
+} __attribute__ ((packed)) evt_le_meta_event;
+#define EVT_LE_META_EVENT_SIZE 1
+
+#define EVT_LE_CONN_COMPLETE	0x01
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		role;
+	uint8_t		peer_bdaddr_type;
+	bdaddr_t	peer_bdaddr;
+	uint16_t	interval;
+	uint16_t	latency;
+	uint16_t	supervision_timeout;
+	uint8_t		master_clock_accuracy;
+} __attribute__ ((packed)) evt_le_connection_complete;
+#define EVT_LE_CONN_COMPLETE_SIZE 18
+
+#define EVT_LE_ADVERTISING_REPORT	0x02
+typedef struct {
+	uint8_t		evt_type;
+	uint8_t		bdaddr_type;
+	bdaddr_t	bdaddr;
+	uint8_t		length;
+	uint8_t		data[0];
+} __attribute__ ((packed)) le_advertising_info;
+#define LE_ADVERTISING_INFO_SIZE 9
+
+#define EVT_LE_CONN_UPDATE_COMPLETE	0x03
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	interval;
+	uint16_t	latency;
+	uint16_t	supervision_timeout;
+} __attribute__ ((packed)) evt_le_connection_update_complete;
+#define EVT_LE_CONN_UPDATE_COMPLETE_SIZE 9
+
+#define EVT_LE_READ_REMOTE_USED_FEATURES_COMPLETE	0x04
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		features[8];
+} __attribute__ ((packed)) evt_le_read_remote_used_features_complete;
+#define EVT_LE_READ_REMOTE_USED_FEATURES_COMPLETE_SIZE 11
+
+#define EVT_LE_LTK_REQUEST	0x05
+typedef struct {
+	uint16_t	handle;
+	uint64_t	random;
+	uint16_t	diversifier;
+} __attribute__ ((packed)) evt_le_long_term_key_request;
+#define EVT_LE_LTK_REQUEST_SIZE 12
+
+#define EVT_PHYSICAL_LINK_COMPLETE		0x40
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+} __attribute__ ((packed)) evt_physical_link_complete;
+#define EVT_PHYSICAL_LINK_COMPLETE_SIZE 2
+
+#define EVT_CHANNEL_SELECTED		0x41
+
+#define EVT_DISCONNECT_PHYSICAL_LINK_COMPLETE	0x42
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) evt_disconn_physical_link_complete;
+#define EVT_DISCONNECT_PHYSICAL_LINK_COMPLETE_SIZE 3
+
+#define EVT_PHYSICAL_LINK_LOSS_EARLY_WARNING	0x43
+typedef struct {
+	uint8_t		handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) evt_physical_link_loss_warning;
+#define EVT_PHYSICAL_LINK_LOSS_WARNING_SIZE 2
+
+#define EVT_PHYSICAL_LINK_RECOVERY		0x44
+typedef struct {
+	uint8_t		handle;
+} __attribute__ ((packed)) evt_physical_link_recovery;
+#define EVT_PHYSICAL_LINK_RECOVERY_SIZE 1
+
+#define EVT_LOGICAL_LINK_COMPLETE		0x45
+typedef struct {
+	uint8_t		status;
+	uint16_t	log_handle;
+	uint8_t		handle;
+	uint8_t		tx_flow_id;
+} __attribute__ ((packed)) evt_logical_link_complete;
+#define EVT_LOGICAL_LINK_COMPLETE_SIZE 5
+
+#define EVT_DISCONNECT_LOGICAL_LINK_COMPLETE	0x46
+
+#define EVT_FLOW_SPEC_MODIFY_COMPLETE		0x47
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_flow_spec_modify_complete;
+#define EVT_FLOW_SPEC_MODIFY_COMPLETE_SIZE 3
+
+#define EVT_NUMBER_COMPLETED_BLOCKS		0x48
+
+#define EVT_AMP_STATUS_CHANGE			0x4D
+typedef struct {
+	uint8_t		status;
+	uint8_t		amp_status;
+} __attribute__ ((packed)) evt_amp_status_change;
+#define EVT_AMP_STATUS_CHANGE_SIZE 2
+
+#define EVT_TESTING			0xFE
+
+#define EVT_VENDOR			0xFF
+
+/* Internal events generated by BlueZ stack */
+#define EVT_STACK_INTERNAL		0xFD
+typedef struct {
+	uint16_t	type;
+	uint8_t		data[0];
+} __attribute__ ((packed)) evt_stack_internal;
+#define EVT_STACK_INTERNAL_SIZE 2
+
+#define EVT_SI_DEVICE	0x01
+typedef struct {
+	uint16_t	event;
+	uint16_t	dev_id;
+} __attribute__ ((packed)) evt_si_device;
+#define EVT_SI_DEVICE_SIZE 4
+
+/* --------  HCI Packet structures  -------- */
+#define HCI_TYPE_LEN	1
+
+typedef struct {
+	uint16_t	opcode;		/* OCF & OGF */
+	uint8_t		plen;
+} __attribute__ ((packed))	hci_command_hdr;
+#define HCI_COMMAND_HDR_SIZE 	3
+
+typedef struct {
+	uint8_t		evt;
+	uint8_t		plen;
+} __attribute__ ((packed))	hci_event_hdr;
+#define HCI_EVENT_HDR_SIZE 	2
+
+typedef struct {
+	uint16_t	handle;		/* Handle & Flags(PB, BC) */
+	uint16_t	dlen;
+} __attribute__ ((packed))	hci_acl_hdr;
+#define HCI_ACL_HDR_SIZE 	4
+
+typedef struct {
+	uint16_t	handle;
+	uint8_t		dlen;
+} __attribute__ ((packed))	hci_sco_hdr;
+#define HCI_SCO_HDR_SIZE 	3
+
+typedef struct {
+	uint16_t	device;
+	uint16_t	type;
+	uint16_t	plen;
+} __attribute__ ((packed))	hci_msg_hdr;
+#define HCI_MSG_HDR_SIZE	6
+
+/* Command opcode pack/unpack */
+#define cmd_opcode_pack(ogf, ocf)	(uint16_t)((ocf & 0x03ff)|(ogf << 10))
+#define cmd_opcode_ogf(op)		(op >> 10)
+#define cmd_opcode_ocf(op)		(op & 0x03ff)
+
+/* ACL handle and flags pack/unpack */
+#define acl_handle_pack(h, f)	(uint16_t)((h & 0x0fff)|(f << 12))
+#define acl_handle(h)		(h & 0x0fff)
+#define acl_flags(h)		(h >> 12)
+
+#endif /* _NO_HCI_DEFS */
+
+/* HCI Socket options */
+#define HCI_DATA_DIR	1
+#define HCI_FILTER	2
+#define HCI_TIME_STAMP	3
+
+/* HCI CMSG flags */
+#define HCI_CMSG_DIR	0x0001
+#define HCI_CMSG_TSTAMP	0x0002
+
+struct sockaddr_hci {
+	sa_family_t	hci_family;
+	unsigned short	hci_dev;
+	unsigned short  hci_channel;
+};
+#define HCI_DEV_NONE	0xffff
+
+#define HCI_CHANNEL_RAW		0
+#define HCI_CHANNEL_CONTROL	1
+
+struct hci_filter {
+	uint32_t type_mask;
+	uint32_t event_mask[2];
+	uint16_t opcode;
+};
+
+#define HCI_FLT_TYPE_BITS	31
+#define HCI_FLT_EVENT_BITS	63
+#define HCI_FLT_OGF_BITS	63
+#define HCI_FLT_OCF_BITS	127
+
+/* Ioctl requests structures */
+struct hci_dev_stats {
+	uint32_t err_rx;
+	uint32_t err_tx;
+	uint32_t cmd_tx;
+	uint32_t evt_rx;
+	uint32_t acl_tx;
+	uint32_t acl_rx;
+	uint32_t sco_tx;
+	uint32_t sco_rx;
+	uint32_t byte_rx;
+	uint32_t byte_tx;
+};
+
+struct hci_dev_info {
+	uint16_t dev_id;
+	char     name[8];
+
+	bdaddr_t bdaddr;
+
+	uint32_t flags;
+	uint8_t  type;
+
+	uint8_t  features[8];
+
+	uint32_t pkt_type;
+	uint32_t link_policy;
+	uint32_t link_mode;
+
+	uint16_t acl_mtu;
+	uint16_t acl_pkts;
+	uint16_t sco_mtu;
+	uint16_t sco_pkts;
+
+	struct   hci_dev_stats stat;
+};
+
+struct hci_conn_info {
+	uint16_t handle;
+	bdaddr_t bdaddr;
+	uint8_t  type;
+	uint8_t	 out;
+	uint16_t state;
+	uint32_t link_mode;
+	uint32_t mtu;
+	uint32_t cnt;
+	uint32_t pkts;
+};
+
+struct hci_dev_req {
+	uint16_t dev_id;
+	uint32_t dev_opt;
+};
+
+struct hci_dev_list_req {
+	uint16_t dev_num;
+	struct hci_dev_req dev_req[0];	/* hci_dev_req structures */
+};
+
+struct hci_conn_list_req {
+	uint16_t dev_id;
+	uint16_t conn_num;
+	struct hci_conn_info conn_info[0];
+};
+
+struct hci_conn_info_req {
+	bdaddr_t bdaddr;
+	uint8_t  type;
+	struct hci_conn_info conn_info[0];
+};
+
+struct hci_auth_info_req {
+	bdaddr_t bdaddr;
+	uint8_t  type;
+};
+
+struct hci_inquiry_req {
+	uint16_t dev_id;
+	uint16_t flags;
+	uint8_t  lap[3];
+	uint8_t  length;
+	uint8_t  num_rsp;
+};
+#define IREQ_CACHE_FLUSH 0x0001
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HCI_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/hci_lib.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/hci_lib.h
new file mode 100644
index 0000000000..725eb05908
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/hci_lib.h
@@ -0,0 +1,233 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __HCI_LIB_H
+#define __HCI_LIB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct hci_request {
+	uint16_t ogf;
+	uint16_t ocf;
+	int      event;
+	void     *cparam;
+	int      clen;
+	void     *rparam;
+	int      rlen;
+};
+
+struct hci_version {
+	uint16_t manufacturer;
+	uint8_t  hci_ver;
+	uint16_t hci_rev;
+	uint8_t  lmp_ver;
+	uint16_t lmp_subver;
+};
+
+int hci_open_dev(int dev_id);
+int hci_close_dev(int dd);
+int hci_send_cmd(int dd, uint16_t ogf, uint16_t ocf, uint8_t plen, void *param);
+int hci_send_req(int dd, struct hci_request *req, int timeout);
+
+int hci_create_connection(int dd, const bdaddr_t *bdaddr, uint16_t ptype, uint16_t clkoffset, uint8_t rswitch, uint16_t *handle, int to);
+int hci_disconnect(int dd, uint16_t handle, uint8_t reason, int to);
+
+int hci_inquiry(int dev_id, int len, int num_rsp, const uint8_t *lap, inquiry_info **ii, long flags);
+int hci_devinfo(int dev_id, struct hci_dev_info *di);
+int hci_devba(int dev_id, bdaddr_t *bdaddr);
+int hci_devid(const char *str);
+
+int hci_read_local_name(int dd, int len, char *name, int to);
+int hci_write_local_name(int dd, const char *name, int to);
+int hci_read_remote_name(int dd, const bdaddr_t *bdaddr, int len, char *name, int to);
+int hci_read_remote_name_with_clock_offset(int dd, const bdaddr_t *bdaddr, uint8_t pscan_rep_mode, uint16_t clkoffset, int len, char *name, int to);
+int hci_read_remote_name_cancel(int dd, const bdaddr_t *bdaddr, int to);
+int hci_read_remote_version(int dd, uint16_t handle, struct hci_version *ver, int to);
+int hci_read_remote_features(int dd, uint16_t handle, uint8_t *features, int to);
+int hci_read_remote_ext_features(int dd, uint16_t handle, uint8_t page, uint8_t *max_page, uint8_t *features, int to);
+int hci_read_clock_offset(int dd, uint16_t handle, uint16_t *clkoffset, int to);
+int hci_read_local_version(int dd, struct hci_version *ver, int to);
+int hci_read_local_commands(int dd, uint8_t *commands, int to);
+int hci_read_local_features(int dd, uint8_t *features, int to);
+int hci_read_local_ext_features(int dd, uint8_t page, uint8_t *max_page, uint8_t *features, int to);
+int hci_read_bd_addr(int dd, bdaddr_t *bdaddr, int to);
+int hci_read_class_of_dev(int dd, uint8_t *cls, int to);
+int hci_write_class_of_dev(int dd, uint32_t cls, int to);
+int hci_read_voice_setting(int dd, uint16_t *vs, int to);
+int hci_write_voice_setting(int dd, uint16_t vs, int to);
+int hci_read_current_iac_lap(int dd, uint8_t *num_iac, uint8_t *lap, int to);
+int hci_write_current_iac_lap(int dd, uint8_t num_iac, uint8_t *lap, int to);
+int hci_read_stored_link_key(int dd, bdaddr_t *bdaddr, uint8_t all, int to);
+int hci_write_stored_link_key(int dd, bdaddr_t *bdaddr, uint8_t *key, int to);
+int hci_delete_stored_link_key(int dd, bdaddr_t *bdaddr, uint8_t all, int to);
+int hci_authenticate_link(int dd, uint16_t handle, int to);
+int hci_encrypt_link(int dd, uint16_t handle, uint8_t encrypt, int to);
+int hci_change_link_key(int dd, uint16_t handle, int to);
+int hci_switch_role(int dd, bdaddr_t *bdaddr, uint8_t role, int to);
+int hci_park_mode(int dd, uint16_t handle, uint16_t max_interval, uint16_t min_interval, int to);
+int hci_exit_park_mode(int dd, uint16_t handle, int to);
+int hci_read_inquiry_scan_type(int dd, uint8_t *type, int to);
+int hci_write_inquiry_scan_type(int dd, uint8_t type, int to);
+int hci_read_inquiry_mode(int dd, uint8_t *mode, int to);
+int hci_write_inquiry_mode(int dd, uint8_t mode, int to);
+int hci_read_afh_mode(int dd, uint8_t *mode, int to);
+int hci_write_afh_mode(int dd, uint8_t mode, int to);
+int hci_read_ext_inquiry_response(int dd, uint8_t *fec, uint8_t *data, int to);
+int hci_write_ext_inquiry_response(int dd, uint8_t fec, uint8_t *data, int to);
+int hci_read_simple_pairing_mode(int dd, uint8_t *mode, int to);
+int hci_write_simple_pairing_mode(int dd, uint8_t mode, int to);
+int hci_read_local_oob_data(int dd, uint8_t *hash, uint8_t *randomizer, int to);
+int hci_read_inq_response_tx_power_level(int dd, int8_t *level, int to);
+int hci_read_inquiry_transmit_power_level(int dd, int8_t *level, int to);
+int hci_write_inquiry_transmit_power_level(int dd, int8_t level, int to);
+int hci_read_transmit_power_level(int dd, uint16_t handle, uint8_t type, int8_t *level, int to);
+int hci_read_link_policy(int dd, uint16_t handle, uint16_t *policy, int to);
+int hci_write_link_policy(int dd, uint16_t handle, uint16_t policy, int to);
+int hci_read_link_supervision_timeout(int dd, uint16_t handle, uint16_t *timeout, int to);
+int hci_write_link_supervision_timeout(int dd, uint16_t handle, uint16_t timeout, int to);
+int hci_set_afh_classification(int dd, uint8_t *map, int to);
+int hci_read_link_quality(int dd, uint16_t handle, uint8_t *link_quality, int to);
+int hci_read_rssi(int dd, uint16_t handle, int8_t *rssi, int to);
+int hci_read_afh_map(int dd, uint16_t handle, uint8_t *mode, uint8_t *map, int to);
+int hci_read_clock(int dd, uint16_t handle, uint8_t which, uint32_t *clock, uint16_t *accuracy, int to);
+
+int hci_le_set_scan_enable(int dev_id, uint8_t enable, uint8_t filter_dup, int to);
+int hci_le_set_scan_parameters(int dev_id, uint8_t type, uint16_t interval,
+					uint16_t window, uint8_t own_type,
+					uint8_t filter, int to);
+int hci_le_set_advertise_enable(int dev_id, uint8_t enable, int to);
+int hci_le_create_conn(int dd, uint16_t interval, uint16_t window,
+		uint8_t initiator_filter, uint8_t peer_bdaddr_type,
+		bdaddr_t peer_bdaddr, uint8_t own_bdaddr_type,
+		uint16_t min_interval, 	uint16_t max_interval,
+		uint16_t latency, uint16_t supervision_timeout,
+		uint16_t min_ce_length, uint16_t max_ce_length,
+		uint16_t *handle, int to);
+
+int hci_le_conn_update(int dd, uint16_t handle, uint16_t min_interval,
+			uint16_t max_interval, uint16_t latency,
+			uint16_t supervision_timeout, int to);
+int hci_le_add_white_list(int dd, const bdaddr_t *bdaddr, uint8_t type, int to);
+int hci_le_rm_white_list(int dd, const bdaddr_t *bdaddr, uint8_t type, int to);
+int hci_le_read_white_list_size(int dd, uint8_t *size, int to);
+int hci_le_clear_white_list(int dd, int to);
+int hci_for_each_dev(int flag, int(*func)(int dd, int dev_id, long arg), long arg);
+int hci_get_route(bdaddr_t *bdaddr);
+
+char *hci_bustostr(int bus);
+char *hci_typetostr(int type);
+char *hci_dtypetostr(int type);
+char *hci_dflagstostr(uint32_t flags);
+char *hci_ptypetostr(unsigned int ptype);
+int hci_strtoptype(char *str, unsigned int *val);
+char *hci_scoptypetostr(unsigned int ptype);
+int hci_strtoscoptype(char *str, unsigned int *val);
+char *hci_lptostr(unsigned int ptype);
+int hci_strtolp(char *str, unsigned int *val);
+char *hci_lmtostr(unsigned int ptype);
+int hci_strtolm(char *str, unsigned int *val);
+
+char *hci_cmdtostr(unsigned int cmd);
+char *hci_commandstostr(uint8_t *commands, char *pref, int width);
+
+char *hci_vertostr(unsigned int ver);
+int hci_strtover(char *str, unsigned int *ver);
+char *lmp_vertostr(unsigned int ver);
+int lmp_strtover(char *str, unsigned int *ver);
+
+char *lmp_featurestostr(uint8_t *features, char *pref, int width);
+
+static inline void hci_set_bit(int nr, void *addr)
+{
+	*((uint32_t *) addr + (nr >> 5)) |= (1 << (nr & 31));
+}
+
+static inline void hci_clear_bit(int nr, void *addr)
+{
+	*((uint32_t *) addr + (nr >> 5)) &= ~(1 << (nr & 31));
+}
+
+static inline int hci_test_bit(int nr, void *addr)
+{
+	return *((uint32_t *) addr + (nr >> 5)) & (1 << (nr & 31));
+}
+
+/* HCI filter tools */
+static inline void hci_filter_clear(struct hci_filter *f)
+{
+	memset(f, 0, sizeof(*f));
+}
+static inline void hci_filter_set_ptype(int t, struct hci_filter *f)
+{
+	hci_set_bit((t == HCI_VENDOR_PKT) ? 0 : (t & HCI_FLT_TYPE_BITS), &f->type_mask);
+}
+static inline void hci_filter_clear_ptype(int t, struct hci_filter *f)
+{
+	hci_clear_bit((t == HCI_VENDOR_PKT) ? 0 : (t & HCI_FLT_TYPE_BITS), &f->type_mask);
+}
+static inline int hci_filter_test_ptype(int t, struct hci_filter *f)
+{
+	return hci_test_bit((t == HCI_VENDOR_PKT) ? 0 : (t & HCI_FLT_TYPE_BITS), &f->type_mask);
+}
+static inline void hci_filter_all_ptypes(struct hci_filter *f)
+{
+	memset((void *) &f->type_mask, 0xff, sizeof(f->type_mask));
+}
+static inline void hci_filter_set_event(int e, struct hci_filter *f)
+{
+	hci_set_bit((e & HCI_FLT_EVENT_BITS), &f->event_mask);
+}
+static inline void hci_filter_clear_event(int e, struct hci_filter *f)
+{
+	hci_clear_bit((e & HCI_FLT_EVENT_BITS), &f->event_mask);
+}
+static inline int hci_filter_test_event(int e, struct hci_filter *f)
+{
+	return hci_test_bit((e & HCI_FLT_EVENT_BITS), &f->event_mask);
+}
+static inline void hci_filter_all_events(struct hci_filter *f)
+{
+	memset((void *) f->event_mask, 0xff, sizeof(f->event_mask));
+}
+static inline void hci_filter_set_opcode(int opcode, struct hci_filter *f)
+{
+	f->opcode = opcode;
+}
+static inline void hci_filter_clear_opcode(struct hci_filter *f)
+{
+	f->opcode = 0;
+}
+static inline int hci_filter_test_opcode(int opcode, struct hci_filter *f)
+{
+	return (f->opcode == opcode);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HCI_LIB_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/hidp.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/hidp.h
new file mode 100644
index 0000000000..c5e6a78086
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/hidp.h
@@ -0,0 +1,85 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2003-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __HIDP_H
+#define __HIDP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* HIDP defaults */
+#define HIDP_MINIMUM_MTU 48
+#define HIDP_DEFAULT_MTU 48
+
+/* HIDP ioctl defines */
+#define HIDPCONNADD	_IOW('H', 200, int)
+#define HIDPCONNDEL	_IOW('H', 201, int)
+#define HIDPGETCONNLIST	_IOR('H', 210, int)
+#define HIDPGETCONNINFO	_IOR('H', 211, int)
+
+#define HIDP_VIRTUAL_CABLE_UNPLUG	0
+#define HIDP_BOOT_PROTOCOL_MODE		1
+#define HIDP_BLUETOOTH_VENDOR_ID	9
+
+struct hidp_connadd_req {
+	int ctrl_sock;		/* Connected control socket */
+	int intr_sock;		/* Connected interrupt socket */
+	uint16_t parser;	/* Parser version */
+	uint16_t rd_size;	/* Report descriptor size */
+	uint8_t *rd_data;	/* Report descriptor data */
+	uint8_t  country;
+	uint8_t  subclass;
+	uint16_t vendor;
+	uint16_t product;
+	uint16_t version;
+	uint32_t flags;
+	uint32_t idle_to;
+	char name[128];		/* Device name */
+};
+
+struct hidp_conndel_req {
+	bdaddr_t bdaddr;
+	uint32_t flags;
+};
+
+struct hidp_conninfo {
+	bdaddr_t bdaddr;
+	uint32_t flags;
+	uint16_t state;
+	uint16_t vendor;
+	uint16_t product;
+	uint16_t version;
+	char name[128];
+};
+
+struct hidp_connlist_req {
+	uint32_t cnum;
+	struct hidp_conninfo *ci;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HIDP_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/l2cap.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/l2cap.h
new file mode 100644
index 0000000000..e59cfdd7b2
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/l2cap.h
@@ -0,0 +1,208 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __L2CAP_H
+#define __L2CAP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/socket.h>
+
+/* L2CAP defaults */
+#define L2CAP_DEFAULT_MTU	672
+#define L2CAP_DEFAULT_FLUSH_TO	0xFFFF
+
+/* L2CAP socket address */
+struct sockaddr_l2 {
+	sa_family_t	l2_family;
+	unsigned short	l2_psm;
+	bdaddr_t	l2_bdaddr;
+	unsigned short	l2_cid;
+};
+
+/* L2CAP socket options */
+#define L2CAP_OPTIONS	0x01
+struct l2cap_options {
+	uint16_t	omtu;
+	uint16_t	imtu;
+	uint16_t	flush_to;
+	uint8_t		mode;
+	uint8_t		fcs;
+	uint8_t		max_tx;
+	uint16_t	txwin_size;
+};
+
+#define L2CAP_CONNINFO	0x02
+struct l2cap_conninfo {
+	uint16_t	hci_handle;
+	uint8_t		dev_class[3];
+};
+
+#define L2CAP_LM	0x03
+#define L2CAP_LM_MASTER		0x0001
+#define L2CAP_LM_AUTH		0x0002
+#define L2CAP_LM_ENCRYPT	0x0004
+#define L2CAP_LM_TRUSTED	0x0008
+#define L2CAP_LM_RELIABLE	0x0010
+#define L2CAP_LM_SECURE		0x0020
+
+/* L2CAP command codes */
+#define L2CAP_COMMAND_REJ	0x01
+#define L2CAP_CONN_REQ		0x02
+#define L2CAP_CONN_RSP		0x03
+#define L2CAP_CONF_REQ		0x04
+#define L2CAP_CONF_RSP		0x05
+#define L2CAP_DISCONN_REQ	0x06
+#define L2CAP_DISCONN_RSP	0x07
+#define L2CAP_ECHO_REQ		0x08
+#define L2CAP_ECHO_RSP		0x09
+#define L2CAP_INFO_REQ		0x0a
+#define L2CAP_INFO_RSP		0x0b
+
+/* L2CAP structures */
+typedef struct {
+	uint16_t	len;
+	uint16_t	cid;
+} __attribute__ ((packed)) l2cap_hdr;
+#define L2CAP_HDR_SIZE 4
+
+typedef struct {
+	uint8_t		code;
+	uint8_t		ident;
+	uint16_t	len;
+} __attribute__ ((packed)) l2cap_cmd_hdr;
+#define L2CAP_CMD_HDR_SIZE 4
+
+typedef struct {
+	uint16_t	reason;
+} __attribute__ ((packed)) l2cap_cmd_rej;
+#define L2CAP_CMD_REJ_SIZE 2
+
+typedef struct {
+	uint16_t	psm;
+	uint16_t	scid;
+} __attribute__ ((packed)) l2cap_conn_req;
+#define L2CAP_CONN_REQ_SIZE 4
+
+typedef struct {
+	uint16_t	dcid;
+	uint16_t	scid;
+	uint16_t	result;
+	uint16_t	status;
+} __attribute__ ((packed)) l2cap_conn_rsp;
+#define L2CAP_CONN_RSP_SIZE 8
+
+/* connect result */
+#define L2CAP_CR_SUCCESS	0x0000
+#define L2CAP_CR_PEND		0x0001
+#define L2CAP_CR_BAD_PSM	0x0002
+#define L2CAP_CR_SEC_BLOCK	0x0003
+#define L2CAP_CR_NO_MEM		0x0004
+
+/* connect status */
+#define L2CAP_CS_NO_INFO	0x0000
+#define L2CAP_CS_AUTHEN_PEND	0x0001
+#define L2CAP_CS_AUTHOR_PEND	0x0002
+
+typedef struct {
+	uint16_t	dcid;
+	uint16_t	flags;
+	uint8_t		data[0];
+} __attribute__ ((packed)) l2cap_conf_req;
+#define L2CAP_CONF_REQ_SIZE 4
+
+typedef struct {
+	uint16_t	scid;
+	uint16_t	flags;
+	uint16_t	result;
+	uint8_t		data[0];
+} __attribute__ ((packed)) l2cap_conf_rsp;
+#define L2CAP_CONF_RSP_SIZE 6
+
+#define L2CAP_CONF_SUCCESS	0x0000
+#define L2CAP_CONF_UNACCEPT	0x0001
+#define L2CAP_CONF_REJECT	0x0002
+#define L2CAP_CONF_UNKNOWN	0x0003
+
+typedef struct {
+	uint8_t		type;
+	uint8_t		len;
+	uint8_t		val[0];
+} __attribute__ ((packed)) l2cap_conf_opt;
+#define L2CAP_CONF_OPT_SIZE 2
+
+#define L2CAP_CONF_MTU		0x01
+#define L2CAP_CONF_FLUSH_TO	0x02
+#define L2CAP_CONF_QOS		0x03
+#define L2CAP_CONF_RFC		0x04
+#define L2CAP_CONF_FCS		0x05
+
+#define L2CAP_CONF_MAX_SIZE	22
+
+#define L2CAP_MODE_BASIC	0x00
+#define L2CAP_MODE_RETRANS	0x01
+#define L2CAP_MODE_FLOWCTL	0x02
+#define L2CAP_MODE_ERTM		0x03
+#define L2CAP_MODE_STREAMING	0x04
+
+typedef struct {
+	uint16_t	dcid;
+	uint16_t	scid;
+} __attribute__ ((packed)) l2cap_disconn_req;
+#define L2CAP_DISCONN_REQ_SIZE 4
+
+typedef struct {
+	uint16_t	dcid;
+	uint16_t	scid;
+} __attribute__ ((packed)) l2cap_disconn_rsp;
+#define L2CAP_DISCONN_RSP_SIZE 4
+
+typedef struct {
+	uint16_t	type;
+} __attribute__ ((packed)) l2cap_info_req;
+#define L2CAP_INFO_REQ_SIZE 2
+
+typedef struct {
+	uint16_t	type;
+	uint16_t	result;
+	uint8_t		data[0];
+} __attribute__ ((packed)) l2cap_info_rsp;
+#define L2CAP_INFO_RSP_SIZE 4
+
+/* info type */
+#define L2CAP_IT_CL_MTU		0x0001
+#define L2CAP_IT_FEAT_MASK	0x0002
+
+/* info result */
+#define L2CAP_IR_SUCCESS	0x0000
+#define L2CAP_IR_NOTSUPP	0x0001
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __L2CAP_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/mgmt.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/mgmt.h
new file mode 100644
index 0000000000..57e7603880
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/mgmt.h
@@ -0,0 +1,297 @@
+/*
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2010  Nokia Corporation
+ *  Copyright (C) 2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __packed
+#define __packed __attribute__((packed))
+#endif
+
+#define MGMT_INDEX_NONE			0xFFFF
+
+struct mgmt_hdr {
+	uint16_t opcode;
+	uint16_t index;
+	uint16_t len;
+} __packed;
+#define MGMT_HDR_SIZE	6
+
+#define MGMT_OP_READ_VERSION		0x0001
+struct mgmt_rp_read_version {
+	uint8_t version;
+	uint16_t revision;
+} __packed;
+
+#define MGMT_OP_READ_FEATURES		0x0002
+struct mgmt_rp_read_features {
+	uint8_t features[8];
+} __packed;
+
+#define MGMT_OP_READ_INDEX_LIST		0x0003
+struct mgmt_rp_read_index_list {
+	uint16_t num_controllers;
+	uint16_t index[0];
+} __packed;
+
+/* Reserve one extra byte for names in management messages so that they
+ * are always guaranteed to be nul-terminated */
+#define MGMT_MAX_NAME_LENGTH		(HCI_MAX_NAME_LENGTH + 1)
+
+#define MGMT_OP_READ_INFO		0x0004
+struct mgmt_rp_read_info {
+	uint8_t type;
+	uint8_t powered;
+	uint8_t connectable;
+	uint8_t discoverable;
+	uint8_t pairable;
+	uint8_t sec_mode;
+	bdaddr_t bdaddr;
+	uint8_t dev_class[3];
+	uint8_t features[8];
+	uint16_t manufacturer;
+	uint8_t hci_ver;
+	uint16_t hci_rev;
+	uint8_t name[MGMT_MAX_NAME_LENGTH];
+} __packed;
+
+struct mgmt_mode {
+	uint8_t val;
+} __packed;
+
+#define MGMT_OP_SET_POWERED		0x0005
+
+#define MGMT_OP_SET_DISCOVERABLE	0x0006
+
+#define MGMT_OP_SET_CONNECTABLE		0x0007
+
+#define MGMT_OP_SET_PAIRABLE		0x0008
+
+#define MGMT_OP_ADD_UUID		0x0009
+struct mgmt_cp_add_uuid {
+	uint8_t uuid[16];
+	uint8_t svc_hint;
+} __packed;
+
+#define MGMT_OP_REMOVE_UUID		0x000A
+struct mgmt_cp_remove_uuid {
+	uint8_t uuid[16];
+} __packed;
+
+#define MGMT_OP_SET_DEV_CLASS		0x000B
+struct mgmt_cp_set_dev_class {
+	uint8_t major;
+	uint8_t minor;
+} __packed;
+
+#define MGMT_OP_SET_SERVICE_CACHE	0x000C
+struct mgmt_cp_set_service_cache {
+	uint8_t enable;
+} __packed;
+
+struct mgmt_key_info {
+	bdaddr_t bdaddr;
+	uint8_t type;
+	uint8_t val[16];
+	uint8_t pin_len;
+} __packed;
+
+#define MGMT_OP_LOAD_KEYS		0x000D
+struct mgmt_cp_load_keys {
+	uint8_t debug_keys;
+	uint16_t key_count;
+	struct mgmt_key_info keys[0];
+} __packed;
+
+#define MGMT_OP_REMOVE_KEY		0x000E
+struct mgmt_cp_remove_key {
+	bdaddr_t bdaddr;
+	uint8_t disconnect;
+} __packed;
+
+#define MGMT_OP_DISCONNECT		0x000F
+struct mgmt_cp_disconnect {
+	bdaddr_t bdaddr;
+} __packed;
+struct mgmt_rp_disconnect {
+	bdaddr_t bdaddr;
+} __packed;
+
+#define MGMT_OP_GET_CONNECTIONS		0x0010
+struct mgmt_rp_get_connections {
+	uint16_t conn_count;
+	bdaddr_t conn[0];
+} __packed;
+
+#define MGMT_OP_PIN_CODE_REPLY		0x0011
+struct mgmt_cp_pin_code_reply {
+	bdaddr_t bdaddr;
+	uint8_t pin_len;
+	uint8_t pin_code[16];
+} __packed;
+
+#define MGMT_OP_PIN_CODE_NEG_REPLY	0x0012
+struct mgmt_cp_pin_code_neg_reply {
+	bdaddr_t bdaddr;
+} __packed;
+
+#define MGMT_OP_SET_IO_CAPABILITY	0x0013
+struct mgmt_cp_set_io_capability {
+	uint8_t io_capability;
+} __packed;
+
+#define MGMT_OP_PAIR_DEVICE		0x0014
+struct mgmt_cp_pair_device {
+	bdaddr_t bdaddr;
+	uint8_t io_cap;
+} __packed;
+struct mgmt_rp_pair_device {
+	bdaddr_t bdaddr;
+	uint8_t status;
+} __packed;
+
+#define MGMT_OP_USER_CONFIRM_REPLY	0x0015
+struct mgmt_cp_user_confirm_reply {
+	bdaddr_t bdaddr;
+} __packed;
+struct mgmt_rp_user_confirm_reply {
+	bdaddr_t bdaddr;
+	uint8_t status;
+} __packed;
+
+#define MGMT_OP_USER_CONFIRM_NEG_REPLY	0x0016
+
+#define MGMT_OP_SET_LOCAL_NAME		0x0017
+struct mgmt_cp_set_local_name {
+	uint8_t name[MGMT_MAX_NAME_LENGTH];
+} __packed;
+
+#define MGMT_OP_READ_LOCAL_OOB_DATA	0x0018
+struct mgmt_rp_read_local_oob_data {
+	uint8_t hash[16];
+	uint8_t randomizer[16];
+} __packed;
+
+#define MGMT_OP_ADD_REMOTE_OOB_DATA	0x0019
+struct mgmt_cp_add_remote_oob_data {
+	bdaddr_t bdaddr;
+	uint8_t hash[16];
+	uint8_t randomizer[16];
+} __packed;
+
+#define MGMT_OP_REMOVE_REMOTE_OOB_DATA	0x001A
+struct mgmt_cp_remove_remote_oob_data {
+	bdaddr_t bdaddr;
+} __packed;
+
+#define MGMT_OP_START_DISCOVERY		0x001B
+
+#define MGMT_OP_STOP_DISCOVERY		0x001C
+
+#define MGMT_EV_CMD_COMPLETE		0x0001
+struct mgmt_ev_cmd_complete {
+	uint16_t opcode;
+	uint8_t data[0];
+} __packed;
+
+#define MGMT_EV_CMD_STATUS		0x0002
+struct mgmt_ev_cmd_status {
+	uint8_t status;
+	uint16_t opcode;
+} __packed;
+
+#define MGMT_EV_CONTROLLER_ERROR	0x0003
+struct mgmt_ev_controller_error {
+	uint8_t error_code;
+} __packed;
+
+#define MGMT_EV_INDEX_ADDED		0x0004
+
+#define MGMT_EV_INDEX_REMOVED		0x0005
+
+#define MGMT_EV_POWERED			0x0006
+
+#define MGMT_EV_DISCOVERABLE		0x0007
+
+#define MGMT_EV_CONNECTABLE		0x0008
+
+#define MGMT_EV_PAIRABLE		0x0009
+
+#define MGMT_EV_NEW_KEY			0x000A
+struct mgmt_ev_new_key {
+	uint8_t store_hint;
+	struct mgmt_key_info key;
+} __packed;
+
+#define MGMT_EV_DEVICE_CONNECTED	0x000B
+struct mgmt_ev_device_connected {
+	bdaddr_t bdaddr;
+} __packed;
+
+#define MGMT_EV_DEVICE_DISCONNECTED	0x000C
+struct mgmt_ev_device_disconnected {
+	bdaddr_t bdaddr;
+} __packed;
+
+#define MGMT_EV_CONNECT_FAILED		0x000D
+struct mgmt_ev_connect_failed {
+	bdaddr_t bdaddr;
+	uint8_t status;
+} __packed;
+
+#define MGMT_EV_PIN_CODE_REQUEST	0x000E
+struct mgmt_ev_pin_code_request {
+	bdaddr_t bdaddr;
+	uint8_t secure;
+} __packed;
+
+#define MGMT_EV_USER_CONFIRM_REQUEST	0x000F
+struct mgmt_ev_user_confirm_request {
+	bdaddr_t bdaddr;
+	uint8_t confirm_hint;
+	uint32_t value;
+} __packed;
+
+#define MGMT_EV_AUTH_FAILED		0x0010
+struct mgmt_ev_auth_failed {
+	bdaddr_t bdaddr;
+	uint8_t status;
+} __packed;
+
+#define MGMT_EV_LOCAL_NAME_CHANGED	0x0011
+struct mgmt_ev_local_name_changed {
+	uint8_t name[MGMT_MAX_NAME_LENGTH];
+} __packed;
+
+#define MGMT_EV_DEVICE_FOUND		0x0012
+struct mgmt_ev_device_found {
+	bdaddr_t bdaddr;
+	uint8_t dev_class[3];
+	int8_t rssi;
+	uint8_t eir[HCI_MAX_EIR_LENGTH];
+} __packed;
+
+#define MGMT_EV_REMOTE_NAME		0x0013
+struct mgmt_ev_remote_name {
+	bdaddr_t bdaddr;
+	uint8_t name[MGMT_MAX_NAME_LENGTH];
+} __packed;
+
+#define MGMT_EV_DISCOVERING		0x0014
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/rfcomm.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/rfcomm.h
new file mode 100644
index 0000000000..ad6c0e1c3c
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/rfcomm.h
@@ -0,0 +1,99 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __RFCOMM_H
+#define __RFCOMM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/socket.h>
+
+/* RFCOMM defaults */
+#define RFCOMM_DEFAULT_MTU	127
+
+#define RFCOMM_PSM 3
+
+/* RFCOMM socket address */
+struct sockaddr_rc {
+	sa_family_t	rc_family;
+	bdaddr_t	rc_bdaddr;
+	uint8_t		rc_channel;
+};
+
+/* RFCOMM socket options */
+#define RFCOMM_CONNINFO	0x02
+struct rfcomm_conninfo {
+	uint16_t	hci_handle;
+	uint8_t		dev_class[3];
+};
+
+#define RFCOMM_LM	0x03
+#define RFCOMM_LM_MASTER	0x0001
+#define RFCOMM_LM_AUTH		0x0002
+#define RFCOMM_LM_ENCRYPT	0x0004
+#define RFCOMM_LM_TRUSTED	0x0008
+#define RFCOMM_LM_RELIABLE	0x0010
+#define RFCOMM_LM_SECURE	0x0020
+
+/* RFCOMM TTY support */
+#define RFCOMM_MAX_DEV	256
+
+#define RFCOMMCREATEDEV		_IOW('R', 200, int)
+#define RFCOMMRELEASEDEV	_IOW('R', 201, int)
+#define RFCOMMGETDEVLIST	_IOR('R', 210, int)
+#define RFCOMMGETDEVINFO	_IOR('R', 211, int)
+
+struct rfcomm_dev_req {
+	int16_t		dev_id;
+	uint32_t	flags;
+	bdaddr_t	src;
+	bdaddr_t	dst;
+	uint8_t	channel;
+};
+#define RFCOMM_REUSE_DLC	0
+#define RFCOMM_RELEASE_ONHUP	1
+#define RFCOMM_HANGUP_NOW	2
+#define RFCOMM_TTY_ATTACHED	3
+
+struct rfcomm_dev_info {
+	int16_t		id;
+	uint32_t	flags;
+	uint16_t	state;
+	bdaddr_t	src;
+	bdaddr_t	dst;
+	uint8_t		channel;
+};
+
+struct rfcomm_dev_list_req {
+	uint16_t	dev_num;
+	struct rfcomm_dev_info dev_info[0];
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RFCOMM_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/sco.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/sco.h
new file mode 100644
index 0000000000..a79ab7125b
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/sco.h
@@ -0,0 +1,65 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __SCO_H
+#define __SCO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* SCO defaults */
+#define SCO_DEFAULT_MTU		500
+#define SCO_DEFAULT_FLUSH_TO	0xFFFF
+
+#define SCO_CONN_TIMEOUT	(HZ * 40)
+#define SCO_DISCONN_TIMEOUT	(HZ * 2)
+#define SCO_CONN_IDLE_TIMEOUT	(HZ * 60)
+
+/* SCO socket address */
+struct sockaddr_sco {
+	sa_family_t	sco_family;
+	bdaddr_t	sco_bdaddr;
+	/* for use with eSCO masks such as SCO_ESCO_MASK */
+	uint16_t	sco_pkt_type;
+
+};
+
+/* set/get sockopt defines */
+#define SCO_OPTIONS	0x01
+struct sco_options {
+	uint16_t	mtu;
+};
+
+#define SCO_CONNINFO	0x02
+struct sco_conninfo {
+	uint16_t	hci_handle;
+	uint8_t		dev_class[3];
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SCO_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/sdp.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/sdp.h
new file mode 100644
index 0000000000..f5d8531230
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/sdp.h
@@ -0,0 +1,519 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2001-2002  Nokia Corporation
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2002-2003  Stephen Crane <steve.crane@rococosoft.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __SDP_H
+#define __SDP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <bluetooth/bluetooth.h>
+#include <cutils/sockets.h>
+
+#define SDP_UNIX_PATH ANDROID_SOCKET_DIR"/bluetooth"
+#define SDP_RESPONSE_TIMEOUT	20
+#define SDP_REQ_BUFFER_SIZE	2048
+#define SDP_RSP_BUFFER_SIZE	65535
+#define SDP_PDU_CHUNK_SIZE	1024
+
+/*
+ * All definitions are based on Bluetooth Assigned Numbers
+ * of the Bluetooth Specification
+ */
+#define SDP_PSM		0x0001
+
+/*
+ * Protocol UUIDs
+ */
+#define SDP_UUID	0x0001
+#define UDP_UUID	0x0002
+#define RFCOMM_UUID	0x0003
+#define TCP_UUID	0x0004
+#define TCS_BIN_UUID	0x0005
+#define TCS_AT_UUID	0x0006
+#define ATT_UUID	0x0007
+#define OBEX_UUID	0x0008
+#define IP_UUID		0x0009
+#define FTP_UUID	0x000a
+#define HTTP_UUID	0x000c
+#define WSP_UUID	0x000e
+#define BNEP_UUID	0x000f
+#define UPNP_UUID	0x0010
+#define HIDP_UUID	0x0011
+#define HCRP_CTRL_UUID	0x0012
+#define HCRP_DATA_UUID	0x0014
+#define HCRP_NOTE_UUID	0x0016
+#define AVCTP_UUID	0x0017
+#define AVDTP_UUID	0x0019
+#define CMTP_UUID	0x001b
+#define UDI_UUID	0x001d
+#define MCAP_CTRL_UUID	0x001e
+#define MCAP_DATA_UUID	0x001f
+#define L2CAP_UUID	0x0100
+
+/*
+ * Service class identifiers of standard services and service groups
+ */
+#define SDP_SERVER_SVCLASS_ID		0x1000
+#define BROWSE_GRP_DESC_SVCLASS_ID	0x1001
+#define PUBLIC_BROWSE_GROUP		0x1002
+#define SERIAL_PORT_SVCLASS_ID		0x1101
+#define LAN_ACCESS_SVCLASS_ID		0x1102
+#define DIALUP_NET_SVCLASS_ID		0x1103
+#define IRMC_SYNC_SVCLASS_ID		0x1104
+#define OBEX_OBJPUSH_SVCLASS_ID		0x1105
+#define OBEX_FILETRANS_SVCLASS_ID	0x1106
+#define IRMC_SYNC_CMD_SVCLASS_ID	0x1107
+#define HEADSET_SVCLASS_ID		0x1108
+#define CORDLESS_TELEPHONY_SVCLASS_ID	0x1109
+#define AUDIO_SOURCE_SVCLASS_ID		0x110a
+#define AUDIO_SINK_SVCLASS_ID		0x110b
+#define AV_REMOTE_TARGET_SVCLASS_ID	0x110c
+#define ADVANCED_AUDIO_SVCLASS_ID	0x110d
+#define AV_REMOTE_SVCLASS_ID		0x110e
+#define VIDEO_CONF_SVCLASS_ID		0x110f
+#define INTERCOM_SVCLASS_ID		0x1110
+#define FAX_SVCLASS_ID			0x1111
+#define HEADSET_AGW_SVCLASS_ID		0x1112
+#define WAP_SVCLASS_ID			0x1113
+#define WAP_CLIENT_SVCLASS_ID		0x1114
+#define PANU_SVCLASS_ID			0x1115
+#define NAP_SVCLASS_ID			0x1116
+#define GN_SVCLASS_ID			0x1117
+#define DIRECT_PRINTING_SVCLASS_ID	0x1118
+#define REFERENCE_PRINTING_SVCLASS_ID	0x1119
+#define IMAGING_SVCLASS_ID		0x111a
+#define IMAGING_RESPONDER_SVCLASS_ID	0x111b
+#define IMAGING_ARCHIVE_SVCLASS_ID	0x111c
+#define IMAGING_REFOBJS_SVCLASS_ID	0x111d
+#define HANDSFREE_SVCLASS_ID		0x111e
+#define HANDSFREE_AGW_SVCLASS_ID	0x111f
+#define DIRECT_PRT_REFOBJS_SVCLASS_ID	0x1120
+#define REFLECTED_UI_SVCLASS_ID		0x1121
+#define BASIC_PRINTING_SVCLASS_ID	0x1122
+#define PRINTING_STATUS_SVCLASS_ID	0x1123
+#define HID_SVCLASS_ID			0x1124
+#define HCR_SVCLASS_ID			0x1125
+#define HCR_PRINT_SVCLASS_ID		0x1126
+#define HCR_SCAN_SVCLASS_ID		0x1127
+#define CIP_SVCLASS_ID			0x1128
+#define VIDEO_CONF_GW_SVCLASS_ID	0x1129
+#define UDI_MT_SVCLASS_ID		0x112a
+#define UDI_TA_SVCLASS_ID		0x112b
+#define AV_SVCLASS_ID			0x112c
+#define SAP_SVCLASS_ID			0x112d
+#define PBAP_PCE_SVCLASS_ID		0x112e
+#define PBAP_PSE_SVCLASS_ID		0x112f
+#define PBAP_SVCLASS_ID			0x1130
+#define PNP_INFO_SVCLASS_ID		0x1200
+#define GENERIC_NETWORKING_SVCLASS_ID	0x1201
+#define GENERIC_FILETRANS_SVCLASS_ID	0x1202
+#define GENERIC_AUDIO_SVCLASS_ID	0x1203
+#define GENERIC_TELEPHONY_SVCLASS_ID	0x1204
+#define UPNP_SVCLASS_ID			0x1205
+#define UPNP_IP_SVCLASS_ID		0x1206
+#define UPNP_PAN_SVCLASS_ID		0x1300
+#define UPNP_LAP_SVCLASS_ID		0x1301
+#define UPNP_L2CAP_SVCLASS_ID		0x1302
+#define VIDEO_SOURCE_SVCLASS_ID		0x1303
+#define VIDEO_SINK_SVCLASS_ID		0x1304
+#define VIDEO_DISTRIBUTION_SVCLASS_ID	0x1305
+#define HDP_SVCLASS_ID			0x1400
+#define HDP_SOURCE_SVCLASS_ID		0x1401
+#define HDP_SINK_SVCLASS_ID		0x1402
+#define APPLE_AGENT_SVCLASS_ID		0x2112
+#define GENERIC_ATTRIB_SVCLASS_ID	0x1801
+
+/*
+ * Standard profile descriptor identifiers; note these
+ * may be identical to some of the service classes defined above
+ */
+#define SDP_SERVER_PROFILE_ID		SDP_SERVER_SVCLASS_ID
+#define BROWSE_GRP_DESC_PROFILE_ID	BROWSE_GRP_DESC_SVCLASS_ID
+#define SERIAL_PORT_PROFILE_ID		SERIAL_PORT_SVCLASS_ID
+#define LAN_ACCESS_PROFILE_ID		LAN_ACCESS_SVCLASS_ID
+#define DIALUP_NET_PROFILE_ID		DIALUP_NET_SVCLASS_ID
+#define IRMC_SYNC_PROFILE_ID		IRMC_SYNC_SVCLASS_ID
+#define OBEX_OBJPUSH_PROFILE_ID		OBEX_OBJPUSH_SVCLASS_ID
+#define OBEX_FILETRANS_PROFILE_ID	OBEX_FILETRANS_SVCLASS_ID
+#define IRMC_SYNC_CMD_PROFILE_ID	IRMC_SYNC_CMD_SVCLASS_ID
+#define HEADSET_PROFILE_ID		HEADSET_SVCLASS_ID
+#define CORDLESS_TELEPHONY_PROFILE_ID	CORDLESS_TELEPHONY_SVCLASS_ID
+#define AUDIO_SOURCE_PROFILE_ID		AUDIO_SOURCE_SVCLASS_ID
+#define AUDIO_SINK_PROFILE_ID		AUDIO_SINK_SVCLASS_ID
+#define AV_REMOTE_TARGET_PROFILE_ID	AV_REMOTE_TARGET_SVCLASS_ID
+#define ADVANCED_AUDIO_PROFILE_ID	ADVANCED_AUDIO_SVCLASS_ID
+#define AV_REMOTE_PROFILE_ID		AV_REMOTE_SVCLASS_ID
+#define VIDEO_CONF_PROFILE_ID		VIDEO_CONF_SVCLASS_ID
+#define INTERCOM_PROFILE_ID		INTERCOM_SVCLASS_ID
+#define FAX_PROFILE_ID			FAX_SVCLASS_ID
+#define HEADSET_AGW_PROFILE_ID		HEADSET_AGW_SVCLASS_ID
+#define WAP_PROFILE_ID			WAP_SVCLASS_ID
+#define WAP_CLIENT_PROFILE_ID		WAP_CLIENT_SVCLASS_ID
+#define PANU_PROFILE_ID			PANU_SVCLASS_ID
+#define NAP_PROFILE_ID			NAP_SVCLASS_ID
+#define GN_PROFILE_ID			GN_SVCLASS_ID
+#define DIRECT_PRINTING_PROFILE_ID	DIRECT_PRINTING_SVCLASS_ID
+#define REFERENCE_PRINTING_PROFILE_ID	REFERENCE_PRINTING_SVCLASS_ID
+#define IMAGING_PROFILE_ID		IMAGING_SVCLASS_ID
+#define IMAGING_RESPONDER_PROFILE_ID	IMAGING_RESPONDER_SVCLASS_ID
+#define IMAGING_ARCHIVE_PROFILE_ID	IMAGING_ARCHIVE_SVCLASS_ID
+#define IMAGING_REFOBJS_PROFILE_ID	IMAGING_REFOBJS_SVCLASS_ID
+#define HANDSFREE_PROFILE_ID		HANDSFREE_SVCLASS_ID
+#define HANDSFREE_AGW_PROFILE_ID	HANDSFREE_AGW_SVCLASS_ID
+#define DIRECT_PRT_REFOBJS_PROFILE_ID	DIRECT_PRT_REFOBJS_SVCLASS_ID
+#define REFLECTED_UI_PROFILE_ID		REFLECTED_UI_SVCLASS_ID
+#define BASIC_PRINTING_PROFILE_ID	BASIC_PRINTING_SVCLASS_ID
+#define PRINTING_STATUS_PROFILE_ID	PRINTING_STATUS_SVCLASS_ID
+#define HID_PROFILE_ID			HID_SVCLASS_ID
+#define HCR_PROFILE_ID			HCR_SCAN_SVCLASS_ID
+#define HCR_PRINT_PROFILE_ID		HCR_PRINT_SVCLASS_ID
+#define HCR_SCAN_PROFILE_ID		HCR_SCAN_SVCLASS_ID
+#define CIP_PROFILE_ID			CIP_SVCLASS_ID
+#define VIDEO_CONF_GW_PROFILE_ID	VIDEO_CONF_GW_SVCLASS_ID
+#define UDI_MT_PROFILE_ID		UDI_MT_SVCLASS_ID
+#define UDI_TA_PROFILE_ID		UDI_TA_SVCLASS_ID
+#define AV_PROFILE_ID			AV_SVCLASS_ID
+#define SAP_PROFILE_ID			SAP_SVCLASS_ID
+#define PBAP_PCE_PROFILE_ID		PBAP_PCE_SVCLASS_ID
+#define PBAP_PSE_PROFILE_ID		PBAP_PSE_SVCLASS_ID
+#define PBAP_PROFILE_ID			PBAP_SVCLASS_ID
+#define PNP_INFO_PROFILE_ID		PNP_INFO_SVCLASS_ID
+#define GENERIC_NETWORKING_PROFILE_ID	GENERIC_NETWORKING_SVCLASS_ID
+#define GENERIC_FILETRANS_PROFILE_ID	GENERIC_FILETRANS_SVCLASS_ID
+#define GENERIC_AUDIO_PROFILE_ID	GENERIC_AUDIO_SVCLASS_ID
+#define GENERIC_TELEPHONY_PROFILE_ID	GENERIC_TELEPHONY_SVCLASS_ID
+#define UPNP_PROFILE_ID			UPNP_SVCLASS_ID
+#define UPNP_IP_PROFILE_ID		UPNP_IP_SVCLASS_ID
+#define UPNP_PAN_PROFILE_ID		UPNP_PAN_SVCLASS_ID
+#define UPNP_LAP_PROFILE_ID		UPNP_LAP_SVCLASS_ID
+#define UPNP_L2CAP_PROFILE_ID		UPNP_L2CAP_SVCLASS_ID
+#define VIDEO_SOURCE_PROFILE_ID		VIDEO_SOURCE_SVCLASS_ID
+#define VIDEO_SINK_PROFILE_ID		VIDEO_SINK_SVCLASS_ID
+#define VIDEO_DISTRIBUTION_PROFILE_ID	VIDEO_DISTRIBUTION_SVCLASS_ID
+#define HDP_PROFILE_ID			HDP_SVCLASS_ID
+#define HDP_SOURCE_PROFILE_ID		HDP_SOURCE_SVCLASS_ID
+#define HDP_SINK_PROFILE_ID		HDP_SINK_SVCLASS_ID
+#define APPLE_AGENT_PROFILE_ID		APPLE_AGENT_SVCLASS_ID
+#define GENERIC_ACCESS_PROFILE_ID	0x1800
+#define GENERIC_ATTRIB_PROFILE_ID	GENERIC_ATTRIB_SVCLASS_ID
+
+/*
+ * Compatibility macros for the old MDP acronym
+ */
+#define MDP_SVCLASS_ID			HDP_SVCLASS_ID
+#define MDP_SOURCE_SVCLASS_ID		HDP_SOURCE_SVCLASS_ID
+#define MDP_SINK_SVCLASS_ID		HDP_SINK_SVCLASS_ID
+#define MDP_PROFILE_ID			HDP_PROFILE_ID
+#define MDP_SOURCE_PROFILE_ID		HDP_SOURCE_PROFILE_ID
+#define MDP_SINK_PROFILE_ID		HDP_SINK_PROFILE_ID
+
+/*
+ * Attribute identifier codes
+ */
+#define SDP_SERVER_RECORD_HANDLE		0x0000
+
+/*
+ * Possible values for attribute-id are listed below.
+ * See SDP Spec, section "Service Attribute Definitions" for more details.
+ */
+#define SDP_ATTR_RECORD_HANDLE			0x0000
+#define SDP_ATTR_SVCLASS_ID_LIST		0x0001
+#define SDP_ATTR_RECORD_STATE			0x0002
+#define SDP_ATTR_SERVICE_ID			0x0003
+#define SDP_ATTR_PROTO_DESC_LIST		0x0004
+#define SDP_ATTR_BROWSE_GRP_LIST		0x0005
+#define SDP_ATTR_LANG_BASE_ATTR_ID_LIST		0x0006
+#define SDP_ATTR_SVCINFO_TTL			0x0007
+#define SDP_ATTR_SERVICE_AVAILABILITY		0x0008
+#define SDP_ATTR_PFILE_DESC_LIST		0x0009
+#define SDP_ATTR_DOC_URL			0x000a
+#define SDP_ATTR_CLNT_EXEC_URL			0x000b
+#define SDP_ATTR_ICON_URL			0x000c
+#define SDP_ATTR_ADD_PROTO_DESC_LIST		0x000d
+
+#define SDP_ATTR_GROUP_ID			0x0200
+#define SDP_ATTR_IP_SUBNET			0x0200
+#define SDP_ATTR_VERSION_NUM_LIST		0x0200
+#define SDP_ATTR_SUPPORTED_FEATURES_LIST	0x0200
+#define SDP_ATTR_SVCDB_STATE			0x0201
+
+#define SDP_ATTR_SERVICE_VERSION		0x0300
+#define SDP_ATTR_EXTERNAL_NETWORK		0x0301
+#define SDP_ATTR_SUPPORTED_DATA_STORES_LIST	0x0301
+#define SDP_ATTR_DATA_EXCHANGE_SPEC		0x0301
+#define SDP_ATTR_FAX_CLASS1_SUPPORT		0x0302
+#define SDP_ATTR_REMOTE_AUDIO_VOLUME_CONTROL	0x0302
+#define SDP_ATTR_MCAP_SUPPORTED_PROCEDURES	0x0302
+#define SDP_ATTR_FAX_CLASS20_SUPPORT		0x0303
+#define SDP_ATTR_SUPPORTED_FORMATS_LIST		0x0303
+#define SDP_ATTR_FAX_CLASS2_SUPPORT		0x0304
+#define SDP_ATTR_AUDIO_FEEDBACK_SUPPORT		0x0305
+#define SDP_ATTR_NETWORK_ADDRESS		0x0306
+#define SDP_ATTR_WAP_GATEWAY			0x0307
+#define SDP_ATTR_HOMEPAGE_URL			0x0308
+#define SDP_ATTR_WAP_STACK_TYPE			0x0309
+#define SDP_ATTR_SECURITY_DESC			0x030a
+#define SDP_ATTR_NET_ACCESS_TYPE		0x030b
+#define SDP_ATTR_MAX_NET_ACCESSRATE		0x030c
+#define SDP_ATTR_IP4_SUBNET			0x030d
+#define SDP_ATTR_IP6_SUBNET			0x030e
+#define SDP_ATTR_SUPPORTED_CAPABILITIES		0x0310
+#define SDP_ATTR_SUPPORTED_FEATURES		0x0311
+#define SDP_ATTR_SUPPORTED_FUNCTIONS		0x0312
+#define SDP_ATTR_TOTAL_IMAGING_DATA_CAPACITY	0x0313
+#define SDP_ATTR_SUPPORTED_REPOSITORIES		0x0314
+
+#define SDP_ATTR_SPECIFICATION_ID		0x0200
+#define SDP_ATTR_VENDOR_ID			0x0201
+#define SDP_ATTR_PRODUCT_ID			0x0202
+#define SDP_ATTR_VERSION			0x0203
+#define SDP_ATTR_PRIMARY_RECORD			0x0204
+#define SDP_ATTR_VENDOR_ID_SOURCE		0x0205
+
+#define SDP_ATTR_HID_DEVICE_RELEASE_NUMBER	0x0200
+#define SDP_ATTR_HID_PARSER_VERSION		0x0201
+#define SDP_ATTR_HID_DEVICE_SUBCLASS		0x0202
+#define SDP_ATTR_HID_COUNTRY_CODE		0x0203
+#define SDP_ATTR_HID_VIRTUAL_CABLE		0x0204
+#define SDP_ATTR_HID_RECONNECT_INITIATE		0x0205
+#define SDP_ATTR_HID_DESCRIPTOR_LIST		0x0206
+#define SDP_ATTR_HID_LANG_ID_BASE_LIST		0x0207
+#define SDP_ATTR_HID_SDP_DISABLE		0x0208
+#define SDP_ATTR_HID_BATTERY_POWER		0x0209
+#define SDP_ATTR_HID_REMOTE_WAKEUP		0x020a
+#define SDP_ATTR_HID_PROFILE_VERSION		0x020b
+#define SDP_ATTR_HID_SUPERVISION_TIMEOUT	0x020c
+#define SDP_ATTR_HID_NORMALLY_CONNECTABLE	0x020d
+#define SDP_ATTR_HID_BOOT_DEVICE		0x020e
+
+/*
+ * These identifiers are based on the SDP spec stating that
+ * "base attribute id of the primary (universal) language must be 0x0100"
+ *
+ * Other languages should have their own offset; e.g.:
+ * #define XXXLangBase yyyy
+ * #define AttrServiceName_XXX	0x0000+XXXLangBase
+ */
+#define SDP_PRIMARY_LANG_BASE		0x0100
+
+#define SDP_ATTR_SVCNAME_PRIMARY	0x0000 + SDP_PRIMARY_LANG_BASE
+#define SDP_ATTR_SVCDESC_PRIMARY	0x0001 + SDP_PRIMARY_LANG_BASE
+#define SDP_ATTR_PROVNAME_PRIMARY	0x0002 + SDP_PRIMARY_LANG_BASE
+
+/*
+ * The Data representation in SDP PDUs (pps 339, 340 of BT SDP Spec)
+ * These are the exact data type+size descriptor values
+ * that go into the PDU buffer.
+ *
+ * The datatype (leading 5bits) + size descriptor (last 3 bits)
+ * is 8 bits. The size descriptor is critical to extract the
+ * right number of bytes for the data value from the PDU.
+ *
+ * For most basic types, the datatype+size descriptor is
+ * straightforward. However for constructed types and strings,
+ * the size of the data is in the next "n" bytes following the
+ * 8 bits (datatype+size) descriptor. Exactly what the "n" is
+ * specified in the 3 bits of the data size descriptor.
+ *
+ * TextString and URLString can be of size 2^{8, 16, 32} bytes
+ * DataSequence and DataSequenceAlternates can be of size 2^{8, 16, 32}
+ * The size are computed post-facto in the API and are not known apriori
+ */
+#define SDP_DATA_NIL		0x00
+#define SDP_UINT8		0x08
+#define SDP_UINT16		0x09
+#define SDP_UINT32		0x0A
+#define SDP_UINT64		0x0B
+#define SDP_UINT128		0x0C
+#define SDP_INT8		0x10
+#define SDP_INT16		0x11
+#define SDP_INT32		0x12
+#define SDP_INT64		0x13
+#define SDP_INT128		0x14
+#define SDP_UUID_UNSPEC		0x18
+#define SDP_UUID16		0x19
+#define SDP_UUID32		0x1A
+#define SDP_UUID128		0x1C
+#define SDP_TEXT_STR_UNSPEC	0x20
+#define SDP_TEXT_STR8		0x25
+#define SDP_TEXT_STR16		0x26
+#define SDP_TEXT_STR32		0x27
+#define SDP_BOOL		0x28
+#define SDP_SEQ_UNSPEC		0x30
+#define SDP_SEQ8		0x35
+#define SDP_SEQ16		0x36
+#define SDP_SEQ32		0x37
+#define SDP_ALT_UNSPEC		0x38
+#define SDP_ALT8		0x3D
+#define SDP_ALT16		0x3E
+#define SDP_ALT32		0x3F
+#define SDP_URL_STR_UNSPEC	0x40
+#define SDP_URL_STR8		0x45
+#define SDP_URL_STR16		0x46
+#define SDP_URL_STR32		0x47
+
+/*
+ * The PDU identifiers of SDP packets between client and server
+ */
+#define SDP_ERROR_RSP		0x01
+#define SDP_SVC_SEARCH_REQ	0x02
+#define SDP_SVC_SEARCH_RSP	0x03
+#define SDP_SVC_ATTR_REQ	0x04
+#define SDP_SVC_ATTR_RSP	0x05
+#define SDP_SVC_SEARCH_ATTR_REQ	0x06
+#define SDP_SVC_SEARCH_ATTR_RSP	0x07
+
+/*
+ * Some additions to support service registration.
+ * These are outside the scope of the Bluetooth specification
+ */
+#define SDP_SVC_REGISTER_REQ	0x75
+#define SDP_SVC_REGISTER_RSP	0x76
+#define SDP_SVC_UPDATE_REQ	0x77
+#define SDP_SVC_UPDATE_RSP	0x78
+#define SDP_SVC_REMOVE_REQ	0x79
+#define SDP_SVC_REMOVE_RSP	0x80
+
+/*
+ * SDP Error codes
+ */
+#define SDP_INVALID_VERSION		0x0001
+#define SDP_INVALID_RECORD_HANDLE	0x0002
+#define SDP_INVALID_SYNTAX		0x0003
+#define SDP_INVALID_PDU_SIZE		0x0004
+#define SDP_INVALID_CSTATE		0x0005
+
+/*
+ * SDP PDU
+ */
+typedef struct {
+	uint8_t  pdu_id;
+	uint16_t tid;
+	uint16_t plen;
+} __attribute__ ((packed)) sdp_pdu_hdr_t;
+
+/*
+ * Common definitions for attributes in the SDP.
+ * Should the type of any of these change, you need only make a change here.
+ */
+
+typedef struct {
+	uint8_t type;
+	union {
+		uint16_t  uuid16;
+		uint32_t  uuid32;
+		uint128_t uuid128;
+	} value;
+} uuid_t;
+
+#define SDP_IS_UUID(x) ((x) == SDP_UUID16 || (x) == SDP_UUID32 || (x) ==SDP_UUID128)
+
+typedef struct _sdp_list sdp_list_t;
+struct _sdp_list {
+	sdp_list_t *next;
+	void *data;
+};
+
+/*
+ * User-visible strings can be in many languages
+ * in addition to the universal language.
+ *
+ * Language meta-data includes language code in ISO639
+ * followed by the encoding format. The third field in this
+ * structure is the attribute offset for the language.
+ * User-visible strings in the specified language can be
+ * obtained at this offset.
+ */
+typedef struct {
+	uint16_t code_ISO639;
+	uint16_t encoding;
+	uint16_t base_offset;
+} sdp_lang_attr_t;
+
+/*
+ * Profile descriptor is the Bluetooth profile metadata. If a
+ * service conforms to a well-known profile, then its profile
+ * identifier (UUID) is an attribute of the service. In addition,
+ * if the profile has a version number it is specified here.
+ */
+typedef struct {
+	uuid_t uuid;
+	uint16_t version;
+} sdp_profile_desc_t;
+
+typedef struct {
+	uint8_t major;
+	uint8_t minor;
+} sdp_version_t;
+
+typedef struct {
+	uint8_t *data;
+	uint32_t data_size;
+	uint32_t buf_size;
+} sdp_buf_t;
+
+typedef struct {
+	uint32_t handle;
+
+	/* Search pattern: a sequence of all UUIDs seen in this record */
+	sdp_list_t *pattern;
+	sdp_list_t *attrlist;
+
+	/* Main service class for Extended Inquiry Response */
+	uuid_t svclass;
+} sdp_record_t;
+
+typedef struct sdp_data_struct sdp_data_t;
+struct sdp_data_struct {
+	uint8_t dtd;
+	uint16_t attrId;
+	union {
+		int8_t    int8;
+		int16_t   int16;
+		int32_t   int32;
+		int64_t   int64;
+		uint128_t int128;
+		uint8_t   uint8;
+		uint16_t  uint16;
+		uint32_t  uint32;
+		uint64_t  uint64;
+		uint128_t uint128;
+		uuid_t    uuid;
+		char     *str;
+		sdp_data_t *dataseq;
+	} val;
+	sdp_data_t *next;
+	int unitSize;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SDP_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/sdp_lib.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/sdp_lib.h
new file mode 100644
index 0000000000..433e9effb9
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/sdp_lib.h
@@ -0,0 +1,631 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2001-2002  Nokia Corporation
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2002-2003  Stephen Crane <steve.crane@rococosoft.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __SDP_LIB_H
+#define __SDP_LIB_H
+
+#include <sys/socket.h>
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/hci.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * SDP lists
+ */
+typedef void(*sdp_list_func_t)(void *, void *);
+typedef void(*sdp_free_func_t)(void *);
+typedef int (*sdp_comp_func_t)(const void *, const void *);
+
+sdp_list_t *sdp_list_append(sdp_list_t *list, void *d);
+sdp_list_t *sdp_list_remove(sdp_list_t *list, void *d);
+sdp_list_t *sdp_list_insert_sorted(sdp_list_t *list, void *data, sdp_comp_func_t f);
+void        sdp_list_free(sdp_list_t *list, sdp_free_func_t f);
+
+static inline int sdp_list_len(const sdp_list_t *list)
+{
+	int n = 0;
+	for (; list; list = list->next)
+		n++;
+	return n;
+}
+
+static inline sdp_list_t *sdp_list_find(sdp_list_t *list, void *u, sdp_comp_func_t f)
+{
+	for (; list; list = list->next)
+		if (f(list->data, u) == 0)
+			return list;
+	return NULL;
+}
+
+static inline void sdp_list_foreach(sdp_list_t *list, sdp_list_func_t f, void *u)
+{
+	for (; list; list = list->next)
+		f(list->data, u);
+}
+
+/*
+ * Values of the flags parameter to sdp_record_register
+ */
+#define SDP_RECORD_PERSIST	0x01
+#define SDP_DEVICE_RECORD	0x02
+
+/*
+ * Values of the flags parameter to sdp_connect
+ */
+#define SDP_RETRY_IF_BUSY	0x01
+#define SDP_WAIT_ON_CLOSE	0x02
+#define SDP_NON_BLOCKING	0x04
+
+/*
+ * a session with an SDP server
+ */
+typedef struct {
+	int sock;
+	int state;
+	int local;
+	int flags;
+	uint16_t tid;	/* Current transaction ID */
+	void *priv;
+} sdp_session_t;
+
+typedef enum {
+	/*
+	 *  Attributes are specified as individual elements
+	 */
+	SDP_ATTR_REQ_INDIVIDUAL = 1,
+	/*
+	 *  Attributes are specified as a range
+	 */
+	SDP_ATTR_REQ_RANGE
+} sdp_attrreq_type_t;
+
+/*
+ * 	When the pdu_id(type) is a sdp error response, check the status value
+ * 	to figure out the error reason. For status values 0x0001-0x0006 check
+ * 	Bluetooth SPEC. If the status is 0xffff, call sdp_get_error function
+ * 	to get the real reason:
+ * 	    - wrong transaction ID(EPROTO)
+ * 	    - wrong PDU id or(EPROTO)
+ * 	    - I/O error
+ */
+typedef void sdp_callback_t(uint8_t type, uint16_t status, uint8_t *rsp, size_t size, void *udata);
+
+/*
+ * create an L2CAP connection to a Bluetooth device
+ *
+ * INPUT:
+ *
+ *  bdaddr_t *src:
+ *	Address of the local device to use to make the connection
+ *	(or BDADDR_ANY)
+ *
+ *  bdaddr_t *dst:
+ *    Address of the SDP server device
+ */
+sdp_session_t *sdp_connect(const bdaddr_t *src, const bdaddr_t *dst, uint32_t flags);
+int sdp_close(sdp_session_t *session);
+int sdp_get_socket(const sdp_session_t *session);
+
+/*
+ * SDP transaction: functions for asynchronous search.
+ */
+sdp_session_t *sdp_create(int sk, uint32_t flags);
+int sdp_get_error(sdp_session_t *session);
+int sdp_process(sdp_session_t *session);
+int sdp_set_notify(sdp_session_t *session, sdp_callback_t *func, void *udata);
+
+int sdp_service_search_async(sdp_session_t *session, const sdp_list_t *search, uint16_t max_rec_num);
+int sdp_service_attr_async(sdp_session_t *session, uint32_t handle, sdp_attrreq_type_t reqtype, const sdp_list_t *attrid_list);
+int sdp_service_search_attr_async(sdp_session_t *session, const sdp_list_t *search, sdp_attrreq_type_t reqtype, const sdp_list_t *attrid_list);
+
+uint16_t sdp_gen_tid(sdp_session_t *session);
+
+/*
+ * find all devices in the piconet
+ */
+int sdp_general_inquiry(inquiry_info *ii, int dev_num, int duration, uint8_t *found);
+
+/* flexible extraction of basic attributes - Jean II */
+int sdp_get_int_attr(const sdp_record_t *rec, uint16_t attr, int *value);
+int sdp_get_string_attr(const sdp_record_t *rec, uint16_t attr, char *value, int valuelen);
+
+/*
+ * Basic sdp data functions
+ */
+sdp_data_t *sdp_data_alloc(uint8_t dtd, const void *value);
+sdp_data_t *sdp_data_alloc_with_length(uint8_t dtd, const void *value, uint32_t length);
+void sdp_data_free(sdp_data_t *data);
+sdp_data_t *sdp_data_get(const sdp_record_t *rec, uint16_t attr_id);
+
+sdp_data_t *sdp_seq_alloc(void **dtds, void **values, int len);
+sdp_data_t *sdp_seq_alloc_with_length(void **dtds, void **values, int *length, int len);
+sdp_data_t *sdp_seq_append(sdp_data_t *seq, sdp_data_t *data);
+
+int sdp_attr_add(sdp_record_t *rec, uint16_t attr, sdp_data_t *data);
+void sdp_attr_remove(sdp_record_t *rec, uint16_t attr);
+void sdp_attr_replace(sdp_record_t *rec, uint16_t attr, sdp_data_t *data);
+int sdp_set_uuidseq_attr(sdp_record_t *rec, uint16_t attr, sdp_list_t *seq);
+int sdp_get_uuidseq_attr(const sdp_record_t *rec, uint16_t attr, sdp_list_t **seqp);
+
+/*
+ * NOTE that none of the functions below will update the SDP server,
+ * unless the {register, update}sdp_record_t() function is invoked.
+ * All functions which return an integer value, return 0 on success
+ * or -1 on failure.
+ */
+
+/*
+ * Create an attribute and add it to the service record's attribute list.
+ * This consists of the data type descriptor of the attribute,
+ * the value of the attribute and the attribute identifier.
+ */
+int sdp_attr_add_new(sdp_record_t *rec, uint16_t attr, uint8_t dtd, const void *p);
+
+/*
+ * Set the information attributes of the service record.
+ * The set of attributes comprises service name, description
+ * and provider name
+ */
+void sdp_set_info_attr(sdp_record_t *rec, const char *name, const char *prov, const char *desc);
+
+/*
+ * Set the ServiceClassID attribute to the sequence specified by seq.
+ * Note that the identifiers need to be in sorted order from the most
+ * specific to the most generic service class that this service
+ * conforms to.
+ */
+static inline int sdp_set_service_classes(sdp_record_t *rec, sdp_list_t *seq)
+{
+	return sdp_set_uuidseq_attr(rec, SDP_ATTR_SVCLASS_ID_LIST, seq);
+}
+
+/*
+ * Get the service classes to which the service conforms.
+ *
+ * When set, the list contains elements of ServiceClassIdentifer(uint16_t)
+ * ordered from most specific to most generic
+ */
+static inline int sdp_get_service_classes(const sdp_record_t *rec, sdp_list_t **seqp)
+{
+	return sdp_get_uuidseq_attr(rec, SDP_ATTR_SVCLASS_ID_LIST, seqp);
+}
+
+/*
+ * Set the BrowseGroupList attribute to the list specified by seq.
+ *
+ * A service can belong to one or more service groups
+ * and the list comprises such group identifiers (UUIDs)
+ */
+static inline int sdp_set_browse_groups(sdp_record_t *rec, sdp_list_t *seq)
+{
+	return sdp_set_uuidseq_attr(rec, SDP_ATTR_BROWSE_GRP_LIST, seq);
+}
+
+/*
+ * Set the access protocols of the record to those specified in proto
+ */
+int sdp_set_access_protos(sdp_record_t *rec, const sdp_list_t *proto);
+
+/*
+ * Set the additional access protocols of the record to those specified in proto
+ */
+int sdp_set_add_access_protos(sdp_record_t *rec, const sdp_list_t *proto);
+
+/*
+ * Get protocol port (i.e. PSM for L2CAP, Channel for RFCOMM)
+ */
+int sdp_get_proto_port(const sdp_list_t *list, int proto);
+
+/*
+ * Get protocol descriptor.
+ */
+sdp_data_t *sdp_get_proto_desc(sdp_list_t *list, int proto);
+
+/*
+ * Set the LanguageBase attributes to the values specified in list
+ * (a linked list of sdp_lang_attr_t objects, one for each language in
+ * which user-visible attributes are present).
+ */
+int sdp_set_lang_attr(sdp_record_t *rec, const sdp_list_t *list);
+
+/*
+ * Set the ServiceInfoTimeToLive attribute of the service.
+ * This is the number of seconds that this record is guaranteed
+ * not to change after being obtained by a client.
+ */
+static inline int sdp_set_service_ttl(sdp_record_t *rec, uint32_t ttl)
+{
+	return sdp_attr_add_new(rec, SDP_ATTR_SVCINFO_TTL, SDP_UINT32, &ttl);
+}
+
+/*
+ * Set the ServiceRecordState attribute of a service. This is
+ * guaranteed to change if there is any kind of modification to
+ * the record.
+ */
+static inline int sdp_set_record_state(sdp_record_t *rec, uint32_t state)
+{
+	return sdp_attr_add_new(rec, SDP_ATTR_RECORD_STATE, SDP_UINT32, &state);
+}
+
+/*
+ * Set the ServiceID attribute of a service.
+ */
+void sdp_set_service_id(sdp_record_t *rec, uuid_t uuid);
+
+/*
+ * Set the GroupID attribute of a service
+ */
+void sdp_set_group_id(sdp_record_t *rec, uuid_t grouuuid);
+
+/*
+ * Set the ServiceAvailability attribute of a service.
+ *
+ * Note that this represents the relative availability
+ * of the service: 0x00 means completely unavailable;
+ * 0xFF means maximum availability.
+ */
+static inline int sdp_set_service_avail(sdp_record_t *rec, uint8_t avail)
+{
+	return sdp_attr_add_new(rec, SDP_ATTR_SERVICE_AVAILABILITY, SDP_UINT8, &avail);
+}
+
+/*
+ * Set the profile descriptor list attribute of a record.
+ *
+ * Each element in the list is an object of type
+ * sdp_profile_desc_t which is a definition of the
+ * Bluetooth profile that this service conforms to.
+ */
+int sdp_set_profile_descs(sdp_record_t *rec, const sdp_list_t *desc);
+
+/*
+ * Set URL attributes of a record.
+ *
+ * ClientExecutableURL: a URL to a client's platform specific (WinCE,
+ * PalmOS) executable code that can be used to access this service.
+ *
+ * DocumentationURL: a URL pointing to service documentation
+ *
+ * IconURL: a URL to an icon that can be used to represent this service.
+ *
+ * Note: pass NULL for any URLs that you don't want to set or remove
+ */
+void sdp_set_url_attr(sdp_record_t *rec, const char *clientExecURL, const char *docURL, const char *iconURL);
+
+/*
+ * a service search request.
+ *
+ *  INPUT :
+ *
+ *    sdp_list_t *search
+ *      list containing elements of the search
+ *      pattern. Each entry in the list is a UUID
+ *      of the service to be searched
+ *
+ *    uint16_t max_rec_num
+ *       An integer specifying the maximum number of
+ *       entries that the client can handle in the response.
+ *
+ *  OUTPUT :
+ *
+ *    int return value
+ *      0
+ *        The request completed successfully. This does not
+ *        mean the requested services were found
+ *      -1
+ *        The request completed unsuccessfully
+ *
+ *    sdp_list_t *rsp_list
+ *      This variable is set on a successful return if there are
+ *      non-zero service handles. It is a singly linked list of
+ *      service record handles (uint16_t)
+ */
+int sdp_service_search_req(sdp_session_t *session, const sdp_list_t *search, uint16_t max_rec_num, sdp_list_t **rsp_list);
+
+/*
+ *  a service attribute request.
+ *
+ *  INPUT :
+ *
+ *    uint32_t handle
+ *      The handle of the service for which the attribute(s) are
+ *      requested
+ *
+ *    sdp_attrreq_type_t reqtype
+ *      Attribute identifiers are 16 bit unsigned integers specified
+ *      in one of 2 ways described below :
+ *      SDP_ATTR_REQ_INDIVIDUAL - 16bit individual identifiers
+ *         They are the actual attribute identifiers in ascending order
+ *
+ *      SDP_ATTR_REQ_RANGE - 32bit identifier range
+ *         The high-order 16bits is the start of range
+ *         the low-order 16bits are the end of range
+ *         0x0000 to 0xFFFF gets all attributes
+ *
+ *    sdp_list_t *attrid_list
+ *      Singly linked list containing attribute identifiers desired.
+ *      Every element is either a uint16_t(attrSpec = SDP_ATTR_REQ_INDIVIDUAL)
+ *      or a uint32_t(attrSpec=SDP_ATTR_REQ_RANGE)
+ *
+ *  OUTPUT :
+ *    int return value
+ *      0
+ *        The request completed successfully. This does not
+ *        mean the requested services were found
+ *      -1
+ *        The request completed unsuccessfully due to a timeout
+ */
+sdp_record_t *sdp_service_attr_req(sdp_session_t *session, uint32_t handle, sdp_attrreq_type_t reqtype, const sdp_list_t *attrid_list);
+
+/*
+ *  This is a service search request combined with the service
+ *  attribute request. First a service class match is done and
+ *  for matching service, requested attributes are extracted
+ *
+ *  INPUT :
+ *
+ *    sdp_list_t *search
+ *      Singly linked list containing elements of the search
+ *      pattern. Each entry in the list is a UUID(DataTypeSDP_UUID16)
+ *      of the service to be searched
+ *
+ *    AttributeSpecification attrSpec
+ *      Attribute identifiers are 16 bit unsigned integers specified
+ *      in one of 2 ways described below :
+ *      SDP_ATTR_REQ_INDIVIDUAL - 16bit individual identifiers
+ *         They are the actual attribute identifiers in ascending order
+ *
+ *      SDP_ATTR_REQ_RANGE - 32bit identifier range
+ *         The high-order 16bits is the start of range
+ *         the low-order 16bits are the end of range
+ *         0x0000 to 0xFFFF gets all attributes
+ *
+ *    sdp_list_t *attrid_list
+ *      Singly linked list containing attribute identifiers desired.
+ *      Every element is either a uint16_t(attrSpec = SDP_ATTR_REQ_INDIVIDUAL)
+ *      or a uint32_t(attrSpec=SDP_ATTR_REQ_RANGE)
+ *
+ *  OUTPUT :
+ *    int return value
+ *      0
+ *        The request completed successfully. This does not
+ *        mean the requested services were found
+ *      -1
+ *        The request completed unsuccessfully due to a timeout
+ *
+ *    sdp_list_t *rsp_list
+ *      This variable is set on a successful return to point to
+ *      service(s) found. Each element of this list is of type
+ *      sdp_record_t *.
+ */
+int sdp_service_search_attr_req(sdp_session_t *session, const sdp_list_t *search, sdp_attrreq_type_t reqtype, const sdp_list_t *attrid_list, sdp_list_t **rsp_list);
+
+/*
+ * Allocate/free a service record and its attributes
+ */
+sdp_record_t *sdp_record_alloc(void);
+void sdp_record_free(sdp_record_t *rec);
+
+/*
+ * Register a service record.
+ *
+ * Note: It is the responsbility of the Service Provider to create the
+ * record first and set its attributes using setXXX() methods.
+ *
+ * The service provider must then call sdp_record_register() to make
+ * the service record visible to SDP clients.  This function returns 0
+ * on success or -1 on failure (and sets errno).
+ */
+int sdp_device_record_register_binary(sdp_session_t *session, bdaddr_t *device, uint8_t *data, uint32_t size, uint8_t flags, uint32_t *handle);
+int sdp_device_record_register(sdp_session_t *session, bdaddr_t *device, sdp_record_t *rec, uint8_t flags);
+int sdp_record_register(sdp_session_t *session, sdp_record_t *rec, uint8_t flags);
+
+/*
+ * Unregister a service record.
+ */
+int sdp_device_record_unregister_binary(sdp_session_t *session, bdaddr_t *device, uint32_t handle);
+int sdp_device_record_unregister(sdp_session_t *session, bdaddr_t *device, sdp_record_t *rec);
+int sdp_record_unregister(sdp_session_t *session, sdp_record_t *rec);
+
+/*
+ * Update an existing service record.  (Calling this function
+ * before a previous call to sdp_record_register() will result
+ * in an error.)
+ */
+int sdp_device_record_update_binary(sdp_session_t *session, bdaddr_t *device, uint32_t handle, uint8_t *data, uint32_t size);
+int sdp_device_record_update(sdp_session_t *session, bdaddr_t *device, const sdp_record_t *rec);
+int sdp_record_update(sdp_session_t *sess, const sdp_record_t *rec);
+
+void sdp_record_print(const sdp_record_t *rec);
+
+/*
+ * UUID functions
+ */
+uuid_t *sdp_uuid16_create(uuid_t *uuid, uint16_t data);
+uuid_t *sdp_uuid32_create(uuid_t *uuid, uint32_t data);
+uuid_t *sdp_uuid128_create(uuid_t *uuid, const void *data);
+int sdp_uuid16_cmp(const void *p1, const void *p2);
+int sdp_uuid128_cmp(const void *p1, const void *p2);
+int sdp_uuid_cmp(const void *p1, const void *p2);
+uuid_t *sdp_uuid_to_uuid128(const uuid_t *uuid);
+void sdp_uuid16_to_uuid128(uuid_t *uuid128, const uuid_t *uuid16);
+void sdp_uuid32_to_uuid128(uuid_t *uuid128, const uuid_t *uuid32);
+int sdp_uuid128_to_uuid(uuid_t *uuid);
+int sdp_uuid_to_proto(uuid_t *uuid);
+int sdp_uuid_extract(const uint8_t *buffer, int bufsize, uuid_t *uuid, int *scanned);
+void sdp_uuid_print(const uuid_t *uuid);
+
+#define MAX_LEN_UUID_STR 37
+#define MAX_LEN_PROTOCOL_UUID_STR 8
+#define MAX_LEN_SERVICECLASS_UUID_STR 28
+#define MAX_LEN_PROFILEDESCRIPTOR_UUID_STR 28
+
+int sdp_uuid2strn(const uuid_t *uuid, char *str, size_t n);
+int sdp_proto_uuid2strn(const uuid_t *uuid, char *str, size_t n);
+int sdp_svclass_uuid2strn(const uuid_t *uuid, char *str, size_t n);
+int sdp_profile_uuid2strn(const uuid_t *uuid, char *str, size_t n);
+
+/*
+ * In all the sdp_get_XXX(handle, XXX *xxx) functions below,
+ * the XXX * is set to point to the value, should it exist
+ * and 0 is returned. If the value does not exist, -1 is
+ * returned and errno set to ENODATA.
+ *
+ * In all the methods below, the memory management rules are
+ * simple. Don't free anything! The pointer returned, in the
+ * case of constructed types, is a pointer to the contents
+ * of the sdp_record_t.
+ */
+
+/*
+ * Get the access protocols from the service record
+ */
+int sdp_get_access_protos(const sdp_record_t *rec, sdp_list_t **protos);
+
+/*
+ * Get the additional access protocols from the service record
+ */
+int sdp_get_add_access_protos(const sdp_record_t *rec, sdp_list_t **protos);
+
+/*
+ * Extract the list of browse groups to which the service belongs.
+ * When set, seqp contains elements of GroupID (uint16_t)
+ */
+static inline int sdp_get_browse_groups(const sdp_record_t *rec, sdp_list_t **seqp)
+{
+	return sdp_get_uuidseq_attr(rec, SDP_ATTR_BROWSE_GRP_LIST, seqp);
+}
+
+/*
+ * Extract language attribute meta-data of the service record.
+ * For each language in the service record, LangSeq has a struct of type
+ * sdp_lang_attr_t.
+ */
+int sdp_get_lang_attr(const sdp_record_t *rec, sdp_list_t **langSeq);
+
+/*
+ * Extract the Bluetooth profile descriptor sequence from a record.
+ * Each element in the list is of type sdp_profile_desc_t
+ * which contains the UUID of the profile and its version number
+ * (encoded as major and minor in the high-order 8bits
+ * and low-order 8bits respectively of the uint16_t)
+ */
+int sdp_get_profile_descs(const sdp_record_t *rec, sdp_list_t **profDesc);
+
+/*
+ * Extract SDP server version numbers
+ *
+ * Note: that this is an attribute of the SDP server only and
+ * contains a list of uint16_t each of which represent the
+ * major and minor SDP version numbers supported by this server
+ */
+int sdp_get_server_ver(const sdp_record_t *rec, sdp_list_t **pVnumList);
+
+int sdp_get_service_id(const sdp_record_t *rec, uuid_t *uuid);
+int sdp_get_group_id(const sdp_record_t *rec, uuid_t *uuid);
+int sdp_get_record_state(const sdp_record_t *rec, uint32_t *svcRecState);
+int sdp_get_service_avail(const sdp_record_t *rec, uint8_t *svcAvail);
+int sdp_get_service_ttl(const sdp_record_t *rec, uint32_t *svcTTLInfo);
+int sdp_get_database_state(const sdp_record_t *rec, uint32_t *svcDBState);
+
+static inline int sdp_get_service_name(const sdp_record_t *rec, char *str, int len)
+{
+	return sdp_get_string_attr(rec, SDP_ATTR_SVCNAME_PRIMARY, str, len);
+}
+
+static inline int sdp_get_service_desc(const sdp_record_t *rec, char *str, int len)
+{
+	return sdp_get_string_attr(rec, SDP_ATTR_SVCDESC_PRIMARY, str, len);
+}
+
+static inline int sdp_get_provider_name(const sdp_record_t *rec, char *str, int len)
+{
+	return sdp_get_string_attr(rec, SDP_ATTR_PROVNAME_PRIMARY, str, len);
+}
+
+static inline int sdp_get_doc_url(const sdp_record_t *rec, char *str, int len)
+{
+	return sdp_get_string_attr(rec, SDP_ATTR_DOC_URL, str, len);
+}
+
+static inline int sdp_get_clnt_exec_url(const sdp_record_t *rec, char *str, int len)
+{
+	return sdp_get_string_attr(rec, SDP_ATTR_CLNT_EXEC_URL, str, len);
+}
+
+static inline int sdp_get_icon_url(const sdp_record_t *rec, char *str, int len)
+{
+	return sdp_get_string_attr(rec, SDP_ATTR_ICON_URL, str, len);
+}
+
+/*
+ * Set the supported features
+ * sf should be a list of list with each feature data
+ * Returns 0 on success -1 on fail
+ */
+int sdp_set_supp_feat(sdp_record_t *rec, const sdp_list_t *sf);
+
+/*
+ * Get the supported features
+ * seqp is set to a list of list with each feature data
+ * Returns 0 on success, if an error occurred -1 is returned and errno is set
+ */
+int sdp_get_supp_feat(const sdp_record_t *rec, sdp_list_t **seqp);
+
+sdp_record_t *sdp_extract_pdu(const uint8_t *pdata, int bufsize, int *scanned);
+sdp_record_t *sdp_copy_record(sdp_record_t *rec);
+
+void sdp_data_print(sdp_data_t *data);
+void sdp_print_service_attr(sdp_list_t *alist);
+
+int sdp_attrid_comp_func(const void *key1, const void *key2);
+
+void sdp_set_seq_len(uint8_t *ptr, uint32_t length);
+void sdp_set_attrid(sdp_buf_t *pdu, uint16_t id);
+void sdp_append_to_pdu(sdp_buf_t *dst, sdp_data_t *d);
+void sdp_append_to_buf(sdp_buf_t *dst, uint8_t *data, uint32_t len);
+
+int sdp_gen_pdu(sdp_buf_t *pdu, sdp_data_t *data);
+int sdp_gen_record_pdu(const sdp_record_t *rec, sdp_buf_t *pdu);
+
+int sdp_extract_seqtype(const uint8_t *buf, int bufsize, uint8_t *dtdp, int *size);
+
+sdp_data_t *sdp_extract_attr(const uint8_t *pdata, int bufsize, int *extractedLength, sdp_record_t *rec);
+
+void sdp_pattern_add_uuid(sdp_record_t *rec, uuid_t *uuid);
+void sdp_pattern_add_uuidseq(sdp_record_t *rec, sdp_list_t *seq);
+
+int sdp_send_req_w4_rsp(sdp_session_t *session, uint8_t *req, uint8_t *rsp, uint32_t reqsize, uint32_t *rspsize);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SDP_LIB_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/bluetooth/uuid.h b/bootable/recovery/pcba_core/libbluetooth/bluetooth/uuid.h
new file mode 100644
index 0000000000..9c082d3040
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/bluetooth/uuid.h
@@ -0,0 +1,65 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2011  Nokia Corporation
+ *  Copyright (C) 2011  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __BLUETOOTH_UUID_H
+#define __BLUETOOTH_UUID_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <bluetooth/bluetooth.h>
+
+typedef struct {
+	enum {
+		BT_UUID_UNSPEC = 0,
+		BT_UUID16 = 16,
+		BT_UUID32 = 32,
+		BT_UUID128 = 128,
+	} type;
+	union {
+		uint16_t  u16;
+		uint32_t  u32;
+		uint128_t u128;
+	} value;
+} bt_uuid_t;
+
+int bt_uuid16_create(bt_uuid_t *btuuid, uint16_t value);
+int bt_uuid32_create(bt_uuid_t *btuuid, uint32_t value);
+int bt_uuid128_create(bt_uuid_t *btuuid, uint128_t value);
+
+int bt_uuid_cmp(const bt_uuid_t *uuid1, const bt_uuid_t *uuid2);
+void bt_uuid_to_uuid128(const bt_uuid_t *src, bt_uuid_t *dst);
+
+#define MAX_LEN_UUID_STR 37
+
+int bt_uuid_to_string(const bt_uuid_t *uuid, char *str, size_t n);
+int bt_string_to_uuid(bt_uuid_t *uuid, const char *string);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BLUETOOTH_UUID_H */
diff --git a/bootable/recovery/pcba_core/libbluetooth/hci.c b/bootable/recovery/pcba_core/libbluetooth/hci.c
new file mode 100644
index 0000000000..b1223135e5
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/hci.c
@@ -0,0 +1,2913 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/param.h>
+#include <sys/uio.h>
+#include <sys/poll.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+
+#include "bluetooth.h"
+#include "hci.h"
+#include "hci_lib.h"
+
+#ifndef MIN
+#define MIN(x, y) ((x) < (y) ? (x) : (y))
+#endif
+
+typedef struct {
+	char *str;
+	unsigned int val;
+} hci_map;
+
+static char *hci_bit2str(hci_map *m, unsigned int val)
+{
+	char *str = malloc(120);
+	char *ptr = str;
+
+	if (!str)
+		return NULL;
+
+	*ptr = 0;
+	while (m->str) {
+		if ((unsigned int) m->val & val)
+			ptr += sprintf(ptr, "%s ", m->str);
+		m++;
+	}
+	return str;
+}
+
+static int hci_str2bit(hci_map *map, char *str, unsigned int *val)
+{
+	char *t, *ptr;
+	hci_map *m;
+	int set;
+
+	if (!str || !(str = ptr = strdup(str)))
+		return 0;
+
+	*val = set = 0;
+
+	while ((t = strsep(&ptr, ","))) {
+		for (m = map; m->str; m++) {
+			if (!strcasecmp(m->str, t)) {
+				*val |= (unsigned int) m->val;
+				set = 1;
+			}
+		}
+	}
+	free(str);
+
+	return set;
+}
+
+static char *hci_uint2str(hci_map *m, unsigned int val)
+{
+	char *str = malloc(50);
+	char *ptr = str;
+
+	if (!str)
+		return NULL;
+
+	*ptr = 0;
+	while (m->str) {
+		if ((unsigned int) m->val == val) {
+			ptr += sprintf(ptr, "%s", m->str);
+			break;
+		}
+		m++;
+	}
+	return str;
+}
+
+static int hci_str2uint(hci_map *map, char *str, unsigned int *val)
+{
+	char *t, *ptr;
+	hci_map *m;
+	int set = 0;
+
+	if (!str)
+		return 0;
+
+	str = ptr = strdup(str);
+
+	while ((t = strsep(&ptr, ","))) {
+		for (m = map; m->str; m++) {
+			if (!strcasecmp(m->str,t)) {
+				*val = (unsigned int) m->val;
+				set = 1;
+				break;
+			}
+		}
+	}
+	free(str);
+
+	return set;
+}
+
+char *hci_bustostr(int bus)
+{
+	switch (bus) {
+	case HCI_VIRTUAL:
+		return "VIRTUAL";
+	case HCI_USB:
+		return "USB";
+	case HCI_PCCARD:
+		return "PCCARD";
+	case HCI_UART:
+		return "UART";
+	case HCI_RS232:
+		return "RS232";
+	case HCI_PCI:
+		return "PCI";
+	case HCI_SDIO:
+		return "SDIO";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+char *hci_dtypetostr(int type)
+{
+	return hci_bustostr(type & 0x0f);
+}
+
+char *hci_typetostr(int type)
+{
+	switch (type) {
+	case HCI_BREDR:
+		return "BR/EDR";
+	case HCI_AMP:
+		return "AMP";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+/* HCI dev flags mapping */
+static hci_map dev_flags_map[] = {
+	{ "UP",      HCI_UP      },
+	{ "INIT",    HCI_INIT    },
+	{ "RUNNING", HCI_RUNNING },
+	{ "RAW",     HCI_RAW     },
+	{ "PSCAN",   HCI_PSCAN   },
+	{ "ISCAN",   HCI_ISCAN   },
+	{ "INQUIRY", HCI_INQUIRY },
+	{ "AUTH",    HCI_AUTH    },
+	{ "ENCRYPT", HCI_ENCRYPT },
+	{ NULL }
+};
+
+char *hci_dflagstostr(uint32_t flags)
+{
+	char *str = bt_malloc(50);
+	char *ptr = str;
+	hci_map *m = dev_flags_map;
+
+	if (!str)
+		return NULL;
+
+	*ptr = 0;
+
+	if (!hci_test_bit(HCI_UP, &flags))
+		ptr += sprintf(ptr, "DOWN ");
+
+	while (m->str) {
+		if (hci_test_bit(m->val, &flags))
+			ptr += sprintf(ptr, "%s ", m->str);
+		m++;
+	}
+	return str;
+}
+
+/* HCI packet type mapping */
+static hci_map pkt_type_map[] = {
+	{ "DM1",   HCI_DM1  },
+	{ "DM3",   HCI_DM3  },
+	{ "DM5",   HCI_DM5  },
+	{ "DH1",   HCI_DH1  },
+	{ "DH3",   HCI_DH3  },
+	{ "DH5",   HCI_DH5  },
+	{ "HV1",   HCI_HV1  },
+	{ "HV2",   HCI_HV2  },
+	{ "HV3",   HCI_HV3  },
+	{ "2-DH1", HCI_2DH1 },
+	{ "2-DH3", HCI_2DH3 },
+	{ "2-DH5", HCI_2DH5 },
+	{ "3-DH1", HCI_3DH1 },
+	{ "3-DH3", HCI_3DH3 },
+	{ "3-DH5", HCI_3DH5 },
+	{ NULL }
+};
+
+static hci_map sco_ptype_map[] = {
+	{ "HV1",   0x0001   },
+	{ "HV2",   0x0002   },
+	{ "HV3",   0x0004   },
+	{ "EV3",   HCI_EV3  },
+	{ "EV4",   HCI_EV4  },
+	{ "EV5",   HCI_EV5  },
+	{ "2-EV3", HCI_2EV3 },
+	{ "2-EV5", HCI_2EV5 },
+	{ "3-EV3", HCI_3EV3 },
+	{ "3-EV5", HCI_3EV5 },
+	{ NULL }
+};
+
+char *hci_ptypetostr(unsigned int ptype)
+{
+	return hci_bit2str(pkt_type_map, ptype);
+}
+
+int hci_strtoptype(char *str, unsigned int *val)
+{
+	return hci_str2bit(pkt_type_map, str, val);
+}
+
+char *hci_scoptypetostr(unsigned int ptype)
+{
+	return hci_bit2str(sco_ptype_map, ptype);
+}
+
+int hci_strtoscoptype(char *str, unsigned int *val)
+{
+	return hci_str2bit(sco_ptype_map, str, val);
+}
+
+/* Link policy mapping */
+static hci_map link_policy_map[] = {
+	{ "NONE",	0		},
+	{ "RSWITCH",	HCI_LP_RSWITCH	},
+	{ "HOLD",	HCI_LP_HOLD	},
+	{ "SNIFF",	HCI_LP_SNIFF	},
+	{ "PARK",	HCI_LP_PARK	},
+	{ NULL }
+};
+
+char *hci_lptostr(unsigned int lp)
+{
+	return hci_bit2str(link_policy_map, lp);
+}
+
+int hci_strtolp(char *str, unsigned int *val)
+{
+	return hci_str2bit(link_policy_map, str, val);
+}
+
+/* Link mode mapping */
+static hci_map link_mode_map[] = {
+	{ "NONE",	0		},
+	{ "ACCEPT",	HCI_LM_ACCEPT	},
+	{ "MASTER",	HCI_LM_MASTER	},
+	{ "AUTH",	HCI_LM_AUTH	},
+	{ "ENCRYPT",	HCI_LM_ENCRYPT	},
+	{ "TRUSTED",	HCI_LM_TRUSTED	},
+	{ "RELIABLE",	HCI_LM_RELIABLE	},
+	{ "SECURE",	HCI_LM_SECURE	},
+	{ NULL }
+};
+
+char *hci_lmtostr(unsigned int lm)
+{
+	char *s, *str = bt_malloc(50);
+	if (!str)
+		return NULL;
+
+	*str = 0;
+	if (!(lm & HCI_LM_MASTER))
+		strcpy(str, "SLAVE ");
+
+	s = hci_bit2str(link_mode_map, lm);
+	if (!s) {
+		bt_free(str);
+		return NULL;
+	}
+
+	strcat(str, s);
+	free(s);
+	return str;
+}
+
+int hci_strtolm(char *str, unsigned int *val)
+{
+	return hci_str2bit(link_mode_map, str, val);
+}
+
+/* Command mapping */
+static hci_map commands_map[] = {
+	{ "Inquiry",					0   },
+	{ "Inquiry Cancel",				1   },
+	{ "Periodic Inquiry Mode",			2   },
+	{ "Exit Periodic Inquiry Mode",			3   },
+	{ "Create Connection",				4   },
+	{ "Disconnect",					5   },
+	{ "Add SCO Connection",				6   },
+	{ "Cancel Create Connection",			7   },
+
+	{ "Accept Connection Request",			8   },
+	{ "Reject Connection Request",			9   },
+	{ "Link Key Request Reply",			10  },
+	{ "Link Key Request Negative Reply",		11  },
+	{ "PIN Code Request Reply",			12  },
+	{ "PIN Code Request Negative Reply",		13  },
+	{ "Change Connection Packet Type",		14  },
+	{ "Authentication Requested",			15  },
+
+	{ "Set Connection Encryption",			16  },
+	{ "Change Connection Link Key",			17  },
+	{ "Master Link Key",				18  },
+	{ "Remote Name Request",			19  },
+	{ "Cancel Remote Name Request",			20  },
+	{ "Read Remote Supported Features",		21  },
+	{ "Read Remote Extended Features",		22  },
+	{ "Read Remote Version Information",		23  },
+
+	{ "Read Clock Offset",				24  },
+	{ "Read LMP Handle",				25  },
+	{ "Reserved",					26  },
+	{ "Reserved",					27  },
+	{ "Reserved",					28  },
+	{ "Reserved",					29  },
+	{ "Reserved",					30  },
+	{ "Reserved",					31  },
+
+	{ "Reserved",					32  },
+	{ "Hold Mode",					33  },
+	{ "Sniff Mode",					34  },
+	{ "Exit Sniff Mode",				35  },
+	{ "Park State",					36  },
+	{ "Exit Park State",				37  },
+	{ "QoS Setup",					38  },
+	{ "Role Discovery",				39  },
+
+	{ "Switch Role",				40  },
+	{ "Read Link Policy Settings",			41  },
+	{ "Write Link Policy Settings",			42  },
+	{ "Read Default Link Policy Settings",		43  },
+	{ "Write Default Link Policy Settings",		44  },
+	{ "Flow Specification",				45  },
+	{ "Set Event Mask",				46  },
+	{ "Reset",					47  },
+
+	{ "Set Event Filter",				48  },
+	{ "Flush",					49  },
+	{ "Read PIN Type",				50  },
+	{ "Write PIN Type",				51  },
+	{ "Create New Unit Key",			52  },
+	{ "Read Stored Link Key",			53  },
+	{ "Write Stored Link Key",			54  },
+	{ "Delete Stored Link Key",			55  },
+
+	{ "Write Local Name",				56  },
+	{ "Read Local Name",				57  },
+	{ "Read Connection Accept Timeout",		58  },
+	{ "Write Connection Accept Timeout",		59  },
+	{ "Read Page Timeout",				60  },
+	{ "Write Page Timeout",				61  },
+	{ "Read Scan Enable",				62  },
+	{ "Write Scan Enable",				63  },
+
+	{ "Read Page Scan Activity",			64  },
+	{ "Write Page Scan Activity",			65  },
+	{ "Read Inquiry Scan Activity",			66  },
+	{ "Write Inquiry Scan Activity",		67  },
+	{ "Read Authentication Enable",			68  },
+	{ "Write Authentication Enable",		69  },
+	{ "Read Encryption Mode",			70  },
+	{ "Write Encryption Mode",			71  },
+
+	{ "Read Class Of Device",			72  },
+	{ "Write Class Of Device",			73  },
+	{ "Read Voice Setting",				74  },
+	{ "Write Voice Setting",			75  },
+	{ "Read Automatic Flush Timeout",		76  },
+	{ "Write Automatic Flush Timeout",		77  },
+	{ "Read Num Broadcast Retransmissions",		78  },
+	{ "Write Num Broadcast Retransmissions",	79  },
+
+	{ "Read Hold Mode Activity",			80  },
+	{ "Write Hold Mode Activity",			81  },
+	{ "Read Transmit Power Level",			82  },
+	{ "Read Synchronous Flow Control Enable",	83  },
+	{ "Write Synchronous Flow Control Enable",	84  },
+	{ "Set Host Controller To Host Flow Control",	85  },
+	{ "Host Buffer Size",				86  },
+	{ "Host Number Of Completed Packets",		87  },
+
+	{ "Read Link Supervision Timeout",		88  },
+	{ "Write Link Supervision Timeout",		89  },
+	{ "Read Number of Supported IAC",		90  },
+	{ "Read Current IAC LAP",			91  },
+	{ "Write Current IAC LAP",			92  },
+	{ "Read Page Scan Period Mode",			93  },
+	{ "Write Page Scan Period Mode",		94  },
+	{ "Read Page Scan Mode",			95  },
+
+	{ "Write Page Scan Mode",			96  },
+	{ "Set AFH Channel Classification",		97  },
+	{ "Reserved",					98  },
+	{ "Reserved",					99  },
+	{ "Read Inquiry Scan Type",			100 },
+	{ "Write Inquiry Scan Type",			101 },
+	{ "Read Inquiry Mode",				102 },
+	{ "Write Inquiry Mode",				103 },
+
+	{ "Read Page Scan Type",			104 },
+	{ "Write Page Scan Type",			105 },
+	{ "Read AFH Channel Assessment Mode",		106 },
+	{ "Write AFH Channel Assessment Mode",		107 },
+	{ "Reserved",					108 },
+	{ "Reserved",					109 },
+	{ "Reserved",					110 },
+	{ "Reserved",					111 },
+
+	{ "Reserved",					112 },
+	{ "Reserved",					113 },
+	{ "Reserved",					114 },
+	{ "Read Local Version Information",		115 },
+	{ "Read Local Supported Commands",		116 },
+	{ "Read Local Supported Features",		117 },
+	{ "Read Local Extended Features",		118 },
+	{ "Read Buffer Size",				119 },
+
+	{ "Read Country Code",				120 },
+	{ "Read BD ADDR",				121 },
+	{ "Read Failed Contact Counter",		122 },
+	{ "Reset Failed Contact Counter",		123 },
+	{ "Get Link Quality",				124 },
+	{ "Read RSSI",					125 },
+	{ "Read AFH Channel Map",			126 },
+	{ "Read BD Clock",				127 },
+
+	{ "Read Loopback Mode",				128 },
+	{ "Write Loopback Mode",			129 },
+	{ "Enable Device Under Test Mode",		130 },
+	{ "Setup Synchronous Connection",		131 },
+	{ "Accept Synchronous Connection",		132 },
+	{ "Reject Synchronous Connection",		133 },
+	{ "Reserved",					134 },
+	{ "Reserved",					135 },
+
+	{ "Read Extended Inquiry Response",		136 },
+	{ "Write Extended Inquiry Response",		137 },
+	{ "Refresh Encryption Key",			138 },
+	{ "Reserved",					139 },
+	{ "Sniff Subrating",				140 },
+	{ "Read Simple Pairing Mode",			141 },
+	{ "Write Simple Pairing Mode",			142 },
+	{ "Read Local OOB Data",			143 },
+
+	{ "Read Inquiry Response Transmit Power Level",	144 },
+	{ "Write Inquiry Transmit Power Level",		145 },
+	{ "Read Default Erroneous Data Reporting",	146 },
+	{ "Write Default Erroneous Data Reporting",	147 },
+	{ "Reserved",					148 },
+	{ "Reserved",					149 },
+	{ "Reserved",					150 },
+	{ "IO Capability Request Reply",		151 },
+
+	{ "User Confirmation Request Reply",		152 },
+	{ "User Confirmation Request Negative Reply",	153 },
+	{ "User Passkey Request Reply",			154 },
+	{ "User Passkey Request Negative Reply",	155 },
+	{ "Remote OOB Data Request Reply",		156 },
+	{ "Write Simple Pairing Debug Mode",		157 },
+	{ "Enhanced Flush",				158 },
+	{ "Remote OOB Data Request Negative Reply",	159 },
+
+	{ "Reserved",					160 },
+	{ "Reserved",					161 },
+	{ "Send Keypress Notification",			162 },
+	{ "IO Capability Request Negative Reply",	163 },
+	{ "Read Encryption Key Size",			164 },
+	{ "Reserved",					165 },
+	{ "Reserved",					166 },
+	{ "Reserved",					167 },
+
+	{ "Create Physical Link",			168 },
+	{ "Accept Physical Link",			169 },
+	{ "Disconnect Physical Link",			170 },
+	{ "Create Logical Link",			171 },
+	{ "Accept Logical Link",			172 },
+	{ "Disconnect Logical Link",			173 },
+	{ "Logical Link Cancel",			174 },
+	{ "Flow Specification Modify",			175 },
+
+	{ "Read Logical Link Accept Timeout",		176 },
+	{ "Write Logical Link Accept Timeout",		177 },
+	{ "Set Event Mask Page 2",			178 },
+	{ "Read Location Data",				179 },
+	{ "Write Location Data",			180 },
+	{ "Read Local AMP Info",			181 },
+	{ "Read Local AMP_ASSOC",			182 },
+	{ "Write Remote AMP_ASSOC",			183 },
+
+	{ "Read Flow Control Mode",			184 },
+	{ "Write Flow Control Mode",			185 },
+	{ "Read Data Block Size",			186 },
+	{ "Reserved",					187 },
+	{ "Reserved",					188 },
+	{ "Enable AMP Receiver Reports",		189 },
+	{ "AMP Test End",				190 },
+	{ "AMP Test Command",				191 },
+
+	{ "Read Enhanced Transmit Power Level",		192 },
+	{ "Reserved",					193 },
+	{ "Read Best Effort Flush Timeout",		194 },
+	{ "Write Best Effort Flush Timeout",		195 },
+	{ "Short Range Mode",				196 },
+	{ "Read LE Host Support",			197 },
+	{ "Write LE Host Support",			198 },
+	{ "Reserved",					199 },
+
+	{ "LE Set Event Mask",				200 },
+	{ "LE Read Buffer Size",			201 },
+	{ "LE Read Local Supported Features",		202 },
+	{ "Reserved",					203 },
+	{ "LE Set Random Address",			204 },
+	{ "LE Set Advertising Parameters",		205 },
+	{ "LE Read Advertising Channel TX Power",	206 },
+	{ "LE Set Advertising Data",			207 },
+
+	{ "LE Set Scan Response Data",			208 },
+	{ "LE Set Advertise Enable",			209 },
+	{ "LE Set Scan Parameters",			210 },
+	{ "LE Set Scan Enable",				211 },
+	{ "LE Create Connection",			212 },
+	{ "LE Create Connection Cancel",		213 },
+	{ "LE Read White List Size",			214 },
+	{ "LE Clear White List",			215 },
+
+	{ "LE Add Device To White List",		216 },
+	{ "LE Remove Device From White List",		217 },
+	{ "LE Connection Update",			218 },
+	{ "LE Set Host Channel Classification",		219 },
+	{ "LE Read Channel Map",			220 },
+	{ "LE Read Remote Used Features",		221 },
+	{ "LE Encrypt",					222 },
+	{ "LE Rand",					223 },
+
+	{ "LE Start Encryption",			224 },
+	{ "LE Long Term Key Request Reply",		225 },
+	{ "LE Long Term Key Request Negative Reply",	226 },
+	{ "LE Read Supported States",			227 },
+	{ "LE Receiver Test",				228 },
+	{ "LE Transmitter Test",			229 },
+	{ "LE Test End",				230 },
+	{ "Reserved",					231 },
+
+	{ NULL }
+};
+
+char *hci_cmdtostr(unsigned int cmd)
+{
+	return hci_uint2str(commands_map, cmd);
+}
+
+char *hci_commandstostr(uint8_t *commands, char *pref, int width)
+{
+	unsigned int maxwidth = width - 3;
+	hci_map *m;
+	char *off, *ptr, *str;
+	int size = 10;
+
+	m = commands_map;
+
+	while (m->str) {
+		if (commands[m->val / 8] & (1 << (m->val % 8)))
+			size += strlen(m->str) + (pref ? strlen(pref) : 0) + 3;
+		m++;
+	}
+
+	str = bt_malloc(size);
+	if (!str)
+		return NULL;
+
+	ptr = str; *ptr = '\0';
+
+	if (pref)
+		ptr += sprintf(ptr, "%s", pref);
+
+	off = ptr;
+
+	m = commands_map;
+
+	while (m->str) {
+		if (commands[m->val / 8] & (1 << (m->val % 8))) {
+			if (strlen(off) + strlen(m->str) > maxwidth) {
+				ptr += sprintf(ptr, "\n%s", pref ? pref : "");
+				off = ptr;
+			}
+			ptr += sprintf(ptr, "'%s' ", m->str);
+		}
+		m++;
+	}
+
+	return str;
+}
+
+/* Version mapping */
+static hci_map ver_map[] = {
+	{ "1.0b",	0x00 },
+	{ "1.1",	0x01 },
+	{ "1.2",	0x02 },
+	{ "2.0",	0x03 },
+	{ "2.1",	0x04 },
+	{ "3.0",	0x05 },
+	{ "4.0",	0x06 },
+	{ NULL }
+};
+
+char *hci_vertostr(unsigned int ver)
+{
+	return hci_uint2str(ver_map, ver);
+}
+
+int hci_strtover(char *str, unsigned int *ver)
+{
+	return hci_str2uint(ver_map, str, ver);
+}
+
+char *lmp_vertostr(unsigned int ver)
+{
+	return hci_uint2str(ver_map, ver);
+}
+
+int lmp_strtover(char *str, unsigned int *ver)
+{
+	return hci_str2uint(ver_map, str, ver);
+}
+
+/* LMP features mapping */
+static hci_map lmp_features_map[8][9] = {
+	{	/* Byte 0 */
+		{ "<3-slot packets>",	LMP_3SLOT	},	/* Bit 0 */
+		{ "<5-slot packets>",	LMP_5SLOT	},	/* Bit 1 */
+		{ "<encryption>",	LMP_ENCRYPT	},	/* Bit 2 */
+		{ "<slot offset>",	LMP_SOFFSET	},	/* Bit 3 */
+		{ "<timing accuracy>",	LMP_TACCURACY	},	/* Bit 4 */
+		{ "<role switch>",	LMP_RSWITCH	},	/* Bit 5 */
+		{ "<hold mode>",	LMP_HOLD	},	/* Bit 6 */
+		{ "<sniff mode>",	LMP_SNIFF	},	/* Bit 7 */
+		{ NULL }
+	},
+	{	/* Byte 1 */
+		{ "<park state>",	LMP_PARK	},	/* Bit 0 */
+		{ "<RSSI>",		LMP_RSSI	},	/* Bit 1 */
+		{ "<channel quality>",	LMP_QUALITY	},	/* Bit 2 */
+		{ "<SCO link>",		LMP_SCO		},	/* Bit 3 */
+		{ "<HV2 packets>",	LMP_HV2		},	/* Bit 4 */
+		{ "<HV3 packets>",	LMP_HV3		},	/* Bit 5 */
+		{ "<u-law log>",	LMP_ULAW	},	/* Bit 6 */
+		{ "<A-law log>",	LMP_ALAW	},	/* Bit 7 */
+		{ NULL }
+	},
+	{	/* Byte 2 */
+		{ "<CVSD>",		LMP_CVSD	},	/* Bit 0 */
+		{ "<paging scheme>",	LMP_PSCHEME	},	/* Bit 1 */
+		{ "<power control>",	LMP_PCONTROL	},	/* Bit 2 */
+		{ "<transparent SCO>",	LMP_TRSP_SCO	},	/* Bit 3 */
+		{ "<broadcast encrypt>",LMP_BCAST_ENC	},	/* Bit 7 */
+		{ NULL }
+	},
+	{	/* Byte 3 */
+		{ "<no. 24>",		0x01		},	/* Bit 0 */
+		{ "<EDR ACL 2 Mbps>",	LMP_EDR_ACL_2M	},	/* Bit 1 */
+		{ "<EDR ACL 3 Mbps>",	LMP_EDR_ACL_3M	},	/* Bit 2 */
+		{ "<enhanced iscan>",	LMP_ENH_ISCAN	},	/* Bit 3 */
+		{ "<interlaced iscan>",	LMP_ILACE_ISCAN	},	/* Bit 4 */
+		{ "<interlaced pscan>",	LMP_ILACE_PSCAN	},	/* Bit 5 */
+		{ "<inquiry with RSSI>",LMP_RSSI_INQ	},	/* Bit 6 */
+		{ "<extended SCO>",	LMP_ESCO	},	/* Bit 7 */
+		{ NULL }
+	},
+	{	/* Byte 4 */
+		{ "<EV4 packets>",	LMP_EV4		},	/* Bit 0 */
+		{ "<EV5 packets>",	LMP_EV5		},	/* Bit 1 */
+		{ "<no. 34>",		0x04		},	/* Bit 2 */
+		{ "<AFH cap. slave>",	LMP_AFH_CAP_SLV	},	/* Bit 3 */
+		{ "<AFH class. slave>",	LMP_AFH_CLS_SLV	},	/* Bit 4 */
+		{ "<BR/EDR not supp.>",	LMP_NO_BREDR	},	/* Bit 5 */
+		{ "<LE support>",	LMP_LE		},	/* Bit 6 */
+		{ "<3-slot EDR ACL>",	LMP_EDR_3SLOT	},	/* Bit 7 */
+		{ NULL }
+	},
+	{	/* Byte 5 */
+		{ "<5-slot EDR ACL>",	LMP_EDR_5SLOT	},	/* Bit 0 */
+		{ "<sniff subrating>",	LMP_SNIFF_SUBR	},	/* Bit 1 */
+		{ "<pause encryption>",	LMP_PAUSE_ENC	},	/* Bit 2 */
+		{ "<AFH cap. master>",	LMP_AFH_CAP_MST	},	/* Bit 3 */
+		{ "<AFH class. master>",LMP_AFH_CLS_MST	},	/* Bit 4 */
+		{ "<EDR eSCO 2 Mbps>",	LMP_EDR_ESCO_2M	},	/* Bit 5 */
+		{ "<EDR eSCO 3 Mbps>",	LMP_EDR_ESCO_3M	},	/* Bit 6 */
+		{ "<3-slot EDR eSCO>",	LMP_EDR_3S_ESCO	},	/* Bit 7 */
+		{ NULL }
+	},
+	{	/* Byte 6 */
+		{ "<extended inquiry>",	LMP_EXT_INQ	},	/* Bit 0 */
+		{ "<LE and BR/EDR>",	LMP_LE_BREDR	},	/* Bit 1 */
+		{ "<no. 50>",		0x04		},	/* Bit 2 */
+		{ "<simple pairing>",	LMP_SIMPLE_PAIR	},	/* Bit 3 */
+		{ "<encapsulated PDU>",	LMP_ENCAPS_PDU	},	/* Bit 4 */
+		{ "<err. data report>",	LMP_ERR_DAT_REP	},	/* Bit 5 */
+		{ "<non-flush flag>",	LMP_NFLUSH_PKTS	},	/* Bit 6 */
+		{ "<no. 55>",		0x80		},	/* Bit 7 */
+		{ NULL }
+	},
+	{	/* Byte 7 */
+		{ "<LSTO>",		LMP_LSTO	},	/* Bit 1 */
+		{ "<inquiry TX power>",	LMP_INQ_TX_PWR	},	/* Bit 1 */
+		{ "<EPC>",		LMP_EPC		},	/* Bit 2 */
+		{ "<no. 59>",		0x08		},	/* Bit 3 */
+		{ "<no. 60>",		0x10		},	/* Bit 4 */
+		{ "<no. 61>",		0x20		},	/* Bit 5 */
+		{ "<no. 62>",		0x40		},	/* Bit 6 */
+		{ "<extended features>",LMP_EXT_FEAT	},	/* Bit 7 */
+		{ NULL }
+	},
+};
+
+char *lmp_featurestostr(uint8_t *features, char *pref, int width)
+{
+	unsigned int maxwidth = width - 1;
+	char *off, *ptr, *str;
+	int i, size = 10;
+
+	for (i = 0; i < 8; i++) {
+		hci_map *m = lmp_features_map[i];
+
+		while (m->str) {
+			if (m->val & features[i])
+				size += strlen(m->str) +
+						(pref ? strlen(pref) : 0) + 1;
+			m++;
+		}
+	}
+
+	str = bt_malloc(size);
+	if (!str)
+		return NULL;
+
+	ptr = str; *ptr = '\0';
+
+	if (pref)
+		ptr += sprintf(ptr, "%s", pref);
+
+	off = ptr;
+
+	for (i = 0; i < 8; i++) {
+		hci_map *m = lmp_features_map[i];
+
+		while (m->str) {
+			if (m->val & features[i]) {
+				if (strlen(off) + strlen(m->str) > maxwidth) {
+					ptr += sprintf(ptr, "\n%s",
+							pref ? pref : "");
+					off = ptr;
+				}
+				ptr += sprintf(ptr, "%s ", m->str);
+			}
+			m++;
+		}
+	}
+
+	return str;
+}
+
+/* HCI functions that do not require open device */
+int hci_for_each_dev(int flag, int (*func)(int dd, int dev_id, long arg),
+			long arg)
+{
+	struct hci_dev_list_req *dl;
+	struct hci_dev_req *dr;
+	int dev_id = -1;
+	int i, sk, err = 0;
+
+	sk = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
+	if (sk < 0)
+		return -1;
+
+	dl = malloc(HCI_MAX_DEV * sizeof(*dr) + sizeof(*dl));
+	if (!dl) {
+		err = errno;
+		goto done;
+	}
+
+	memset(dl, 0, HCI_MAX_DEV * sizeof(*dr) + sizeof(*dl));
+
+	dl->dev_num = HCI_MAX_DEV;
+	dr = dl->dev_req;
+
+	if (ioctl(sk, HCIGETDEVLIST, (void *) dl) < 0) {
+		err = errno;
+		goto free;
+	}
+
+	for (i = 0; i < dl->dev_num; i++, dr++) {
+		if (hci_test_bit(flag, &dr->dev_opt))
+			if (!func || func(sk, dr->dev_id, arg)) {
+				dev_id = dr->dev_id;
+				break;
+			}
+	}
+
+	if (dev_id < 0)
+		err = ENODEV;
+
+free:
+	free(dl);
+
+done:
+	close(sk);
+	errno = err;
+
+	return dev_id;
+}
+
+static int __other_bdaddr(int dd, int dev_id, long arg)
+{
+	struct hci_dev_info di = { dev_id: dev_id };
+
+	if (ioctl(dd, HCIGETDEVINFO, (void *) &di))
+		return 0;
+
+	if (hci_test_bit(HCI_RAW, &di.flags))
+		return 0;
+
+	return bacmp((bdaddr_t *) arg, &di.bdaddr);
+}
+
+static int __same_bdaddr(int dd, int dev_id, long arg)
+{
+	struct hci_dev_info di = { dev_id: dev_id };
+
+	if (ioctl(dd, HCIGETDEVINFO, (void *) &di))
+		return 0;
+
+	return !bacmp((bdaddr_t *) arg, &di.bdaddr);
+}
+
+int hci_get_route(bdaddr_t *bdaddr)
+{
+	return hci_for_each_dev(HCI_UP, __other_bdaddr,
+				(long) (bdaddr ? bdaddr : BDADDR_ANY));
+}
+
+int hci_devid(const char *str)
+{
+	bdaddr_t ba;
+	int id = -1;
+
+	if (!strncmp(str, "hci", 3) && strlen(str) >= 4) {
+		id = atoi(str + 3);
+		if (hci_devba(id, &ba) < 0)
+			return -1;
+	} else {
+		errno = ENODEV;
+		str2ba(str, &ba);
+		id = hci_for_each_dev(HCI_UP, __same_bdaddr, (long) &ba);
+	}
+
+	return id;
+}
+
+int hci_devinfo(int dev_id, struct hci_dev_info *di)
+{
+	int dd, err, ret;
+
+	dd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
+	if (dd < 0)
+		return dd;
+
+	memset(di, 0, sizeof(struct hci_dev_info));
+
+	di->dev_id = dev_id;
+	ret = ioctl(dd, HCIGETDEVINFO, (void *) di);
+
+	err = errno;
+	close(dd);
+	errno = err;
+
+	return ret;
+}
+
+int hci_devba(int dev_id, bdaddr_t *bdaddr)
+{
+	struct hci_dev_info di;
+
+	memset(&di, 0, sizeof(di));
+
+	if (hci_devinfo(dev_id, &di))
+		return -1;
+
+	if (!hci_test_bit(HCI_UP, &di.flags)) {
+		errno = ENETDOWN;
+		return -1;
+	}
+
+	bacpy(bdaddr, &di.bdaddr);
+
+	return 0;
+}
+
+int hci_inquiry(int dev_id, int len, int nrsp, const uint8_t *lap,
+		inquiry_info **ii, long flags)
+{
+	struct hci_inquiry_req *ir;
+	uint8_t num_rsp = nrsp;
+	void *buf;
+	int dd, size, err, ret = -1;
+
+	if (nrsp <= 0) {
+		num_rsp = 0;
+		nrsp = 255;
+	}
+
+	if (dev_id < 0) {
+		dev_id = hci_get_route(NULL);
+		if (dev_id < 0) {
+			errno = ENODEV;
+			return -1;
+		}
+	}
+
+	dd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
+	if (dd < 0)
+		return dd;
+
+	buf = malloc(sizeof(*ir) + (sizeof(inquiry_info) * (nrsp)));
+	if (!buf)
+		goto done;
+
+	ir = buf;
+	ir->dev_id  = dev_id;
+	ir->num_rsp = num_rsp;
+	ir->length  = len;
+	ir->flags   = flags;
+
+	if (lap) {
+		memcpy(ir->lap, lap, 3);
+	} else {
+		ir->lap[0] = 0x33;
+		ir->lap[1] = 0x8b;
+		ir->lap[2] = 0x9e;
+	}
+
+	ret = ioctl(dd, HCIINQUIRY, (unsigned long) buf);
+	if (ret < 0)
+		goto free;
+
+	size = sizeof(inquiry_info) * ir->num_rsp;
+
+	if (!*ii)
+		*ii = malloc(size);
+
+	if (*ii) {
+		memcpy((void *) *ii, buf + sizeof(*ir), size);
+		ret = ir->num_rsp;
+	} else
+		ret = -1;
+
+free:
+	free(buf);
+
+done:
+	err = errno;
+	close(dd);
+	errno = err;
+
+	return ret;
+}
+
+/* Open HCI device.
+ * Returns device descriptor (dd). */
+int hci_open_dev(int dev_id)
+{
+	struct sockaddr_hci a;
+	int dd, err;
+
+	/* Create HCI socket */
+	dd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
+	if (dd < 0)
+		return dd;
+
+	/* Bind socket to the HCI device */
+	memset(&a, 0, sizeof(a));
+	a.hci_family = AF_BLUETOOTH;
+	a.hci_dev = dev_id;
+	if (bind(dd, (struct sockaddr *) &a, sizeof(a)) < 0)
+		goto failed;
+
+	return dd;
+
+failed:
+	err = errno;
+	close(dd);
+	errno = err;
+
+	return -1;
+}
+
+int hci_close_dev(int dd)
+{
+	return close(dd);
+}
+
+/* HCI functions that require open device
+ * dd - Device descriptor returned by hci_open_dev. */
+
+int hci_send_cmd(int dd, uint16_t ogf, uint16_t ocf, uint8_t plen, void *param)
+{
+	uint8_t type = HCI_COMMAND_PKT;
+	hci_command_hdr hc;
+	struct iovec iv[3];
+	int ivn;
+
+	hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
+	hc.plen= plen;
+
+	iv[0].iov_base = &type;
+	iv[0].iov_len  = 1;
+	iv[1].iov_base = &hc;
+	iv[1].iov_len  = HCI_COMMAND_HDR_SIZE;
+	ivn = 2;
+
+	if (plen) {
+		iv[2].iov_base = param;
+		iv[2].iov_len  = plen;
+		ivn = 3;
+	}
+
+	while (writev(dd, iv, ivn) < 0) {
+		if (errno == EAGAIN || errno == EINTR)
+			continue;
+		return -1;
+	}
+	return 0;
+}
+
+int hci_send_req(int dd, struct hci_request *r, int to)
+{
+	unsigned char buf[HCI_MAX_EVENT_SIZE], *ptr;
+	uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
+	struct hci_filter nf, of;
+	socklen_t olen;
+	hci_event_hdr *hdr;
+	int err, try;
+
+	olen = sizeof(of);
+	if (getsockopt(dd, SOL_HCI, HCI_FILTER, &of, &olen) < 0)
+		return -1;
+
+	hci_filter_clear(&nf);
+	hci_filter_set_ptype(HCI_EVENT_PKT,  &nf);
+	hci_filter_set_event(EVT_CMD_STATUS, &nf);
+	hci_filter_set_event(EVT_CMD_COMPLETE, &nf);
+	hci_filter_set_event(EVT_LE_META_EVENT, &nf);
+	hci_filter_set_event(r->event, &nf);
+	hci_filter_set_opcode(opcode, &nf);
+	if (setsockopt(dd, SOL_HCI, HCI_FILTER, &nf, sizeof(nf)) < 0)
+		return -1;
+
+	if (hci_send_cmd(dd, r->ogf, r->ocf, r->clen, r->cparam) < 0)
+		goto failed;
+
+	try = 10;
+	while (try--) {
+		evt_cmd_complete *cc;
+		evt_cmd_status *cs;
+		evt_remote_name_req_complete *rn;
+		evt_le_meta_event *me;
+		remote_name_req_cp *cp;
+		int len;
+
+		if (to) {
+			struct pollfd p;
+			int n;
+
+			p.fd = dd; p.events = POLLIN;
+			while ((n = poll(&p, 1, to)) < 0) {
+				if (errno == EAGAIN || errno == EINTR)
+					continue;
+				goto failed;
+			}
+
+			if (!n) {
+				errno = ETIMEDOUT;
+				goto failed;
+			}
+
+			to -= 10;
+			if (to < 0)
+				to = 0;
+
+		}
+
+		while ((len = read(dd, buf, sizeof(buf))) < 0) {
+			if (errno == EAGAIN || errno == EINTR)
+				continue;
+			goto failed;
+		}
+
+		hdr = (void *) (buf + 1);
+		ptr = buf + (1 + HCI_EVENT_HDR_SIZE);
+		len -= (1 + HCI_EVENT_HDR_SIZE);
+
+		switch (hdr->evt) {
+		case EVT_CMD_STATUS:
+			cs = (void *) ptr;
+
+			if (cs->opcode != opcode)
+				continue;
+
+			if (r->event != EVT_CMD_STATUS) {
+				if (cs->status) {
+					errno = EIO;
+					goto failed;
+				}
+				break;
+			}
+
+			r->rlen = MIN(len, r->rlen);
+			memcpy(r->rparam, ptr, r->rlen);
+			goto done;
+
+		case EVT_CMD_COMPLETE:
+			cc = (void *) ptr;
+
+			if (cc->opcode != opcode)
+				continue;
+
+			ptr += EVT_CMD_COMPLETE_SIZE;
+			len -= EVT_CMD_COMPLETE_SIZE;
+
+			r->rlen = MIN(len, r->rlen);
+			memcpy(r->rparam, ptr, r->rlen);
+			goto done;
+
+		case EVT_REMOTE_NAME_REQ_COMPLETE:
+			if (hdr->evt != r->event)
+				break;
+
+			rn = (void *) ptr;
+			cp = r->cparam;
+
+			if (bacmp(&rn->bdaddr, &cp->bdaddr))
+				continue;
+
+			r->rlen = MIN(len, r->rlen);
+			memcpy(r->rparam, ptr, r->rlen);
+			goto done;
+
+		case EVT_LE_META_EVENT:
+			me = (void *) ptr;
+
+			if (me->subevent != r->event)
+				continue;
+
+			len -= 1;
+			r->rlen = MIN(len, r->rlen);
+			memcpy(r->rparam, me->data, r->rlen);
+			goto done;
+
+		default:
+			if (hdr->evt != r->event)
+				break;
+
+			r->rlen = MIN(len, r->rlen);
+			memcpy(r->rparam, ptr, r->rlen);
+			goto done;
+		}
+	}
+	errno = ETIMEDOUT;
+
+failed:
+	err = errno;
+	setsockopt(dd, SOL_HCI, HCI_FILTER, &of, sizeof(of));
+	errno = err;
+	return -1;
+
+done:
+	setsockopt(dd, SOL_HCI, HCI_FILTER, &of, sizeof(of));
+	return 0;
+}
+
+int hci_create_connection(int dd, const bdaddr_t *bdaddr, uint16_t ptype,
+				uint16_t clkoffset, uint8_t rswitch,
+				uint16_t *handle, int to)
+{
+	evt_conn_complete rp;
+	create_conn_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	bacpy(&cp.bdaddr, bdaddr);
+	cp.pkt_type       = ptype;
+	cp.pscan_rep_mode = 0x02;
+	cp.clock_offset   = clkoffset;
+	cp.role_switch    = rswitch;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_CREATE_CONN;
+	rq.event  = EVT_CONN_COMPLETE;
+	rq.cparam = &cp;
+	rq.clen   = CREATE_CONN_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_CONN_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*handle = rp.handle;
+	return 0;
+}
+
+int hci_disconnect(int dd, uint16_t handle, uint8_t reason, int to)
+{
+	evt_disconn_complete rp;
+	disconnect_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle = handle;
+	cp.reason = reason;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_DISCONNECT;
+	rq.event  = EVT_DISCONN_COMPLETE;
+	rq.cparam = &cp;
+	rq.clen   = DISCONNECT_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_DISCONN_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+	return 0;
+}
+
+int hci_le_add_white_list(int dd, const bdaddr_t *bdaddr, uint8_t type, int to)
+{
+	struct hci_request rq;
+	le_add_device_to_white_list_cp cp;
+	uint8_t status;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.bdaddr_type = type;
+	bacpy(&cp.bdaddr, bdaddr);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf = OGF_LE_CTL;
+	rq.ocf = OCF_LE_ADD_DEVICE_TO_WHITE_LIST;
+	rq.cparam = &cp;
+	rq.clen = LE_ADD_DEVICE_TO_WHITE_LIST_CP_SIZE;
+	rq.rparam = &status;
+	rq.rlen = 1;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_le_rm_white_list(int dd, const bdaddr_t *bdaddr, uint8_t type, int to)
+{
+	struct hci_request rq;
+	le_remove_device_from_white_list_cp cp;
+	uint8_t status;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.bdaddr_type = type;
+	bacpy(&cp.bdaddr, bdaddr);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf = OGF_LE_CTL;
+	rq.ocf = OCF_LE_REMOVE_DEVICE_FROM_WHITE_LIST;
+	rq.cparam = &cp;
+	rq.clen = LE_REMOVE_DEVICE_FROM_WHITE_LIST_CP_SIZE;
+	rq.rparam = &status;
+	rq.rlen = 1;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_le_read_white_list_size(int dd, uint8_t *size, int to)
+{
+	struct hci_request rq;
+	le_read_white_list_size_rp rp;
+
+	memset(&rp, 0, sizeof(rp));
+	memset(&rq, 0, sizeof(rq));
+
+	rq.ogf = OGF_LE_CTL;
+	rq.ocf = OCF_LE_READ_WHITE_LIST_SIZE;
+	rq.rparam = &rp;
+	rq.rlen = LE_READ_WHITE_LIST_SIZE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	if (size)
+		*size = rp.size;
+
+	return 0;
+}
+
+int hci_le_clear_white_list(int dd, int to)
+{
+	struct hci_request rq;
+	uint8_t status;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf = OGF_LE_CTL;
+	rq.ocf = OCF_LE_CLEAR_WHITE_LIST;
+	rq.rparam = &status;
+	rq.rlen = 1;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_local_name(int dd, int len, char *name, int to)
+{
+	read_local_name_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_LOCAL_NAME;
+	rq.rparam = &rp;
+	rq.rlen   = READ_LOCAL_NAME_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	rp.name[247] = '\0';
+	strncpy(name, (char *) rp.name, len);
+	return 0;
+}
+
+int hci_write_local_name(int dd, const char *name, int to)
+{
+	change_local_name_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	strncpy((char *) cp.name, name, sizeof(cp.name));
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_CHANGE_LOCAL_NAME;
+	rq.cparam = &cp;
+	rq.clen   = CHANGE_LOCAL_NAME_CP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	return 0;
+}
+
+int hci_read_remote_name_with_clock_offset(int dd, const bdaddr_t *bdaddr,
+						uint8_t pscan_rep_mode,
+						uint16_t clkoffset,
+						int len, char *name, int to)
+{
+	evt_remote_name_req_complete rn;
+	remote_name_req_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	bacpy(&cp.bdaddr, bdaddr);
+	cp.pscan_rep_mode = pscan_rep_mode;
+	cp.clock_offset   = clkoffset;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_REMOTE_NAME_REQ;
+	rq.cparam = &cp;
+	rq.clen   = REMOTE_NAME_REQ_CP_SIZE;
+	rq.event  = EVT_REMOTE_NAME_REQ_COMPLETE;
+	rq.rparam = &rn;
+	rq.rlen   = EVT_REMOTE_NAME_REQ_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rn.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	rn.name[247] = '\0';
+	strncpy(name, (char *) rn.name, len);
+	return 0;
+}
+
+int hci_read_remote_name(int dd, const bdaddr_t *bdaddr, int len, char *name,
+				int to)
+{
+	return hci_read_remote_name_with_clock_offset(dd, bdaddr, 0x02, 0x0000,
+							len, name, to);
+}
+
+int hci_read_remote_name_cancel(int dd, const bdaddr_t *bdaddr, int to)
+{
+	remote_name_req_cancel_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	bacpy(&cp.bdaddr, bdaddr);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_REMOTE_NAME_REQ_CANCEL;
+	rq.cparam = &cp;
+	rq.clen   = REMOTE_NAME_REQ_CANCEL_CP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	return 0;
+}
+
+int hci_read_remote_version(int dd, uint16_t handle, struct hci_version *ver,
+				int to)
+{
+	evt_read_remote_version_complete rp;
+	read_remote_version_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle = handle;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_READ_REMOTE_VERSION;
+	rq.event  = EVT_READ_REMOTE_VERSION_COMPLETE;
+	rq.cparam = &cp;
+	rq.clen   = READ_REMOTE_VERSION_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_READ_REMOTE_VERSION_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	ver->manufacturer = btohs(rp.manufacturer);
+	ver->lmp_ver      = rp.lmp_ver;
+	ver->lmp_subver   = btohs(rp.lmp_subver);
+	return 0;
+}
+
+int hci_read_remote_features(int dd, uint16_t handle, uint8_t *features, int to)
+{
+	evt_read_remote_features_complete rp;
+	read_remote_features_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle = handle;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_READ_REMOTE_FEATURES;
+	rq.event  = EVT_READ_REMOTE_FEATURES_COMPLETE;
+	rq.cparam = &cp;
+	rq.clen   = READ_REMOTE_FEATURES_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_READ_REMOTE_FEATURES_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	if (features)
+		memcpy(features, rp.features, 8);
+
+	return 0;
+}
+
+int hci_read_remote_ext_features(int dd, uint16_t handle, uint8_t page,
+					uint8_t *max_page, uint8_t *features,
+					int to)
+{
+	evt_read_remote_ext_features_complete rp;
+	read_remote_ext_features_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle   = handle;
+	cp.page_num = page;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_READ_REMOTE_EXT_FEATURES;
+	rq.event  = EVT_READ_REMOTE_EXT_FEATURES_COMPLETE;
+	rq.cparam = &cp;
+	rq.clen   = READ_REMOTE_EXT_FEATURES_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_READ_REMOTE_EXT_FEATURES_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	if (max_page)
+		*max_page = rp.max_page_num;
+
+	if (features)
+		memcpy(features, rp.features, 8);
+
+	return 0;
+}
+
+int hci_read_clock_offset(int dd, uint16_t handle, uint16_t *clkoffset, int to)
+{
+	evt_read_clock_offset_complete rp;
+	read_clock_offset_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle = handle;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_READ_CLOCK_OFFSET;
+	rq.event  = EVT_READ_CLOCK_OFFSET_COMPLETE;
+	rq.cparam = &cp;
+	rq.clen   = READ_CLOCK_OFFSET_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_READ_CLOCK_OFFSET_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*clkoffset = rp.clock_offset;
+	return 0;
+}
+
+int hci_read_local_version(int dd, struct hci_version *ver, int to)
+{
+	read_local_version_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_INFO_PARAM;
+	rq.ocf    = OCF_READ_LOCAL_VERSION;
+	rq.rparam = &rp;
+	rq.rlen   = READ_LOCAL_VERSION_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	ver->manufacturer = btohs(rp.manufacturer);
+	ver->hci_ver      = rp.hci_ver;
+	ver->hci_rev      = btohs(rp.hci_rev);
+	ver->lmp_ver      = rp.lmp_ver;
+	ver->lmp_subver   = btohs(rp.lmp_subver);
+	return 0;
+}
+
+int hci_read_local_commands(int dd, uint8_t *commands, int to)
+{
+	read_local_commands_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_INFO_PARAM;
+	rq.ocf    = OCF_READ_LOCAL_COMMANDS;
+	rq.rparam = &rp;
+	rq.rlen   = READ_LOCAL_COMMANDS_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	if (commands)
+		memcpy(commands, rp.commands, 64);
+
+	return 0;
+}
+
+int hci_read_local_features(int dd, uint8_t *features, int to)
+{
+	read_local_features_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_INFO_PARAM;
+	rq.ocf    = OCF_READ_LOCAL_FEATURES;
+	rq.rparam = &rp;
+	rq.rlen   = READ_LOCAL_FEATURES_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	if (features)
+		memcpy(features, rp.features, 8);
+
+	return 0;
+}
+
+int hci_read_local_ext_features(int dd, uint8_t page, uint8_t *max_page,
+				uint8_t *features, int to)
+{
+	read_local_ext_features_cp cp;
+	read_local_ext_features_rp rp;
+	struct hci_request rq;
+
+	cp.page_num = page;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_INFO_PARAM;
+	rq.ocf    = OCF_READ_LOCAL_EXT_FEATURES;
+	rq.cparam = &cp;
+	rq.clen   = READ_LOCAL_EXT_FEATURES_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = READ_LOCAL_EXT_FEATURES_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	if (max_page)
+		*max_page = rp.max_page_num;
+
+	if (features)
+		memcpy(features, rp.features, 8);
+
+	return 0;
+}
+
+int hci_read_bd_addr(int dd, bdaddr_t *bdaddr, int to)
+{
+	read_bd_addr_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_INFO_PARAM;
+	rq.ocf    = OCF_READ_BD_ADDR;
+	rq.rparam = &rp;
+	rq.rlen   = READ_BD_ADDR_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	if (bdaddr)
+		bacpy(bdaddr, &rp.bdaddr);
+
+	return 0;
+}
+
+int hci_read_class_of_dev(int dd, uint8_t *cls, int to)
+{
+	read_class_of_dev_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_CLASS_OF_DEV;
+	rq.rparam = &rp;
+	rq.rlen   = READ_CLASS_OF_DEV_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	memcpy(cls, rp.dev_class, 3);
+	return 0;
+}
+
+int hci_write_class_of_dev(int dd, uint32_t cls, int to)
+{
+	write_class_of_dev_cp cp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	cp.dev_class[0] = cls & 0xff;
+	cp.dev_class[1] = (cls >> 8) & 0xff;
+	cp.dev_class[2] = (cls >> 16) & 0xff;
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_CLASS_OF_DEV;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_CLASS_OF_DEV_CP_SIZE;
+	return hci_send_req(dd, &rq, to);
+}
+
+int hci_read_voice_setting(int dd, uint16_t *vs, int to)
+{
+	read_voice_setting_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_VOICE_SETTING;
+	rq.rparam = &rp;
+	rq.rlen   = READ_VOICE_SETTING_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*vs = rp.voice_setting;
+	return 0;
+}
+
+int hci_write_voice_setting(int dd, uint16_t vs, int to)
+{
+	write_voice_setting_cp cp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	cp.voice_setting = vs;
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_VOICE_SETTING;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_VOICE_SETTING_CP_SIZE;
+
+	return hci_send_req(dd, &rq, to);
+}
+
+int hci_read_current_iac_lap(int dd, uint8_t *num_iac, uint8_t *lap, int to)
+{
+	read_current_iac_lap_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_CURRENT_IAC_LAP;
+	rq.rparam = &rp;
+	rq.rlen   = READ_CURRENT_IAC_LAP_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*num_iac = rp.num_current_iac;
+	memcpy(lap, rp.lap, rp.num_current_iac * 3);
+	return 0;
+}
+
+int hci_write_current_iac_lap(int dd, uint8_t num_iac, uint8_t *lap, int to)
+{
+	write_current_iac_lap_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.num_current_iac = num_iac;
+	memcpy(&cp.lap, lap, num_iac * 3);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_CURRENT_IAC_LAP;
+	rq.cparam = &cp;
+	rq.clen   = num_iac * 3 + 1;
+
+	return hci_send_req(dd, &rq, to);
+}
+
+int hci_read_stored_link_key(int dd, bdaddr_t *bdaddr, uint8_t all, int to)
+{
+	read_stored_link_key_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	bacpy(&cp.bdaddr, bdaddr);
+	cp.read_all = all;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_STORED_LINK_KEY;
+	rq.cparam = &cp;
+	rq.clen   = READ_STORED_LINK_KEY_CP_SIZE;
+
+	return hci_send_req(dd, &rq, to);
+}
+
+int hci_write_stored_link_key(int dd, bdaddr_t *bdaddr, uint8_t *key, int to)
+{
+	unsigned char cp[WRITE_STORED_LINK_KEY_CP_SIZE + 6 + 16];
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp[0] = 1;
+	bacpy((bdaddr_t *) (cp + 1), bdaddr);
+	memcpy(cp + 7, key, 16);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_STORED_LINK_KEY;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_STORED_LINK_KEY_CP_SIZE + 6 + 16;
+
+	return hci_send_req(dd, &rq, to);
+}
+
+int hci_delete_stored_link_key(int dd, bdaddr_t *bdaddr, uint8_t all, int to)
+{
+	delete_stored_link_key_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	bacpy(&cp.bdaddr, bdaddr);
+	cp.delete_all = all;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_DELETE_STORED_LINK_KEY;
+	rq.cparam = &cp;
+	rq.clen   = DELETE_STORED_LINK_KEY_CP_SIZE;
+
+	return hci_send_req(dd, &rq, to);
+}
+
+int hci_authenticate_link(int dd, uint16_t handle, int to)
+{
+	auth_requested_cp cp;
+	evt_auth_complete rp;
+	struct hci_request rq;
+
+	cp.handle = handle;
+
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_AUTH_REQUESTED;
+	rq.event  = EVT_AUTH_COMPLETE;
+	rq.cparam = &cp;
+	rq.clen   = AUTH_REQUESTED_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_AUTH_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_encrypt_link(int dd, uint16_t handle, uint8_t encrypt, int to)
+{
+	set_conn_encrypt_cp cp;
+	evt_encrypt_change rp;
+	struct hci_request rq;
+
+	cp.handle  = handle;
+	cp.encrypt = encrypt;
+
+	rq.ogf     = OGF_LINK_CTL;
+	rq.ocf     = OCF_SET_CONN_ENCRYPT;
+	rq.event   = EVT_ENCRYPT_CHANGE;
+	rq.cparam  = &cp;
+	rq.clen    = SET_CONN_ENCRYPT_CP_SIZE;
+	rq.rparam  = &rp;
+	rq.rlen    = EVT_ENCRYPT_CHANGE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_change_link_key(int dd, uint16_t handle, int to)
+{
+	change_conn_link_key_cp cp;
+	evt_change_conn_link_key_complete rp;
+	struct hci_request rq;
+
+	cp.handle = handle;
+
+	rq.ogf    = OGF_LINK_CTL;
+	rq.ocf    = OCF_CHANGE_CONN_LINK_KEY;
+	rq.event  = EVT_CHANGE_CONN_LINK_KEY_COMPLETE;
+	rq.cparam = &cp;
+	rq.clen   = CHANGE_CONN_LINK_KEY_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_CHANGE_CONN_LINK_KEY_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_switch_role(int dd, bdaddr_t *bdaddr, uint8_t role, int to)
+{
+	switch_role_cp cp;
+	evt_role_change rp;
+	struct hci_request rq;
+
+	bacpy(&cp.bdaddr, bdaddr);
+	cp.role   = role;
+	rq.ogf    = OGF_LINK_POLICY;
+	rq.ocf    = OCF_SWITCH_ROLE;
+	rq.cparam = &cp;
+	rq.clen   = SWITCH_ROLE_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_ROLE_CHANGE_SIZE;
+	rq.event  = EVT_ROLE_CHANGE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_park_mode(int dd, uint16_t handle, uint16_t max_interval,
+			uint16_t min_interval, int to)
+{
+	park_mode_cp cp;
+	evt_mode_change rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof (cp));
+	cp.handle       = handle;
+	cp.max_interval = max_interval;
+	cp.min_interval = min_interval;
+
+	memset(&rq, 0, sizeof (rq));
+	rq.ogf    = OGF_LINK_POLICY;
+	rq.ocf    = OCF_PARK_MODE;
+	rq.event  = EVT_MODE_CHANGE;
+	rq.cparam = &cp;
+	rq.clen   = PARK_MODE_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_MODE_CHANGE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_exit_park_mode(int dd, uint16_t handle, int to)
+{
+	exit_park_mode_cp cp;
+	evt_mode_change rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof (cp));
+	cp.handle = handle;
+
+	memset (&rq, 0, sizeof (rq));
+	rq.ogf    = OGF_LINK_POLICY;
+	rq.ocf    = OCF_EXIT_PARK_MODE;
+	rq.event  = EVT_MODE_CHANGE;
+	rq.cparam = &cp;
+	rq.clen   = EXIT_PARK_MODE_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = EVT_MODE_CHANGE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_inquiry_scan_type(int dd, uint8_t *type, int to)
+{
+	read_inquiry_scan_type_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_INQUIRY_SCAN_TYPE;
+	rq.rparam = &rp;
+	rq.rlen   = READ_INQUIRY_SCAN_TYPE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*type = rp.type;
+	return 0;
+}
+
+int hci_write_inquiry_scan_type(int dd, uint8_t type, int to)
+{
+	write_inquiry_scan_type_cp cp;
+	write_inquiry_scan_type_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.type = type;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_INQUIRY_SCAN_TYPE;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_INQUIRY_SCAN_TYPE_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = WRITE_INQUIRY_SCAN_TYPE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_inquiry_mode(int dd, uint8_t *mode, int to)
+{
+	read_inquiry_mode_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_INQUIRY_MODE;
+	rq.rparam = &rp;
+	rq.rlen   = READ_INQUIRY_MODE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*mode = rp.mode;
+	return 0;
+}
+
+int hci_write_inquiry_mode(int dd, uint8_t mode, int to)
+{
+	write_inquiry_mode_cp cp;
+	write_inquiry_mode_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.mode = mode;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_INQUIRY_MODE;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_INQUIRY_MODE_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = WRITE_INQUIRY_MODE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_afh_mode(int dd, uint8_t *mode, int to)
+{
+	read_afh_mode_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_AFH_MODE;
+	rq.rparam = &rp;
+	rq.rlen   = READ_AFH_MODE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*mode = rp.mode;
+	return 0;
+}
+
+int hci_write_afh_mode(int dd, uint8_t mode, int to)
+{
+	write_afh_mode_cp cp;
+	write_afh_mode_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.mode = mode;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_AFH_MODE;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_AFH_MODE_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = WRITE_AFH_MODE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_ext_inquiry_response(int dd, uint8_t *fec, uint8_t *data, int to)
+{
+	read_ext_inquiry_response_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_EXT_INQUIRY_RESPONSE;
+	rq.rparam = &rp;
+	rq.rlen   = READ_EXT_INQUIRY_RESPONSE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*fec = rp.fec;
+	memcpy(data, rp.data, HCI_MAX_EIR_LENGTH);
+
+	return 0;
+}
+
+int hci_write_ext_inquiry_response(int dd, uint8_t fec, uint8_t *data, int to)
+{
+	write_ext_inquiry_response_cp cp;
+	write_ext_inquiry_response_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.fec = fec;
+	memcpy(cp.data, data, HCI_MAX_EIR_LENGTH);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_EXT_INQUIRY_RESPONSE;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_EXT_INQUIRY_RESPONSE_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = WRITE_EXT_INQUIRY_RESPONSE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_simple_pairing_mode(int dd, uint8_t *mode, int to)
+{
+	read_simple_pairing_mode_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_SIMPLE_PAIRING_MODE;
+	rq.rparam = &rp;
+	rq.rlen   = READ_SIMPLE_PAIRING_MODE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*mode = rp.mode;
+	return 0;
+}
+
+int hci_write_simple_pairing_mode(int dd, uint8_t mode, int to)
+{
+	write_simple_pairing_mode_cp cp;
+	write_simple_pairing_mode_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.mode = mode;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_SIMPLE_PAIRING_MODE;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_SIMPLE_PAIRING_MODE_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = WRITE_SIMPLE_PAIRING_MODE_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_local_oob_data(int dd, uint8_t *hash, uint8_t *randomizer, int to)
+{
+	read_local_oob_data_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_LOCAL_OOB_DATA;
+	rq.rparam = &rp;
+	rq.rlen   = READ_LOCAL_OOB_DATA_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	memcpy(hash, rp.hash, 16);
+	memcpy(randomizer, rp.randomizer, 16);
+	return 0;
+}
+
+int hci_read_inq_response_tx_power_level(int dd, int8_t *level, int to)
+{
+	read_inq_response_tx_power_level_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_INQ_RESPONSE_TX_POWER_LEVEL;
+	rq.rparam = &rp;
+	rq.rlen   = READ_INQ_RESPONSE_TX_POWER_LEVEL_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*level = rp.level;
+	return 0;
+}
+
+int hci_read_inquiry_transmit_power_level(int dd, int8_t *level, int to)
+{
+	return hci_read_inq_response_tx_power_level(dd, level, to);
+}
+
+int hci_write_inquiry_transmit_power_level(int dd, int8_t level, int to)
+{
+	write_inquiry_transmit_power_level_cp cp;
+	write_inquiry_transmit_power_level_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.level = level;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_INQUIRY_TRANSMIT_POWER_LEVEL_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = WRITE_INQUIRY_TRANSMIT_POWER_LEVEL_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_transmit_power_level(int dd, uint16_t handle, uint8_t type,
+					int8_t *level, int to)
+{
+	read_transmit_power_level_cp cp;
+	read_transmit_power_level_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle = handle;
+	cp.type   = type;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_TRANSMIT_POWER_LEVEL;
+	rq.cparam = &cp;
+	rq.clen   = READ_TRANSMIT_POWER_LEVEL_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = READ_TRANSMIT_POWER_LEVEL_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*level = rp.level;
+	return 0;
+}
+
+int hci_read_link_policy(int dd, uint16_t handle, uint16_t *policy, int to)
+{
+	read_link_policy_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_POLICY;
+	rq.ocf    = OCF_READ_LINK_POLICY;
+	rq.cparam = &handle;
+	rq.clen   = 2;
+	rq.rparam = &rp;
+	rq.rlen   = READ_LINK_POLICY_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*policy = rp.policy;
+	return 0;
+}
+
+int hci_write_link_policy(int dd, uint16_t handle, uint16_t policy, int to)
+{
+	write_link_policy_cp cp;
+	write_link_policy_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle = handle;
+	cp.policy = policy;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_LINK_POLICY;
+	rq.ocf    = OCF_WRITE_LINK_POLICY;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_LINK_POLICY_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = WRITE_LINK_POLICY_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_link_supervision_timeout(int dd, uint16_t handle,
+					uint16_t *timeout, int to)
+{
+	read_link_supervision_timeout_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_READ_LINK_SUPERVISION_TIMEOUT;
+	rq.cparam = &handle;
+	rq.clen   = 2;
+	rq.rparam = &rp;
+	rq.rlen   = READ_LINK_SUPERVISION_TIMEOUT_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*timeout = rp.timeout;
+	return 0;
+}
+
+int hci_write_link_supervision_timeout(int dd, uint16_t handle,
+					uint16_t timeout, int to)
+{
+	write_link_supervision_timeout_cp cp;
+	write_link_supervision_timeout_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle  = handle;
+	cp.timeout = timeout;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_WRITE_LINK_SUPERVISION_TIMEOUT;
+	rq.cparam = &cp;
+	rq.clen   = WRITE_LINK_SUPERVISION_TIMEOUT_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = WRITE_LINK_SUPERVISION_TIMEOUT_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_set_afh_classification(int dd, uint8_t *map, int to)
+{
+	set_afh_classification_cp cp;
+	set_afh_classification_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	memcpy(cp.map, map, 10);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_HOST_CTL;
+	rq.ocf    = OCF_SET_AFH_CLASSIFICATION;
+	rq.cparam = &cp;
+	rq.clen   = SET_AFH_CLASSIFICATION_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = SET_AFH_CLASSIFICATION_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_read_link_quality(int dd, uint16_t handle, uint8_t *link_quality,
+				int to)
+{
+	read_link_quality_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_STATUS_PARAM;
+	rq.ocf    = OCF_READ_LINK_QUALITY;
+	rq.cparam = &handle;
+	rq.clen   = 2;
+	rq.rparam = &rp;
+	rq.rlen   = READ_LINK_QUALITY_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*link_quality = rp.link_quality;
+	return 0;
+}
+
+int hci_read_rssi(int dd, uint16_t handle, int8_t *rssi, int to)
+{
+	read_rssi_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_STATUS_PARAM;
+	rq.ocf    = OCF_READ_RSSI;
+	rq.cparam = &handle;
+	rq.clen   = 2;
+	rq.rparam = &rp;
+	rq.rlen   = READ_RSSI_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*rssi = rp.rssi;
+	return 0;
+}
+
+int hci_read_afh_map(int dd, uint16_t handle, uint8_t *mode, uint8_t *map,
+			int to)
+{
+	read_afh_map_rp rp;
+	struct hci_request rq;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_STATUS_PARAM;
+	rq.ocf    = OCF_READ_AFH_MAP;
+	rq.cparam = &handle;
+	rq.clen   = 2;
+	rq.rparam = &rp;
+	rq.rlen   = READ_AFH_MAP_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*mode = rp.mode;
+	memcpy(map, rp.map, 10);
+	return 0;
+}
+
+int hci_read_clock(int dd, uint16_t handle, uint8_t which, uint32_t *clock,
+			uint16_t *accuracy, int to)
+{
+	read_clock_cp cp;
+	read_clock_rp rp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle      = handle;
+	cp.which_clock = which;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_STATUS_PARAM;
+	rq.ocf    = OCF_READ_CLOCK;
+	rq.cparam = &cp;
+	rq.clen   = READ_CLOCK_CP_SIZE;
+	rq.rparam = &rp;
+	rq.rlen   = READ_CLOCK_RP_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	*clock    = rp.clock;
+	*accuracy = rp.accuracy;
+	return 0;
+}
+
+int hci_le_set_scan_enable(int dd, uint8_t enable, uint8_t filter_dup, int to)
+{
+	struct hci_request rq;
+	le_set_scan_enable_cp scan_cp;
+	uint8_t status;
+
+	memset(&scan_cp, 0, sizeof(scan_cp));
+	scan_cp.enable = enable;
+	scan_cp.filter_dup = filter_dup;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf = OGF_LE_CTL;
+	rq.ocf = OCF_LE_SET_SCAN_ENABLE;
+	rq.cparam = &scan_cp;
+	rq.clen = LE_SET_SCAN_ENABLE_CP_SIZE;
+	rq.rparam = &status;
+	rq.rlen = 1;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_le_set_scan_parameters(int dd, uint8_t type,
+					uint16_t interval, uint16_t window,
+					uint8_t own_type, uint8_t filter, int to)
+{
+	struct hci_request rq;
+	le_set_scan_parameters_cp param_cp;
+	uint8_t status;
+
+	memset(&param_cp, 0, sizeof(param_cp));
+	param_cp.type = type;
+	param_cp.interval = interval;
+	param_cp.window = window;
+	param_cp.own_bdaddr_type = own_type;
+	param_cp.filter = filter;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf = OGF_LE_CTL;
+	rq.ocf = OCF_LE_SET_SCAN_PARAMETERS;
+	rq.cparam = &param_cp;
+	rq.clen = LE_SET_SCAN_PARAMETERS_CP_SIZE;
+	rq.rparam = &status;
+	rq.rlen = 1;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_le_set_advertise_enable(int dd, uint8_t enable, int to)
+{
+	struct hci_request rq;
+	le_set_advertise_enable_cp adv_cp;
+	uint8_t status;
+
+	memset(&adv_cp, 0, sizeof(adv_cp));
+	adv_cp.enable = enable;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf = OGF_LE_CTL;
+	rq.ocf = OCF_LE_SET_ADVERTISE_ENABLE;
+	rq.cparam = &adv_cp;
+	rq.clen = LE_SET_ADVERTISE_ENABLE_CP_SIZE;
+	rq.rparam = &status;
+	rq.rlen = 1;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int hci_le_create_conn(int dd, uint16_t interval, uint16_t window,
+		uint8_t initiator_filter, uint8_t peer_bdaddr_type,
+		bdaddr_t peer_bdaddr, uint8_t own_bdaddr_type,
+		uint16_t min_interval, 	uint16_t max_interval,
+		uint16_t latency, uint16_t supervision_timeout,
+		uint16_t min_ce_length, uint16_t max_ce_length,
+		uint16_t *handle, int to)
+{
+	struct hci_request rq;
+	le_create_connection_cp create_conn_cp;
+	evt_le_connection_complete conn_complete_rp;
+
+	memset(&create_conn_cp, 0, sizeof(create_conn_cp));
+	create_conn_cp.interval = interval;
+	create_conn_cp.window = window;
+	create_conn_cp.initiator_filter = initiator_filter;
+	create_conn_cp.peer_bdaddr_type = peer_bdaddr_type;
+	create_conn_cp.peer_bdaddr = peer_bdaddr;
+	create_conn_cp.own_bdaddr_type = own_bdaddr_type;
+	create_conn_cp.min_interval = min_interval;
+	create_conn_cp.max_interval = max_interval;
+	create_conn_cp.latency = latency;
+	create_conn_cp.supervision_timeout = supervision_timeout;
+	create_conn_cp.min_ce_length = min_ce_length;
+	create_conn_cp.max_ce_length = max_ce_length;
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf = OGF_LE_CTL;
+	rq.ocf = OCF_LE_CREATE_CONN;
+	rq.event = EVT_LE_CONN_COMPLETE;
+	rq.cparam = &create_conn_cp;
+	rq.clen = LE_CREATE_CONN_CP_SIZE;
+	rq.rparam = &conn_complete_rp;
+	rq.rlen = EVT_CONN_COMPLETE_SIZE;
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (conn_complete_rp.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	if (handle)
+		*handle = conn_complete_rp.handle;
+
+	return 0;
+}
+
+int hci_le_conn_update(int dd, uint16_t handle, uint16_t min_interval,
+			uint16_t max_interval, uint16_t latency,
+			uint16_t supervision_timeout, int to)
+{
+	evt_le_connection_update_complete evt;
+	le_connection_update_cp cp;
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle = handle;
+	cp.min_interval = min_interval;
+	cp.max_interval = max_interval;
+	cp.latency = latency;
+	cp.supervision_timeout = supervision_timeout;
+	cp.min_ce_length = htobs(0x0001);
+	cp.max_ce_length = htobs(0x0001);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf = OGF_LE_CTL;
+	rq.ocf = OCF_LE_CONN_UPDATE;
+	rq.cparam = &cp;
+	rq.clen = LE_CONN_UPDATE_CP_SIZE;
+	rq.event = EVT_LE_CONN_UPDATE_COMPLETE;
+	rq.rparam = &evt;
+	rq.rlen = sizeof(evt);
+
+	if (hci_send_req(dd, &rq, to) < 0)
+		return -1;
+
+	if (evt.status) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/bootable/recovery/pcba_core/libbluetooth/sdp.c b/bootable/recovery/pcba_core/libbluetooth/sdp.c
new file mode 100644
index 0000000000..a48ee14f35
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/sdp.c
@@ -0,0 +1,4791 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2001-2002  Nokia Corporation
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2002-2003  Stephen Crane <steve.crane@rococosoft.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <string.h>
+#include <syslog.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+
+#include "bluetooth.h"
+#include "hci.h"
+#include "hci_lib.h"
+#include "l2cap.h"
+#include "sdp.h"
+#include "sdp_lib.h"
+
+#define SDPINF(fmt, arg...) syslog(LOG_INFO, fmt "\n", ## arg)
+#define SDPERR(fmt, arg...) syslog(LOG_ERR, "%s: " fmt "\n", __func__ , ## arg)
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+#ifdef SDP_DEBUG
+#define SDPDBG(fmt, arg...) syslog(LOG_DEBUG, "%s: " fmt "\n", __func__ , ## arg)
+#else
+#define SDPDBG(fmt...)
+#endif
+
+#define BASE_UUID "00000000-0000-1000-8000-00805F9B34FB"
+
+static uint128_t bluetooth_base_uuid = {
+	.data = {	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
+			0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB }
+};
+
+#define SDP_MAX_ATTR_LEN 65535
+
+static sdp_data_t *sdp_copy_seq(sdp_data_t *data);
+static int sdp_attr_add_new_with_length(sdp_record_t *rec,
+	uint16_t attr, uint8_t dtd, const void *value, uint32_t len);
+static int sdp_gen_buffer(sdp_buf_t *buf, sdp_data_t *d);
+
+/* Message structure. */
+struct tupla {
+	int index;
+	char *str;
+};
+
+static struct tupla Protocol[] = {
+	{ SDP_UUID,		"SDP"		},
+	{ UDP_UUID,		"UDP"		},
+	{ RFCOMM_UUID,		"RFCOMM"	},
+	{ TCP_UUID,		"TCP"		},
+	{ TCS_BIN_UUID,		"TCS-BIN"	},
+	{ TCS_AT_UUID,		"TCS-AT"	},
+	{ OBEX_UUID,		"OBEX"		},
+	{ IP_UUID,		"IP"		},
+	{ FTP_UUID,		"FTP"		},
+	{ HTTP_UUID,		"HTTP"		},
+	{ WSP_UUID,		"WSP"		},
+	{ BNEP_UUID,		"BNEP"		},
+	{ UPNP_UUID,		"UPNP"		},
+	{ HIDP_UUID,		"HIDP"		},
+	{ HCRP_CTRL_UUID,	"HCRP-Ctrl"	},
+	{ HCRP_DATA_UUID,	"HCRP-Data"	},
+	{ HCRP_NOTE_UUID,	"HCRP-Notify"	},
+	{ AVCTP_UUID,		"AVCTP"		},
+	{ AVDTP_UUID,		"AVDTP"		},
+	{ CMTP_UUID,		"CMTP"		},
+	{ UDI_UUID,		"UDI"		},
+	{ MCAP_CTRL_UUID,	"MCAP-Ctrl"	},
+	{ MCAP_DATA_UUID,	"MCAP-Data"	},
+	{ L2CAP_UUID,		"L2CAP"		},
+	{ ATT_UUID,		"ATT"		},
+	{ 0 }
+};
+
+static struct tupla ServiceClass[] = {
+	{ SDP_SERVER_SVCLASS_ID,		"SDP Server"			},
+	{ BROWSE_GRP_DESC_SVCLASS_ID,		"Browse Group Descriptor"	},
+	{ PUBLIC_BROWSE_GROUP,			"Public Browse Group"		},
+	{ SERIAL_PORT_SVCLASS_ID,		"Serial Port"			},
+	{ LAN_ACCESS_SVCLASS_ID,		"LAN Access Using PPP"		},
+	{ DIALUP_NET_SVCLASS_ID,		"Dialup Networking"		},
+	{ IRMC_SYNC_SVCLASS_ID,			"IrMC Sync"			},
+	{ OBEX_OBJPUSH_SVCLASS_ID,		"OBEX Object Push"		},
+	{ OBEX_FILETRANS_SVCLASS_ID,		"OBEX File Transfer"		},
+	{ IRMC_SYNC_CMD_SVCLASS_ID,		"IrMC Sync Command"		},
+	{ HEADSET_SVCLASS_ID,			"Headset"			},
+	{ CORDLESS_TELEPHONY_SVCLASS_ID,	"Cordless Telephony"		},
+	{ AUDIO_SOURCE_SVCLASS_ID,		"Audio Source"			},
+	{ AUDIO_SINK_SVCLASS_ID,		"Audio Sink"			},
+	{ AV_REMOTE_TARGET_SVCLASS_ID,		"AV Remote Target"		},
+	{ ADVANCED_AUDIO_SVCLASS_ID,		"Advanced Audio"		},
+	{ AV_REMOTE_SVCLASS_ID,			"AV Remote"			},
+	{ VIDEO_CONF_SVCLASS_ID,		"Video Conferencing"		},
+	{ INTERCOM_SVCLASS_ID,			"Intercom"			},
+	{ FAX_SVCLASS_ID,			"Fax"				},
+	{ HEADSET_AGW_SVCLASS_ID,		"Headset Audio Gateway"		},
+	{ WAP_SVCLASS_ID,			"WAP"				},
+	{ WAP_CLIENT_SVCLASS_ID,		"WAP Client"			},
+	{ PANU_SVCLASS_ID,			"PAN User"			},
+	{ NAP_SVCLASS_ID,			"Network Access Point"		},
+	{ GN_SVCLASS_ID,			"PAN Group Network"		},
+	{ DIRECT_PRINTING_SVCLASS_ID,		"Direct Printing"		},
+	{ REFERENCE_PRINTING_SVCLASS_ID,	"Reference Printing"		},
+	{ IMAGING_SVCLASS_ID,			"Imaging"			},
+	{ IMAGING_RESPONDER_SVCLASS_ID,		"Imaging Responder"		},
+	{ IMAGING_ARCHIVE_SVCLASS_ID,		"Imaging Automatic Archive"	},
+	{ IMAGING_REFOBJS_SVCLASS_ID,		"Imaging Referenced Objects"	},
+	{ HANDSFREE_SVCLASS_ID,			"Handsfree"			},
+	{ HANDSFREE_AGW_SVCLASS_ID,		"Handsfree Audio Gateway"	},
+	{ DIRECT_PRT_REFOBJS_SVCLASS_ID,	"Direct Printing Ref. Objects"	},
+	{ REFLECTED_UI_SVCLASS_ID,		"Reflected UI"			},
+	{ BASIC_PRINTING_SVCLASS_ID,		"Basic Printing"		},
+	{ PRINTING_STATUS_SVCLASS_ID,		"Printing Status"		},
+	{ HID_SVCLASS_ID,			"Human Interface Device"	},
+	{ HCR_SVCLASS_ID,			"Hardcopy Cable Replacement"	},
+	{ HCR_PRINT_SVCLASS_ID,			"HCR Print"			},
+	{ HCR_SCAN_SVCLASS_ID,			"HCR Scan"			},
+	{ CIP_SVCLASS_ID,			"Common ISDN Access"		},
+	{ VIDEO_CONF_GW_SVCLASS_ID,		"Video Conferencing Gateway"	},
+	{ UDI_MT_SVCLASS_ID,			"UDI MT"			},
+	{ UDI_TA_SVCLASS_ID,			"UDI TA"			},
+	{ AV_SVCLASS_ID,			"Audio/Video"			},
+	{ SAP_SVCLASS_ID,			"SIM Access"			},
+	{ PBAP_PCE_SVCLASS_ID,			"Phonebook Access - PCE"	},
+	{ PBAP_PSE_SVCLASS_ID,			"Phonebook Access - PSE"	},
+	{ PBAP_SVCLASS_ID,			"Phonebook Access"		},
+	{ PNP_INFO_SVCLASS_ID,			"PnP Information"		},
+	{ GENERIC_NETWORKING_SVCLASS_ID,	"Generic Networking"		},
+	{ GENERIC_FILETRANS_SVCLASS_ID,		"Generic File Transfer"		},
+	{ GENERIC_AUDIO_SVCLASS_ID,		"Generic Audio"			},
+	{ GENERIC_TELEPHONY_SVCLASS_ID,		"Generic Telephony"		},
+	{ UPNP_SVCLASS_ID,			"UPnP"				},
+	{ UPNP_IP_SVCLASS_ID,			"UPnP IP"			},
+	{ UPNP_PAN_SVCLASS_ID,			"UPnP PAN"			},
+	{ UPNP_LAP_SVCLASS_ID,			"UPnP LAP"			},
+	{ UPNP_L2CAP_SVCLASS_ID,		"UPnP L2CAP"			},
+	{ VIDEO_SOURCE_SVCLASS_ID,		"Video Source"			},
+	{ VIDEO_SINK_SVCLASS_ID,		"Video Sink"			},
+	{ VIDEO_DISTRIBUTION_SVCLASS_ID,	"Video Distribution"		},
+	{ HDP_SVCLASS_ID,			"HDP"				},
+	{ HDP_SOURCE_SVCLASS_ID,		"HDP Source"			},
+	{ HDP_SINK_SVCLASS_ID,			"HDP Sink"			},
+	{ APPLE_AGENT_SVCLASS_ID,		"Apple Agent"			},
+	{ GENERIC_ATTRIB_SVCLASS_ID,		"Generic Attribute"		},
+	{ 0 }
+};
+
+#define Profile ServiceClass
+
+static char *string_lookup(struct tupla *pt0, int index)
+{
+	struct tupla *pt;
+
+	for (pt = pt0; pt->index; pt++)
+		if (pt->index == index)
+			return pt->str;
+
+	return "";
+}
+
+static char *string_lookup_uuid(struct tupla *pt0, const uuid_t* uuid)
+{
+	uuid_t tmp_uuid;
+
+	memcpy(&tmp_uuid, uuid, sizeof(tmp_uuid));
+
+	if (sdp_uuid128_to_uuid(&tmp_uuid)) {
+		switch (tmp_uuid.type) {
+		case SDP_UUID16:
+			return string_lookup(pt0, tmp_uuid.value.uuid16);
+		case SDP_UUID32:
+			return string_lookup(pt0, tmp_uuid.value.uuid32);
+		}
+	}
+
+	return "";
+}
+
+/*
+ * Prints into a string the Protocol UUID
+ * coping a maximum of n characters.
+ */
+static int uuid2str(struct tupla *message, const uuid_t *uuid, char *str, size_t n)
+{
+	char *str2;
+
+	if (!uuid) {
+		snprintf(str, n, "NULL");
+		return -2;
+	}
+
+	switch (uuid->type) {
+	case SDP_UUID16:
+		str2 = string_lookup(message, uuid->value.uuid16);
+		snprintf(str, n, "%s", str2);
+		break;
+	case SDP_UUID32:
+		str2 = string_lookup(message, uuid->value.uuid32);
+		snprintf(str, n, "%s", str2);
+		break;
+	case SDP_UUID128:
+		str2 = string_lookup_uuid(message, uuid);
+		snprintf(str, n, "%s", str2);
+		break;
+	default:
+		snprintf(str, n, "Type of UUID (%x) unknown.", uuid->type);
+		return -1;
+	}
+
+	return 0;
+}
+
+int sdp_proto_uuid2strn(const uuid_t *uuid, char *str, size_t n)
+{
+	return uuid2str(Protocol, uuid, str, n);
+}
+
+int sdp_svclass_uuid2strn(const uuid_t *uuid, char *str, size_t n)
+{
+	return uuid2str(ServiceClass, uuid, str, n);
+}
+
+int sdp_profile_uuid2strn(const uuid_t *uuid, char *str, size_t n)
+{
+	return uuid2str(Profile, uuid, str, n);
+}
+
+/*
+ * convert the UUID to string, copying a maximum of n characters.
+ */
+int sdp_uuid2strn(const uuid_t *uuid, char *str, size_t n)
+{
+	if (!uuid) {
+		snprintf(str, n, "NULL");
+		return -2;
+	}
+	switch (uuid->type) {
+	case SDP_UUID16:
+		snprintf(str, n, "%.4x", uuid->value.uuid16);
+		break;
+	case SDP_UUID32:
+		snprintf(str, n, "%.8x", uuid->value.uuid32);
+		break;
+	case SDP_UUID128:{
+		unsigned int   data0;
+		unsigned short data1;
+		unsigned short data2;
+		unsigned short data3;
+		unsigned int   data4;
+		unsigned short data5;
+
+		memcpy(&data0, &uuid->value.uuid128.data[0], 4);
+		memcpy(&data1, &uuid->value.uuid128.data[4], 2);
+		memcpy(&data2, &uuid->value.uuid128.data[6], 2);
+		memcpy(&data3, &uuid->value.uuid128.data[8], 2);
+		memcpy(&data4, &uuid->value.uuid128.data[10], 4);
+		memcpy(&data5, &uuid->value.uuid128.data[14], 2);
+
+		snprintf(str, n, "%.8x-%.4x-%.4x-%.4x-%.8x%.4x",
+				ntohl(data0), ntohs(data1),
+				ntohs(data2), ntohs(data3),
+				ntohl(data4), ntohs(data5));
+		}
+		break;
+	default:
+		snprintf(str, n, "Type of UUID (%x) unknown.", uuid->type);
+		return -1;	/* Enum type of UUID not set */
+	}
+	return 0;
+}
+
+#ifdef SDP_DEBUG
+/*
+ * Function prints the UUID in hex as per defined syntax -
+ *
+ * 4bytes-2bytes-2bytes-2bytes-6bytes
+ *
+ * There is some ugly code, including hardcoding, but
+ * that is just the way it is converting 16 and 32 bit
+ * UUIDs to 128 bit as defined in the SDP doc
+ */
+void sdp_uuid_print(const uuid_t *uuid)
+{
+	if (uuid == NULL) {
+		SDPERR("Null passed to print UUID\n");
+		return;
+	}
+	if (uuid->type == SDP_UUID16) {
+		SDPDBG("  uint16_t : 0x%.4x\n", uuid->value.uuid16);
+	} else if (uuid->type == SDP_UUID32) {
+		SDPDBG("  uint32_t : 0x%.8x\n", uuid->value.uuid32);
+	} else if (uuid->type == SDP_UUID128) {
+		unsigned int data0;
+		unsigned short data1;
+		unsigned short data2;
+		unsigned short data3;
+		unsigned int data4;
+		unsigned short data5;
+
+		memcpy(&data0, &uuid->value.uuid128.data[0], 4);
+		memcpy(&data1, &uuid->value.uuid128.data[4], 2);
+		memcpy(&data2, &uuid->value.uuid128.data[6], 2);
+		memcpy(&data3, &uuid->value.uuid128.data[8], 2);
+		memcpy(&data4, &uuid->value.uuid128.data[10], 4);
+		memcpy(&data5, &uuid->value.uuid128.data[14], 2);
+
+		SDPDBG("  uint128_t : 0x%.8x-", ntohl(data0));
+		SDPDBG("%.4x-", ntohs(data1));
+		SDPDBG("%.4x-", ntohs(data2));
+		SDPDBG("%.4x-", ntohs(data3));
+		SDPDBG("%.8x", ntohl(data4));
+		SDPDBG("%.4x\n", ntohs(data5));
+	} else
+		SDPERR("Enum type of UUID not set\n");
+}
+#endif
+
+sdp_data_t *sdp_data_alloc_with_length(uint8_t dtd, const void *value,
+							uint32_t length)
+{
+	sdp_data_t *seq;
+	sdp_data_t *d = malloc(sizeof(sdp_data_t));
+
+	if (!d)
+		return NULL;
+
+	memset(d, 0, sizeof(sdp_data_t));
+	d->dtd = dtd;
+	d->unitSize = sizeof(uint8_t);
+
+	switch (dtd) {
+	case SDP_DATA_NIL:
+		break;
+	case SDP_UINT8:
+		d->val.uint8 = *(uint8_t *) value;
+		d->unitSize += sizeof(uint8_t);
+		break;
+	case SDP_INT8:
+	case SDP_BOOL:
+		d->val.int8 = *(int8_t *) value;
+		d->unitSize += sizeof(int8_t);
+		break;
+	case SDP_UINT16:
+		d->val.uint16 = bt_get_unaligned((uint16_t *) value);
+		d->unitSize += sizeof(uint16_t);
+		break;
+	case SDP_INT16:
+		d->val.int16 = bt_get_unaligned((int16_t *) value);
+		d->unitSize += sizeof(int16_t);
+		break;
+	case SDP_UINT32:
+		d->val.uint32 = bt_get_unaligned((uint32_t *) value);
+		d->unitSize += sizeof(uint32_t);
+		break;
+	case SDP_INT32:
+		d->val.int32 = bt_get_unaligned((int32_t *) value);
+		d->unitSize += sizeof(int32_t);
+		break;
+	case SDP_INT64:
+		d->val.int64 = bt_get_unaligned((int64_t *) value);
+		d->unitSize += sizeof(int64_t);
+		break;
+	case SDP_UINT64:
+		d->val.uint64 = bt_get_unaligned((uint64_t *) value);
+		d->unitSize += sizeof(uint64_t);
+		break;
+	case SDP_UINT128:
+		memcpy(&d->val.uint128.data, value, sizeof(uint128_t));
+		d->unitSize += sizeof(uint128_t);
+		break;
+	case SDP_INT128:
+		memcpy(&d->val.int128.data, value, sizeof(uint128_t));
+		d->unitSize += sizeof(uint128_t);
+		break;
+	case SDP_UUID16:
+		sdp_uuid16_create(&d->val.uuid, bt_get_unaligned((uint16_t *) value));
+		d->unitSize += sizeof(uint16_t);
+		break;
+	case SDP_UUID32:
+		sdp_uuid32_create(&d->val.uuid, bt_get_unaligned((uint32_t *) value));
+		d->unitSize += sizeof(uint32_t);
+		break;
+	case SDP_UUID128:
+		sdp_uuid128_create(&d->val.uuid, value);
+		d->unitSize += sizeof(uint128_t);
+		break;
+	case SDP_URL_STR8:
+	case SDP_URL_STR16:
+	case SDP_TEXT_STR8:
+	case SDP_TEXT_STR16:
+		if (!value) {
+			free(d);
+			return NULL;
+		}
+
+		d->unitSize += length;
+		if (length <= USHRT_MAX) {
+			d->val.str = malloc(length);
+			if (!d->val.str) {
+				free(d);
+				return NULL;
+			}
+
+			memcpy(d->val.str, value, length);
+		} else {
+			SDPERR("Strings of size > USHRT_MAX not supported\n");
+			free(d);
+			d = NULL;
+		}
+		break;
+	case SDP_URL_STR32:
+	case SDP_TEXT_STR32:
+		SDPERR("Strings of size > USHRT_MAX not supported\n");
+		break;
+	case SDP_ALT8:
+	case SDP_ALT16:
+	case SDP_ALT32:
+	case SDP_SEQ8:
+	case SDP_SEQ16:
+	case SDP_SEQ32:
+		if (dtd == SDP_ALT8 || dtd == SDP_SEQ8)
+			d->unitSize += sizeof(uint8_t);
+		else if (dtd == SDP_ALT16 || dtd == SDP_SEQ16)
+			d->unitSize += sizeof(uint16_t);
+		else if (dtd == SDP_ALT32 || dtd == SDP_SEQ32)
+			d->unitSize += sizeof(uint32_t);
+		seq = (sdp_data_t *)value;
+		d->val.dataseq = seq;
+		for (; seq; seq = seq->next)
+			d->unitSize += seq->unitSize;
+		break;
+	default:
+		free(d);
+		d = NULL;
+	}
+
+	return d;
+}
+
+sdp_data_t *sdp_data_alloc(uint8_t dtd, const void *value)
+{
+	uint32_t length;
+
+	switch (dtd) {
+	case SDP_URL_STR8:
+	case SDP_URL_STR16:
+	case SDP_TEXT_STR8:
+	case SDP_TEXT_STR16:
+		if (!value)
+			return NULL;
+
+		length = strlen((char *) value);
+		break;
+	default:
+		length = 0;
+		break;
+	}
+
+	return sdp_data_alloc_with_length(dtd, value, length);
+}
+
+sdp_data_t *sdp_seq_append(sdp_data_t *seq, sdp_data_t *d)
+{
+	if (seq) {
+		sdp_data_t *p;
+		for (p = seq; p->next; p = p->next);
+		p->next = d;
+	} else
+		seq = d;
+	d->next = NULL;
+	return seq;
+}
+
+sdp_data_t *sdp_seq_alloc_with_length(void **dtds, void **values, int *length,
+								int len)
+{
+	sdp_data_t *curr = NULL, *seq = NULL;
+	int i;
+
+	for (i = 0; i < len; i++) {
+		sdp_data_t *data;
+		int8_t dtd = *(uint8_t *) dtds[i];
+
+		if (dtd >= SDP_SEQ8 && dtd <= SDP_ALT32)
+			data = (sdp_data_t *) values[i];
+		else
+			data = sdp_data_alloc_with_length(dtd, values[i], length[i]);
+
+		if (!data)
+			return NULL;
+
+		if (curr)
+			curr->next = data;
+		else
+			seq = data;
+
+		curr = data;
+	}
+
+	return sdp_data_alloc_with_length(SDP_SEQ8, seq, length[i]);
+}
+
+sdp_data_t *sdp_seq_alloc(void **dtds, void **values, int len)
+{
+	sdp_data_t *curr = NULL, *seq = NULL;
+	int i;
+
+	for (i = 0; i < len; i++) {
+		sdp_data_t *data;
+		uint8_t dtd = *(uint8_t *) dtds[i];
+
+		if (dtd >= SDP_SEQ8 && dtd <= SDP_ALT32)
+			data = (sdp_data_t *) values[i];
+		else
+			data = sdp_data_alloc(dtd, values[i]);
+
+		if (!data)
+			return NULL;
+
+		if (curr)
+			curr->next = data;
+		else
+			seq = data;
+
+		curr = data;
+	}
+
+	return sdp_data_alloc(SDP_SEQ8, seq);
+}
+
+static void extract_svclass_uuid(sdp_data_t *data, uuid_t *uuid)
+{
+	sdp_data_t *d;
+
+	if (!data || data->dtd < SDP_SEQ8 || data->dtd > SDP_SEQ32)
+		return;
+
+	d = data->val.dataseq;
+	if (!d)
+		return;
+
+	if (d->dtd < SDP_UUID16 || d->dtd > SDP_UUID128)
+		return;
+
+	*uuid = d->val.uuid;
+}
+
+int sdp_attr_add(sdp_record_t *rec, uint16_t attr, sdp_data_t *d)
+{
+	sdp_data_t *p = sdp_data_get(rec, attr);
+
+	if (p)
+		return -1;
+
+	d->attrId = attr;
+	rec->attrlist = sdp_list_insert_sorted(rec->attrlist, d, sdp_attrid_comp_func);
+
+	if (attr == SDP_ATTR_SVCLASS_ID_LIST)
+		extract_svclass_uuid(d, &rec->svclass);
+
+	return 0;
+}
+
+void sdp_attr_remove(sdp_record_t *rec, uint16_t attr)
+{
+	sdp_data_t *d = sdp_data_get(rec, attr);
+
+	if (d)
+		rec->attrlist = sdp_list_remove(rec->attrlist, d);
+
+	if (attr == SDP_ATTR_SVCLASS_ID_LIST)
+		memset(&rec->svclass, 0, sizeof(rec->svclass));
+}
+
+void sdp_set_seq_len(uint8_t *ptr, uint32_t length)
+{
+	uint8_t dtd = *ptr++;
+
+	switch (dtd) {
+	case SDP_SEQ8:
+	case SDP_ALT8:
+	case SDP_TEXT_STR8:
+	case SDP_URL_STR8:
+		*ptr = (uint8_t) length;
+		break;
+	case SDP_SEQ16:
+	case SDP_ALT16:
+	case SDP_TEXT_STR16:
+	case SDP_URL_STR16:
+		bt_put_unaligned(htons(length), (uint16_t *) ptr);
+		break;
+	case SDP_SEQ32:
+	case SDP_ALT32:
+	case SDP_TEXT_STR32:
+	case SDP_URL_STR32:
+		bt_put_unaligned(htonl(length), (uint32_t *) ptr);
+		break;
+	}
+}
+
+static int sdp_get_data_type(sdp_buf_t *buf, uint8_t dtd)
+{
+	int data_type = 0;
+
+	data_type += sizeof(uint8_t);
+
+	switch (dtd) {
+	case SDP_SEQ8:
+	case SDP_TEXT_STR8:
+	case SDP_URL_STR8:
+	case SDP_ALT8:
+		data_type += sizeof(uint8_t);
+		break;
+	case SDP_SEQ16:
+	case SDP_TEXT_STR16:
+	case SDP_URL_STR16:
+	case SDP_ALT16:
+		data_type += sizeof(uint16_t);
+		break;
+	case SDP_SEQ32:
+	case SDP_TEXT_STR32:
+	case SDP_URL_STR32:
+	case SDP_ALT32:
+		data_type += sizeof(uint32_t);
+		break;
+	}
+
+	if (!buf->data)
+		buf->buf_size += data_type;
+
+	return data_type;
+}
+
+static int sdp_set_data_type(sdp_buf_t *buf, uint8_t dtd)
+{
+	int data_type = 0;
+	uint8_t *p = buf->data + buf->data_size;
+
+	*p = dtd;
+	data_type = sdp_get_data_type(buf, dtd);
+	buf->data_size += data_type;
+
+	return data_type;
+}
+
+void sdp_set_attrid(sdp_buf_t *buf, uint16_t attr)
+{
+	uint8_t *p = buf->data;
+
+	/* data type for attr */
+	*p++ = SDP_UINT16;
+	buf->data_size = sizeof(uint8_t);
+	bt_put_unaligned(htons(attr), (uint16_t *) p);
+	buf->data_size += sizeof(uint16_t);
+}
+
+static int get_data_size(sdp_buf_t *buf, sdp_data_t *sdpdata)
+{
+	sdp_data_t *d;
+	int n = 0;
+
+	for (d = sdpdata->val.dataseq; d; d = d->next) {
+		if (buf->data)
+			n += sdp_gen_pdu(buf, d);
+		else
+			n += sdp_gen_buffer(buf, d);
+	}
+
+	return n;
+}
+
+static int sdp_get_data_size(sdp_buf_t *buf, sdp_data_t *d)
+{
+	uint32_t data_size = 0;
+	uint8_t dtd = d->dtd;
+
+	switch (dtd) {
+	case SDP_DATA_NIL:
+		break;
+	case SDP_UINT8:
+		data_size = sizeof(uint8_t);
+		break;
+	case SDP_UINT16:
+		data_size = sizeof(uint16_t);
+		break;
+	case SDP_UINT32:
+		data_size = sizeof(uint32_t);
+		break;
+	case SDP_UINT64:
+		data_size = sizeof(uint64_t);
+		break;
+	case SDP_UINT128:
+		data_size = sizeof(uint128_t);
+		break;
+	case SDP_INT8:
+	case SDP_BOOL:
+		data_size = sizeof(int8_t);
+		break;
+	case SDP_INT16:
+		data_size = sizeof(int16_t);
+		break;
+	case SDP_INT32:
+		data_size = sizeof(int32_t);
+		break;
+	case SDP_INT64:
+		data_size = sizeof(int64_t);
+		break;
+	case SDP_INT128:
+		data_size = sizeof(uint128_t);
+		break;
+	case SDP_TEXT_STR8:
+	case SDP_TEXT_STR16:
+	case SDP_TEXT_STR32:
+	case SDP_URL_STR8:
+	case SDP_URL_STR16:
+	case SDP_URL_STR32:
+		data_size = d->unitSize - sizeof(uint8_t);
+		break;
+	case SDP_SEQ8:
+	case SDP_SEQ16:
+	case SDP_SEQ32:
+		data_size = get_data_size(buf, d);
+		break;
+	case SDP_ALT8:
+	case SDP_ALT16:
+	case SDP_ALT32:
+		data_size = get_data_size(buf, d);
+		break;
+	case SDP_UUID16:
+		data_size = sizeof(uint16_t);
+		break;
+	case SDP_UUID32:
+		data_size = sizeof(uint32_t);
+		break;
+	case SDP_UUID128:
+		data_size = sizeof(uint128_t);
+		break;
+	default:
+		break;
+	}
+
+	if (!buf->data)
+		buf->buf_size += data_size;
+
+	return data_size;
+}
+
+static int sdp_gen_buffer(sdp_buf_t *buf, sdp_data_t *d)
+{
+	int orig = buf->buf_size;
+
+	if (buf->buf_size == 0 && d->dtd == 0) {
+		/* create initial sequence */
+		buf->buf_size += sizeof(uint8_t);
+
+		/* reserve space for sequence size */
+		buf->buf_size += sizeof(uint8_t);
+	}
+
+	/* attribute length */
+	buf->buf_size += sizeof(uint8_t) + sizeof(uint16_t);
+
+	sdp_get_data_type(buf, d->dtd);
+	sdp_get_data_size(buf, d);
+
+	if (buf->buf_size > UCHAR_MAX && d->dtd == SDP_SEQ8)
+		buf->buf_size += sizeof(uint8_t);
+
+	return buf->buf_size - orig;
+}
+
+int sdp_gen_pdu(sdp_buf_t *buf, sdp_data_t *d)
+{
+	uint32_t pdu_size = 0, data_size = 0;
+	unsigned char *src = NULL, is_seq = 0, is_alt = 0;
+	uint8_t dtd = d->dtd;
+	uint16_t u16;
+	uint32_t u32;
+	uint64_t u64;
+	uint128_t u128;
+	uint8_t *seqp = buf->data + buf->data_size;
+
+	pdu_size = sdp_set_data_type(buf, dtd);
+	data_size = sdp_get_data_size(buf, d);
+
+	switch (dtd) {
+	case SDP_DATA_NIL:
+		break;
+	case SDP_UINT8:
+		src = &d->val.uint8;
+		break;
+	case SDP_UINT16:
+		u16 = htons(d->val.uint16);
+		src = (unsigned char *) &u16;
+		break;
+	case SDP_UINT32:
+		u32 = htonl(d->val.uint32);
+		src = (unsigned char *) &u32;
+		break;
+	case SDP_UINT64:
+		u64 = hton64(d->val.uint64);
+		src = (unsigned char *) &u64;
+		break;
+	case SDP_UINT128:
+		hton128(&d->val.uint128, &u128);
+		src = (unsigned char *) &u128;
+		break;
+	case SDP_INT8:
+	case SDP_BOOL:
+		src = (unsigned char *) &d->val.int8;
+		break;
+	case SDP_INT16:
+		u16 = htons(d->val.int16);
+		src = (unsigned char *) &u16;
+		break;
+	case SDP_INT32:
+		u32 = htonl(d->val.int32);
+		src = (unsigned char *) &u32;
+		break;
+	case SDP_INT64:
+		u64 = hton64(d->val.int64);
+		src = (unsigned char *) &u64;
+		break;
+	case SDP_INT128:
+		hton128(&d->val.int128, &u128);
+		src = (unsigned char *) &u128;
+		break;
+	case SDP_TEXT_STR8:
+	case SDP_TEXT_STR16:
+	case SDP_TEXT_STR32:
+	case SDP_URL_STR8:
+	case SDP_URL_STR16:
+	case SDP_URL_STR32:
+		src = (unsigned char *) d->val.str;
+		sdp_set_seq_len(seqp, data_size);
+		break;
+	case SDP_SEQ8:
+	case SDP_SEQ16:
+	case SDP_SEQ32:
+		is_seq = 1;
+		sdp_set_seq_len(seqp, data_size);
+		break;
+	case SDP_ALT8:
+	case SDP_ALT16:
+	case SDP_ALT32:
+		is_alt = 1;
+		sdp_set_seq_len(seqp, data_size);
+		break;
+	case SDP_UUID16:
+		u16 = htons(d->val.uuid.value.uuid16);
+		src = (unsigned char *) &u16;
+		break;
+	case SDP_UUID32:
+		u32 = htonl(d->val.uuid.value.uuid32);
+		src = (unsigned char *) &u32;
+		break;
+	case SDP_UUID128:
+		src = (unsigned char *) &d->val.uuid.value.uuid128;
+		break;
+	default:
+		break;
+	}
+
+	if (!is_seq && !is_alt) {
+		if (src && buf->buf_size >= buf->data_size + data_size) {
+			memcpy(buf->data + buf->data_size, src, data_size);
+			buf->data_size += data_size;
+		} else if (dtd != SDP_DATA_NIL) {
+			SDPDBG("Gen PDU : Can't copy from invalid source or dest\n");
+		}
+	}
+
+	pdu_size += data_size;
+
+	return pdu_size;
+}
+
+static void sdp_attr_pdu(void *value, void *udata)
+{
+	sdp_append_to_pdu((sdp_buf_t *)udata, (sdp_data_t *)value);
+}
+
+static void sdp_attr_size(void *value, void *udata)
+{
+	sdp_gen_buffer((sdp_buf_t *)udata, (sdp_data_t *)value);
+}
+
+int sdp_gen_record_pdu(const sdp_record_t *rec, sdp_buf_t *buf)
+{
+	memset(buf, 0, sizeof(sdp_buf_t));
+	sdp_list_foreach(rec->attrlist, sdp_attr_size, buf);
+
+	buf->data = malloc(buf->buf_size);
+	if (!buf->data)
+		return -ENOMEM;
+	buf->data_size = 0;
+	memset(buf->data, 0, buf->buf_size);
+
+	sdp_list_foreach(rec->attrlist, sdp_attr_pdu, buf);
+
+	return 0;
+}
+
+void sdp_attr_replace(sdp_record_t *rec, uint16_t attr, sdp_data_t *d)
+{
+	sdp_data_t *p = sdp_data_get(rec, attr);
+
+	if (p) {
+		rec->attrlist = sdp_list_remove(rec->attrlist, p);
+		sdp_data_free(p);
+	}
+
+	d->attrId = attr;
+	rec->attrlist = sdp_list_insert_sorted(rec->attrlist, d, sdp_attrid_comp_func);
+
+	if (attr == SDP_ATTR_SVCLASS_ID_LIST)
+		extract_svclass_uuid(d, &rec->svclass);
+}
+
+int sdp_attrid_comp_func(const void *key1, const void *key2)
+{
+	const sdp_data_t *d1 = (const sdp_data_t *)key1;
+	const sdp_data_t *d2 = (const sdp_data_t *)key2;
+
+	if (d1 && d2)
+		return d1->attrId - d2->attrId;
+	return 0;
+}
+
+static void data_seq_free(sdp_data_t *seq)
+{
+	sdp_data_t *d = seq->val.dataseq;
+
+	while (d) {
+		sdp_data_t *next = d->next;
+		sdp_data_free(d);
+		d = next;
+	}
+}
+
+void sdp_data_free(sdp_data_t *d)
+{
+	switch (d->dtd) {
+	case SDP_SEQ8:
+	case SDP_SEQ16:
+	case SDP_SEQ32:
+		data_seq_free(d);
+		break;
+	case SDP_URL_STR8:
+	case SDP_URL_STR16:
+	case SDP_URL_STR32:
+	case SDP_TEXT_STR8:
+	case SDP_TEXT_STR16:
+	case SDP_TEXT_STR32:
+		free(d->val.str);
+		break;
+	}
+	free(d);
+}
+
+int sdp_uuid_extract(const uint8_t *p, int bufsize, uuid_t *uuid, int *scanned)
+{
+	uint8_t type;
+
+	if (bufsize < (int) sizeof(uint8_t)) {
+		SDPERR("Unexpected end of packet");
+		return -1;
+	}
+
+	type = *(const uint8_t *) p;
+
+	if (!SDP_IS_UUID(type)) {
+		SDPERR("Unknown data type : %d expecting a svc UUID\n", type);
+		return -1;
+	}
+	p += sizeof(uint8_t);
+	*scanned += sizeof(uint8_t);
+	bufsize -= sizeof(uint8_t);
+	if (type == SDP_UUID16) {
+		if (bufsize < (int) sizeof(uint16_t)) {
+			SDPERR("Not enough room for 16-bit UUID");
+			return -1;
+		}
+		sdp_uuid16_create(uuid, ntohs(bt_get_unaligned((uint16_t *) p)));
+		*scanned += sizeof(uint16_t);
+	} else if (type == SDP_UUID32) {
+		if (bufsize < (int) sizeof(uint32_t)) {
+			SDPERR("Not enough room for 32-bit UUID");
+			return -1;
+		}
+		sdp_uuid32_create(uuid, ntohl(bt_get_unaligned((uint32_t *) p)));
+		*scanned += sizeof(uint32_t);
+	} else {
+		if (bufsize < (int) sizeof(uint128_t)) {
+			SDPERR("Not enough room for 128-bit UUID");
+			return -1;
+		}
+		sdp_uuid128_create(uuid, p);
+		*scanned += sizeof(uint128_t);
+	}
+	return 0;
+}
+
+static sdp_data_t *extract_int(const void *p, int bufsize, int *len)
+{
+	sdp_data_t *d;
+
+	if (bufsize < (int) sizeof(uint8_t)) {
+		SDPERR("Unexpected end of packet");
+		return NULL;
+	}
+
+	d = malloc(sizeof(sdp_data_t));
+	if (!d)
+		return NULL;
+
+	SDPDBG("Extracting integer\n");
+	memset(d, 0, sizeof(sdp_data_t));
+	d->dtd = *(uint8_t *) p;
+	p += sizeof(uint8_t);
+	*len += sizeof(uint8_t);
+	bufsize -= sizeof(uint8_t);
+
+	switch (d->dtd) {
+	case SDP_DATA_NIL:
+		break;
+	case SDP_BOOL:
+	case SDP_INT8:
+	case SDP_UINT8:
+		if (bufsize < (int) sizeof(uint8_t)) {
+			SDPERR("Unexpected end of packet");
+			free(d);
+			return NULL;
+		}
+		*len += sizeof(uint8_t);
+		d->val.uint8 = *(uint8_t *) p;
+		break;
+	case SDP_INT16:
+	case SDP_UINT16:
+		if (bufsize < (int) sizeof(uint16_t)) {
+			SDPERR("Unexpected end of packet");
+			free(d);
+			return NULL;
+		}
+		*len += sizeof(uint16_t);
+		d->val.uint16 = ntohs(bt_get_unaligned((uint16_t *) p));
+		break;
+	case SDP_INT32:
+	case SDP_UINT32:
+		if (bufsize < (int) sizeof(uint32_t)) {
+			SDPERR("Unexpected end of packet");
+			free(d);
+			return NULL;
+		}
+		*len += sizeof(uint32_t);
+		d->val.uint32 = ntohl(bt_get_unaligned((uint32_t *) p));
+		break;
+	case SDP_INT64:
+	case SDP_UINT64:
+		if (bufsize < (int) sizeof(uint64_t)) {
+			SDPERR("Unexpected end of packet");
+			free(d);
+			return NULL;
+		}
+		*len += sizeof(uint64_t);
+		d->val.uint64 = ntoh64(bt_get_unaligned((uint64_t *) p));
+		break;
+	case SDP_INT128:
+	case SDP_UINT128:
+		if (bufsize < (int) sizeof(uint128_t)) {
+			SDPERR("Unexpected end of packet");
+			free(d);
+			return NULL;
+		}
+		*len += sizeof(uint128_t);
+		ntoh128((uint128_t *) p, &d->val.uint128);
+		break;
+	default:
+		free(d);
+		d = NULL;
+	}
+	return d;
+}
+
+static sdp_data_t *extract_uuid(const uint8_t *p, int bufsize, int *len,
+							sdp_record_t *rec)
+{
+	sdp_data_t *d = malloc(sizeof(sdp_data_t));
+
+	if (!d)
+		return NULL;
+
+	SDPDBG("Extracting UUID");
+	memset(d, 0, sizeof(sdp_data_t));
+	if (sdp_uuid_extract(p, bufsize, &d->val.uuid, len) < 0) {
+		free(d);
+		return NULL;
+	}
+	d->dtd = *p;
+	if (rec)
+		sdp_pattern_add_uuid(rec, &d->val.uuid);
+	return d;
+}
+
+/*
+ * Extract strings from the PDU (could be service description and similar info)
+ */
+static sdp_data_t *extract_str(const void *p, int bufsize, int *len)
+{
+	char *s;
+	int n;
+	sdp_data_t *d;
+
+	if (bufsize < (int) sizeof(uint8_t)) {
+		SDPERR("Unexpected end of packet");
+		return NULL;
+	}
+
+	d = malloc(sizeof(sdp_data_t));
+	if (!d)
+		return NULL;
+
+	memset(d, 0, sizeof(sdp_data_t));
+	d->dtd = *(uint8_t *) p;
+	p += sizeof(uint8_t);
+	*len += sizeof(uint8_t);
+	bufsize -= sizeof(uint8_t);
+
+	switch (d->dtd) {
+	case SDP_TEXT_STR8:
+	case SDP_URL_STR8:
+		if (bufsize < (int) sizeof(uint8_t)) {
+			SDPERR("Unexpected end of packet");
+			free(d);
+			return NULL;
+		}
+		n = *(uint8_t *) p;
+		p += sizeof(uint8_t);
+		*len += sizeof(uint8_t);
+		bufsize -= sizeof(uint8_t);
+		break;
+	case SDP_TEXT_STR16:
+	case SDP_URL_STR16:
+		if (bufsize < (int) sizeof(uint16_t)) {
+			SDPERR("Unexpected end of packet");
+			free(d);
+			return NULL;
+		}
+		n = ntohs(bt_get_unaligned((uint16_t *) p));
+		p += sizeof(uint16_t);
+		*len += sizeof(uint16_t) + n;
+		bufsize -= sizeof(uint16_t);
+		break;
+	default:
+		SDPERR("Sizeof text string > UINT16_MAX\n");
+		free(d);
+		return NULL;
+	}
+
+	if (bufsize < n) {
+		SDPERR("String too long to fit in packet");
+		free(d);
+		return NULL;
+	}
+
+	s = malloc(n + 1);
+	if (!s) {
+		SDPERR("Not enough memory for incoming string");
+		free(d);
+		return NULL;
+	}
+	memset(s, 0, n + 1);
+	memcpy(s, p, n);
+
+	*len += n;
+
+	SDPDBG("Len : %d\n", n);
+	SDPDBG("Str : %s\n", s);
+
+	d->val.str = s;
+	d->unitSize = n + sizeof(uint8_t);
+	return d;
+}
+
+/*
+ * Extract the sequence type and its length, and return offset into buf
+ * or 0 on failure.
+ */
+int sdp_extract_seqtype(const uint8_t *buf, int bufsize, uint8_t *dtdp, int *size)
+{
+	uint8_t dtd;
+	int scanned = sizeof(uint8_t);
+
+	if (bufsize < (int) sizeof(uint8_t)) {
+		SDPERR("Unexpected end of packet");
+		return 0;
+	}
+
+	dtd = *(uint8_t *) buf;
+	buf += sizeof(uint8_t);
+	bufsize -= sizeof(uint8_t);
+	*dtdp = dtd;
+	switch (dtd) {
+	case SDP_SEQ8:
+	case SDP_ALT8:
+		if (bufsize < (int) sizeof(uint8_t)) {
+			SDPERR("Unexpected end of packet");
+			return 0;
+		}
+		*size = *(uint8_t *) buf;
+		scanned += sizeof(uint8_t);
+		break;
+	case SDP_SEQ16:
+	case SDP_ALT16:
+		if (bufsize < (int) sizeof(uint16_t)) {
+			SDPERR("Unexpected end of packet");
+			return 0;
+		}
+		*size = ntohs(bt_get_unaligned((uint16_t *) buf));
+		scanned += sizeof(uint16_t);
+		break;
+	case SDP_SEQ32:
+	case SDP_ALT32:
+		if (bufsize < (int) sizeof(uint32_t)) {
+			SDPERR("Unexpected end of packet");
+			return 0;
+		}
+		*size = ntohl(bt_get_unaligned((uint32_t *) buf));
+		scanned += sizeof(uint32_t);
+		break;
+	default:
+		SDPERR("Unknown sequence type, aborting\n");
+		return 0;
+	}
+	return scanned;
+}
+
+static sdp_data_t *extract_seq(const void *p, int bufsize, int *len,
+							sdp_record_t *rec)
+{
+	int seqlen, n = 0;
+	sdp_data_t *curr, *prev;
+	sdp_data_t *d = malloc(sizeof(sdp_data_t));
+
+	if (!d)
+		return NULL;
+
+	SDPDBG("Extracting SEQ");
+	memset(d, 0, sizeof(sdp_data_t));
+	*len = sdp_extract_seqtype(p, bufsize, &d->dtd, &seqlen);
+	SDPDBG("Sequence Type : 0x%x length : 0x%x\n", d->dtd, seqlen);
+
+	if (*len == 0)
+		return d;
+
+	if (*len > bufsize) {
+		SDPERR("Packet not big enough to hold sequence.");
+		free(d);
+		return NULL;
+	}
+
+	p += *len;
+	bufsize -= *len;
+	prev = NULL;
+	while (n < seqlen) {
+		int attrlen = 0;
+		curr = sdp_extract_attr(p, bufsize, &attrlen, rec);
+		if (curr == NULL)
+			break;
+
+		if (prev)
+			prev->next = curr;
+		else
+			d->val.dataseq = curr;
+		prev = curr;
+		p += attrlen;
+		n += attrlen;
+		bufsize -= attrlen;
+
+		SDPDBG("Extracted: %d SequenceLength: %d", n, seqlen);
+	}
+
+	*len += n;
+	return d;
+}
+
+sdp_data_t *sdp_extract_attr(const uint8_t *p, int bufsize, int *size,
+							sdp_record_t *rec)
+{
+	sdp_data_t *elem;
+	int n = 0;
+	uint8_t dtd;
+
+	if (bufsize < (int) sizeof(uint8_t)) {
+		SDPERR("Unexpected end of packet");
+		return NULL;
+	}
+
+	dtd = *(const uint8_t *)p;
+
+	SDPDBG("extract_attr: dtd=0x%x", dtd);
+	switch (dtd) {
+	case SDP_DATA_NIL:
+	case SDP_BOOL:
+	case SDP_UINT8:
+	case SDP_UINT16:
+	case SDP_UINT32:
+	case SDP_UINT64:
+	case SDP_UINT128:
+	case SDP_INT8:
+	case SDP_INT16:
+	case SDP_INT32:
+	case SDP_INT64:
+	case SDP_INT128:
+		elem = extract_int(p, bufsize, &n);
+		break;
+	case SDP_UUID16:
+	case SDP_UUID32:
+	case SDP_UUID128:
+		elem = extract_uuid(p, bufsize, &n, rec);
+		break;
+	case SDP_TEXT_STR8:
+	case SDP_TEXT_STR16:
+	case SDP_TEXT_STR32:
+	case SDP_URL_STR8:
+	case SDP_URL_STR16:
+	case SDP_URL_STR32:
+		elem = extract_str(p, bufsize, &n);
+		break;
+	case SDP_SEQ8:
+	case SDP_SEQ16:
+	case SDP_SEQ32:
+	case SDP_ALT8:
+	case SDP_ALT16:
+	case SDP_ALT32:
+		elem = extract_seq(p, bufsize, &n, rec);
+		break;
+	default:
+		SDPERR("Unknown data descriptor : 0x%x terminating\n", dtd);
+		return NULL;
+	}
+	*size += n;
+	return elem;
+}
+
+#ifdef SDP_DEBUG
+static void attr_print_func(void *value, void *userData)
+{
+	sdp_data_t *d = (sdp_data_t *)value;
+
+	SDPDBG("=====================================\n");
+	SDPDBG("ATTRIBUTE IDENTIFIER : 0x%x\n",  d->attrId);
+	SDPDBG("ATTRIBUTE VALUE PTR : 0x%x\n", (uint32_t)value);
+	if (d)
+		sdp_data_print(d);
+	else
+		SDPDBG("NULL value\n");
+	SDPDBG("=====================================\n");
+}
+
+void sdp_print_service_attr(sdp_list_t *svcAttrList)
+{
+	SDPDBG("Printing service attr list %p\n", svcAttrList);
+	sdp_list_foreach(svcAttrList, attr_print_func, NULL);
+	SDPDBG("Printed service attr list %p\n", svcAttrList);
+}
+#endif
+
+sdp_record_t *sdp_extract_pdu(const uint8_t *buf, int bufsize, int *scanned)
+{
+	int extracted = 0, seqlen = 0;
+	uint8_t dtd;
+	uint16_t attr;
+	sdp_record_t *rec = sdp_record_alloc();
+	const uint8_t *p = buf;
+
+	*scanned = sdp_extract_seqtype(buf, bufsize, &dtd, &seqlen);
+	p += *scanned;
+	bufsize -= *scanned;
+	rec->attrlist = NULL;
+
+	while (extracted < seqlen && bufsize > 0) {
+		int n = sizeof(uint8_t), attrlen = 0;
+		sdp_data_t *data = NULL;
+
+		SDPDBG("Extract PDU, sequenceLength: %d localExtractedLength: %d",
+							seqlen, extracted);
+
+		if (bufsize < n + (int) sizeof(uint16_t)) {
+			SDPERR("Unexpected end of packet");
+			break;
+		}
+
+		dtd = *(uint8_t *) p;
+		attr = ntohs(bt_get_unaligned((uint16_t *) (p + n)));
+		n += sizeof(uint16_t);
+
+		SDPDBG("DTD of attrId : %d Attr id : 0x%x \n", dtd, attr);
+
+		data = sdp_extract_attr(p + n, bufsize - n, &attrlen, rec);
+
+		SDPDBG("Attr id : 0x%x attrValueLength : %d\n", attr, attrlen);
+
+		n += attrlen;
+		if (data == NULL) {
+			SDPDBG("Terminating extraction of attributes");
+			break;
+		}
+
+		if (attr == SDP_ATTR_RECORD_HANDLE)
+			rec->handle = data->val.uint32;
+
+		if (attr == SDP_ATTR_SVCLASS_ID_LIST)
+			extract_svclass_uuid(data, &rec->svclass);
+
+		extracted += n;
+		p += n;
+		bufsize -= n;
+		sdp_attr_replace(rec, attr, data);
+
+		SDPDBG("Extract PDU, seqLength: %d localExtractedLength: %d",
+							seqlen, extracted);
+	}
+#ifdef SDP_DEBUG
+	SDPDBG("Successful extracting of Svc Rec attributes\n");
+	sdp_print_service_attr(rec->attrlist);
+#endif
+	*scanned += seqlen;
+	return rec;
+}
+
+static void sdp_copy_pattern(void *value, void *udata)
+{
+	uuid_t *uuid = value;
+	sdp_record_t *rec = udata;
+
+	sdp_pattern_add_uuid(rec, uuid);
+}
+
+static void *sdp_data_value(sdp_data_t *data, uint32_t *len)
+{
+	void *val = NULL;
+
+	switch (data->dtd) {
+	case SDP_DATA_NIL:
+		break;
+	case SDP_UINT8:
+		val = &data->val.uint8;
+		break;
+	case SDP_INT8:
+	case SDP_BOOL:
+		val = &data->val.int8;
+		break;
+	case SDP_UINT16:
+		val = &data->val.uint16;
+		break;
+	case SDP_INT16:
+		val = &data->val.int16;
+		break;
+	case SDP_UINT32:
+		val = &data->val.uint32;
+		break;
+	case SDP_INT32:
+		val = &data->val.int32;
+		break;
+	case SDP_INT64:
+		val = &data->val.int64;
+		break;
+	case SDP_UINT64:
+		val = &data->val.uint64;
+		break;
+	case SDP_UINT128:
+		val = &data->val.uint128;
+		break;
+	case SDP_INT128:
+		val = &data->val.int128;
+		break;
+	case SDP_UUID16:
+		val = &data->val.uuid.value.uuid16;
+		break;
+	case SDP_UUID32:
+		val = &data->val.uuid.value.uuid32;
+		break;
+	case SDP_UUID128:
+		val = &data->val.uuid.value.uuid128;
+		break;
+	case SDP_URL_STR8:
+	case SDP_URL_STR16:
+	case SDP_TEXT_STR8:
+	case SDP_TEXT_STR16:
+	case SDP_URL_STR32:
+	case SDP_TEXT_STR32:
+		val = data->val.str;
+		if (len)
+			*len = data->unitSize - 1;
+		break;
+	case SDP_ALT8:
+	case SDP_ALT16:
+	case SDP_ALT32:
+	case SDP_SEQ8:
+	case SDP_SEQ16:
+	case SDP_SEQ32:
+		val = sdp_copy_seq(data->val.dataseq);
+		break;
+	}
+
+	return val;
+}
+
+static sdp_data_t *sdp_copy_seq(sdp_data_t *data)
+{
+	sdp_data_t *tmp, *seq = NULL, *cur = NULL;
+
+	for (tmp = data; tmp; tmp = tmp->next) {
+		sdp_data_t *datatmp;
+		void *value;
+
+		value = sdp_data_value(tmp, NULL);
+		datatmp = sdp_data_alloc_with_length(tmp->dtd, value,
+								tmp->unitSize);
+
+		if (cur)
+			cur->next = datatmp;
+		else
+			seq = datatmp;
+
+		cur = datatmp;
+	}
+
+	return seq;
+}
+
+static void sdp_copy_attrlist(void *value, void *udata)
+{
+	sdp_data_t *data = value;
+	sdp_record_t *rec = udata;
+	void *val;
+	uint32_t len = 0;
+
+	val = sdp_data_value(data, &len);
+
+	if (!len)
+		sdp_attr_add_new(rec, data->attrId, data->dtd, val);
+	else
+		sdp_attr_add_new_with_length(rec, data->attrId,
+							data->dtd, val, len);
+}
+
+sdp_record_t *sdp_copy_record(sdp_record_t *rec)
+{
+	sdp_record_t *cpy;
+
+	cpy = sdp_record_alloc();
+
+	cpy->handle = rec->handle;
+
+	sdp_list_foreach(rec->pattern, sdp_copy_pattern, cpy);
+	sdp_list_foreach(rec->attrlist, sdp_copy_attrlist, cpy);
+
+	cpy->svclass = rec->svclass;
+
+	return cpy;
+}
+
+#ifdef SDP_DEBUG
+static void print_dataseq(sdp_data_t *p)
+{
+	sdp_data_t *d;
+
+	for (d = p; d; d = d->next)
+		sdp_data_print(d);
+}
+#endif
+
+void sdp_record_print(const sdp_record_t *rec)
+{
+	sdp_data_t *d = sdp_data_get(rec, SDP_ATTR_SVCNAME_PRIMARY);
+	if (d)
+		printf("Service Name: %.*s\n", d->unitSize, d->val.str);
+	d = sdp_data_get(rec, SDP_ATTR_SVCDESC_PRIMARY);
+	if (d)
+		printf("Service Description: %.*s\n", d->unitSize, d->val.str);
+	d = sdp_data_get(rec, SDP_ATTR_PROVNAME_PRIMARY);
+	if (d)
+		printf("Service Provider: %.*s\n", d->unitSize, d->val.str);
+}
+
+#ifdef SDP_DEBUG
+void sdp_data_print(sdp_data_t *d)
+{
+	switch (d->dtd) {
+	case SDP_DATA_NIL:
+		SDPDBG("NIL\n");
+		break;
+	case SDP_BOOL:
+	case SDP_UINT8:
+	case SDP_UINT16:
+	case SDP_UINT32:
+	case SDP_UINT64:
+	case SDP_UINT128:
+	case SDP_INT8:
+	case SDP_INT16:
+	case SDP_INT32:
+	case SDP_INT64:
+	case SDP_INT128:
+		SDPDBG("Integer : 0x%x\n", d->val.uint32);
+		break;
+	case SDP_UUID16:
+	case SDP_UUID32:
+	case SDP_UUID128:
+		SDPDBG("UUID\n");
+		sdp_uuid_print(&d->val.uuid);
+		break;
+	case SDP_TEXT_STR8:
+	case SDP_TEXT_STR16:
+	case SDP_TEXT_STR32:
+		SDPDBG("Text : %s\n", d->val.str);
+		break;
+	case SDP_URL_STR8:
+	case SDP_URL_STR16:
+	case SDP_URL_STR32:
+		SDPDBG("URL : %s\n", d->val.str);
+		break;
+	case SDP_SEQ8:
+	case SDP_SEQ16:
+	case SDP_SEQ32:
+		print_dataseq(d->val.dataseq);
+		break;
+	case SDP_ALT8:
+	case SDP_ALT16:
+	case SDP_ALT32:
+		SDPDBG("Data Sequence Alternates\n");
+		print_dataseq(d->val.dataseq);
+		break;
+	}
+}
+#endif
+
+sdp_data_t *sdp_data_get(const sdp_record_t *rec, uint16_t attrId)
+{
+	if (rec->attrlist) {
+		sdp_data_t sdpTemplate;
+		sdp_list_t *p;
+
+		sdpTemplate.attrId = attrId;
+		p = sdp_list_find(rec->attrlist, &sdpTemplate, sdp_attrid_comp_func);
+		if (p)
+			return p->data;
+	}
+	return NULL;
+}
+
+static int sdp_send_req(sdp_session_t *session, uint8_t *buf, uint32_t size)
+{
+	uint32_t sent = 0;
+
+	while (sent < size) {
+		int n = send(session->sock, buf + sent, size - sent, 0);
+		if (n < 0)
+			return -1;
+		sent += n;
+	}
+	return 0;
+}
+
+static int sdp_read_rsp(sdp_session_t *session, uint8_t *buf, uint32_t size)
+{
+	fd_set readFds;
+	struct timeval timeout = { SDP_RESPONSE_TIMEOUT, 0 };
+
+	FD_ZERO(&readFds);
+	FD_SET(session->sock, &readFds);
+	SDPDBG("Waiting for response\n");
+	if (select(session->sock + 1, &readFds, NULL, NULL, &timeout) == 0) {
+		SDPERR("Client timed out\n");
+		errno = ETIMEDOUT;
+		return -1;
+	}
+	return recv(session->sock, buf, size, 0);
+}
+
+/*
+ * generic send request, wait for response method.
+ */
+int sdp_send_req_w4_rsp(sdp_session_t *session, uint8_t *reqbuf,
+			uint8_t *rspbuf, uint32_t reqsize, uint32_t *rspsize)
+{
+	int n;
+	sdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *) reqbuf;
+	sdp_pdu_hdr_t *rsphdr = (sdp_pdu_hdr_t *) rspbuf;
+
+	SDPDBG("");
+	if (0 > sdp_send_req(session, reqbuf, reqsize)) {
+		SDPERR("Error sending data:%s", strerror(errno));
+		return -1;
+	}
+	n = sdp_read_rsp(session, rspbuf, SDP_RSP_BUFFER_SIZE);
+	if (0 > n)
+		return -1;
+	SDPDBG("Read : %d\n", n);
+	if (n == 0 || reqhdr->tid != rsphdr->tid) {
+		errno = EPROTO;
+		return -1;
+	}
+	*rspsize = n;
+	return 0;
+}
+
+/*
+ * singly-linked lists (after openobex implementation)
+ */
+sdp_list_t *sdp_list_append(sdp_list_t *p, void *d)
+{
+	sdp_list_t *q, *n = malloc(sizeof(sdp_list_t));
+
+	if (!n)
+		return NULL;
+
+	n->data = d;
+	n->next = 0;
+
+	if (!p)
+		return n;
+
+	for (q = p; q->next; q = q->next);
+	q->next = n;
+
+	return p;
+}
+
+sdp_list_t *sdp_list_remove(sdp_list_t *list, void *d)
+{
+	sdp_list_t *p, *q;
+
+	for (q = 0, p = list; p; q = p, p = p->next)
+		if (p->data == d) {
+			if (q)
+				q->next = p->next;
+			else
+				list = p->next;
+			free(p);
+			break;
+		}
+
+	return list;
+}
+
+sdp_list_t *sdp_list_insert_sorted(sdp_list_t *list, void *d,
+							sdp_comp_func_t f)
+{
+	sdp_list_t *q, *p, *n;
+
+	n = malloc(sizeof(sdp_list_t));
+	if (!n)
+		return NULL;
+	n->data = d;
+	for (q = 0, p = list; p; q = p, p = p->next)
+		if (f(p->data, d) >= 0)
+			break;
+	/* insert between q and p; if !q insert at head */
+	if (q)
+		q->next = n;
+	else
+		list = n;
+	n->next = p;
+	return list;
+}
+
+/*
+ * Every element of the list points to things which need
+ * to be free()'d. This method frees the list's contents
+ */
+void sdp_list_free(sdp_list_t *list, sdp_free_func_t f)
+{
+	sdp_list_t *next;
+	while (list) {
+		next = list->next;
+		if (f)
+			f(list->data);
+		free(list);
+		list = next;
+	}
+}
+
+static inline int __find_port(sdp_data_t *seq, int proto)
+{
+	if (!seq || !seq->next)
+		return 0;
+
+	if (SDP_IS_UUID(seq->dtd) && sdp_uuid_to_proto(&seq->val.uuid) == proto) {
+		seq = seq->next;
+		switch (seq->dtd) {
+		case SDP_UINT8:
+			return seq->val.uint8;
+		case SDP_UINT16:
+			return seq->val.uint16;
+		}
+	}
+	return 0;
+}
+
+int sdp_get_proto_port(const sdp_list_t *list, int proto)
+{
+	if (proto != L2CAP_UUID && proto != RFCOMM_UUID) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	for (; list; list = list->next) {
+		sdp_list_t *p;
+		for (p = list->data; p; p = p->next) {
+			sdp_data_t *seq = p->data;
+			int port = __find_port(seq, proto);
+			if (port)
+				return port;
+		}
+	}
+	return 0;
+}
+
+sdp_data_t *sdp_get_proto_desc(sdp_list_t *list, int proto)
+{
+	for (; list; list = list->next) {
+		sdp_list_t *p;
+		for (p = list->data; p; p = p->next) {
+			sdp_data_t *seq = p->data;
+			if (SDP_IS_UUID(seq->dtd) &&
+					sdp_uuid_to_proto(&seq->val.uuid) == proto)
+				return seq->next;
+		}
+	}
+	return NULL;
+}
+
+int sdp_get_access_protos(const sdp_record_t *rec, sdp_list_t **pap)
+{
+	sdp_data_t *pdlist, *curr;
+	sdp_list_t *ap = 0;
+
+	pdlist = sdp_data_get(rec, SDP_ATTR_PROTO_DESC_LIST);
+	if (pdlist == NULL) {
+		errno = ENODATA;
+		return -1;
+	}
+	SDPDBG("AP type : 0%x\n", pdlist->dtd);
+
+	for (; pdlist; pdlist = pdlist->next) {
+		sdp_list_t *pds = 0;
+		for (curr = pdlist->val.dataseq; curr; curr = curr->next)
+			pds = sdp_list_append(pds, curr->val.dataseq);
+		ap = sdp_list_append(ap, pds);
+	}
+	*pap = ap;
+	return 0;
+}
+
+int sdp_get_add_access_protos(const sdp_record_t *rec, sdp_list_t **pap)
+{
+	sdp_data_t *pdlist, *curr;
+	sdp_list_t *ap = 0;
+
+	pdlist = sdp_data_get(rec, SDP_ATTR_ADD_PROTO_DESC_LIST);
+	if (pdlist == NULL) {
+		errno = ENODATA;
+		return -1;
+	}
+	SDPDBG("AP type : 0%x\n", pdlist->dtd);
+
+	pdlist = pdlist->val.dataseq;
+
+	for (; pdlist; pdlist = pdlist->next) {
+		sdp_list_t *pds = 0;
+		for (curr = pdlist->val.dataseq; curr; curr = curr->next)
+			pds = sdp_list_append(pds, curr->val.dataseq);
+		ap = sdp_list_append(ap, pds);
+	}
+	*pap = ap;
+	return 0;
+}
+
+int sdp_get_uuidseq_attr(const sdp_record_t *rec, uint16_t attr,
+							sdp_list_t **seqp)
+{
+	sdp_data_t *sdpdata = sdp_data_get(rec, attr);
+
+	*seqp = NULL;
+	if (sdpdata && sdpdata->dtd >= SDP_SEQ8 && sdpdata->dtd <= SDP_SEQ32) {
+		sdp_data_t *d;
+		for (d = sdpdata->val.dataseq; d; d = d->next) {
+			uuid_t *u;
+			if (d->dtd < SDP_UUID16 || d->dtd > SDP_UUID128) {
+				errno = EINVAL;
+				goto fail;
+			}
+
+			u = malloc(sizeof(uuid_t));
+			if (!u)
+				goto fail;
+
+			memset(u, 0, sizeof(uuid_t));
+			*u = d->val.uuid;
+			*seqp = sdp_list_append(*seqp, u);
+		}
+		return 0;
+	}
+fail:
+	sdp_list_free(*seqp, free);
+	*seqp = NULL;
+	return -1;
+}
+
+int sdp_set_uuidseq_attr(sdp_record_t *rec, uint16_t aid, sdp_list_t *seq)
+{
+	int status = 0, i, len;
+	void **dtds, **values;
+	uint8_t uuid16 = SDP_UUID16;
+	uint8_t uuid32 = SDP_UUID32;
+	uint8_t uuid128 = SDP_UUID128;
+	sdp_list_t *p;
+
+	len = sdp_list_len(seq);
+	if (!seq || len == 0)
+		return -1;
+	dtds = malloc(len * sizeof(void *));
+	if (!dtds)
+		return -1;
+
+	values = malloc(len * sizeof(void *));
+	if (!values) {
+		free(dtds);
+		return -1;
+	}
+
+	for (p = seq, i = 0; i < len; i++, p = p->next) {
+		uuid_t *uuid = p->data;
+		if (uuid)
+			switch (uuid->type) {
+			case SDP_UUID16:
+				dtds[i] = &uuid16;
+				values[i] = &uuid->value.uuid16;
+				break;
+			case SDP_UUID32:
+				dtds[i] = &uuid32;
+				values[i] = &uuid->value.uuid32;
+				break;
+			case SDP_UUID128:
+				dtds[i] = &uuid128;
+				values[i] = &uuid->value.uuid128;
+				break;
+			default:
+				status = -1;
+				break;
+			}
+		else {
+			status = -1;
+			break;
+		}
+	}
+	if (status == 0) {
+		sdp_data_t *data = sdp_seq_alloc(dtds, values, len);
+		sdp_attr_replace(rec, aid, data);
+		sdp_pattern_add_uuidseq(rec, seq);
+	}
+	free(dtds);
+	free(values);
+	return status;
+}
+
+int sdp_get_lang_attr(const sdp_record_t *rec, sdp_list_t **langSeq)
+{
+	sdp_lang_attr_t *lang;
+	sdp_data_t *sdpdata, *curr_data;
+
+	*langSeq = NULL;
+	sdpdata = sdp_data_get(rec, SDP_ATTR_LANG_BASE_ATTR_ID_LIST);
+	if (sdpdata == NULL) {
+		errno = ENODATA;
+		return -1;
+	}
+	curr_data = sdpdata->val.dataseq;
+	while (curr_data) {
+		sdp_data_t *pCode = curr_data;
+		sdp_data_t *pEncoding;
+		sdp_data_t *pOffset;
+
+		pEncoding = pCode->next;
+		if (!pEncoding)
+			break;
+
+		pOffset = pEncoding->next;
+		if (!pOffset)
+			break;
+
+		lang = malloc(sizeof(sdp_lang_attr_t));
+		if (!lang) {
+			sdp_list_free(*langSeq, free);
+			*langSeq = NULL;
+			return -1;
+		}
+		lang->code_ISO639 = pCode->val.uint16;
+		lang->encoding = pEncoding->val.uint16;
+		lang->base_offset = pOffset->val.uint16;
+		SDPDBG("code_ISO639 :  0x%02x\n", lang->code_ISO639);
+		SDPDBG("encoding :     0x%02x\n", lang->encoding);
+		SDPDBG("base_offfset : 0x%02x\n", lang->base_offset);
+		*langSeq = sdp_list_append(*langSeq, lang);
+
+		curr_data = pOffset->next;
+	}
+
+	return 0;
+}
+
+int sdp_get_profile_descs(const sdp_record_t *rec, sdp_list_t **profDescSeq)
+{
+	sdp_profile_desc_t *profDesc;
+	sdp_data_t *sdpdata, *seq;
+
+	*profDescSeq = NULL;
+	sdpdata = sdp_data_get(rec, SDP_ATTR_PFILE_DESC_LIST);
+	if (!sdpdata || !sdpdata->val.dataseq) {
+		errno = ENODATA;
+		return -1;
+	}
+	for (seq = sdpdata->val.dataseq; seq && seq->val.dataseq; seq = seq->next) {
+		uuid_t *uuid = NULL;
+		uint16_t version = 0x100;
+
+		if (SDP_IS_UUID(seq->dtd)) {
+			uuid = &seq->val.uuid;
+		} else {
+			sdp_data_t *puuid = seq->val.dataseq;
+			sdp_data_t *pVnum = seq->val.dataseq->next;
+			if (puuid && pVnum) {
+				uuid = &puuid->val.uuid;
+				version = pVnum->val.uint16;
+			}
+		}
+
+		if (uuid != NULL) {
+			profDesc = malloc(sizeof(sdp_profile_desc_t));
+			if (!profDesc) {
+				sdp_list_free(*profDescSeq, free);
+				*profDescSeq = NULL;
+				return -1;
+			}
+			profDesc->uuid = *uuid;
+			profDesc->version = version;
+#ifdef SDP_DEBUG
+			sdp_uuid_print(&profDesc->uuid);
+			SDPDBG("Vnum : 0x%04x\n", profDesc->version);
+#endif
+			*profDescSeq = sdp_list_append(*profDescSeq, profDesc);
+		}
+	}
+	return 0;
+}
+
+int sdp_get_server_ver(const sdp_record_t *rec, sdp_list_t **u16)
+{
+	sdp_data_t *d, *curr;
+
+	*u16 = NULL;
+	d = sdp_data_get(rec, SDP_ATTR_VERSION_NUM_LIST);
+	if (d == NULL) {
+		errno = ENODATA;
+		return -1;
+	}
+	for (curr = d->val.dataseq; curr; curr = curr->next)
+		*u16 = sdp_list_append(*u16, &curr->val.uint16);
+	return 0;
+}
+
+/* flexible extraction of basic attributes - Jean II */
+/* How do we expect caller to extract predefined data sequences? */
+int sdp_get_int_attr(const sdp_record_t *rec, uint16_t attrid, int *value)
+{
+	sdp_data_t *sdpdata = sdp_data_get(rec, attrid);
+
+	if (sdpdata)
+		/* Verify that it is what the caller expects */
+		if (sdpdata->dtd == SDP_BOOL || sdpdata->dtd == SDP_UINT8 ||
+		sdpdata->dtd == SDP_UINT16 || sdpdata->dtd == SDP_UINT32 ||
+		sdpdata->dtd == SDP_INT8 || sdpdata->dtd == SDP_INT16 ||
+		sdpdata->dtd == SDP_INT32) {
+			*value = sdpdata->val.uint32;
+			return 0;
+		}
+	errno = EINVAL;
+	return -1;
+}
+
+int sdp_get_string_attr(const sdp_record_t *rec, uint16_t attrid, char *value,
+								int valuelen)
+{
+	sdp_data_t *sdpdata = sdp_data_get(rec, attrid);
+	if (sdpdata)
+		/* Verify that it is what the caller expects */
+		if (sdpdata->dtd == SDP_TEXT_STR8 ||
+				sdpdata->dtd == SDP_TEXT_STR16 ||
+				sdpdata->dtd == SDP_TEXT_STR32)
+			if ((int) strlen(sdpdata->val.str) < valuelen) {
+				strcpy(value, sdpdata->val.str);
+				return 0;
+			}
+	errno = EINVAL;
+	return -1;
+}
+
+#define get_basic_attr(attrID, pAttrValue, fieldName)		\
+	sdp_data_t *data = sdp_data_get(rec, attrID);		\
+	if (data) {						\
+		*pAttrValue = data->val.fieldName;		\
+		return 0;					\
+	}							\
+	errno = EINVAL;						\
+	return -1;
+
+int sdp_get_service_id(const sdp_record_t *rec, uuid_t *uuid)
+{
+	get_basic_attr(SDP_ATTR_SERVICE_ID, uuid, uuid);
+}
+
+int sdp_get_group_id(const sdp_record_t *rec, uuid_t *uuid)
+{
+	get_basic_attr(SDP_ATTR_GROUP_ID, uuid, uuid);
+}
+
+int sdp_get_record_state(const sdp_record_t *rec, uint32_t *svcRecState)
+{
+	get_basic_attr(SDP_ATTR_RECORD_STATE, svcRecState, uint32);
+}
+
+int sdp_get_service_avail(const sdp_record_t *rec, uint8_t *svcAvail)
+{
+	get_basic_attr(SDP_ATTR_SERVICE_AVAILABILITY, svcAvail, uint8);
+}
+
+int sdp_get_service_ttl(const sdp_record_t *rec, uint32_t *svcTTLInfo)
+{
+	get_basic_attr(SDP_ATTR_SVCINFO_TTL, svcTTLInfo, uint32);
+}
+
+int sdp_get_database_state(const sdp_record_t *rec, uint32_t *svcDBState)
+{
+	get_basic_attr(SDP_ATTR_SVCDB_STATE, svcDBState, uint32);
+}
+
+/*
+ * NOTE that none of the setXXX() functions below will
+ * actually update the SDP server, unless the
+ * {register, update}sdp_record_t() function is invoked.
+ */
+
+int sdp_attr_add_new(sdp_record_t *rec, uint16_t attr, uint8_t dtd,
+							const void *value)
+{
+	sdp_data_t *d = sdp_data_alloc(dtd, value);
+	if (d) {
+		sdp_attr_replace(rec, attr, d);
+		return 0;
+	}
+	return -1;
+}
+
+static int sdp_attr_add_new_with_length(sdp_record_t *rec,
+	uint16_t attr, uint8_t dtd, const void *value, uint32_t len)
+{
+	sdp_data_t *d;
+
+	d = sdp_data_alloc_with_length(dtd, value, len);
+	if (!d)
+		return -1;
+
+	sdp_attr_replace(rec, attr, d);
+
+	return 0;
+}
+
+/*
+ * Set the information attributes of the service
+ * pointed to by rec. The attributes are
+ * service name, description and provider name
+ */
+void sdp_set_info_attr(sdp_record_t *rec, const char *name, const char *prov,
+							const char *desc)
+{
+	if (name)
+		sdp_attr_add_new(rec, SDP_ATTR_SVCNAME_PRIMARY,
+							SDP_TEXT_STR8, name);
+	if (prov)
+		sdp_attr_add_new(rec, SDP_ATTR_PROVNAME_PRIMARY,
+							SDP_TEXT_STR8, prov);
+	if (desc)
+		sdp_attr_add_new(rec, SDP_ATTR_SVCDESC_PRIMARY,
+							SDP_TEXT_STR8, desc);
+}
+
+static sdp_data_t *access_proto_to_dataseq(sdp_record_t *rec, sdp_list_t *proto)
+{
+	sdp_data_t *seq = NULL;
+	void *dtds[10], *values[10];
+	void **seqDTDs, **seqs;
+	int i, seqlen;
+	sdp_list_t *p;
+
+	seqlen = sdp_list_len(proto);
+	seqDTDs = malloc(seqlen * sizeof(void *));
+	if (!seqDTDs)
+		return NULL;
+
+	seqs = malloc(seqlen * sizeof(void *));
+	if (!seqs) {
+		free(seqDTDs);
+		return NULL;
+	}
+
+	for (i = 0, p = proto; p; p = p->next, i++) {
+		sdp_list_t *elt = p->data;
+		sdp_data_t *s;
+		uuid_t *uuid = NULL;
+		unsigned int pslen = 0;
+		for (; elt && pslen < ARRAY_SIZE(dtds); elt = elt->next, pslen++) {
+			sdp_data_t *d = elt->data;
+			dtds[pslen] = &d->dtd;
+			switch (d->dtd) {
+			case SDP_UUID16:
+				uuid = (uuid_t *) d;
+				values[pslen] = &uuid->value.uuid16;
+				break;
+			case SDP_UUID32:
+				uuid = (uuid_t *) d;
+				values[pslen] = &uuid->value.uuid32;
+				break;
+			case SDP_UUID128:
+				uuid = (uuid_t *) d;
+				values[pslen] = &uuid->value.uuid128;
+				break;
+			case SDP_UINT8:
+				values[pslen] = &d->val.uint8;
+				break;
+			case SDP_UINT16:
+				values[pslen] = &d->val.uint16;
+				break;
+			case SDP_SEQ8:
+			case SDP_SEQ16:
+			case SDP_SEQ32:
+				values[pslen] = d;
+				break;
+			/* FIXME: more */
+			}
+		}
+		s = sdp_seq_alloc(dtds, values, pslen);
+		if (s) {
+			seqDTDs[i] = &s->dtd;
+			seqs[i] = s;
+			if (uuid)
+				sdp_pattern_add_uuid(rec, uuid);
+		}
+	}
+	seq = sdp_seq_alloc(seqDTDs, seqs, seqlen);
+	free(seqDTDs);
+	free(seqs);
+	return seq;
+}
+
+/*
+ * sets the access protocols of the service specified
+ * to the value specified in "access_proto"
+ *
+ * Note that if there are alternate mechanisms by
+ * which the service is accessed, then they should
+ * be specified as sequences
+ *
+ * Using a value of NULL for accessProtocols has
+ * effect of removing this attribute (if previously set)
+ *
+ * This function replaces the existing sdp_access_proto_t
+ * structure (if any) with the new one specified.
+ *
+ * returns 0 if successful or -1 if there is a failure.
+ */
+int sdp_set_access_protos(sdp_record_t *rec, const sdp_list_t *ap)
+{
+	const sdp_list_t *p;
+	sdp_data_t *protos = NULL;
+
+	for (p = ap; p; p = p->next) {
+		sdp_data_t *seq = access_proto_to_dataseq(rec, p->data);
+		protos = sdp_seq_append(protos, seq);
+	}
+
+	sdp_attr_add(rec, SDP_ATTR_PROTO_DESC_LIST, protos);
+
+	return 0;
+}
+
+int sdp_set_add_access_protos(sdp_record_t *rec, const sdp_list_t *ap)
+{
+	const sdp_list_t *p;
+	sdp_data_t *protos = NULL;
+
+	for (p = ap; p; p = p->next) {
+		sdp_data_t *seq = access_proto_to_dataseq(rec, p->data);
+		protos = sdp_seq_append(protos, seq);
+	}
+
+	sdp_attr_add(rec, SDP_ATTR_ADD_PROTO_DESC_LIST,
+			protos ? sdp_data_alloc(SDP_SEQ8, protos) : NULL);
+
+	return 0;
+}
+
+/*
+ * set the "LanguageBase" attributes of the service record
+ * record to the value specified in "langAttrList".
+ *
+ * "langAttrList" is a linked list of "sdp_lang_attr_t"
+ * objects, one for each language in which user visible
+ * attributes are present in the service record.
+ *
+ * Using a value of NULL for langAttrList has
+ * effect of removing this attribute (if previously set)
+ *
+ * This function replaces the exisiting sdp_lang_attr_t
+ * structure (if any) with the new one specified.
+ *
+ * returns 0 if successful or -1 if there is a failure.
+ */
+int sdp_set_lang_attr(sdp_record_t *rec, const sdp_list_t *seq)
+{
+	uint8_t uint16 = SDP_UINT16;
+	int status = 0, i = 0, seqlen = sdp_list_len(seq);
+	void **dtds, **values;
+	const sdp_list_t *p;
+
+	dtds = malloc(3 * seqlen * sizeof(void *));
+	if (!dtds)
+		return -1;
+
+	values = malloc(3 * seqlen * sizeof(void *));
+	if (!values) {
+		free(dtds);
+		return -1;
+	}
+
+	for (p = seq; p; p = p->next) {
+		sdp_lang_attr_t *lang = p->data;
+		if (!lang) {
+			status = -1;
+			break;
+		}
+		dtds[i] = &uint16;
+		values[i] = &lang->code_ISO639;
+		i++;
+		dtds[i] = &uint16;
+		values[i] = &lang->encoding;
+		i++;
+		dtds[i] = &uint16;
+		values[i] = &lang->base_offset;
+		i++;
+	}
+	if (status == 0) {
+		sdp_data_t *seq = sdp_seq_alloc(dtds, values, 3 * seqlen);
+		sdp_attr_add(rec, SDP_ATTR_LANG_BASE_ATTR_ID_LIST, seq);
+	}
+	free(dtds);
+	free(values);
+	return status;
+}
+
+/*
+ * set the "ServiceID" attribute of the service.
+ *
+ * This is the UUID of the service.
+ *
+ * returns 0 if successful or -1 if there is a failure.
+ */
+void sdp_set_service_id(sdp_record_t *rec, uuid_t uuid)
+{
+	switch (uuid.type) {
+	case SDP_UUID16:
+		sdp_attr_add_new(rec, SDP_ATTR_SERVICE_ID, SDP_UUID16,
+							&uuid.value.uuid16);
+		break;
+	case SDP_UUID32:
+		sdp_attr_add_new(rec, SDP_ATTR_SERVICE_ID, SDP_UUID32,
+							&uuid.value.uuid32);
+		break;
+	case SDP_UUID128:
+		sdp_attr_add_new(rec, SDP_ATTR_SERVICE_ID, SDP_UUID128,
+							&uuid.value.uuid128);
+		break;
+	}
+	sdp_pattern_add_uuid(rec, &uuid);
+}
+
+/*
+ * set the GroupID attribute of the service record defining a group.
+ *
+ * This is the UUID of the group.
+ *
+ * returns 0 if successful or -1 if there is a failure.
+ */
+void sdp_set_group_id(sdp_record_t *rec, uuid_t uuid)
+{
+	switch (uuid.type) {
+	case SDP_UUID16:
+		sdp_attr_add_new(rec, SDP_ATTR_GROUP_ID, SDP_UUID16,
+							&uuid.value.uuid16);
+		break;
+	case SDP_UUID32:
+		sdp_attr_add_new(rec, SDP_ATTR_GROUP_ID, SDP_UUID32,
+							&uuid.value.uuid32);
+		break;
+	case SDP_UUID128:
+		sdp_attr_add_new(rec, SDP_ATTR_GROUP_ID, SDP_UUID128,
+							&uuid.value.uuid128);
+		break;
+	}
+	sdp_pattern_add_uuid(rec, &uuid);
+}
+
+/*
+ * set the ProfileDescriptorList attribute of the service record
+ * pointed to by record to the value specified in "profileDesc".
+ *
+ * Each element in the list is an object of type
+ * sdp_profile_desc_t which is a definition of the
+ * Bluetooth profile that this service conforms to.
+ *
+ * Using a value of NULL for profileDesc has
+ * effect of removing this attribute (if previously set)
+ *
+ * This function replaces the exisiting ProfileDescriptorList
+ * structure (if any) with the new one specified.
+ *
+ * returns 0 if successful or -1 if there is a failure.
+ */
+int sdp_set_profile_descs(sdp_record_t *rec, const sdp_list_t *profiles)
+{
+	int status = 0;
+	uint8_t uuid16 = SDP_UUID16;
+	uint8_t uuid32 = SDP_UUID32;
+	uint8_t uuid128 = SDP_UUID128;
+	uint8_t uint16 = SDP_UINT16;
+	int i = 0, seqlen = sdp_list_len(profiles);
+	void **seqDTDs, **seqs;
+	const sdp_list_t *p;
+
+	seqDTDs = malloc(seqlen * sizeof(void *));
+	if (!seqDTDs)
+		return -1;
+
+	seqs = malloc(seqlen * sizeof(void *));
+	if (!seqs) {
+		free(seqDTDs);
+		return -1;
+	}
+
+	for (p = profiles; p; p = p->next) {
+		sdp_data_t *seq;
+		void *dtds[2], *values[2];
+		sdp_profile_desc_t *profile = p->data;
+		if (!profile) {
+			status = -1;
+			break;
+		}
+		switch (profile->uuid.type) {
+		case SDP_UUID16:
+			dtds[0] = &uuid16;
+			values[0] = &profile->uuid.value.uuid16;
+			break;
+		case SDP_UUID32:
+			dtds[0] = &uuid32;
+			values[0] = &profile->uuid.value.uuid32;
+			break;
+		case SDP_UUID128:
+			dtds[0] = &uuid128;
+			values[0] = &profile->uuid.value.uuid128;
+			break;
+		default:
+			status = -1;
+			break;
+		}
+		dtds[1] = &uint16;
+		values[1] = &profile->version;
+		seq = sdp_seq_alloc(dtds, values, 2);
+		if (seq) {
+			seqDTDs[i] = &seq->dtd;
+			seqs[i] = seq;
+			sdp_pattern_add_uuid(rec, &profile->uuid);
+		}
+		i++;
+	}
+	if (status == 0) {
+		sdp_data_t *pAPSeq = sdp_seq_alloc(seqDTDs, seqs, seqlen);
+		sdp_attr_add(rec, SDP_ATTR_PFILE_DESC_LIST, pAPSeq);
+	}
+	free(seqDTDs);
+	free(seqs);
+	return status;
+}
+
+/*
+ * sets various URL attributes of the service
+ * pointed to by record. The URL include
+ *
+ * client: a URL to the client's
+ *   platform specific (WinCE, PalmOS) executable
+ *   code that can be used to access this service.
+ *
+ * doc: a URL pointing to service documentation
+ *
+ * icon: a URL to an icon that can be used to represent
+ *   this service.
+ *
+ * Note that you need to pass NULL for any URLs
+ * that you don't want to set or remove
+ */
+void sdp_set_url_attr(sdp_record_t *rec, const char *client, const char *doc,
+							const char *icon)
+{
+	sdp_attr_add_new(rec, SDP_ATTR_CLNT_EXEC_URL, SDP_URL_STR8, client);
+	sdp_attr_add_new(rec, SDP_ATTR_DOC_URL, SDP_URL_STR8, doc);
+	sdp_attr_add_new(rec, SDP_ATTR_ICON_URL, SDP_URL_STR8, icon);
+}
+
+uuid_t *sdp_uuid16_create(uuid_t *u, uint16_t val)
+{
+	memset(u, 0, sizeof(uuid_t));
+	u->type = SDP_UUID16;
+	u->value.uuid16 = val;
+	return u;
+}
+
+uuid_t *sdp_uuid32_create(uuid_t *u, uint32_t val)
+{
+	memset(u, 0, sizeof(uuid_t));
+	u->type = SDP_UUID32;
+	u->value.uuid32 = val;
+	return u;
+}
+
+uuid_t *sdp_uuid128_create(uuid_t *u, const void *val)
+{
+	memset(u, 0, sizeof(uuid_t));
+	u->type = SDP_UUID128;
+	memcpy(&u->value.uuid128, val, sizeof(uint128_t));
+	return u;
+}
+
+/*
+ * UUID comparison function
+ * returns 0 if uuidValue1 == uuidValue2 else -1
+ */
+int sdp_uuid_cmp(const void *p1, const void *p2)
+{
+	uuid_t *u1 = sdp_uuid_to_uuid128(p1);
+	uuid_t *u2 = sdp_uuid_to_uuid128(p2);
+	int ret;
+
+	ret = sdp_uuid128_cmp(u1, u2);
+
+	bt_free(u1);
+	bt_free(u2);
+
+	return ret;
+}
+
+/*
+ * UUID comparison function
+ * returns 0 if uuidValue1 == uuidValue2 else -1
+ */
+int sdp_uuid16_cmp(const void *p1, const void *p2)
+{
+	const uuid_t *u1 = p1;
+	const uuid_t *u2 = p2;
+	return memcmp(&u1->value.uuid16, &u2->value.uuid16, sizeof(uint16_t));
+}
+
+/*
+ * UUID comparison function
+ * returns 0 if uuidValue1 == uuidValue2 else -1
+ */
+int sdp_uuid128_cmp(const void *p1, const void *p2)
+{
+	const uuid_t *u1 = p1;
+	const uuid_t *u2 = p2;
+	return memcmp(&u1->value.uuid128, &u2->value.uuid128, sizeof(uint128_t));
+}
+
+/*
+ * 128 to 16 bit and 32 to 16 bit UUID conversion functions
+ * yet to be implemented. Note that the input is in NBO in
+ * both 32 and 128 bit UUIDs and conversion is needed
+ */
+void sdp_uuid16_to_uuid128(uuid_t *uuid128, const uuid_t *uuid16)
+{
+	/*
+	 * We have a 16 bit value, which needs to be added to
+	 * bytes 3 and 4 (at indices 2 and 3) of the Bluetooth base
+	 */
+	unsigned short data1;
+
+	/* allocate a 128bit UUID and init to the Bluetooth base UUID */
+	uuid128->value.uuid128 = bluetooth_base_uuid;
+	uuid128->type = SDP_UUID128;
+
+	/* extract bytes 2 and 3 of 128bit BT base UUID */
+	memcpy(&data1, &bluetooth_base_uuid.data[2], 2);
+
+	/* add the given UUID (16 bits) */
+	data1 += htons(uuid16->value.uuid16);
+
+	/* set bytes 2 and 3 of the 128 bit value */
+	memcpy(&uuid128->value.uuid128.data[2], &data1, 2);
+}
+
+void sdp_uuid32_to_uuid128(uuid_t *uuid128, const uuid_t *uuid32)
+{
+	/*
+	 * We have a 32 bit value, which needs to be added to
+	 * bytes 1->4 (at indices 0 thru 3) of the Bluetooth base
+	 */
+	unsigned int data0;
+
+	/* allocate a 128bit UUID and init to the Bluetooth base UUID */
+	uuid128->value.uuid128 = bluetooth_base_uuid;
+	uuid128->type = SDP_UUID128;
+
+	/* extract first 4 bytes */
+	memcpy(&data0, &bluetooth_base_uuid.data[0], 4);
+
+	/* add the given UUID (32bits) */
+	data0 += htonl(uuid32->value.uuid32);
+
+	/* set the 4 bytes of the 128 bit value */
+	memcpy(&uuid128->value.uuid128.data[0], &data0, 4);
+}
+
+uuid_t *sdp_uuid_to_uuid128(const uuid_t *uuid)
+{
+	uuid_t *uuid128 = bt_malloc(sizeof(uuid_t));
+
+	if (!uuid128)
+		return NULL;
+
+	memset(uuid128, 0, sizeof(uuid_t));
+	switch (uuid->type) {
+	case SDP_UUID128:
+		*uuid128 = *uuid;
+		break;
+	case SDP_UUID32:
+		sdp_uuid32_to_uuid128(uuid128, uuid);
+		break;
+	case SDP_UUID16:
+		sdp_uuid16_to_uuid128(uuid128, uuid);
+		break;
+	}
+	return uuid128;
+}
+
+/*
+ * converts a 128-bit uuid to a 16/32-bit one if possible
+ * returns true if uuid contains a 16/32-bit UUID at exit
+ */
+int sdp_uuid128_to_uuid(uuid_t *uuid)
+{
+	uint128_t *b = &bluetooth_base_uuid;
+	uint128_t *u = &uuid->value.uuid128;
+	uint32_t data;
+	unsigned int i;
+
+	if (uuid->type != SDP_UUID128)
+		return 1;
+
+	for (i = 4; i < sizeof(b->data); i++)
+		if (b->data[i] != u->data[i])
+			return 0;
+
+	memcpy(&data, u->data, 4);
+	data = htonl(data);
+	if (data <= 0xffff) {
+		uuid->type = SDP_UUID16;
+		uuid->value.uuid16 = (uint16_t) data;
+	} else {
+		uuid->type = SDP_UUID32;
+		uuid->value.uuid32 = data;
+	}
+	return 1;
+}
+
+/*
+ * convert a UUID to the 16-bit short-form
+ */
+int sdp_uuid_to_proto(uuid_t *uuid)
+{
+	uuid_t u = *uuid;
+	if (sdp_uuid128_to_uuid(&u)) {
+		switch (u.type) {
+		case SDP_UUID16:
+			return u.value.uuid16;
+		case SDP_UUID32:
+			return u.value.uuid32;
+		}
+	}
+	return 0;
+}
+
+/*
+ * This function appends data to the PDU buffer "dst" from source "src".
+ * The data length is also computed and set.
+ * Should the PDU length exceed 2^8, then sequence type is
+ * set accordingly and the data is memmove()'d.
+ */
+void sdp_append_to_buf(sdp_buf_t *dst, uint8_t *data, uint32_t len)
+{
+	uint8_t *p = dst->data;
+	uint8_t dtd = *p;
+
+	SDPDBG("Append src size: %d\n", len);
+	SDPDBG("Append dst size: %d\n", dst->data_size);
+	SDPDBG("Dst buffer size: %d\n", dst->buf_size);
+	if (dst->data_size == 0 && dtd == 0) {
+		/* create initial sequence */
+		*p = SDP_SEQ8;
+		dst->data_size += sizeof(uint8_t);
+		/* reserve space for sequence size */
+		dst->data_size += sizeof(uint8_t);
+	}
+
+	memcpy(dst->data + dst->data_size, data, len);
+	dst->data_size += len;
+
+	dtd = *(uint8_t *) dst->data;
+	if (dst->data_size > UCHAR_MAX && dtd == SDP_SEQ8) {
+		short offset = sizeof(uint8_t) + sizeof(uint8_t);
+		memmove(dst->data + offset + 1, dst->data + offset,
+						dst->data_size - offset);
+		*p = SDP_SEQ16;
+		dst->data_size += 1;
+	}
+	dtd = *(uint8_t *) p;
+	p += sizeof(uint8_t);
+	switch (dtd) {
+	case SDP_SEQ8:
+		*(uint8_t *) p = dst->data_size - sizeof(uint8_t) - sizeof(uint8_t);
+		break;
+	case SDP_SEQ16:
+		bt_put_unaligned(htons(dst->data_size - sizeof(uint8_t) - sizeof(uint16_t)), (uint16_t *) p);
+		break;
+	case SDP_SEQ32:
+		bt_put_unaligned(htonl(dst->data_size - sizeof(uint8_t) - sizeof(uint32_t)), (uint32_t *) p);
+		break;
+	}
+}
+
+void sdp_append_to_pdu(sdp_buf_t *pdu, sdp_data_t *d)
+{
+	sdp_buf_t append;
+
+	memset(&append, 0, sizeof(sdp_buf_t));
+	sdp_gen_buffer(&append, d);
+	append.data = malloc(append.buf_size);
+	if (!append.data)
+		return;
+
+	sdp_set_attrid(&append, d->attrId);
+	sdp_gen_pdu(&append, d);
+	sdp_append_to_buf(pdu, append.data, append.data_size);
+	free(append.data);
+}
+
+/*
+ * Registers an sdp record.
+ *
+ * It is incorrect to call this method on a record that
+ * has been already registered with the server.
+ *
+ * Returns zero on success, otherwise -1 (and sets errno).
+ */
+int sdp_device_record_register_binary(sdp_session_t *session, bdaddr_t *device, uint8_t *data, uint32_t size, uint8_t flags, uint32_t *handle)
+{
+	uint8_t *req, *rsp, *p;
+	uint32_t reqsize, rspsize;
+	sdp_pdu_hdr_t *reqhdr, *rsphdr;
+	int status;
+
+	SDPDBG("");
+
+	if (!session->local) {
+		errno = EREMOTE;
+		return -1;
+	}
+	req = malloc(SDP_REQ_BUFFER_SIZE);
+	rsp = malloc(SDP_RSP_BUFFER_SIZE);
+	if (req == NULL || rsp == NULL) {
+		status = -1;
+		errno = ENOMEM;
+		goto end;
+	}
+
+	reqhdr = (sdp_pdu_hdr_t *)req;
+	reqhdr->pdu_id = SDP_SVC_REGISTER_REQ;
+	reqhdr->tid    = htons(sdp_gen_tid(session));
+	reqsize = sizeof(sdp_pdu_hdr_t) + 1;
+	p = req + sizeof(sdp_pdu_hdr_t);
+
+	if (bacmp(device, BDADDR_ANY)) {
+		*p++ = flags | SDP_DEVICE_RECORD;
+		bacpy((bdaddr_t *) p, device);
+		p += sizeof(bdaddr_t);
+		reqsize += sizeof(bdaddr_t);
+	} else
+		*p++ = flags;
+
+	memcpy(p, data, size);
+	reqsize += size;
+	reqhdr->plen = htons(reqsize - sizeof(sdp_pdu_hdr_t));
+
+	status = sdp_send_req_w4_rsp(session, req, rsp, reqsize, &rspsize);
+	if (status < 0)
+		goto end;
+
+	if (rspsize < sizeof(sdp_pdu_hdr_t)) {
+		SDPERR("Unexpected end of packet");
+		errno = EPROTO;
+		status = -1;
+		goto end;
+	}
+
+	rsphdr = (sdp_pdu_hdr_t *) rsp;
+	p = rsp + sizeof(sdp_pdu_hdr_t);
+
+	if (rsphdr->pdu_id == SDP_ERROR_RSP) {
+		/* Invalid service record */
+		errno = EINVAL;
+		status = -1;
+	} else if (rsphdr->pdu_id != SDP_SVC_REGISTER_RSP) {
+		errno = EPROTO;
+		status = -1;
+	} else {
+		if (rspsize < sizeof(sdp_pdu_hdr_t) + sizeof(uint32_t)) {
+			SDPERR("Unexpected end of packet");
+			errno = EPROTO;
+			status = -1;
+			goto end;
+		}
+		if (handle)
+			*handle  = ntohl(bt_get_unaligned((uint32_t *) p));
+	}
+
+end:
+	free(req);
+	free(rsp);
+
+	return status;
+}
+
+int sdp_device_record_register(sdp_session_t *session, bdaddr_t *device, sdp_record_t *rec, uint8_t flags)
+{
+	sdp_buf_t pdu;
+	uint32_t handle;
+	int err;
+
+	SDPDBG("");
+
+	if (rec->handle && rec->handle != 0xffffffff) {
+		uint32_t handle = rec->handle;
+		sdp_data_t *data = sdp_data_alloc(SDP_UINT32, &handle);
+		sdp_attr_replace(rec, SDP_ATTR_RECORD_HANDLE, data);
+	}
+
+	if (sdp_gen_record_pdu(rec, &pdu) < 0) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	err = sdp_device_record_register_binary(session, device,
+				pdu.data, pdu.data_size, flags, &handle);
+
+	free(pdu.data);
+
+	if (err == 0) {
+		sdp_data_t *data = sdp_data_alloc(SDP_UINT32, &handle);
+		rec->handle = handle;
+		sdp_attr_replace(rec, SDP_ATTR_RECORD_HANDLE, data);
+	}
+
+	return err;
+}
+
+int sdp_record_register(sdp_session_t *session, sdp_record_t *rec, uint8_t flags)
+{
+	return sdp_device_record_register(session, BDADDR_ANY, rec, flags);
+}
+
+/*
+ * unregister a service record
+ */
+int sdp_device_record_unregister_binary(sdp_session_t *session, bdaddr_t *device, uint32_t handle)
+{
+	uint8_t *reqbuf, *rspbuf, *p;
+	uint32_t reqsize = 0, rspsize = 0;
+	sdp_pdu_hdr_t *reqhdr, *rsphdr;
+	int status;
+
+	SDPDBG("");
+
+	if (handle == SDP_SERVER_RECORD_HANDLE) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if (!session->local) {
+		errno = EREMOTE;
+		return -1;
+	}
+
+	reqbuf = malloc(SDP_REQ_BUFFER_SIZE);
+	rspbuf = malloc(SDP_RSP_BUFFER_SIZE);
+	if (!reqbuf || !rspbuf) {
+		errno = ENOMEM;
+		status = -1;
+		goto end;
+	}
+	reqhdr = (sdp_pdu_hdr_t *) reqbuf;
+	reqhdr->pdu_id = SDP_SVC_REMOVE_REQ;
+	reqhdr->tid    = htons(sdp_gen_tid(session));
+
+	p = reqbuf + sizeof(sdp_pdu_hdr_t);
+	reqsize = sizeof(sdp_pdu_hdr_t);
+	bt_put_unaligned(htonl(handle), (uint32_t *) p);
+	reqsize += sizeof(uint32_t);
+
+	reqhdr->plen = htons(reqsize - sizeof(sdp_pdu_hdr_t));
+	status = sdp_send_req_w4_rsp(session, reqbuf, rspbuf, reqsize, &rspsize);
+	if (status < 0)
+		goto end;
+
+	if (rspsize < sizeof(sdp_pdu_hdr_t) + sizeof(uint16_t)) {
+		SDPERR("Unexpected end of packet");
+		errno = EPROTO;
+		status = -1;
+		goto end;
+	}
+
+	rsphdr = (sdp_pdu_hdr_t *) rspbuf;
+	p = rspbuf + sizeof(sdp_pdu_hdr_t);
+	status = bt_get_unaligned((uint16_t *) p);
+
+	if (rsphdr->pdu_id == SDP_ERROR_RSP) {
+		/* For this case the status always is invalid record handle */
+		errno = EINVAL;
+		status = -1;
+	} else if (rsphdr->pdu_id != SDP_SVC_REMOVE_RSP) {
+		errno = EPROTO;
+		status = -1;
+	}
+end:
+	free(reqbuf);
+	free(rspbuf);
+
+	return status;
+}
+
+int sdp_device_record_unregister(sdp_session_t *session, bdaddr_t *device, sdp_record_t *rec)
+{
+	int err;
+
+	err = sdp_device_record_unregister_binary(session, device, rec->handle);
+	if (err == 0)
+		sdp_record_free(rec);
+
+	return err;
+}
+
+int sdp_record_unregister(sdp_session_t *session, sdp_record_t *rec)
+{
+	return sdp_device_record_unregister(session, BDADDR_ANY, rec);
+}
+
+/*
+ * modify an existing service record
+ */
+int sdp_device_record_update_binary(sdp_session_t *session, bdaddr_t *device, uint32_t handle, uint8_t *data, uint32_t size)
+{
+	return -1;
+}
+
+int sdp_device_record_update(sdp_session_t *session, bdaddr_t *device, const sdp_record_t *rec)
+{
+	uint8_t *reqbuf, *rspbuf, *p;
+	uint32_t reqsize, rspsize;
+	sdp_pdu_hdr_t *reqhdr, *rsphdr;
+	uint32_t handle;
+	sdp_buf_t pdu;
+	int status;
+
+	SDPDBG("");
+
+	handle = rec->handle;
+
+	if (handle == SDP_SERVER_RECORD_HANDLE) {
+		errno = EINVAL;
+		return -1;
+	}
+	if (!session->local) {
+		errno = EREMOTE;
+		return -1;
+	}
+	reqbuf = malloc(SDP_REQ_BUFFER_SIZE);
+	rspbuf = malloc(SDP_RSP_BUFFER_SIZE);
+	if (!reqbuf || !rspbuf) {
+		errno = ENOMEM;
+		status = -1;
+		goto end;
+	}
+	reqhdr = (sdp_pdu_hdr_t *) reqbuf;
+	reqhdr->pdu_id = SDP_SVC_UPDATE_REQ;
+	reqhdr->tid    = htons(sdp_gen_tid(session));
+
+	p = reqbuf + sizeof(sdp_pdu_hdr_t);
+	reqsize = sizeof(sdp_pdu_hdr_t);
+
+	bt_put_unaligned(htonl(handle), (uint32_t *) p);
+	reqsize += sizeof(uint32_t);
+	p += sizeof(uint32_t);
+
+	if (sdp_gen_record_pdu(rec, &pdu) < 0) {
+		errno = ENOMEM;
+		status = -1;
+		goto end;
+	}
+	memcpy(p, pdu.data, pdu.data_size);
+	reqsize += pdu.data_size;
+	free(pdu.data);
+
+	reqhdr->plen = htons(reqsize - sizeof(sdp_pdu_hdr_t));
+	status = sdp_send_req_w4_rsp(session, reqbuf, rspbuf, reqsize, &rspsize);
+	if (status < 0)
+		goto end;
+
+	if (rspsize < sizeof(sdp_pdu_hdr_t) + sizeof(uint16_t)) {
+		SDPERR("Unexpected end of packet");
+		errno = EPROTO;
+		status = -1;
+		goto end;
+	}
+
+	SDPDBG("Send req status : %d\n", status);
+
+	rsphdr = (sdp_pdu_hdr_t *) rspbuf;
+	p = rspbuf + sizeof(sdp_pdu_hdr_t);
+	status = bt_get_unaligned((uint16_t *) p);
+
+	if (rsphdr->pdu_id == SDP_ERROR_RSP) {
+		/* The status can be invalid sintax or invalid record handle */
+		errno = EINVAL;
+		status = -1;
+	} else if (rsphdr->pdu_id != SDP_SVC_UPDATE_RSP) {
+		errno = EPROTO;
+		status = -1;
+	}
+end:
+	free(reqbuf);
+	free(rspbuf);
+	return status;
+}
+
+int sdp_record_update(sdp_session_t *session, const sdp_record_t *rec)
+{
+	return sdp_device_record_update(session, BDADDR_ANY, rec);
+}
+
+sdp_record_t *sdp_record_alloc(void)
+{
+	sdp_record_t *rec = malloc(sizeof(sdp_record_t));
+
+	if (!rec)
+		return NULL;
+
+	memset(rec, 0, sizeof(sdp_record_t));
+	rec->handle = 0xffffffff;
+	return rec;
+}
+
+/*
+ * Free the contents of a service record
+ */
+void sdp_record_free(sdp_record_t *rec)
+{
+	sdp_list_free(rec->attrlist, (sdp_free_func_t) sdp_data_free);
+	sdp_list_free(rec->pattern, free);
+	free(rec);
+}
+
+void sdp_pattern_add_uuid(sdp_record_t *rec, uuid_t *uuid)
+{
+	uuid_t *uuid128 = sdp_uuid_to_uuid128(uuid);
+
+	SDPDBG("Elements in target pattern : %d\n", sdp_list_len(rec->pattern));
+	SDPDBG("Trying to add : 0x%lx\n", (unsigned long) uuid128);
+
+	if (sdp_list_find(rec->pattern, uuid128, sdp_uuid128_cmp) == NULL)
+		rec->pattern = sdp_list_insert_sorted(rec->pattern, uuid128, sdp_uuid128_cmp);
+	else
+		bt_free(uuid128);
+
+	SDPDBG("Elements in target pattern : %d\n", sdp_list_len(rec->pattern));
+}
+
+void sdp_pattern_add_uuidseq(sdp_record_t *rec, sdp_list_t *seq)
+{
+	for (; seq; seq = seq->next) {
+		uuid_t *uuid = (uuid_t *)seq->data;
+		sdp_pattern_add_uuid(rec, uuid);
+	}
+}
+
+/*
+ * Extract a sequence of service record handles from a PDU buffer
+ * and add the entries to a sdp_list_t. Note that the service record
+ * handles are not in "data element sequence" form, but just like
+ * an array of service handles
+ */
+static void extract_record_handle_seq(uint8_t *pdu, int bufsize, sdp_list_t **seq, int count, unsigned int *scanned)
+{
+	sdp_list_t *pSeq = *seq;
+	uint8_t *pdata = pdu;
+	int n;
+
+	for (n = 0; n < count; n++) {
+		uint32_t *pSvcRec;
+		if (bufsize < (int) sizeof(uint32_t)) {
+			SDPERR("Unexpected end of packet");
+			break;
+		}
+		pSvcRec = malloc(sizeof(uint32_t));
+		if (!pSvcRec)
+			break;
+		*pSvcRec = ntohl(bt_get_unaligned((uint32_t *) pdata));
+		pSeq = sdp_list_append(pSeq, pSvcRec);
+		pdata += sizeof(uint32_t);
+		*scanned += sizeof(uint32_t);
+		bufsize -= sizeof(uint32_t);
+	}
+	*seq = pSeq;
+}
+/*
+ * Generate the attribute sequence pdu form
+ * from sdp_list_t elements. Return length of attr seq
+ */
+static int gen_dataseq_pdu(uint8_t *dst, const sdp_list_t *seq, uint8_t dtd)
+{
+	sdp_data_t *dataseq;
+	void **types, **values;
+	sdp_buf_t buf;
+	int i, seqlen = sdp_list_len(seq);
+
+	/* Fill up the value and the dtd arrays */
+	SDPDBG("");
+
+	SDPDBG("Seq length : %d\n", seqlen);
+
+	types = malloc(seqlen * sizeof(void *));
+	if (!types)
+		return -ENOMEM;
+
+	values = malloc(seqlen * sizeof(void *));
+	if (!values) {
+		free(types);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < seqlen; i++) {
+		void *data = seq->data;
+		types[i] = &dtd;
+		if (SDP_IS_UUID(dtd))
+			data = &((uuid_t *)data)->value;
+		values[i] = data;
+		seq = seq->next;
+	}
+
+	dataseq = sdp_seq_alloc(types, values, seqlen);
+	if (!dataseq) {
+		free(types);
+		free(values);
+		return -ENOMEM;
+	}
+
+	memset(&buf, 0, sizeof(sdp_buf_t));
+	sdp_gen_buffer(&buf, dataseq);
+	buf.data = malloc(buf.buf_size);
+
+	if (!buf.data) {
+		sdp_data_free(dataseq);
+		free(types);
+		free(values);
+		return -ENOMEM;
+	}
+
+	SDPDBG("Data Seq : 0x%p\n", seq);
+	seqlen = sdp_gen_pdu(&buf, dataseq);
+	SDPDBG("Copying : %d\n", buf.data_size);
+	memcpy(dst, buf.data, buf.data_size);
+
+	sdp_data_free(dataseq);
+
+	free(types);
+	free(values);
+	free(buf.data);
+	return seqlen;
+}
+
+static int gen_searchseq_pdu(uint8_t *dst, const sdp_list_t *seq)
+{
+	uuid_t *uuid = seq->data;
+	return gen_dataseq_pdu(dst, seq, uuid->type);
+}
+
+static int gen_attridseq_pdu(uint8_t *dst, const sdp_list_t *seq, uint8_t dataType)
+{
+	return gen_dataseq_pdu(dst, seq, dataType);
+}
+
+typedef struct {
+	uint8_t length;
+	unsigned char data[16];
+} __attribute__ ((packed)) sdp_cstate_t;
+
+static int copy_cstate(uint8_t *pdata, int pdata_len, const sdp_cstate_t *cstate)
+{
+	if (cstate) {
+		uint8_t len = cstate->length;
+		if (len >= pdata_len) {
+			SDPERR("Continuation state size exceeds internal buffer");
+			len = pdata_len - 1;
+		}
+		*pdata++ = len;
+		memcpy(pdata, cstate->data, len);
+		return len + 1;
+	}
+	*pdata = 0;
+	return 1;
+}
+
+/*
+ * This is a service search request.
+ *
+ * INPUT :
+ *
+ *   sdp_list_t *search
+ *     Singly linked list containing elements of the search
+ *     pattern. Each entry in the list is a UUID (DataTypeSDP_UUID16)
+ *     of the service to be searched
+ *
+ *   uint16_t max_rec_num
+ *      A 16 bit integer which tells the service, the maximum
+ *      entries that the client can handle in the response. The
+ *      server is obliged not to return > max_rec_num entries
+ *
+ * OUTPUT :
+ *
+ *   int return value
+ *     0:
+ *       The request completed successfully. This does not
+ *       mean the requested services were found
+ *     -1:
+ *       On any failure and sets errno
+ *
+ *   sdp_list_t **rsp_list
+ *     This variable is set on a successful return if there are
+ *     non-zero service handles. It is a singly linked list of
+ *     service record handles (uint16_t)
+ */
+int sdp_service_search_req(sdp_session_t *session, const sdp_list_t *search,
+			uint16_t max_rec_num, sdp_list_t **rsp)
+{
+	int status = 0;
+	uint32_t reqsize = 0, _reqsize;
+	uint32_t rspsize = 0, rsplen;
+	int seqlen = 0;
+	int rec_count;
+	unsigned scanned, pdata_len;
+	uint8_t *pdata, *_pdata;
+	uint8_t *reqbuf, *rspbuf;
+	sdp_pdu_hdr_t *reqhdr, *rsphdr;
+	sdp_cstate_t *cstate = NULL;
+
+	reqbuf = malloc(SDP_REQ_BUFFER_SIZE);
+	rspbuf = malloc(SDP_RSP_BUFFER_SIZE);
+	if (!reqbuf || !rspbuf) {
+		errno = ENOMEM;
+		status = -1;
+		goto end;
+	}
+	reqhdr = (sdp_pdu_hdr_t *) reqbuf;
+	reqhdr->pdu_id = SDP_SVC_SEARCH_REQ;
+	pdata = reqbuf + sizeof(sdp_pdu_hdr_t);
+	reqsize = sizeof(sdp_pdu_hdr_t);
+
+	/* add service class IDs for search */
+	seqlen = gen_searchseq_pdu(pdata, search);
+
+	SDPDBG("Data seq added : %d\n", seqlen);
+
+	/* set the length and increment the pointer */
+	reqsize += seqlen;
+	pdata += seqlen;
+
+	/* specify the maximum svc rec count that client expects */
+	bt_put_unaligned(htons(max_rec_num), (uint16_t *) pdata);
+	reqsize += sizeof(uint16_t);
+	pdata += sizeof(uint16_t);
+
+	_reqsize = reqsize;
+	_pdata   = pdata;
+	*rsp = NULL;
+
+	do {
+		/* Add continuation state or NULL (first time) */
+		reqsize = _reqsize + copy_cstate(_pdata,
+					SDP_REQ_BUFFER_SIZE - _reqsize, cstate);
+
+		/* Set the request header's param length */
+		reqhdr->plen = htons(reqsize - sizeof(sdp_pdu_hdr_t));
+
+		reqhdr->tid  = htons(sdp_gen_tid(session));
+		/*
+		 * Send the request, wait for response and if
+		 * no error, set the appropriate values and return
+		 */
+		status = sdp_send_req_w4_rsp(session, reqbuf, rspbuf, reqsize, &rspsize);
+		if (status < 0)
+			goto end;
+
+		if (rspsize < sizeof(sdp_pdu_hdr_t)) {
+			SDPERR("Unexpected end of packet");
+			status = -1;
+			goto end;
+		}
+
+		rsphdr = (sdp_pdu_hdr_t *) rspbuf;
+		rsplen = ntohs(rsphdr->plen);
+
+		if (rsphdr->pdu_id == SDP_ERROR_RSP) {
+			SDPDBG("Status : 0x%x\n", rsphdr->pdu_id);
+			status = -1;
+			goto end;
+		}
+		scanned = 0;
+		pdata = rspbuf + sizeof(sdp_pdu_hdr_t);
+		pdata_len = rspsize - sizeof(sdp_pdu_hdr_t);
+
+		if (pdata_len < sizeof(uint16_t) + sizeof(uint16_t)) {
+			SDPERR("Unexpected end of packet");
+			status = -1;
+			goto end;
+		}
+
+		/* net service record match count */
+		pdata += sizeof(uint16_t);
+		scanned += sizeof(uint16_t);
+		pdata_len -= sizeof(uint16_t);
+		rec_count = ntohs(bt_get_unaligned((uint16_t *) pdata));
+		pdata += sizeof(uint16_t);
+		scanned += sizeof(uint16_t);
+		pdata_len -= sizeof(uint16_t);
+
+		SDPDBG("Total svc count: %d\n", total_rec_count);
+		SDPDBG("Current svc count: %d\n", rec_count);
+		SDPDBG("ResponseLength: %d\n", rsplen);
+
+		if (!rec_count) {
+			status = -1;
+			goto end;
+		}
+		extract_record_handle_seq(pdata, pdata_len, rsp, rec_count, &scanned);
+		SDPDBG("BytesScanned : %d\n", scanned);
+
+		if (rsplen > scanned) {
+			uint8_t cstate_len;
+
+			if (rspsize < sizeof(sdp_pdu_hdr_t) + scanned + sizeof(uint8_t)) {
+				SDPERR("Unexpected end of packet: continuation state data missing");
+				status = -1;
+				goto end;
+			}
+
+			pdata = rspbuf + sizeof(sdp_pdu_hdr_t) + scanned;
+			cstate_len = *(uint8_t *) pdata;
+			if (cstate_len > 0) {
+				cstate = (sdp_cstate_t *)pdata;
+				SDPDBG("Cont state length: %d\n", cstate_len);
+			} else
+				cstate = NULL;
+		}
+	} while (cstate);
+
+end:
+	free(reqbuf);
+	free(rspbuf);
+
+	return status;
+}
+
+/*
+ * This is a service attribute request.
+ *
+ * INPUT :
+ *
+ *   uint32_t handle
+ *     The handle of the service for which the attribute(s) are
+ *     requested
+ *
+ *   sdp_attrreq_type_t reqtype
+ *     Attribute identifiers are 16 bit unsigned integers specified
+ *     in one of 2 ways described below :
+ *     SDP_ATTR_REQ_INDIVIDUAL - 16bit individual identifiers
+ *        They are the actual attribute identifiers in ascending order
+ *
+ *     SDP_ATTR_REQ_RANGE - 32bit identifier range
+ *        The high-order 16bits is the start of range
+ *        the low-order 16bits are the end of range
+ *        0x0000 to 0xFFFF gets all attributes
+ *
+ *   sdp_list_t *attrid
+ *     Singly linked list containing attribute identifiers desired.
+ *     Every element is either a uint16_t(attrSpec = SDP_ATTR_REQ_INDIVIDUAL)
+ *     or a uint32_t(attrSpec=SDP_ATTR_REQ_RANGE)
+ *
+ * OUTPUT :
+ *   return sdp_record_t *
+ *     0:
+ *       On any error and sets errno
+ *     !0:
+ *	 The service record
+ */
+sdp_record_t *sdp_service_attr_req(sdp_session_t *session, uint32_t handle,
+			sdp_attrreq_type_t reqtype, const sdp_list_t *attrids)
+{
+	uint32_t reqsize = 0, _reqsize;
+	uint32_t rspsize = 0, rsp_count;
+	int attr_list_len = 0;
+	int seqlen = 0;
+	unsigned int pdata_len;
+	uint8_t *pdata, *_pdata;
+	uint8_t *reqbuf, *rspbuf;
+	sdp_pdu_hdr_t *reqhdr, *rsphdr;
+	sdp_cstate_t *cstate = NULL;
+	uint8_t cstate_len = 0;
+	sdp_buf_t rsp_concat_buf;
+	sdp_record_t *rec = 0;
+
+	if (reqtype != SDP_ATTR_REQ_INDIVIDUAL && reqtype != SDP_ATTR_REQ_RANGE) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	memset(&rsp_concat_buf, 0, sizeof(sdp_buf_t));
+
+	reqbuf = malloc(SDP_REQ_BUFFER_SIZE);
+	rspbuf = malloc(SDP_RSP_BUFFER_SIZE);
+	if (!reqbuf || !rspbuf) {
+		errno = ENOMEM;
+		goto end;
+	}
+	reqhdr = (sdp_pdu_hdr_t *) reqbuf;
+	reqhdr->pdu_id = SDP_SVC_ATTR_REQ;
+
+	pdata = reqbuf + sizeof(sdp_pdu_hdr_t);
+	reqsize = sizeof(sdp_pdu_hdr_t);
+
+	/* add the service record handle */
+	bt_put_unaligned(htonl(handle), (uint32_t *) pdata);
+	reqsize += sizeof(uint32_t);
+	pdata += sizeof(uint32_t);
+
+	/* specify the response limit */
+	bt_put_unaligned(htons(65535), (uint16_t *) pdata);
+	reqsize += sizeof(uint16_t);
+	pdata += sizeof(uint16_t);
+
+	/* get attr seq PDU form */
+	seqlen = gen_attridseq_pdu(pdata, attrids,
+		reqtype == SDP_ATTR_REQ_INDIVIDUAL? SDP_UINT16 : SDP_UINT32);
+	if (seqlen == -1) {
+		errno = EINVAL;
+		goto end;
+	}
+	pdata += seqlen;
+	reqsize += seqlen;
+	SDPDBG("Attr list length : %d\n", seqlen);
+
+	/* save before Continuation State */
+	_pdata = pdata;
+	_reqsize = reqsize;
+
+	do {
+		int status;
+
+		/* add NULL continuation state */
+		reqsize = _reqsize + copy_cstate(_pdata,
+					SDP_REQ_BUFFER_SIZE - _reqsize, cstate);
+
+		/* set the request header's param length */
+		reqhdr->tid  = htons(sdp_gen_tid(session));
+		reqhdr->plen = htons(reqsize - sizeof(sdp_pdu_hdr_t));
+
+		status = sdp_send_req_w4_rsp(session, reqbuf, rspbuf, reqsize, &rspsize);
+		if (status < 0)
+			goto end;
+
+		if (rspsize < sizeof(sdp_pdu_hdr_t)) {
+			SDPERR("Unexpected end of packet");
+			goto end;
+		}
+
+		rsphdr = (sdp_pdu_hdr_t *) rspbuf;
+		if (rsphdr->pdu_id == SDP_ERROR_RSP) {
+			SDPDBG("PDU ID : 0x%x\n", rsphdr->pdu_id);
+			goto end;
+		}
+		pdata = rspbuf + sizeof(sdp_pdu_hdr_t);
+		pdata_len = rspsize - sizeof(sdp_pdu_hdr_t);
+
+		if (pdata_len < sizeof(uint16_t)) {
+			SDPERR("Unexpected end of packet");
+			goto end;
+		}
+
+		rsp_count = ntohs(bt_get_unaligned((uint16_t *) pdata));
+		attr_list_len += rsp_count;
+		pdata += sizeof(uint16_t);
+		pdata_len -= sizeof(uint16_t);
+
+		/*
+		 * if continuation state set need to re-issue request before
+		 * parsing
+		 */
+		if (pdata_len < rsp_count + sizeof(uint8_t)) {
+			SDPERR("Unexpected end of packet: continuation state data missing");
+			goto end;
+		}
+		cstate_len = *(uint8_t *) (pdata + rsp_count);
+
+		SDPDBG("Response id : %d\n", rsphdr->pdu_id);
+		SDPDBG("Attrlist byte count : %d\n", rsp_count);
+		SDPDBG("sdp_cstate_t length : %d\n", cstate_len);
+
+		/*
+		 * a split response: concatenate intermediate responses
+		 * and the last one (which has cstate_len == 0)
+		 */
+		if (cstate_len > 0 || rsp_concat_buf.data_size != 0) {
+			uint8_t *targetPtr = NULL;
+
+			cstate = cstate_len > 0 ? (sdp_cstate_t *) (pdata + rsp_count) : 0;
+
+			/* build concatenated response buffer */
+			rsp_concat_buf.data = realloc(rsp_concat_buf.data, rsp_concat_buf.data_size + rsp_count);
+			rsp_concat_buf.buf_size = rsp_concat_buf.data_size + rsp_count;
+			targetPtr = rsp_concat_buf.data + rsp_concat_buf.data_size;
+			memcpy(targetPtr, pdata, rsp_count);
+			rsp_concat_buf.data_size += rsp_count;
+		}
+	} while (cstate);
+
+	if (attr_list_len > 0) {
+		int scanned = 0;
+		if (rsp_concat_buf.data_size != 0) {
+			pdata = rsp_concat_buf.data;
+			pdata_len = rsp_concat_buf.data_size;
+		}
+		rec = sdp_extract_pdu(pdata, pdata_len, &scanned);
+	}
+
+end:
+	free(reqbuf);
+	free(rsp_concat_buf.data);
+	free(rspbuf);
+	return rec;
+}
+
+/*
+ * SDP transaction structure for asynchronous search
+ */
+struct sdp_transaction {
+	sdp_callback_t *cb;	/* called when the transaction finishes */
+	void *udata;		/* client user data */
+	uint8_t *reqbuf;	/* pointer to request PDU */
+	sdp_buf_t rsp_concat_buf;
+	uint32_t reqsize;	/* without cstate */
+	int err;		/* ZERO if success or the errno if failed */
+};
+
+/*
+ * Creates a new sdp session for asynchronous search
+ * INPUT:
+ *  int sk
+ *     non-blocking L2CAP socket
+ *
+ * RETURN:
+ *  sdp_session_t *
+ *  NULL - On memory allocation failure
+ */
+sdp_session_t *sdp_create(int sk, uint32_t flags)
+{
+	sdp_session_t *session;
+	struct sdp_transaction *t;
+
+	session = malloc(sizeof(sdp_session_t));
+	if (!session) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	memset(session, 0, sizeof(*session));
+
+	session->flags = flags;
+	session->sock = sk;
+
+	t = malloc(sizeof(struct sdp_transaction));
+	if (!t) {
+		errno = ENOMEM;
+		free(session);
+		return NULL;
+	}
+	memset(t, 0, sizeof(*t));
+
+	session->priv = t;
+
+	return session;
+}
+
+/*
+ * Sets the callback function/user data used to notify the application
+ * that the asynchronous transaction finished. This function must be
+ * called before request an asynchronous search.
+ *
+ * INPUT:
+ *  sdp_session_t *session
+ *	Current sdp session to be handled
+ *  sdp_callback_t *cb
+ *      callback to be called when the transaction finishes
+ *  void *udata
+ *      user data passed to callback
+ * RETURN:
+ * 	 0 - Success
+ * 	-1 - Failure
+ */
+int sdp_set_notify(sdp_session_t *session, sdp_callback_t *func, void *udata)
+{
+	struct sdp_transaction *t;
+
+	if (!session || !session->priv)
+		return -1;
+
+	t = session->priv;
+	t->cb = func;
+	t->udata = udata;
+
+	return 0;
+}
+
+/*
+ * This function starts an asynchronous service search request.
+ * The incomming and outgoing data are stored in the transaction structure
+ * buffers. When there is incomming data the sdp_process function must be
+ * called to get the data and handle the continuation state.
+ *
+ * INPUT :
+ *  sdp_session_t *session
+ *     Current sdp session to be handled
+ *
+ *   sdp_list_t *search
+ *     Singly linked list containing elements of the search
+ *     pattern. Each entry in the list is a UUID (DataTypeSDP_UUID16)
+ *     of the service to be searched
+ *
+ *   uint16_t max_rec_num
+ *      A 16 bit integer which tells the service, the maximum
+ *      entries that the client can handle in the response. The
+ *      server is obliged not to return > max_rec_num entries
+ *
+ * OUTPUT :
+ *
+ *   int return value
+ * 	0  - if the request has been sent properly
+ * 	-1 - On any failure and sets errno
+ */
+
+int sdp_service_search_async(sdp_session_t *session, const sdp_list_t *search, uint16_t max_rec_num)
+{
+	struct sdp_transaction *t;
+	sdp_pdu_hdr_t *reqhdr;
+	uint8_t *pdata;
+	int cstate_len, seqlen = 0;
+
+	if (!session || !session->priv)
+		return -1;
+
+	t = session->priv;
+
+	/* clean possible allocated buffer */
+	free(t->rsp_concat_buf.data);
+	memset(&t->rsp_concat_buf, 0, sizeof(sdp_buf_t));
+
+	if (!t->reqbuf) {
+		t->reqbuf = malloc(SDP_REQ_BUFFER_SIZE);
+		if (!t->reqbuf) {
+			t->err = ENOMEM;
+			goto end;
+		}
+	}
+	memset(t->reqbuf, 0, SDP_REQ_BUFFER_SIZE);
+
+	reqhdr = (sdp_pdu_hdr_t *) t->reqbuf;
+	reqhdr->tid = htons(sdp_gen_tid(session));
+	reqhdr->pdu_id = SDP_SVC_SEARCH_REQ;
+
+	/* generate PDU */
+	pdata = t->reqbuf + sizeof(sdp_pdu_hdr_t);
+	t->reqsize = sizeof(sdp_pdu_hdr_t);
+
+	/* add service class IDs for search */
+	seqlen = gen_searchseq_pdu(pdata, search);
+
+	SDPDBG("Data seq added : %d\n", seqlen);
+
+	/* now set the length and increment the pointer */
+	t->reqsize += seqlen;
+	pdata += seqlen;
+
+	bt_put_unaligned(htons(max_rec_num), (uint16_t *) pdata);
+	t->reqsize += sizeof(uint16_t);
+	pdata += sizeof(uint16_t);
+
+	/* set the request header's param length */
+	cstate_len = copy_cstate(pdata, SDP_REQ_BUFFER_SIZE - t->reqsize, NULL);
+	reqhdr->plen = htons((t->reqsize + cstate_len) - sizeof(sdp_pdu_hdr_t));
+
+	if (sdp_send_req(session, t->reqbuf, t->reqsize + cstate_len) < 0) {
+		SDPERR("Error sendind data:%s", strerror(errno));
+		t->err = errno;
+		goto end;
+	}
+
+	return 0;
+end:
+
+	free(t->reqbuf);
+	t->reqbuf = NULL;
+
+	return -1;
+}
+
+/*
+ * This function starts an asynchronous service attribute request.
+ * The incomming and outgoing data are stored in the transaction structure
+ * buffers. When there is incomming data the sdp_process function must be
+ * called to get the data and handle the continuation state.
+ *
+ * INPUT :
+ *  sdp_session_t *session
+ *	Current sdp session to be handled
+ *
+ *   uint32_t handle
+ *     The handle of the service for which the attribute(s) are
+ *     requested
+ *
+ *   sdp_attrreq_type_t reqtype
+ *     Attribute identifiers are 16 bit unsigned integers specified
+ *     in one of 2 ways described below :
+ *     SDP_ATTR_REQ_INDIVIDUAL - 16bit individual identifiers
+ *        They are the actual attribute identifiers in ascending order
+ *
+ *     SDP_ATTR_REQ_RANGE - 32bit identifier range
+ *        The high-order 16bits is the start of range
+ *        the low-order 16bits are the end of range
+ *        0x0000 to 0xFFFF gets all attributes
+ *
+ *   sdp_list_t *attrid_list
+ *     Singly linked list containing attribute identifiers desired.
+ *     Every element is either a uint16_t(attrSpec = SDP_ATTR_REQ_INDIVIDUAL)
+ *     or a uint32_t(attrSpec=SDP_ATTR_REQ_RANGE)
+ *
+ * OUTPUT :
+ *   int return value
+ * 	 0 - if the request has been sent properly
+ * 	-1 - On any failure and sets errno
+ */
+
+int sdp_service_attr_async(sdp_session_t *session, uint32_t handle, sdp_attrreq_type_t reqtype, const sdp_list_t *attrid_list)
+{
+	struct sdp_transaction *t;
+	sdp_pdu_hdr_t *reqhdr;
+	uint8_t *pdata;
+	int cstate_len, seqlen = 0;
+
+	if (!session || !session->priv)
+		return -1;
+
+	t = session->priv;
+
+	/* clean possible allocated buffer */
+	free(t->rsp_concat_buf.data);
+	memset(&t->rsp_concat_buf, 0, sizeof(sdp_buf_t));
+
+	if (!t->reqbuf) {
+		t->reqbuf = malloc(SDP_REQ_BUFFER_SIZE);
+		if (!t->reqbuf) {
+			t->err = ENOMEM;
+			goto end;
+		}
+	}
+	memset(t->reqbuf, 0, SDP_REQ_BUFFER_SIZE);
+
+	reqhdr = (sdp_pdu_hdr_t *) t->reqbuf;
+	reqhdr->tid = htons(sdp_gen_tid(session));
+	reqhdr->pdu_id = SDP_SVC_ATTR_REQ;
+
+	/* generate PDU */
+	pdata = t->reqbuf + sizeof(sdp_pdu_hdr_t);
+	t->reqsize = sizeof(sdp_pdu_hdr_t);
+
+	/* add the service record handle */
+	bt_put_unaligned(htonl(handle), (uint32_t *) pdata);
+	t->reqsize += sizeof(uint32_t);
+	pdata += sizeof(uint32_t);
+
+	/* specify the response limit */
+	bt_put_unaligned(htons(65535), (uint16_t *) pdata);
+	t->reqsize += sizeof(uint16_t);
+	pdata += sizeof(uint16_t);
+
+	/* get attr seq PDU form */
+	seqlen = gen_attridseq_pdu(pdata, attrid_list,
+			reqtype == SDP_ATTR_REQ_INDIVIDUAL? SDP_UINT16 : SDP_UINT32);
+	if (seqlen == -1) {
+		t->err = EINVAL;
+		goto end;
+	}
+
+	/* now set the length and increment the pointer */
+	t->reqsize += seqlen;
+	pdata += seqlen;
+	SDPDBG("Attr list length : %d\n", seqlen);
+
+	/* set the request header's param length */
+	cstate_len = copy_cstate(pdata, SDP_REQ_BUFFER_SIZE - t->reqsize, NULL);
+	reqhdr->plen = htons((t->reqsize + cstate_len) - sizeof(sdp_pdu_hdr_t));
+
+	if (sdp_send_req(session, t->reqbuf, t->reqsize + cstate_len) < 0) {
+		SDPERR("Error sendind data:%s", strerror(errno));
+		t->err = errno;
+		goto end;
+	}
+
+	return 0;
+end:
+
+	free(t->reqbuf);
+	t->reqbuf = NULL;
+
+	return -1;
+}
+
+/*
+ * This function starts an asynchronous service search attributes.
+ * It is a service search request combined with attribute request. The incomming
+ * and outgoing data are stored in the transaction structure buffers. When there
+ * is incomming data the sdp_process function must be called to get the data
+ * and handle the continuation state.
+ *
+ * INPUT:
+ *  sdp_session_t *session
+ *	Current sdp session to be handled
+ *
+ *   sdp_list_t *search
+ *     Singly linked list containing elements of the search
+ *     pattern. Each entry in the list is a UUID(DataTypeSDP_UUID16)
+ *     of the service to be searched
+ *
+ *   AttributeSpecification attrSpec
+ *     Attribute identifiers are 16 bit unsigned integers specified
+ *     in one of 2 ways described below :
+ *     SDP_ATTR_REQ_INDIVIDUAL - 16bit individual identifiers
+ *        They are the actual attribute identifiers in ascending order
+ *
+ *     SDP_ATTR_REQ_RANGE - 32bit identifier range
+ *        The high-order 16bits is the start of range
+ *        the low-order 16bits are the end of range
+ *        0x0000 to 0xFFFF gets all attributes
+ *
+ *   sdp_list_t *attrid_list
+ *     Singly linked list containing attribute identifiers desired.
+ *     Every element is either a uint16_t(attrSpec = SDP_ATTR_REQ_INDIVIDUAL)
+ *     or a uint32_t(attrSpec=SDP_ATTR_REQ_RANGE)
+ *
+
+ * RETURN:
+ * 	 0 - if the request has been sent properly
+ * 	-1 - On any failure
+ */
+int sdp_service_search_attr_async(sdp_session_t *session, const sdp_list_t *search, sdp_attrreq_type_t reqtype, const sdp_list_t *attrid_list)
+{
+	struct sdp_transaction *t;
+	sdp_pdu_hdr_t *reqhdr;
+	uint8_t *pdata;
+	int cstate_len, seqlen = 0;
+
+	if (!session || !session->priv)
+		return -1;
+
+	t = session->priv;
+
+	/* clean possible allocated buffer */
+	free(t->rsp_concat_buf.data);
+	memset(&t->rsp_concat_buf, 0, sizeof(sdp_buf_t));
+
+	if (!t->reqbuf) {
+		t->reqbuf = malloc(SDP_REQ_BUFFER_SIZE);
+		if (!t->reqbuf) {
+			t->err = ENOMEM;
+			goto end;
+		}
+	}
+	memset(t->reqbuf, 0, SDP_REQ_BUFFER_SIZE);
+
+	reqhdr = (sdp_pdu_hdr_t *) t->reqbuf;
+	reqhdr->tid = htons(sdp_gen_tid(session));
+	reqhdr->pdu_id = SDP_SVC_SEARCH_ATTR_REQ;
+
+	/* generate PDU */
+	pdata = t->reqbuf + sizeof(sdp_pdu_hdr_t);
+	t->reqsize = sizeof(sdp_pdu_hdr_t);
+
+	/* add service class IDs for search */
+	seqlen = gen_searchseq_pdu(pdata, search);
+
+	SDPDBG("Data seq added : %d\n", seqlen);
+
+	/* now set the length and increment the pointer */
+	t->reqsize += seqlen;
+	pdata += seqlen;
+
+	bt_put_unaligned(htons(SDP_MAX_ATTR_LEN), (uint16_t *) pdata);
+	t->reqsize += sizeof(uint16_t);
+	pdata += sizeof(uint16_t);
+
+	SDPDBG("Max attr byte count : %d\n", SDP_MAX_ATTR_LEN);
+
+	/* get attr seq PDU form */
+	seqlen = gen_attridseq_pdu(pdata, attrid_list,
+			reqtype == SDP_ATTR_REQ_INDIVIDUAL ? SDP_UINT16 : SDP_UINT32);
+	if (seqlen == -1) {
+		t->err = EINVAL;
+		goto end;
+	}
+
+	pdata += seqlen;
+	SDPDBG("Attr list length : %d\n", seqlen);
+	t->reqsize += seqlen;
+
+	/* set the request header's param length */
+	cstate_len = copy_cstate(pdata, SDP_REQ_BUFFER_SIZE - t->reqsize, NULL);
+	reqhdr->plen = htons((t->reqsize + cstate_len) - sizeof(sdp_pdu_hdr_t));
+
+	if (sdp_send_req(session, t->reqbuf, t->reqsize + cstate_len) < 0) {
+		SDPERR("Error sendind data:%s", strerror(errno));
+		t->err = errno;
+		goto end;
+	}
+
+	return 0;
+end:
+
+	free(t->reqbuf);
+	t->reqbuf = NULL;
+
+	return -1;
+}
+
+/*
+ * Function used to get the error reason after sdp_callback_t function has been called
+ * and the status is 0xffff or if sdp_service_{search, attr, search_attr}_async returns -1.
+ * It indicates that an error NOT related to SDP_ErrorResponse happened. Get errno directly
+ * is not safe because multiple transactions can be triggered.
+ * This function must be used with asynchronous sdp functions only.
+ *
+ * INPUT:
+ *  sdp_session_t *session
+ *	Current sdp session to be handled
+ * RETURN:
+ * 	 0 = No error in the current transaction
+ * 	-1 - if the session is invalid
+ * 	positive value - the errno value
+ *
+ */
+int sdp_get_error(sdp_session_t *session)
+{
+	struct sdp_transaction *t;
+
+	if (!session || !session->priv) {
+		SDPERR("Invalid session");
+		return -1;
+	}
+
+	t = session->priv;
+
+	return t->err;
+}
+
+/*
+ * Receive the incomming SDP PDU. This function must be called when there is data
+ * available to be read. On continuation state, the original request (with a new
+ * transaction ID) and the continuation state data will be appended in the initial PDU.
+ * If an error happens or the transaction finishes the callback function will be called.
+ *
+ * INPUT:
+ *  sdp_session_t *session
+ *	Current sdp session to be handled
+ * RETURN:
+ * 	0  - if the transaction is on continuation state
+ * 	-1 - On any failure or the transaction finished
+ */
+int sdp_process(sdp_session_t *session)
+{
+	struct sdp_transaction *t;
+	sdp_pdu_hdr_t *reqhdr, *rsphdr;
+	sdp_cstate_t *pcstate;
+	uint8_t *pdata, *rspbuf, *targetPtr;
+	int rsp_count, err = -1;
+	size_t size = 0;
+	int n, plen;
+	uint16_t status = 0xffff;
+	uint8_t pdu_id = 0x00;
+
+	if (!session || !session->priv) {
+		SDPERR("Invalid session");
+		return -1;
+	}
+
+	rspbuf = malloc(SDP_RSP_BUFFER_SIZE);
+	if (!rspbuf) {
+		SDPERR("Response buffer alloc failure:%s (%d)",
+				strerror(errno), errno);
+		return -1;
+	}
+
+	memset(rspbuf, 0, SDP_RSP_BUFFER_SIZE);
+
+	t = session->priv;
+	reqhdr = (sdp_pdu_hdr_t *)t->reqbuf;
+	rsphdr = (sdp_pdu_hdr_t *)rspbuf;
+
+	pdata = rspbuf + sizeof(sdp_pdu_hdr_t);
+
+	n = sdp_read_rsp(session, rspbuf, SDP_RSP_BUFFER_SIZE);
+	if (n < 0) {
+		SDPERR("Read response:%s (%d)", strerror(errno), errno);
+		t->err = errno;
+		goto end;
+	}
+
+	if (n == 0 || reqhdr->tid != rsphdr->tid ||
+		(n != (ntohs(rsphdr->plen) + (int) sizeof(sdp_pdu_hdr_t)))) {
+		t->err = EPROTO;
+		SDPERR("Protocol error.");
+		goto end;
+	}
+
+	pdu_id = rsphdr->pdu_id;
+	switch (rsphdr->pdu_id) {
+	uint8_t *ssr_pdata;
+	uint16_t tsrc, csrc;
+	case SDP_SVC_SEARCH_RSP:
+		/*
+		 * TSRC: Total Service Record Count (2 bytes)
+		 * CSRC: Current Service Record Count (2 bytes)
+		 */
+		ssr_pdata = pdata;
+		tsrc = ntohs(bt_get_unaligned((uint16_t *) ssr_pdata));
+		ssr_pdata += sizeof(uint16_t);
+		csrc = ntohs(bt_get_unaligned((uint16_t *) ssr_pdata));
+
+		/* csrc should never be larger than tsrc */
+		if (csrc > tsrc) {
+			t->err = EPROTO;
+			SDPERR("Protocol error: wrong current service record count value.");
+			goto end;
+		}
+
+		SDPDBG("Total svc count: %d\n", tsrc);
+		SDPDBG("Current svc count: %d\n", csrc);
+
+		/* parameter length without continuation state */
+		plen = sizeof(tsrc) + sizeof(csrc) + csrc * 4;
+
+		if (t->rsp_concat_buf.data_size == 0) {
+			/* first fragment */
+			rsp_count = sizeof(tsrc) + sizeof(csrc) + csrc * 4;
+		} else {
+			/* point to the first csrc */
+			uint16_t *pcsrc = (uint16_t *) (t->rsp_concat_buf.data + 2);
+
+			/* FIXME: update the interface later. csrc doesn't need be passed to clients */
+
+			pdata += sizeof(uint16_t); /* point to csrc */
+
+			/* the first csrc contains the sum of partial csrc responses */
+			*pcsrc += bt_get_unaligned((uint16_t *) pdata);
+
+			pdata += sizeof(uint16_t); /* point to the first handle */
+			rsp_count = csrc * 4;
+		}
+		status = 0x0000;
+		break;
+	case SDP_SVC_ATTR_RSP:
+	case SDP_SVC_SEARCH_ATTR_RSP:
+		rsp_count = ntohs(bt_get_unaligned((uint16_t *) pdata));
+		SDPDBG("Attrlist byte count : %d\n", rsp_count);
+
+		/*
+		 * Number of bytes in the AttributeLists parameter(without
+		 * continuation state) + AttributeListsByteCount field size.
+		 */
+		plen = sizeof(uint16_t) + rsp_count;
+
+		pdata += sizeof(uint16_t); /* points to attribute list */
+		status = 0x0000;
+		break;
+	case SDP_ERROR_RSP:
+		status = ntohs(bt_get_unaligned((uint16_t *) pdata));
+		size = ntohs(rsphdr->plen);
+
+		goto end;
+	default:
+		t->err = EPROTO;
+		SDPERR("Illegal PDU ID: 0x%x", rsphdr->pdu_id);
+		goto end;
+	}
+
+	pcstate = (sdp_cstate_t *) (pdata + rsp_count);
+
+	SDPDBG("Cstate length : %d\n", pcstate->length);
+
+	/*
+	 * Check out of bound. Continuation state must have at least
+	 * 1 byte: ZERO to indicate that it is not a partial response.
+	 */
+	if ((n - (int) sizeof(sdp_pdu_hdr_t))  != (plen + pcstate->length + 1)) {
+		t->err = EPROTO;
+		SDPERR("Protocol error: wrong PDU size.");
+		status = 0xffff;
+		goto end;
+	}
+
+	/*
+	 * This is a split response, need to concatenate intermediate
+	 * responses and the last one which will have cstate length == 0
+	 */
+	t->rsp_concat_buf.data = realloc(t->rsp_concat_buf.data, t->rsp_concat_buf.data_size + rsp_count);
+	targetPtr = t->rsp_concat_buf.data + t->rsp_concat_buf.data_size;
+	t->rsp_concat_buf.buf_size = t->rsp_concat_buf.data_size + rsp_count;
+	memcpy(targetPtr, pdata, rsp_count);
+	t->rsp_concat_buf.data_size += rsp_count;
+
+	if (pcstate->length > 0) {
+		int reqsize, cstate_len;
+
+		reqhdr->tid = htons(sdp_gen_tid(session));
+
+		/* add continuation state */
+		cstate_len = copy_cstate(t->reqbuf + t->reqsize,
+				SDP_REQ_BUFFER_SIZE - t->reqsize, pcstate);
+
+		reqsize = t->reqsize + cstate_len;
+
+		/* set the request header's param length */
+		reqhdr->plen = htons(reqsize - sizeof(sdp_pdu_hdr_t));
+
+		if (sdp_send_req(session, t->reqbuf, reqsize) < 0) {
+			SDPERR("Error sendind data:%s(%d)", strerror(errno), errno);
+			status = 0xffff;
+			t->err = errno;
+			goto end;
+		}
+		err = 0;
+	}
+
+end:
+	if (err) {
+		if (t->rsp_concat_buf.data_size != 0) {
+			pdata = t->rsp_concat_buf.data;
+			size = t->rsp_concat_buf.data_size;
+		}
+		if (t->cb)
+			t->cb(pdu_id, status, pdata, size, t->udata);
+	}
+
+	free(rspbuf);
+
+	return err;
+}
+
+/*
+ * This is a service search request combined with the service
+ * attribute request. First a service class match is done and
+ * for matching service, requested attributes are extracted
+ *
+ * INPUT :
+ *
+ *   sdp_list_t *search
+ *     Singly linked list containing elements of the search
+ *     pattern. Each entry in the list is a UUID(DataTypeSDP_UUID16)
+ *     of the service to be searched
+ *
+ *   AttributeSpecification attrSpec
+ *     Attribute identifiers are 16 bit unsigned integers specified
+ *     in one of 2 ways described below :
+ *     SDP_ATTR_REQ_INDIVIDUAL - 16bit individual identifiers
+ *        They are the actual attribute identifiers in ascending order
+ *
+ *     SDP_ATTR_REQ_RANGE - 32bit identifier range
+ *        The high-order 16bits is the start of range
+ *        the low-order 16bits are the end of range
+ *        0x0000 to 0xFFFF gets all attributes
+ *
+ *   sdp_list_t *attrids
+ *     Singly linked list containing attribute identifiers desired.
+ *     Every element is either a uint16_t(attrSpec = SDP_ATTR_REQ_INDIVIDUAL)
+ *     or a uint32_t(attrSpec=SDP_ATTR_REQ_RANGE)
+ *
+ * OUTPUT :
+ *   int return value
+ *     0:
+ *       The request completed successfully. This does not
+ *       mean the requested services were found
+ *     -1:
+ *       On any error and sets errno
+ *
+ *   sdp_list_t **rsp
+ *     This variable is set on a successful return to point to
+ *     service(s) found. Each element of this list is of type
+ *     sdp_record_t* (of the services which matched the search list)
+ */
+int sdp_service_search_attr_req(sdp_session_t *session, const sdp_list_t *search, sdp_attrreq_type_t reqtype, const sdp_list_t *attrids, sdp_list_t **rsp)
+{
+	int status = 0;
+	uint32_t reqsize = 0, _reqsize;
+	uint32_t rspsize = 0;
+	int seqlen = 0, attr_list_len = 0;
+	int rsp_count = 0, cstate_len = 0;
+	unsigned int pdata_len;
+	uint8_t *pdata, *_pdata;
+	uint8_t *reqbuf, *rspbuf;
+	sdp_pdu_hdr_t *reqhdr, *rsphdr;
+	uint8_t dataType;
+	sdp_list_t *rec_list = NULL;
+	sdp_buf_t rsp_concat_buf;
+	sdp_cstate_t *cstate = NULL;
+
+	if (reqtype != SDP_ATTR_REQ_INDIVIDUAL && reqtype != SDP_ATTR_REQ_RANGE) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	memset(&rsp_concat_buf, 0, sizeof(sdp_buf_t));
+
+	reqbuf = malloc(SDP_REQ_BUFFER_SIZE);
+	rspbuf = malloc(SDP_RSP_BUFFER_SIZE);
+	if (!reqbuf || !rspbuf) {
+		errno = ENOMEM;
+		status = -1;
+		goto end;
+	}
+
+	reqhdr = (sdp_pdu_hdr_t *) reqbuf;
+	reqhdr->pdu_id = SDP_SVC_SEARCH_ATTR_REQ;
+
+	/* generate PDU */
+	pdata = reqbuf + sizeof(sdp_pdu_hdr_t);
+	reqsize = sizeof(sdp_pdu_hdr_t);
+
+	/* add service class IDs for search */
+	seqlen = gen_searchseq_pdu(pdata, search);
+
+	SDPDBG("Data seq added : %d\n", seqlen);
+
+	/* now set the length and increment the pointer */
+	reqsize += seqlen;
+	pdata += seqlen;
+
+	bt_put_unaligned(htons(SDP_MAX_ATTR_LEN), (uint16_t *) pdata);
+	reqsize += sizeof(uint16_t);
+	pdata += sizeof(uint16_t);
+
+	SDPDBG("Max attr byte count : %d\n", SDP_MAX_ATTR_LEN);
+
+	/* get attr seq PDU form */
+	seqlen = gen_attridseq_pdu(pdata, attrids,
+		reqtype == SDP_ATTR_REQ_INDIVIDUAL ? SDP_UINT16 : SDP_UINT32);
+	if (seqlen == -1) {
+		status = EINVAL;
+		goto end;
+	}
+	pdata += seqlen;
+	SDPDBG("Attr list length : %d\n", seqlen);
+	reqsize += seqlen;
+	*rsp = 0;
+
+	/* save before Continuation State */
+	_pdata = pdata;
+	_reqsize = reqsize;
+
+	do {
+		reqhdr->tid = htons(sdp_gen_tid(session));
+
+		/* add continuation state (can be null) */
+		reqsize = _reqsize + copy_cstate(_pdata,
+					SDP_REQ_BUFFER_SIZE - _reqsize, cstate);
+
+		/* set the request header's param length */
+		reqhdr->plen = htons(reqsize - sizeof(sdp_pdu_hdr_t));
+		rsphdr = (sdp_pdu_hdr_t *) rspbuf;
+		status = sdp_send_req_w4_rsp(session, reqbuf, rspbuf, reqsize, &rspsize);
+		if (rspsize < sizeof(sdp_pdu_hdr_t)) {
+			SDPERR("Unexpected end of packet");
+			status = -1;
+			goto end;
+		}
+
+		if (status < 0) {
+			SDPDBG("Status : 0x%x\n", rsphdr->pdu_id);
+			goto end;
+		}
+
+		if (rsphdr->pdu_id == SDP_ERROR_RSP) {
+			status = -1;
+			goto end;
+		}
+
+		pdata = rspbuf + sizeof(sdp_pdu_hdr_t);
+		pdata_len = rspsize - sizeof(sdp_pdu_hdr_t);
+
+		if (pdata_len < sizeof(uint16_t)) {
+			SDPERR("Unexpected end of packet");
+			status = -1;
+			goto end;
+		}
+
+		rsp_count = ntohs(bt_get_unaligned((uint16_t *) pdata));
+		attr_list_len += rsp_count;
+		pdata += sizeof(uint16_t); /* pdata points to attribute list */
+		pdata_len -= sizeof(uint16_t);
+
+		if (pdata_len < rsp_count + sizeof(uint8_t)) {
+			SDPERR("Unexpected end of packet: continuation state data missing");
+			status = -1;
+			goto end;
+		}
+
+		cstate_len = *(uint8_t *) (pdata + rsp_count);
+
+		SDPDBG("Attrlist byte count : %d\n", attr_list_len);
+		SDPDBG("Response byte count : %d\n", rsp_count);
+		SDPDBG("Cstate length : %d\n", cstate_len);
+		/*
+		 * This is a split response, need to concatenate intermediate
+		 * responses and the last one which will have cstate_len == 0
+		 */
+		if (cstate_len > 0 || rsp_concat_buf.data_size != 0) {
+			uint8_t *targetPtr = NULL;
+
+			cstate = cstate_len > 0 ? (sdp_cstate_t *) (pdata + rsp_count) : 0;
+
+			/* build concatenated response buffer */
+			rsp_concat_buf.data = realloc(rsp_concat_buf.data, rsp_concat_buf.data_size + rsp_count);
+			targetPtr = rsp_concat_buf.data + rsp_concat_buf.data_size;
+			rsp_concat_buf.buf_size = rsp_concat_buf.data_size + rsp_count;
+			memcpy(targetPtr, pdata, rsp_count);
+			rsp_concat_buf.data_size += rsp_count;
+		}
+	} while (cstate);
+
+	if (attr_list_len > 0) {
+		int scanned = 0;
+
+		if (rsp_concat_buf.data_size != 0) {
+			pdata = rsp_concat_buf.data;
+			pdata_len = rsp_concat_buf.data_size;
+		}
+
+		/*
+		 * Response is a sequence of sequence(s) for one or
+		 * more data element sequence(s) representing services
+		 * for which attributes are returned
+		 */
+		scanned = sdp_extract_seqtype(pdata, pdata_len, &dataType, &seqlen);
+
+		SDPDBG("Bytes scanned : %d\n", scanned);
+		SDPDBG("Seq length : %d\n", seqlen);
+
+		if (scanned && seqlen) {
+			pdata += scanned;
+			pdata_len -= scanned;
+			do {
+				int recsize = 0;
+				sdp_record_t *rec = sdp_extract_pdu(pdata, pdata_len, &recsize);
+				if (rec == NULL) {
+					SDPERR("SVC REC is null\n");
+					status = -1;
+					goto end;
+				}
+				if (!recsize) {
+					sdp_record_free(rec);
+					break;
+				}
+				scanned += recsize;
+				pdata += recsize;
+				pdata_len -= recsize;
+
+				SDPDBG("Loc seq length : %d\n", recsize);
+				SDPDBG("Svc Rec Handle : 0x%x\n", rec->handle);
+				SDPDBG("Bytes scanned : %d\n", scanned);
+				SDPDBG("Attrlist byte count : %d\n", attr_list_len);
+				rec_list = sdp_list_append(rec_list, rec);
+			} while (scanned < attr_list_len && pdata_len > 0);
+
+			SDPDBG("Successful scan of service attr lists\n");
+			*rsp = rec_list;
+		}
+	}
+end:
+	free(rsp_concat_buf.data);
+	free(reqbuf);
+	free(rspbuf);
+	return status;
+}
+
+/*
+ * Find devices in the piconet.
+ */
+int sdp_general_inquiry(inquiry_info *ii, int num_dev, int duration, uint8_t *found)
+{
+	int n = hci_inquiry(-1, 10, num_dev, NULL, &ii, 0);
+	if (n < 0) {
+		SDPERR("Inquiry failed:%s", strerror(errno));
+		return -1;
+	}
+	*found = n;
+	return 0;
+}
+
+int sdp_close(sdp_session_t *session)
+{
+	struct sdp_transaction *t;
+	int ret;
+
+	if (!session)
+		return -1;
+
+	ret = close(session->sock);
+
+	t = session->priv;
+
+	if (t) {
+		free(t->reqbuf);
+
+		free(t->rsp_concat_buf.data);
+
+		free(t);
+	}
+	free(session);
+	return ret;
+}
+
+static inline int sdp_is_local(const bdaddr_t *device)
+{
+	return memcmp(device, BDADDR_LOCAL, sizeof(bdaddr_t)) == 0;
+}
+
+static int sdp_connect_local(sdp_session_t *session)
+{
+	struct sockaddr_un sa;
+
+	session->sock = socket(PF_UNIX, SOCK_STREAM, 0);
+	if (session->sock < 0)
+		return -1;
+	session->local = 1;
+
+	sa.sun_family = AF_UNIX;
+	strcpy(sa.sun_path, SDP_UNIX_PATH);
+
+	return connect(session->sock, (struct sockaddr *) &sa, sizeof(sa));
+}
+
+static int sdp_connect_l2cap(const bdaddr_t *src,
+		const bdaddr_t *dst, sdp_session_t *session)
+{
+	uint32_t flags = session->flags;
+	struct sockaddr_l2 sa;
+	int sk;
+
+	session->sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);
+	if (session->sock < 0)
+		return -1;
+	session->local = 0;
+
+	sk = session->sock;
+
+	if (flags & SDP_NON_BLOCKING) {
+		long arg = fcntl(sk, F_GETFL, 0);
+		fcntl(sk, F_SETFL, arg | O_NONBLOCK);
+	}
+
+	memset(&sa, 0, sizeof(sa));
+
+	sa.l2_family = AF_BLUETOOTH;
+	sa.l2_psm = 0;
+
+	if (bacmp(src, BDADDR_ANY)) {
+		sa.l2_bdaddr = *src;
+		if (bind(sk, (struct sockaddr *) &sa, sizeof(sa)) < 0)
+			return -1;
+	}
+
+	if (flags & SDP_WAIT_ON_CLOSE) {
+		struct linger l = { .l_onoff = 1, .l_linger = 1 };
+		setsockopt(sk, SOL_SOCKET, SO_LINGER, &l, sizeof(l));
+	}
+
+	sa.l2_psm = htobs(SDP_PSM);
+	sa.l2_bdaddr = *dst;
+
+	do {
+		int ret = connect(sk, (struct sockaddr *) &sa, sizeof(sa));
+		if (!ret)
+			return 0;
+		if (ret < 0 && (flags & SDP_NON_BLOCKING) &&
+				(errno == EAGAIN || errno == EINPROGRESS))
+			return 0;
+	} while (errno == EBUSY && (flags & SDP_RETRY_IF_BUSY));
+
+	return -1;
+}
+
+sdp_session_t *sdp_connect(const bdaddr_t *src,
+		const bdaddr_t *dst, uint32_t flags)
+{
+	sdp_session_t *session;
+	int err;
+
+	if ((flags & SDP_RETRY_IF_BUSY) && (flags & SDP_NON_BLOCKING)) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	session = sdp_create(-1, flags);
+	if (!session)
+		return NULL;
+
+	if (sdp_is_local(dst)) {
+		if (sdp_connect_local(session) < 0)
+			goto fail;
+	} else {
+		if (sdp_connect_l2cap(src, dst, session) < 0)
+			goto fail;
+	}
+
+	return session;
+
+fail:
+	err = errno;
+	if (session->sock >= 0)
+		close(session->sock);
+	free(session->priv);
+	free(session);
+	errno = err;
+
+	return NULL;
+}
+
+int sdp_get_socket(const sdp_session_t *session)
+{
+	return session->sock;
+}
+
+uint16_t sdp_gen_tid(sdp_session_t *session)
+{
+	return session->tid++;
+}
+
+/*
+ * Set the supported features
+ */
+int sdp_set_supp_feat(sdp_record_t *rec, const sdp_list_t *sf)
+{
+	const sdp_list_t *p, *r;
+	sdp_data_t *feat, *seq_feat;
+	int seqlen, i;
+	void **seqDTDs, **seqVals;
+
+	seqlen = sdp_list_len(sf);
+	seqDTDs = malloc(seqlen * sizeof(void *));
+	if (!seqDTDs)
+		return -1;
+	seqVals = malloc(seqlen * sizeof(void *));
+	if (!seqVals) {
+		free(seqDTDs);
+		return -1;
+	}
+
+	for (p = sf, i = 0; p; p = p->next, i++) {
+		int plen, j;
+		void **dtds, **vals;
+		int *lengths;
+
+		plen = sdp_list_len(p->data);
+		dtds = malloc(plen * sizeof(void *));
+		if (!dtds)
+			goto fail;
+		vals = malloc(plen * sizeof(void *));
+		if (!vals) {
+			free(dtds);
+			goto fail;
+		}
+		lengths = malloc(plen * sizeof(int *));
+		if (!lengths) {
+			free(dtds);
+			free(vals);
+			goto fail;
+		}
+		for (r = p->data, j = 0; r; r = r->next, j++) {
+			sdp_data_t *data = (sdp_data_t*)r->data;
+			dtds[j] = &data->dtd;
+			switch (data->dtd) {
+			case SDP_URL_STR8:
+			case SDP_URL_STR16:
+			case SDP_TEXT_STR8:
+			case SDP_TEXT_STR16:
+				vals[j] = data->val.str;
+				lengths[j] = data->unitSize - sizeof(uint8_t);
+				break;
+			case SDP_ALT8:
+			case SDP_ALT16:
+			case SDP_ALT32:
+			case SDP_SEQ8:
+			case SDP_SEQ16:
+			case SDP_SEQ32:
+				vals[j] = data->val.dataseq;
+				lengths[j] = 0;
+				break;
+			default:
+				vals[j] = &data->val;
+				lengths[j] = 0;
+				break;
+			}
+		}
+		feat = sdp_seq_alloc_with_length(dtds, vals, lengths, plen);
+		free(dtds);
+		free(vals);
+		free(lengths);
+		if (!feat)
+			goto fail;
+		seqDTDs[i] = &feat->dtd;
+		seqVals[i] = feat;
+	}
+	seq_feat = sdp_seq_alloc(seqDTDs, seqVals, seqlen);
+	if (!seq_feat)
+		goto fail;
+	sdp_attr_replace(rec, SDP_ATTR_SUPPORTED_FEATURES_LIST, seq_feat);
+
+	free(seqVals);
+	free(seqDTDs);
+	return 0;
+
+fail:
+	free(seqVals);
+	free(seqDTDs);
+	return -1;
+}
+
+/*
+ * Get the supported features
+ * If an error occurred -1 is returned and errno is set
+ */
+int sdp_get_supp_feat(const sdp_record_t *rec, sdp_list_t **seqp)
+{
+	sdp_data_t *sdpdata, *d;
+	sdp_list_t *tseq;
+	tseq = NULL;
+
+	sdpdata = sdp_data_get(rec, SDP_ATTR_SUPPORTED_FEATURES_LIST);
+
+	if (!sdpdata || sdpdata->dtd < SDP_SEQ8 || sdpdata->dtd > SDP_SEQ32)
+		return sdp_get_uuidseq_attr(rec,
+					SDP_ATTR_SUPPORTED_FEATURES_LIST, seqp);
+
+	for (d = sdpdata->val.dataseq; d; d = d->next) {
+		sdp_data_t *dd;
+		sdp_list_t *subseq;
+
+		if (d->dtd < SDP_SEQ8 || d->dtd > SDP_SEQ32)
+			goto fail;
+
+		subseq = NULL;
+
+		for (dd = d->val.dataseq; dd; dd = dd->next) {
+			sdp_data_t *data;
+			void *val;
+			int length;
+
+			switch (dd->dtd) {
+			case SDP_URL_STR8:
+			case SDP_URL_STR16:
+			case SDP_TEXT_STR8:
+			case SDP_TEXT_STR16:
+				val = dd->val.str;
+				length = dd->unitSize - sizeof(uint8_t);
+				break;
+			case SDP_UINT8:
+			case SDP_UINT16:
+				val = &dd->val;
+				length = 0;
+				break;
+			default:
+				goto fail;
+			}
+
+			data = sdp_data_alloc_with_length(dd->dtd, val, length);
+			if (data)
+				subseq = sdp_list_append(subseq, data);
+		}
+		tseq = sdp_list_append(tseq, subseq);
+	}
+	*seqp = tseq;
+	return 0;
+
+fail:
+	while (tseq) {
+		sdp_list_t * next;
+
+		next = tseq->next;
+		sdp_list_free(tseq, free);
+		tseq = next;
+	}
+	errno = EINVAL;
+	return -1;
+}
+
diff --git a/bootable/recovery/pcba_core/libbluetooth/uuid.c b/bootable/recovery/pcba_core/libbluetooth/uuid.c
new file mode 100644
index 0000000000..325016aabd
--- /dev/null
+++ b/bootable/recovery/pcba_core/libbluetooth/uuid.c
@@ -0,0 +1,273 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2011  Nokia Corporation
+ *  Copyright (C) 2011  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include "uuid.h"
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+static uint128_t bluetooth_base_uuid = {
+	.data = {	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
+			0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB }
+};
+
+#define BASE_UUID16_OFFSET	2
+#define BASE_UUID32_OFFSET	0
+
+#else
+static uint128_t bluetooth_base_uuid = {
+	.data = {	0xFB, 0x34, 0x9B, 0x5F, 0x80, 0x00, 0x00, 0x80,
+			0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+};
+
+#define BASE_UUID16_OFFSET	12
+#define BASE_UUID32_OFFSET	BASE_UUID16_OFFSET
+
+#endif
+
+static void bt_uuid16_to_uuid128(const bt_uuid_t *src, bt_uuid_t *dst)
+{
+	dst->value.u128 = bluetooth_base_uuid;
+	dst->type = BT_UUID128;
+
+	memcpy(&dst->value.u128.data[BASE_UUID16_OFFSET],
+			&src->value.u16, sizeof(src->value.u16));
+}
+
+static void bt_uuid32_to_uuid128(const bt_uuid_t *src, bt_uuid_t *dst)
+{
+	dst->value.u128 = bluetooth_base_uuid;
+	dst->type = BT_UUID128;
+
+	memcpy(&dst->value.u128.data[BASE_UUID32_OFFSET],
+				&src->value.u32, sizeof(src->value.u32));
+}
+
+void bt_uuid_to_uuid128(const bt_uuid_t *src, bt_uuid_t *dst)
+{
+	switch (src->type) {
+	case BT_UUID128:
+		memcpy(dst, src, sizeof(bt_uuid_t));
+		break;
+	case BT_UUID32:
+		bt_uuid32_to_uuid128(src, dst);
+		break;
+	case BT_UUID16:
+		bt_uuid16_to_uuid128(src, dst);
+		break;
+	default:
+		break;
+	}
+}
+
+static int bt_uuid128_cmp(const bt_uuid_t *u1, const bt_uuid_t *u2)
+{
+	return memcmp(&u1->value.u128, &u2->value.u128, sizeof(uint128_t));
+}
+
+int bt_uuid16_create(bt_uuid_t *btuuid, uint16_t value)
+{
+	memset(btuuid, 0, sizeof(bt_uuid_t));
+	btuuid->type = BT_UUID16;
+	btuuid->value.u16 = value;
+
+	return 0;
+}
+
+int bt_uuid32_create(bt_uuid_t *btuuid, uint32_t value)
+{
+	memset(btuuid, 0, sizeof(bt_uuid_t));
+	btuuid->type = BT_UUID32;
+	btuuid->value.u32 = value;
+
+	return 0;
+}
+
+int bt_uuid128_create(bt_uuid_t *btuuid, uint128_t value)
+{
+	memset(btuuid, 0, sizeof(bt_uuid_t));
+	btuuid->type = BT_UUID128;
+	btuuid->value.u128 = value;
+
+	return 0;
+}
+
+int bt_uuid_cmp(const bt_uuid_t *uuid1, const bt_uuid_t *uuid2)
+{
+	bt_uuid_t u1, u2;
+
+	bt_uuid_to_uuid128(uuid1, &u1);
+	bt_uuid_to_uuid128(uuid2, &u2);
+
+	return bt_uuid128_cmp(&u1, &u2);
+}
+
+/*
+ * convert the UUID to string, copying a maximum of n characters.
+ */
+int bt_uuid_to_string(const bt_uuid_t *uuid, char *str, size_t n)
+{
+	if (!uuid) {
+		snprintf(str, n, "NULL");
+		return -EINVAL;
+	}
+
+	switch (uuid->type) {
+	case BT_UUID16:
+		snprintf(str, n, "%.4x", uuid->value.u16);
+		break;
+	case BT_UUID32:
+		snprintf(str, n, "%.8x", uuid->value.u32);
+		break;
+	case BT_UUID128: {
+		unsigned int   data0;
+		unsigned short data1;
+		unsigned short data2;
+		unsigned short data3;
+		unsigned int   data4;
+		unsigned short data5;
+
+		uint128_t nvalue;
+		const uint8_t *data = (uint8_t *) &nvalue;
+
+		hton128(&uuid->value.u128, &nvalue);
+
+		memcpy(&data0, &data[0], 4);
+		memcpy(&data1, &data[4], 2);
+		memcpy(&data2, &data[6], 2);
+		memcpy(&data3, &data[8], 2);
+		memcpy(&data4, &data[10], 4);
+		memcpy(&data5, &data[14], 2);
+
+		snprintf(str, n, "%.8x-%.4x-%.4x-%.4x-%.8x%.4x",
+				ntohl(data0), ntohs(data1),
+				ntohs(data2), ntohs(data3),
+				ntohl(data4), ntohs(data5));
+		}
+		break;
+	default:
+		snprintf(str, n, "Type of UUID (%x) unknown.", uuid->type);
+		return -EINVAL;	/* Enum type of UUID not set */
+	}
+
+	return 0;
+}
+
+static inline int is_uuid128(const char *string)
+{
+	return (strlen(string) == 36 &&
+			string[8] == '-' &&
+			string[13] == '-' &&
+			string[18] == '-' &&
+			string[23] == '-');
+}
+
+static inline int is_uuid32(const char *string)
+{
+	return (strlen(string) == 8 || strlen(string) == 10);
+}
+
+static inline int is_uuid16(const char *string)
+{
+	return (strlen(string) == 4 || strlen(string) == 6);
+}
+
+static int bt_string_to_uuid16(bt_uuid_t *uuid, const char *string)
+{
+	uint16_t u16;
+	char *endptr = NULL;
+
+	u16 = strtol(string, &endptr, 16);
+	if (endptr && *endptr == '\0') {
+		bt_uuid16_create(uuid, u16);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int bt_string_to_uuid32(bt_uuid_t *uuid, const char *string)
+{
+	uint32_t u32;
+	char *endptr = NULL;
+
+	u32 = strtol(string, &endptr, 16);
+	if (endptr && *endptr == '\0') {
+		bt_uuid32_create(uuid, u32);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int bt_string_to_uuid128(bt_uuid_t *uuid, const char *string)
+{
+	uint32_t data0, data4;
+	uint16_t data1, data2, data3, data5;
+	uint128_t n128, u128;
+	uint8_t *val = (uint8_t *) &n128;
+
+	if (sscanf(string, "%08x-%04hx-%04hx-%04hx-%08x%04hx",
+				&data0, &data1, &data2,
+				&data3, &data4, &data5) != 6)
+		return -EINVAL;
+
+	data0 = htonl(data0);
+	data1 = htons(data1);
+	data2 = htons(data2);
+	data3 = htons(data3);
+	data4 = htonl(data4);
+	data5 = htons(data5);
+
+	memcpy(&val[0], &data0, 4);
+	memcpy(&val[4], &data1, 2);
+	memcpy(&val[6], &data2, 2);
+	memcpy(&val[8], &data3, 2);
+	memcpy(&val[10], &data4, 4);
+	memcpy(&val[14], &data5, 2);
+
+	ntoh128(&n128, &u128);
+
+	bt_uuid128_create(uuid, u128);
+
+	return 0;
+}
+
+int bt_string_to_uuid(bt_uuid_t *uuid, const char *string)
+{
+	if (is_uuid128(string))
+		return bt_string_to_uuid128(uuid, string);
+	else if (is_uuid32(string))
+		return bt_string_to_uuid32(uuid, string);
+	else if (is_uuid16(string))
+		return bt_string_to_uuid16(uuid, string);
+
+	return -EINVAL;
+}
diff --git a/bootable/recovery/pcba_core/res/WIFI_RAM_CODE b/bootable/recovery/pcba_core/res/WIFI_RAM_CODE
new file mode 100644
index 0000000000..50515df56a
Binary files /dev/null and b/bootable/recovery/pcba_core/res/WIFI_RAM_CODE differ
diff --git a/bootable/recovery/pcba_core/res/codectest.pcm b/bootable/recovery/pcba_core/res/codectest.pcm
new file mode 100644
index 0000000000..1f63e711ba
Binary files /dev/null and b/bootable/recovery/pcba_core/res/codectest.pcm differ
diff --git a/bootable/recovery/pcba_core/res/emmctester.sh b/bootable/recovery/pcba_core/res/emmctester.sh
new file mode 100644
index 0000000000..09f227da73
--- /dev/null
+++ b/bootable/recovery/pcba_core/res/emmctester.sh
@@ -0,0 +1,61 @@
+#!/sbin/sh
+
+#source send_cmd_pipe.sh
+
+nr="1"
+mmcblk="/dev/block/mmcblk$nr"
+mmcp=$mmcblk
+
+#while true; do
+    while true; do
+        while true; do
+            if [ -b "$mmcblk" ]; then
+              busybox  sleep 1
+                if [ -b "$mmcblk" ]; then
+                    echo "card$nr insert"
+                    break
+                fi
+            else
+               busybox sleep 1
+            fi
+        done
+        
+        if [ ! -d "/tmp/extsd" ]; then
+            busybox mkdir -p /tmp/extsd
+        fi
+        
+        mmcp=$mmcblk
+		echo $mmcp
+        busybox mount -t vfat $mmcp /tmp/extsd
+        if [ $? -ne 0 ]; then
+            mmcp=$mmcblk"p1"
+           busybox mount -t vfat $mmcp /tmp/extsd
+            if [ $? -ne 0 ]; then
+                exit 0
+                busybox sleep 3
+                continue 2
+            fi
+        fi
+
+        break
+    done
+    
+    capacity=`busybox df | busybox grep "/tmp/extsd" | busybox awk '{printf $2}'`
+    echo "$mmcp: $capacity"
+    
+    busybox umount /tmp/extsd
+    
+    echo $capacity > /data/sd_capacity
+
+	exit 1
+#    while true; do
+ #       if [ -b "$mmcblk" ]; then
+#            echo "please remove card$nr"
+#            busybox sleep 1
+ #       else
+  #          echo "card$nr remove"
+  #          break
+   #     fi
+    #done
+#done
+
diff --git a/bootable/recovery/pcba_core/res/ethernet.sh b/bootable/recovery/pcba_core/res/ethernet.sh
new file mode 100644
index 0000000000..ef0d8efb01
--- /dev/null
+++ b/bootable/recovery/pcba_core/res/ethernet.sh
@@ -0,0 +1,67 @@
+#!/sbin/busybox sh
+
+result_file=/data/ether_result.txt
+interface_up=true
+jmax=3
+
+echo "touch $result_file"
+busybox touch $result_file
+
+j=0
+
+echo "Get ping results"
+while [ $j -lt $jmax ]; 
+do
+    if busybox ifconfig eth0; then
+        if [ $interface_up = "true" ]; then
+            busybox ifconfig eth0 up
+        fi
+
+		#use ping type
+		if [ "$3" = "1" ]; then
+	    	busybox ifconfig eth0 $1
+
+		echo "sleep 2s"
+	    	busybox sleep 2
+	    	
+	    	#busybox ping -c 5 -W 5 $2 | busybox grep seq > $result_file
+	    	busybox ping -c 5 -W 5 $2 | busybox grep "packet loss" > $result_file
+	        echo "success local $1 ping $2"
+	        busybox cat $result_file
+	        exit 1
+	        
+	    #use view local address
+	    else
+	    	echo "sleep 2s"
+	    	busybox sleep 2
+
+	    	busybox ifconfig eth0 | busybox grep inet > $result_file
+	    	
+			#Check result
+			if [ -s $result_file ]; then
+				echo "the local ip address from dhcp assign"
+	    		busybox cat $result_file
+	    		exit 1
+		    	else
+		    	echo "the local ip address is Null"
+		    fi
+	    	
+	    fi
+	    
+        
+    fi
+
+	#Clear ethernet address
+	if [ "$3" = "1" ]; then
+	    echo "Clear eth0 addr"
+	    busybox ifconfig eth0 0.0.0.0
+	fi
+	
+    busybox sleep 2
+    
+    j=$((j+1))
+done
+
+echo "lan test failed"
+exit 0
+
diff --git a/bootable/recovery/pcba_core/res/mmctester.sh b/bootable/recovery/pcba_core/res/mmctester.sh
new file mode 100644
index 0000000000..78ae314764
--- /dev/null
+++ b/bootable/recovery/pcba_core/res/mmctester.sh
@@ -0,0 +1,31 @@
+#!/system/bin/sh
+
+#source send_cmd_pipe.sh
+ismount=0
+while true; do
+    if [ ! -d "/tmp/extsd" ]; then
+        busybox mkdir -p /tmp/extsd
+    fi
+
+    for nr in 0 1 2 3 4 5 6;do
+        mmcblk="/dev/block/mmcblk$nr"
+        mmcp=$mmcblk
+        mount -t vfat $mmcp /tmp/extsd
+        if [ $? -eq 0 ]; then
+	    ismount=1
+            break
+        fi
+    done
+	if [ $ismount -eq 1 ]; then
+		break
+	fi
+done
+
+capacity=`df | grep "/tmp/extsd" | busybox awk '{printf $2}'`
+echo "$mmcp: $capacity"
+
+umount /tmp/extsd
+
+echo $capacity > /data/sd_capacity
+
+exit 1
diff --git a/bootable/recovery/pcba_core/res/send_cmd_pipe.sh b/bootable/recovery/pcba_core/res/send_cmd_pipe.sh
new file mode 100644
index 0000000000..c8fdc29f30
--- /dev/null
+++ b/bootable/recovery/pcba_core/res/send_cmd_pipe.sh
@@ -0,0 +1,36 @@
+# the following functions use to comunication with core.
+# example:
+#   SEND_CMD_PIPE_OK $3
+# or
+#   SEND_CMD_PIPE_FAIL
+#
+# send message to core
+SEND_CMD_PIPE_MSG()
+{
+    echo "$1 -1 $2" >> /tmp/cmd_pipe
+}
+
+# send OK to core
+SEND_CMD_PIPE_OK()
+{
+    echo "$1 0" >> /tmp/cmd_pipe
+}
+
+# send OK with message to core
+SEND_CMD_PIPE_OK_EX()
+{
+    echo "$1 0 $2" >> /tmp/cmd_pipe
+}
+
+# send Fail to core
+SEND_CMD_PIPE_FAIL()
+{
+    echo "$1 1" >> /tmp/cmd_pipe
+}
+
+# send Fail with message to core
+SEND_CMD_PIPE_FAIL_EX()
+{
+    echo "$1 1 $2" >> /tmp/cmd_pipe
+}
+
diff --git a/bootable/recovery/pcba_core/res/test_config.cfg b/bootable/recovery/pcba_core/res/test_config.cfg
new file mode 100644
index 0000000000..9414fd8962
--- /dev/null
+++ b/bootable/recovery/pcba_core/res/test_config.cfg
@@ -0,0 +1,375 @@
+;-------------------------------------------------------------------------------
+; 测试模块配置示例
+;
+; [example]
+; display_name= "Example"
+; activated   = 1
+; program     = "example.sh"
+; category    = 0
+; run_type    = 1
+;
+; display_name
+;   显示到界面的名称，字符串类型，如果需要显示双引号，可以使用以下语法：
+;       display_name= string:"Example"
+;   区别在于后者会显示"string:"后面所有的字符，包括空格和制表符。该项能够容纳
+;   64个英文字符，32个中文字符。如果display_name为空，测试程序不会运行。
+;
+; activated
+;   0: 不测试该模块
+;   1: 测试该模块
+;
+; program
+;   模块的测试程序，该项能够容纳16个英文字符。
+;
+; category
+;   0: 自动化测试模块
+;   1: 手动测试模块
+;
+; run_type
+;   0: 等待当前模块的测试程序执行完毕再运行下一个模块的测试程序
+;   1: 不等待当前模块的测试程序执行完毕
+;   一般为了提高整体的测试速度，对于耗时较长的测试程序建议填0，反之填1；注意，当
+;   category = 1，即手动测试模块时，该项无效。
+;-------------------------------------------------------------------------------
+
+;-------------------------------------------------------------------------------
+; test_size
+;   unit: MB
+;-------------------------------------------------------------------------------
+[ddr]
+display_name= "ddr"
+activated   = 1
+program     = "ddr_emmc_test"
+category    = 0
+freq_test   = 0
+min_freq    = 0
+max_freq    = 0
+
+;-------------------------------------------------------------------------------
+; emmc
+;-------------------------------------------------------------------------------
+
+[emmc]
+display_name= "emmc"
+activated   = 1
+program     = "ddr_emmc_test"
+category    = 0
+freq_test   = 0
+min_freq    = 0
+max_freq    = 0
+
+;-------------------------------------------------------------------------------
+; lcd test
+; start_key:  value: "KEY_BACK" "KEY_VOLUMEUP"  "KEY_VOLUMEDOWN" "KEY_HOME" "KEY_MENU"
+;              "KEY_ENTER" "KEY_ALL"
+; key_times:  press start_key key_times will enter lcd test mode.
+; all_key_change: if 1, all keys will change the picture(after test started).
+;-------------------------------------------------------------------------------
+
+[Lcd]
+display_name= "lcd"
+activated   = 1
+program     = "lcd test"
+category    = 1
+run_type    = 1
+start_key  = "KEY_VOLUMEUP"
+key_times   = 3
+all_key_change = 1
+
+
+[rtc]
+display_name= "rtc"
+activated   = 1
+program     = "rtctester.sh"
+category    = 0
+run_type    = 1
+module_args = "20121113.160145"
+
+[sim]
+display_name= "sim"
+activated   = 0
+program     = "simtester.sh"
+category    = 0
+run_type    = 1
+;-------------------------------------------------------------------------------
+; module_path
+;   The full path of wifi module file.
+; module_args
+;   The arguments of wifi module.
+;-------------------------------------------------------------------------------
+[wifi]
+display_name= "wlan"
+activated   = 1
+program     = "wifitester.sh"
+category    = 0
+run_type    = 1
+module_path = "/system/vendor/modules/8192cu.ko"
+module_args = 
+
+[cpu]
+display_name= "cpu"
+activated   = 0
+program     = ""
+category    = 0
+
+;-------------------------------------------------------------------------------
+; use_ping
+;   Whether to use ping cmd to test ethernet, 1:Yes 0:No
+; local_addr
+;   The ip address of local device. if use_ping is 1
+; ping_addr
+;   The destination address that use to ping test. if use_ping is 1
+;-------------------------------------------------------------------------------
+[lan]
+display_name= "Lan"
+activated   = 0
+program     = ""
+category    = 0
+run_type    = 1
+use_ping    = 0
+local_addr  = "172.16.8.177"
+ping_addr   = "172.16.8.1"
+
+;-------------------------------------------------------------------------------
+; support sensor type
+;   1 : GSENSOR
+;   2 : GYROSCOPE
+;   4 : COMPASS
+;   8 : LSENSOR
+;  16 : PSENSOR
+;  32 : GSENSOR_CALIBRATE
+;
+;   3 : GSENSOR|GYROSCOPE
+;   7 : GSENSOR|GYROSCOPE|COMPASS
+;  39 : GSENSOR|GYROSCOPE|COMPASS|GSENSOR_CALIBRATE
+;  15 : GSENSOR|GYROSCOPE|COMPASS|LSENSOR
+;  31 : GSENSOR|GYROSCOPE|COMPASS|LSENSOR|PSENSOR
+;  63 : GSENSOR|GYROSCOPE|COMPASS|LSENSOR|PSENSOR|GSENSOR_CALIBRATE
+;-------------------------------------------------------------------------------
+[allsensor]
+display_name= "allsensor"
+activated   = 0
+program     = ""
+category    = 0
+run_type    = 1
+sensor_type = 39
+
+;-------------------------------------------------------------------------------
+; module_path
+;   The full path of g-sensor module file.
+; device_name
+;   The name of g-sensor device.
+;-------------------------------------------------------------------------------
+[gsensor]
+display_name= "gsensor"
+activated   = 1
+program     = "gsensortester.sh"
+category    = 0
+run_type    = 1
+module_count= 1
+calibrate   = 0 
+
+;-------------------------------------------------------------------------------
+; test_size
+;   Test size for nand read and write test.
+;-------------------------------------------------------------------------------
+[nand]
+display_name= "nand"
+activated   = 0
+program     = "nandtester.sh"
+category    = 0
+run_type    = 1
+test_size   = 128
+
+[bluetooth]
+display_name= "bluetooth"
+activated   = 1
+program     = ""
+category    = 0
+run_type    = 1
+chip_type   = "" ; rk903, mt6622, rda587x, rda5990, rtk8723as, rtk8723bs, rtk8723au, rtk8723bu, bk3515
+
+[sdcard]
+display_name= "SDcard"
+activated   = 1
+program     = "mmctester.sh"
+category    = 1
+run_type    = 1
+
+[udisk]
+display_name= "Udisk"
+activated   = 1
+program     = "udisktester.sh"
+category    = 1
+run_type    = 1
+
+;-------------------------------------------------------------------------------
+; sound_file
+;   The full path of sound file.
+; samplerate
+;   The samplerate of sound file.
+; support_mode
+;   0 : 480I    
+;   1 : 576I    
+;   2 : 480P    
+;   3 : 576P    
+;   4 : 720P 50HZ
+;   5 : 720P 60HZ
+;   6 : 1080I 50HZ
+;   7 : 1080I 60HZ
+;   8 : 1080P 24HZ
+;   9 : 1080P 50HZ
+;   10: 1080P 60HZ
+;-------------------------------------------------------------------------------
+[hdmi]
+display_name= "HDMI"
+activated   = 0
+program     = "hdmitester"
+category    = 0
+run_type    = 1
+sound_file  = "/res/codectest.pcm"
+;samplerate  = 48000
+;support_mode= 2
+
+;-------------------------------------------------------------------------------
+; module_path
+;   The full path of key module file.
+;-------------------------------------------------------------------------------
+[Key]
+display_name= "Key"
+activated   = 1
+program     = "keytester"
+category    = 1
+run_type    = 1
+;module_path = 
+
+;-------------------------------------------------------------------------------
+; module_path
+;   The full path of ir module file.
+;-------------------------------------------------------------------------------
+[ir]
+display_name= "红外"
+activated   = 0
+program     = "irtester"
+category    = 1
+run_type    = 1
+
+;-------------------------------------------------------------------------------
+; delay
+;   delay ? second before recording
+;-------------------------------------------------------------------------------
+[Codec]
+display_name= "Codec"
+activated   = 1
+program     = "case1" ; case1 : 先放后录模式，测试效率相对低，使用喇叭时不会有啸叫，可在使用喇叭时选择此模式 
+                      ; case2 : 边录边放模式，测试效率高，使用喇叭时会有啸叫，可在使用耳机时选择此模式
+category    = 1
+run_type    = 1
+delay       = 5
+volume      = 40
+
+;-------------------------------------------------------------------------------
+; type
+;   0: rtp
+;   1: ctp
+; module_path
+;   The full path of tp module.
+;-------------------------------------------------------------------------------
+[tp]
+display_name= "tp"
+type        = 0
+
+;-------------------------------------------------------------------------------
+; moudle battery
+;-------------------------------------------------------------------------------
+[battery]
+display_name= "battery"
+activated   = 1
+program     = "battery_test"
+category    = 1
+run_type    = 1
+
+;-------------------------------------------------------------------------------
+; module_count
+;   The number of module need to be insmod.
+; modulex_path
+;   'x' is the index of module, starts from 0.
+;-------------------------------------------------------------------------------
+[camera]
+display_name = "camera"
+activated   = 1
+category    = 0
+program     = "camerates.sh"
+number	    = 2
+
+;-------------------------------------------------------------------------------
+; manual_menu_name
+;   manual test case menu name, 32bytes.
+; auto_menu_name
+;   auto test case menu name, 32bytes.
+; clear_button_name
+;   clear screen button name, 8bytes.
+; font_size
+;   test case font display size, valid value: 20pixel(default), 24pixel.
+; height_adjust
+;   adjust height of manual test case and auto test case.
+;
+; Color Index
+;   0: White
+;   1: Yellow
+;   2: Green
+;   3: Cyan
+;   4: Magenta
+;   5: Red
+;   6: Blue
+;   7: Black
+;
+; menu_bgcolor
+;   The background color index of test case category menu.
+; menu_fgcolor
+;   The foreground color index of test case category menu.
+; item_init_bgcolor
+;   The background color index of test case item init status.
+; item_init_fgcolor
+;   The foreground color index of test case item init status.
+; item_ok_bgcolor
+;   The background color index of test case item OK status.
+; item_ok_fgcolor
+;   The foreground color index of test case item OK status.
+; item_fail_bgcolor
+;   The background color index of test case item fail status.
+; item_fail_fgcolor
+;   The foreground color index of test case item fail status.
+;
+; pass_str
+;   The string display after test case display_name when test OK.
+; fail_str
+;   The string display after test case display_name when test Fail.
+;-------------------------------------------------------------------------------
+[df_view]
+manual_menu_name    = "手动测试项"
+auto_menu_name      = "自动测试项"
+clear_button_name   = "清屏"
+font_size           = 20
+height_adjust       = 56
+menu_bgcolor        = 1
+menu_fgcolor        = 7
+
+item_init_bgcolor   = 7
+item_init_fgcolor   = 0
+item_ok_bgcolor     = 7
+item_ok_fgcolor     = 6
+item_fail_bgcolor   = 7
+item_fail_fgcolor   = 5
+tp_draw_color       = 0
+
+;item_init_bgcolor   = 0
+;item_init_fgcolor   = 7
+;item_ok_bgcolor     = 0
+;item_ok_fgcolor     = 6
+;item_fail_bgcolor   = 0
+;item_fail_fgcolor   = 5
+;tp_draw_color       = 7
+
+pass_str            = "通过"
+fail_str            = "失败"
diff --git a/bootable/recovery/pcba_core/res/udisktester.sh b/bootable/recovery/pcba_core/res/udisktester.sh
new file mode 100644
index 0000000000..46b75621c2
--- /dev/null
+++ b/bootable/recovery/pcba_core/res/udisktester.sh
@@ -0,0 +1,74 @@
+#!/system/bin/sh
+
+#RESULT_FILE="/data/udisk_capacity.txt"
+#LOG_FILE="/data/udisk.log"
+#source send_cmd_pipe.sh
+
+#while true; do
+for nr in a b c d e f g h i j k l m n o p q r s t u v w x y z; do
+    udisk="/dev/block/sd$nr"
+    part=$udisk
+
+    echo "searching disk ..."
+    while true; do
+        if [ -b "$udisk" ]; then
+            busybox sleep 1
+            if [ -b "$udisk" ]; then
+                echo "udisk insert"
+                break;
+            fi
+        else
+            busybox sleep 1
+        fi
+    done
+
+    if [ ! -d "/tmp/udisk" ]; then
+        busybox mkdir -p /tmp/udisk
+    fi
+
+    echo "mounting disk $udisk..."
+    mount -t vfat $udisk /tmp/udisk
+    if [ $? -ne 0 ]; then
+        for num in 1 2 3 4 5 6;do
+            udiskp=$udisk"$num"
+            echo "mounting disk $udiskp..."
+            mount -t vfat $udiskp /tmp/udisk
+            if [ $? -ne 0 ]; then
+                echo "udisk mount failed"
+                #SEND_CMD_PIPE_FAIL $3
+                #busybox sleep 3
+                # goto for nr in ...
+                # detect next plugin, the devno will changed
+                #continue 2
+            else
+                part=$udiskp
+                break
+            fi
+        done
+    else
+        break
+    fi
+
+    if [ $part = $udiskp ];then
+        break
+    fi
+done
+
+capacity=`df | grep /tmp/udisk | busybox awk '{printf $2}'`
+#echo "$part: $capacity" >> LOG_FILE
+
+umount /tmp/udisk
+#SEND_CMD_PIPE_OK_EX $3 $capacity
+
+echo $capacity > /data/udisk_capacity.txt
+
+#        while true; do
+#            if [ -b "$udisk" ]; then
+#                echo "please remove udisk"
+#                busybox sleep 1
+#            else
+#                echo "udisk removed"
+#                break
+#            fi
+#        done
+#done
diff --git a/bootable/recovery/pcba_core/res/wifi.sh b/bootable/recovery/pcba_core/res/wifi.sh
new file mode 100644
index 0000000000..89e535aa07
--- /dev/null
+++ b/bootable/recovery/pcba_core/res/wifi.sh
@@ -0,0 +1,171 @@
+#!/system/bin/sh
+
+module_path_bcmdhd=/pcba/lib/modules/rkwifi/bcmdhd/bcmdhd.ko
+module_path_8188eu=/pcba/lib/modules/rtl8188eu/8188eu.ko
+module_path_8723bu=/pcba/lib/modules/rtl8723bu/8723bu.ko
+module_path_8723bs=/pcba/lib/modules/rtl8723bs/8723bs.ko
+module_path_8723cs=/pcba/lib/modules/rtl8723cs/8723cs.ko
+module_path_8723ds=/pcba/lib/modules/rtl8723ds/8723ds.ko
+module_path_8188fu=/pcba/lib/modules/rtl8188fu/8188fu.ko
+module_path_8822bs=/pcba/lib/modules/rtl8822bs/8822bs.ko
+module_path_8189es=/pcba/lib/modules/rtl8189es/8189es.ko
+module_path_8189fs=/pcba/lib/modules/rtl8189fs/8189fs.ko
+
+result_file=/data/scan_result.txt
+result_file2=/data/scan_result2.txt
+chip_type_path=/data/wifi_chip
+driver_node=/sys/class/rkwifi/driver
+pcba_node=/sys/class/rkwifi/pcba
+version_path=/proc/version
+module_path=$module_path_wlan
+chip_broadcom=false
+driver_buildin=false
+interface_up=true
+version=.3.0.36+
+mt5931_kitkat=false
+android_kitkat=false
+
+jmax=3
+
+if busybox cat $chip_type_path | busybox grep AP; then
+  module_path=$module_path_bcmdhd
+  chip_broadcom=true
+  echo 1 > $pcba_node
+fi
+
+if busybox cat $chip_type_path | busybox grep RTL8188EU; then
+  jmax=6
+  module_path=$module_path_8188eu
+fi
+
+if busybox cat $chip_type_path | busybox grep RTL8723AU; then
+  module_path=$module_path_8723bu
+fi
+
+if busybox cat $chip_type_path | busybox grep RTL8723BS; then
+  module_path=$module_path_8723bs
+fi
+
+if busybox cat $chip_type_path | busybox grep RTL8723CS; then
+  module_path=$module_path_8723cs
+fi
+
+if busybox cat $chip_type_path | busybox grep RTL8723DS; then
+  module_path=$module_path_8723ds
+fi
+
+if busybox cat $chip_type_path | busybox grep RTL8188FU; then
+  jmax=6
+  module_path=$module_path_8188fu
+fi
+
+if busybox cat $chip_type_path | busybox grep RTL8822BS; then
+  module_path=$module_path_8822bs
+fi
+
+if busybox cat $chip_type_path | busybox grep RTL8189ES; then
+  module_path=$module_path_8189es
+fi
+
+if busybox cat $chip_type_path | busybox grep RTL8189FS; then
+  module_path=$module_path_8189fs
+fi
+
+if busybox cat $version_path | busybox grep 3.0.36+; then
+  echo "kernel version 3.0.36+"
+  if [ -e $module_path$version ]; then
+    module_path=$module_path$version
+  fi
+fi
+
+if busybox ls /dev/wmtWifi | busybox grep wmtWifi; then
+  echo "mt5931_kitkat=true"
+  mt5931_kitkat=true
+fi
+
+if busybox ifconfig wlan0; then
+  echo "android_kitkat=true"
+  android_kitkat=true
+fi
+
+#if busybox ls $driver_node; then
+#  echo "wifi driver is buildin"
+#  driver_buildin=true
+#fi
+
+echo "touch $result_file"
+touch $result_file
+
+j=0
+
+echo "get scan results"
+while [ $j -lt $jmax ]; 
+do
+    echo "insmod wifi driver"
+    if [ $mt5931_kitkat = "true" ]; then
+        echo "echo 1 > /dev/wmtWifi"
+        echo 1 > /dev/wmtWifi
+    else
+      if [ $android_kitkat = "false" ]; then
+        if [ $driver_buildin = "true" ]; then
+          echo "echo 1 > $driver_node"
+          echo 1 > "$driver_node"
+        else
+          echo "insmod $module_path"
+          insmod "$module_path"
+        fi
+      fi
+    fi
+    if [ $? -ne 0 ]; then
+        echo "insmod failed"
+        exit 0
+    fi
+
+    echo "sleep 3s"
+    busybox sleep 3
+
+    if busybox ifconfig wlan0; then
+        if [ $interface_up = "true" ]; then
+            busybox ifconfig wlan0 up
+        fi
+        #if [ $? -ne 0 ]; then
+        #    echo "ifconfig wlan0 up failed"
+        #    exit 0
+        #fi
+    
+        iwlist wlan0 scanning > $result_file
+        if [ $chip_broadcom = "true" ]; then
+            echo "sleep 3s"
+            busybox sleep 3    
+        fi
+        iwlist wlan0 scanning last | busybox grep SSID > $result_file
+        busybox cat $result_file
+        iwlist wlan0 scanning last | busybox grep "Signal level" > $result_file2
+        busybox cat $result_file2
+        echo "success"
+        exit 1
+    fi
+
+    echo "remove wifi driver"
+    if [ $mt5931_kitkat = "true" ]; then
+        echo "echo 0 > /dev/wmtWifi"
+        echo 0 > /dev/wmtWifi
+    else
+      if [ $android_kitkat = "false" ]; then
+        if [ $driver_buildin = "true" ]; then
+          echo "echo 0 > $driver_node"
+          echo 0 > "$driver_node"
+        else
+          echo "rmmod wlan"
+          rmmod wlan
+        fi
+      fi
+    fi
+    busybox sleep 1
+    
+    j=$((j+1))
+done
+
+echo "wlan test failed"
+exit 0
+
diff --git a/bootable/recovery/pcba_core/rk32_codec/alsa_audio.h b/bootable/recovery/pcba_core/rk32_codec/alsa_audio.h
new file mode 100644
index 0000000000..bea9ec6a8d
--- /dev/null
+++ b/bootable/recovery/pcba_core/rk32_codec/alsa_audio.h
@@ -0,0 +1,153 @@
+#ifndef _AUDIO_H_
+#define _AUDIO_H_
+
+#define PCM_OUT        0x00000000
+#define PCM_IN         0x10000000
+
+#define PCM_STEREO     0x00000000
+#define PCM_MONO       0x01000000
+
+#define PCM_44100HZ    0x00000000
+#define PCM_48000HZ    0x00100000
+#define PCM_8000HZ     0x00200000
+#define PCM_RATE_MASK  0x00F00000
+
+#define PCM_DEVICE0      0x00000000
+#define PCM_DEVICE1      0x00000010
+#define PCM_DEVICE2      0x00000020
+#define PCM_DEVICE_MASK  0x000000F0
+#define PCM_DEVICE_SHIFT 4
+
+#define PCM_CARD0      0x00000000
+#define PCM_CARD1      0x00000001
+#define PCM_CARD2      0x00000002
+#define PCM_CARD_MASK  0x0000000F
+#define PCM_CARD_SHIFT 0
+
+#define PCM_PERIOD_CNT_MIN 3
+#define PCM_PERIOD_CNT_SHIFT 16
+#define PCM_PERIOD_CNT_MASK (0xF << PCM_PERIOD_CNT_SHIFT)
+#define PCM_PERIOD_SZ_MIN 64
+#define PCM_PERIOD_SZ_SHIFT 12
+#define PCM_PERIOD_SZ_MASK (0xF << PCM_PERIOD_SZ_SHIFT)
+
+typedef enum _AudioRoute {
+    SPEAKER_NORMAL_ROUTE = 0,
+    SPEAKER_INCALL_ROUTE, // 1
+    SPEAKER_RINGTONE_ROUTE,
+    SPEAKER_VOIP_ROUTE,
+
+    EARPIECE_NORMAL_ROUTE, // 4
+    EARPIECE_INCALL_ROUTE,
+    EARPIECE_RINGTONE_ROUTE,
+    EARPIECE_VOIP_ROUTE,
+
+    HEADPHONE_NORMAL_ROUTE, // 8
+    HEADPHONE_INCALL_ROUTE,
+    HEADPHONE_RINGTONE_ROUTE,
+    SPEAKER_HEADPHONE_NORMAL_ROUTE,
+    SPEAKER_HEADPHONE_RINGTONE_ROUTE,
+    HEADPHONE_VOIP_ROUTE,
+
+    HEADSET_NORMAL_ROUTE, // 14
+    HEADSET_INCALL_ROUTE,
+    HEADSET_RINGTONE_ROUTE,
+    HEADSET_VOIP_ROUTE,
+
+    BLUETOOTH_NORMAL_ROUTE, // 18
+    BLUETOOTH_INCALL_ROUTE,
+    BLUETOOTH_VOIP_ROUTE,
+
+    MAIN_MIC_CAPTURE_ROUTE, // 21
+    HANDS_FREE_MIC_CAPTURE_ROUTE,
+    BLUETOOTH_SOC_MIC_CAPTURE_ROUTE,
+
+    PLAYBACK_OFF_ROUTE, // 24
+    CAPTURE_OFF_ROUTE,
+    INCALL_OFF_ROUTE,
+    VOIP_OFF_ROUTE,
+
+    HDMI_NORMAL_ROUTE, // 28
+
+    USB_NORMAL_ROUTE, // 29
+    USB_CAPTURE_ROUTE,
+
+    MAX_ROUTE, // 31
+} AudioRoute;
+
+#define PCM_ERROR_MAX 128
+extern struct mixer* mMixerPlayback;
+extern struct mixer* mMixerCapture;
+struct pcm {
+    int fd;
+    unsigned flags;
+    int running:1;
+    int underruns;
+    unsigned buffer_size;
+    char error[PCM_ERROR_MAX];
+};
+
+/* Acquire/release a pcm channel.
+ * Returns non-zero on error
+ */
+struct pcm *pcm_open(unsigned flags);
+int pcm_close(struct pcm *pcm);
+int pcm_ready(struct pcm *pcm);
+
+/* Returns a human readable reason for the last error. */
+const char *pcm_error(struct pcm *pcm);
+
+/* Returns the buffer size (int bytes) that should be used for pcm_write.
+ * This will be 1/2 of the actual fifo size.
+ */
+unsigned pcm_buffer_size(struct pcm *pcm);
+
+/* Write data to the fifo.
+ * Will start playback on the first write or on a write that
+ * occurs after a fifo underrun.
+ */
+int pcm_write(struct pcm *pcm, void *data, unsigned count);
+int pcm_read(struct pcm *pcm, void *data, unsigned count);
+
+struct mixer_ctl {
+    struct mixer *mixer;
+    struct snd_ctl_elem_info *info;
+    struct snd_ctl_tlv *tlv;
+    char **ename;
+};
+
+struct mixer {
+    int fd;
+    struct snd_ctl_elem_info *info;
+    struct mixer_ctl *ctl;
+    unsigned count;
+};
+
+struct mixer *mixer_open(unsigned card);
+void mixer_close(struct mixer *mixer);
+void mixer_dump(struct mixer *mixer);
+
+struct mixer_ctl *mixer_get_control(struct mixer *mixer,
+                                    const char *name, unsigned index);
+struct mixer_ctl *mixer_get_nth_control(struct mixer *mixer, unsigned n);
+
+int mixer_ctl_set(struct mixer_ctl *ctl, unsigned percent);
+int mixer_ctl_select(struct mixer_ctl *ctl, const char *value);
+void mixer_ctl_print(struct mixer_ctl *ctl);
+int mixer_ctl_set_int_double(struct mixer_ctl *ctl, long long left, long long right);
+int mixer_ctl_set_int(struct mixer_ctl *ctl, long long value);
+int mixer_tlv_get_dB_range(unsigned int *tlv, long rangemin, long rangemax,
+                                    long *min, long *max);
+int mixer_get_ctl_minmax(struct mixer_ctl *ctl, long long *min, long long *max);
+int mixer_get_dB_range(struct mixer_ctl *ctl, long rangemin, long rangemax,
+                                    float *dB_min, float *dB_max, float *dB_step);
+
+int route_init(void);
+void route_uninit(void);
+int route_set_input_source(const char *source);
+int route_set_voice_volume(const char *ctlName, float volume);
+int route_set_controls(unsigned route);
+struct pcm *route_pcm_open(unsigned route, unsigned int flags);
+int route_pcm_close(unsigned route);
+
+#endif
diff --git a/bootable/recovery/pcba_core/rk32_codec/alsa_mixer.c b/bootable/recovery/pcba_core/rk32_codec/alsa_mixer.c
new file mode 100644
index 0000000000..181ddae94f
--- /dev/null
+++ b/bootable/recovery/pcba_core/rk32_codec/alsa_mixer.c
@@ -0,0 +1,592 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+
+#include <linux/ioctl.h>
+#define __force
+#define __bitwise
+#define __user
+#include "../asound.h"
+#define LOG_TAG "alsa_mixer"
+
+#define LOG_NDEBUG 0
+
+#include "alsa_audio.h"
+#include <cutils/log.h>
+
+#define MAX_SOUND_CARDS     10
+#define VOLUME_PERCENTS     90
+#define SOUND_CTL_PREFIX    "/dev/snd/controlC%d"
+
+/* convert to index of integer array */
+#define int_index(size)	(((size) + sizeof(int) - 1) / sizeof(int))
+/* max size of a TLV entry for dB information (including compound one) */
+#define MAX_TLV_RANGE_SIZE	256
+
+char *volume_controls_name_table[] = {
+    "Earpiece Playback Volume",
+    "Speaker Playback Volume",
+    "Headphone Playback Volume",
+    "PCM Playback Volume",
+    "Mic Capture Volume",
+};
+
+static const char *elem_iface_name(snd_ctl_elem_iface_t n)
+{
+    switch (n) {
+    case SNDRV_CTL_ELEM_IFACE_CARD: return "CARD";
+    case SNDRV_CTL_ELEM_IFACE_HWDEP: return "HWDEP";
+    case SNDRV_CTL_ELEM_IFACE_MIXER: return "MIXER";
+    case SNDRV_CTL_ELEM_IFACE_PCM: return "PCM";
+    case SNDRV_CTL_ELEM_IFACE_RAWMIDI: return "MIDI";
+    case SNDRV_CTL_ELEM_IFACE_TIMER: return "TIMER";
+    case SNDRV_CTL_ELEM_IFACE_SEQUENCER: return "SEQ";
+    default: return "???";
+    }
+}
+
+static const char *elem_type_name(snd_ctl_elem_type_t n)
+{
+    switch (n) {
+    case SNDRV_CTL_ELEM_TYPE_NONE: return "NONE";
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN: return "BOOL";
+    case SNDRV_CTL_ELEM_TYPE_INTEGER: return "INT32";
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED: return "ENUM";
+    case SNDRV_CTL_ELEM_TYPE_BYTES: return "BYTES";
+    case SNDRV_CTL_ELEM_TYPE_IEC958: return "IEC958";
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64: return "INT64";
+    default: return "???";
+    }
+}
+
+void mixer_close(struct mixer *mixer)
+{
+    unsigned n,m;
+
+    if (mixer->fd >= 0)
+        close(mixer->fd);
+
+    if (mixer->ctl) {
+        for (n = 0; n < mixer->count; n++) {
+            if (mixer->ctl[n].tlv)
+                free(mixer->ctl[n].tlv);
+            if (mixer->ctl[n].ename) {
+                unsigned max = mixer->ctl[n].info->value.enumerated.items;
+                for (m = 0; m < max; m++)
+                    free(mixer->ctl[n].ename[m]);
+                free(mixer->ctl[n].ename);
+            }
+        }
+        free(mixer->ctl);
+    }
+
+    if (mixer->info)
+        free(mixer->info);
+
+    free(mixer);
+}
+
+struct mixer *mixer_open(unsigned card)
+{
+    char dname[sizeof(SOUND_CTL_PREFIX) + 20];
+    struct snd_ctl_elem_list elist;
+    struct snd_ctl_elem_info tmp;
+    struct snd_ctl_elem_id *eid = NULL;
+    struct mixer *mixer = NULL;
+    unsigned n, m, i, max = sizeof(volume_controls_name_table) / sizeof(char *);
+    int fd;
+
+    sprintf(dname, SOUND_CTL_PREFIX, card);
+
+    fd = open(dname, O_RDWR);
+
+    if (fd < 0) {
+        printf("mixer_open() Can not open %s for card %d \n", dname, card);
+        return 0;
+    }
+
+    memset(&elist, 0, sizeof(elist));
+    if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_LIST, &elist) < 0)
+        goto fail;
+
+    mixer = calloc(1, sizeof(*mixer));
+    if (!mixer)
+        goto fail;
+
+    mixer->ctl = calloc(elist.count, sizeof(struct mixer_ctl));
+    mixer->info = calloc(elist.count, sizeof(struct snd_ctl_elem_info));
+    if (!mixer->ctl || !mixer->info)
+        goto fail;
+
+    eid = calloc(elist.count, sizeof(struct snd_ctl_elem_id));
+    if (!eid)
+        goto fail;
+
+    mixer->count = elist.count;
+    mixer->fd = fd;
+    elist.space = mixer->count;
+    elist.pids = eid;
+    if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_LIST, &elist) < 0)
+        goto fail;
+
+    for (n = 0; n < mixer->count; n++) {
+        struct snd_ctl_elem_info *ei = mixer->info + n;
+        ei->id.numid = eid[n].numid;
+        if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_INFO, ei) < 0)
+            goto fail;
+        mixer->ctl[n].info = ei;
+        mixer->ctl[n].mixer = mixer;
+        if (ei->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+            char **enames = calloc(ei->value.enumerated.items, sizeof(char*));
+            if (!enames)
+                goto fail;
+            mixer->ctl[n].ename = enames;
+            for (m = 0; m < ei->value.enumerated.items; m++) {
+                memset(&tmp, 0, sizeof(tmp));
+                tmp.id.numid = ei->id.numid;
+                tmp.value.enumerated.item = m;
+                if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_INFO, &tmp) < 0)
+                    goto fail;
+                enames[m] = strdup(tmp.value.enumerated.name);
+                if (!enames[m])
+                    goto fail;
+            }
+        }
+
+        //add for incall volume by Jear.Chen. get tlv.
+        for (i = 0; i < max; i++) {
+            if (!strcmp((char*) mixer->ctl[n].info->id.name, volume_controls_name_table[i]))
+                break;
+        }
+
+        if (i >= max) {
+            mixer->ctl[n].tlv = NULL;
+            continue;
+        }
+
+        if ((mixer->ctl[n].info->access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) == 0) {
+            printf("mixer_open() type of control %s is not TLVT_DB \n", mixer->ctl[n].info->id.name);
+            mixer->ctl[n].tlv = NULL;
+            continue;
+        }
+
+        unsigned int tlv_size = 2 * sizeof(unsigned int) + 2 * sizeof(unsigned int);
+        struct snd_ctl_tlv *tlv = malloc(sizeof(struct sndrv_ctl_tlv) + tlv_size);
+
+        //tlv->numid < (info->id.numid + info->count) and
+        //tlv->numid >= info->id.numid
+        tlv->numid = mixer->ctl[n].info->id.numid;
+        //length >= tlv.p[1] + 2 * sizeof(unsigned int);
+        //tlv.p is DECLARE_TLV_DB_SCALE defined in kernel
+        tlv->length = tlv_size;
+
+        if (ioctl(fd, SNDRV_CTL_IOCTL_TLV_READ, tlv) < 0) {
+            printf("mixer_open() get tlv for control %s fail \n", mixer->ctl[n].info->id.name);
+            free(tlv);
+            mixer->ctl[n].tlv = tlv = NULL;
+			continue;
+        }
+
+        printf("mixer_open() get tlv for control %s \n", mixer->ctl[n].info->id.name);
+        mixer->ctl[n].tlv = tlv;
+        //add for incall volume end
+    }
+
+    free(eid);
+    return mixer;
+
+fail:
+    if (eid)
+        free(eid);
+    if (mixer)
+        mixer_close(mixer);
+    else if (fd >= 0)
+        close(fd);
+    return 0;
+}
+
+void mixer_ctl_print(struct mixer_ctl *ctl)
+{
+    struct snd_ctl_elem_value ev;
+    struct snd_ctl_elem_info *ei = ctl->info;
+    unsigned m;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    if (ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_READ, &ev))
+        return;
+    printf("%s:", ctl->info->id.name);
+
+    switch (ei->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        for (m = 0; m < ei->count; m++)
+            printf(" %s \n", ev.value.integer.value[m] ? "ON" : "OFF");
+
+        printf(" { OFF=0, ON=1 } \n");
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        for (m = 0; m < ei->count; m++)
+            printf(" %ld", ev.value.integer.value[m]);
+
+        printf(ei->value.integer.step ?
+               " { %ld-%ld, %ld }\n" : " { %ld-%ld } \n",
+               ei->value.integer.min,
+               ei->value.integer.max,
+               ei->value.integer.step);
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        for (m = 0; m < ei->count; m++)
+            printf(" %lld", ev.value.integer64.value[m]);
+
+        printf(ei->value.integer64.step ?
+               " { %lld-%lld, %lld }\n" : " { %lld-%lld } \n",
+               ei->value.integer64.min,
+               ei->value.integer64.max,
+               ei->value.integer64.step);
+        break;
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED: {
+        for (m = 0; m < ei->count; m++) {
+            unsigned v = ev.value.enumerated.item[m];
+            printf(" (%d %s) \n", v,
+                  (v < ei->value.enumerated.items) ? ctl->ename[v] : "???");
+        }
+
+        printf(" { %s=0 \n", ctl->ename[0]);
+        for (m = 1; m < ei->value.enumerated.items; m++)
+            printf(", %s=%d \n", ctl->ename[m],m);
+        printf(" } \n");
+        break;
+    }
+    default:
+        printf(" ??? \n");
+    }
+    printf("\n");
+}
+
+void mixer_dump(struct mixer *mixer)
+{
+    unsigned n;
+
+    printf("  id iface dev sub idx num perms     type   name\n");
+    for (n = 0; n < mixer->count; n++) {
+        struct snd_ctl_elem_info *ei = mixer->info + n;
+
+        printf("%4d %5s %3d %3d %3d %3d %c%c%c%c%c%c%c%c%c %-6s  \n",
+               ei->id.numid, elem_iface_name(ei->id.iface),
+               ei->id.device, ei->id.subdevice, ei->id.index,
+               ei->count,
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_READ) ? 'r' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ? 'w' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_VOLATILE) ? 'V' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TIMESTAMP) ? 'T' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) ? 'R' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) ? 'W' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) ? 'C' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE) ? 'I' : ' ',
+               (ei->access & SNDRV_CTL_ELEM_ACCESS_LOCK) ? 'L' : ' ',
+               elem_type_name(ei->type));
+
+        mixer_ctl_print(mixer->ctl + n);
+    }
+}
+
+struct mixer_ctl *mixer_get_control(struct mixer *mixer,
+                                    const char *name, unsigned index)
+{
+    unsigned n;
+    for (n = 0; n < mixer->count; n++) {
+//		printf("mixer_get_control() %s / %s access 0x%08x \n",name,mixer->info[n].id.name,mixer->info[n].access);
+        if (mixer->info[n].id.index == index) {
+            if (!strcmp(name, (char*) mixer->info[n].id.name)) {
+				//printf("mixer_get_control() %s access 0x%08x \n",mixer->info[n].id.name,mixer->info[n].access);
+                return mixer->ctl + n;
+            }
+        }
+    }
+    return 0;
+}
+
+struct mixer_ctl *mixer_get_nth_control(struct mixer *mixer, unsigned n)
+{
+    if (n < mixer->count)
+        return mixer->ctl + n;
+    return 0;
+}
+
+static long scale_int(struct snd_ctl_elem_info *ei, unsigned _percent)
+{
+    long percent;
+    long range;
+
+    if (_percent > 100)
+        percent = 100;
+    else
+        percent = (long) _percent;
+
+    range = (ei->value.integer.max - ei->value.integer.min);
+
+    return ei->value.integer.min + (range * percent) / 100LL;
+}
+
+static long long scale_int64(struct snd_ctl_elem_info *ei, unsigned _percent)
+{
+    long long percent;
+    long long range;
+
+    if (_percent > 100)
+        percent = 100;
+    else
+        percent = (long) _percent;
+
+    range = (ei->value.integer.max - ei->value.integer.min) * 100LL;
+
+    return ei->value.integer.min + (range / percent);
+}
+
+int mixer_ctl_set(struct mixer_ctl *ctl, unsigned percent)
+{
+    struct snd_ctl_elem_value ev;
+    unsigned n;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        for (n = 0; n < ctl->info->count; n++)
+            ev.value.integer.value[n] = !!percent;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER: {
+        long value = scale_int(ctl->info, percent);
+        for (n = 0; n < ctl->info->count; n++)
+            ev.value.integer.value[n] = value;
+        break;
+    }
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64: {
+        long long value = scale_int64(ctl->info, percent);
+        for (n = 0; n < ctl->info->count; n++)
+            ev.value.integer64.value[n] = value;
+        break;
+    }
+    default:
+        errno = EINVAL;
+        return -1;
+    }
+
+    return ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+}
+
+int mixer_ctl_select(struct mixer_ctl *ctl, const char *value)
+{
+    unsigned n, max;
+    struct snd_ctl_elem_value ev;
+
+    if (ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    max = ctl->info->value.enumerated.items;
+    for (n = 0; n < max; n++) {
+        if (!strcmp(value, ctl->ename[n])) {
+            memset(&ev, 0, sizeof(ev));
+            ev.value.enumerated.item[0] = n;
+            ev.id.numid = ctl->info->id.numid;
+            if (ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev) < 0)
+                return -1;
+            return 0;
+        }
+    }
+
+    errno = EINVAL;
+    return -1;
+}
+
+//add for incall volume by Jear.Chen
+/*
+  set value to control
+*/
+
+int mixer_ctl_set_int_double(struct mixer_ctl *ctl, long long left, long long right)
+{
+    struct snd_ctl_elem_value ev;
+    unsigned n;
+    long long max, min, value = left;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        for (n = 0; n < ctl->info->count; n++) {
+            ev.value.integer.value[n] = !!value;
+            value = right;
+        }
+        break;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER: {
+        max = ctl->info->value.integer.max;
+        min = ctl->info->value.integer.min;
+
+        left = left > max ? max : left;
+        left = left < min ? min : left;
+        right = right > max ? max : right;
+        right = right < min ? min : right;
+
+        value = left;
+
+        for (n = 0; n < ctl->info->count; n++) {
+            ev.value.integer.value[n] = (long)value;
+            value = right;
+        }
+        break;
+    }
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64: {
+        max = ctl->info->value.integer64.max;
+        min = ctl->info->value.integer64.min;
+
+        left = left > max ? max : left;
+        left = left < min ? min : left;
+        right = right > max ? max : right;
+        right = right < min ? min : right;
+
+        value = left;
+
+        for (n = 0; n < ctl->info->count; n++) {
+            ev.value.integer64.value[n] = value;
+            value = right;
+        }
+        break;
+    }
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        max = ctl->info->value.enumerated.items;
+        return mixer_ctl_select(ctl, ctl->ename[value > max ? max : value]);
+    default:
+        errno = EINVAL;
+        return -1;
+    }
+
+    return ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+}
+
+int mixer_ctl_set_int(struct mixer_ctl *ctl, long long value)
+{
+    return mixer_ctl_set_int_double(ctl, value, value);
+}
+
+/*
+  Get min and max value of control
+ */
+int mixer_get_ctl_minmax(struct mixer_ctl *ctl, long long *min, long long *max)
+{
+    struct snd_ctl_elem_info *ei = ctl->info;
+
+    switch (ei->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        *min = ei->value.integer.min;
+        *max = ei->value.integer.max;
+        break;
+	case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+        *min = ei->value.integer64.min;
+        *max = ei->value.integer64.max;
+        break;
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        *min = 0;
+        *max = ei->value.enumerated.items;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+/*
+  Get dB range from tlv[] which is obtained from control
+ */
+int mixer_tlv_get_dB_range(unsigned int *tlv, long rangemin, long rangemax,
+                                    long *min, long *max)
+{
+    int err;
+
+    switch (tlv[0]) {
+    case SND_CTL_TLVT_DB_RANGE: {
+        unsigned int pos, len;
+        len = int_index(tlv[1]);
+        if (len > MAX_TLV_RANGE_SIZE)
+            return -EINVAL;
+        pos = 2;
+        while (pos + 4 <= len) {
+            long rmin, rmax;
+            rangemin = (int)tlv[pos];
+            rangemax = (int)tlv[pos + 1];
+            err = mixer_tlv_get_dB_range(tlv + pos + 2,
+                rangemin, rangemax,
+                &rmin, &rmax);
+            if (err < 0)
+                return err;
+            if (pos > 2) {
+                if (rmin < *min)
+                    *min = rmin;
+                if (rmax > *max)
+                    *max = rmax;
+            } else {
+                *min = rmin;
+                *max = rmax;
+            }
+            pos += int_index(tlv[pos + 3]) + 4;
+        }
+        return 0;
+    }
+    case SND_CTL_TLVT_DB_SCALE: {
+        long step;
+        *min = (int)tlv[2];
+        step = (tlv[3] & 0xffff);
+        *max = *min + (long)(step * (rangemax - rangemin));
+        return 0;
+    }
+    case SND_CTL_TLVT_DB_MINMAX:
+    case SND_CTL_TLVT_DB_MINMAX_MUTE:
+    case SND_CTL_TLVT_DB_LINEAR:
+        *min = (int)tlv[2];
+        *max = (int)tlv[3];
+        return 0;
+    }
+    return -EINVAL;
+}
+
+/*
+  Get dB range of control
+ */
+int mixer_get_dB_range(struct mixer_ctl *ctl, long rangemin, long rangemax,
+                                    float *dB_min, float *dB_max, float *dB_step)
+{
+    unsigned int *tlv;
+    long min, max;
+
+    if (ctl->tlv == NULL) {
+        printf("mixer_get_dB_range() tlv of control %s is NULL \n", ctl->info->id.name);
+        return -EINVAL;
+    }
+
+    if (mixer_tlv_get_dB_range(ctl->tlv->tlv, rangemin, rangemax,
+           &min, &max) < 0) {
+        printf("mixer_get_dB_range() get control dB range fail \n");
+        return -EINVAL;
+    }
+
+    *dB_min = min * 1.0 / 100;
+    *dB_max = max * 1.0 / 100;
+    *dB_step = (max - min) * 1.0 / (rangemax - rangemin) / 100;
+
+    printf("control %s : dB min = %f, dB max = %f, dB step = %f \n",
+           ctl->info->id.name,
+           *dB_min,
+           *dB_max,
+           *dB_step);
+
+    return 0;
+}
+//add for incall volume end
diff --git a/bootable/recovery/pcba_core/rk32_codec/alsa_pcm.c b/bootable/recovery/pcba_core/rk32_codec/alsa_pcm.c
new file mode 100644
index 0000000000..b2aa5da70b
--- /dev/null
+++ b/bootable/recovery/pcba_core/rk32_codec/alsa_pcm.c
@@ -0,0 +1,592 @@
+#define LOG_TAG "alsa_pcm"
+//#define LOG_NDEBUG 0
+#include <cutils/log.h>
+#include <cutils/config_utils.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+
+#include <linux/ioctl.h>
+
+#include "alsa_audio.h"
+
+#define __force
+#define __bitwise
+#define __user
+#include "../asound.h"
+
+#define PARAM_MAX SNDRV_PCM_HW_PARAM_LAST_INTERVAL
+
+int64_t last_read_time = 0;
+
+static int64_t systemTime()
+{
+    struct timespec t;
+    t.tv_sec = t.tv_nsec = 0;
+    clock_gettime(CLOCK_MONOTONIC, &t);
+    return t.tv_sec*1000000000LL + t.tv_nsec;
+}
+
+static inline int param_is_mask(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_MASK) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_MASK);
+}
+
+static inline int param_is_interval(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL);
+}
+
+static inline struct snd_interval *param_to_interval(struct snd_pcm_hw_params *p, int n)
+{
+    return &(p->intervals[n - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL]);
+}
+
+static inline struct snd_mask *param_to_mask(struct snd_pcm_hw_params *p, int n)
+{
+    return &(p->masks[n - SNDRV_PCM_HW_PARAM_FIRST_MASK]);
+}
+
+static void param_set_mask(struct snd_pcm_hw_params *p, int n, unsigned bit)
+{
+    if (bit >= SNDRV_MASK_MAX)
+        return;
+    if (param_is_mask(n)) {
+        struct snd_mask *m = param_to_mask(p, n);
+        m->bits[0] = 0;
+        m->bits[1] = 0;
+        m->bits[bit >> 5] |= (1 << (bit & 31));
+    }
+}
+
+static void param_set_min(struct snd_pcm_hw_params *p, int n, unsigned val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->min = val;
+    }
+}
+
+static void param_set_max(struct snd_pcm_hw_params *p, int n, unsigned val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->max = val;
+    }
+}
+
+static void param_set_int(struct snd_pcm_hw_params *p, int n, unsigned val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->min = val;
+        i->max = val;
+        i->integer = 1;
+    }
+}
+
+static void param_init(struct snd_pcm_hw_params *p)
+{
+    int n;
+    memset(p, 0, sizeof(*p));
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_MASK;
+         n <= SNDRV_PCM_HW_PARAM_LAST_MASK; n++) {
+            struct snd_mask *m = param_to_mask(p, n);
+            m->bits[0] = ~0;
+            m->bits[1] = ~0;
+    }
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL;
+         n <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; n++) {
+            struct snd_interval *i = param_to_interval(p, n);
+            i->min = 0;
+            i->max = ~0;
+    }
+}
+
+/* debugging gunk */
+
+#if DEBUG
+static const char *param_name[PARAM_MAX+1] = {
+    [SNDRV_PCM_HW_PARAM_ACCESS] = "access",
+    [SNDRV_PCM_HW_PARAM_FORMAT] = "format",
+    [SNDRV_PCM_HW_PARAM_SUBFORMAT] = "subformat",
+
+    [SNDRV_PCM_HW_PARAM_SAMPLE_BITS] = "sample_bits",
+    [SNDRV_PCM_HW_PARAM_FRAME_BITS] = "frame_bits",
+    [SNDRV_PCM_HW_PARAM_CHANNELS] = "channels",
+    [SNDRV_PCM_HW_PARAM_RATE] = "rate",
+    [SNDRV_PCM_HW_PARAM_PERIOD_TIME] = "period_time",
+    [SNDRV_PCM_HW_PARAM_PERIOD_SIZE] = "period_size",
+    [SNDRV_PCM_HW_PARAM_PERIOD_BYTES] = "period_bytes",
+    [SNDRV_PCM_HW_PARAM_PERIODS] = "periods",
+    [SNDRV_PCM_HW_PARAM_BUFFER_TIME] = "buffer_time",
+    [SNDRV_PCM_HW_PARAM_BUFFER_SIZE] = "buffer_size",
+    [SNDRV_PCM_HW_PARAM_BUFFER_BYTES] = "buffer_bytes",
+    [SNDRV_PCM_HW_PARAM_TICK_TIME] = "tick_time",
+};
+
+static void param_dump(struct snd_pcm_hw_params *p)
+{
+    int n;
+
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_MASK;
+         n <= SNDRV_PCM_HW_PARAM_LAST_MASK; n++) {
+            struct snd_mask *m = param_to_mask(p, n);
+            printf("%s = %08x%08x\n", param_name[n],
+                   m->bits[1], m->bits[0]);
+    }
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL;
+         n <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; n++) {
+            struct snd_interval *i = param_to_interval(p, n);
+            printf("%s = (%d,%d) omin=%d omax=%d int=%d empty=%d\n",
+                   param_name[n], i->min, i->max, i->openmin,
+                   i->openmax, i->integer, i->empty);
+    }
+    printf("info = %08x\n", p->info);
+    printf("msbits = %d\n", p->msbits);
+    printf("rate = %d/%d\n", p->rate_num, p->rate_den);
+    printf("fifo = %d\n", (int) p->fifo_size);
+}
+
+static void info_dump(struct snd_pcm_info *info)
+{
+    printf("device = %d\n", info->device);
+    printf("subdevice = %d\n", info->subdevice);
+    printf("stream = %d\n", info->stream);
+    printf("card = %d\n", info->card);
+    printf("id = '%s'\n", info->id);
+    printf("name = '%s'\n", info->name);
+    printf("subname = '%s'\n", info->subname);
+    printf("dev_class = %d\n", info->dev_class);
+    printf("dev_subclass = %d\n", info->dev_subclass);
+    printf("subdevices_count = %d\n", info->subdevices_count);
+    printf("subdevices_avail = %d\n", info->subdevices_avail);
+}
+#else
+static void param_dump(struct snd_pcm_hw_params *p) {}
+static void info_dump(struct snd_pcm_info *info) {}
+#endif
+
+unsigned pcm_buffer_size(struct pcm *pcm)
+{
+    return pcm->buffer_size;
+}
+
+const char* pcm_error(struct pcm *pcm)
+{
+    return pcm->error;
+}
+
+static int oops(struct pcm *pcm, int e, const char *fmt, ...) __attribute__((format(printf, 3, 4)));
+static int oops(struct pcm *pcm, int e, const char *fmt, ...)
+{
+    va_list ap;
+    int sz;
+
+    va_start(ap, fmt);
+    vsnprintf(pcm->error, PCM_ERROR_MAX, fmt, ap);
+    va_end(ap);
+    sz = strlen(pcm->error);
+
+    if (errno)
+        snprintf(pcm->error + sz, PCM_ERROR_MAX - sz,
+                 ": %s", strerror(e));
+    return -1;
+}
+
+int pcm_write(struct pcm *pcm, void *data, unsigned count)
+{
+    struct snd_xferi x;
+
+    if (pcm->flags & PCM_IN)
+        return -EINVAL;
+
+    x.buf = data;
+    x.frames = (pcm->flags & PCM_MONO) ? (count / 2) : (count / 4);
+
+    for (;;) {
+        if (!pcm->running) {
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE))
+                return oops(pcm, errno, "cannot prepare channel");
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x))
+                return oops(pcm, errno, "cannot write initial data");
+            pcm->running = 1;
+            return 0;
+        }
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x)) {
+#ifdef SUPPORT_USB
+            //usb sound card out, so sleep for data and return no error.
+            unsigned int usleep_time = 0;
+            unsigned int frames = (pcm->flags & PCM_MONO) ? (count / 2) : (count / 4);
+
+            if ((pcm->flags & PCM_RATE_MASK) == PCM_8000HZ)
+                usleep_time = frames * 1000 * 1000 / 8000;
+            else if ((pcm->flags & PCM_RATE_MASK) == PCM_48000HZ)
+                usleep_time = frames * 1000 * 1000 / 48000;
+            else
+                usleep_time = frames * 1000 * 1000 / 44100;
+            usleep(usleep_time);
+
+            return 0;
+#endif
+            pcm->running = 0;
+            if (errno == EPIPE) {
+                    /* we failed to make our window -- try to restart */
+                pcm->underruns++;
+                continue;
+            }
+            return oops(pcm, errno, "cannot write stream data");
+        }
+        return 0;
+    }
+}
+
+/********************************
+	author:charles chen
+	data:2012.09.27
+	parameter 
+	data: the input data buf point
+	len:   the input data len need consider the pcm_format
+	ret: 0:Left and right channel is valid
+		  1:Left      channel is valid
+		  2:Right    channel is valid
+
+defalt the input signal is like LRLRLR,default pcm_format is 16bit
+*********************************/
+#define SAMPLECOUNT 441*5*2*2
+int channalFlags = -1;//mean the channel is not checked now
+
+int startCheckCount = 0;
+
+int channel_check(void * data, unsigned len)
+{
+	short * pcmLeftChannel = (short *)data;
+	short * pcmRightChannel = pcmLeftChannel+1;
+	unsigned index = 0;
+	int leftValid = 0x0;
+	int rightValid = 0x0;
+	short checkValue = 0;
+	
+	checkValue = *pcmLeftChannel;
+
+	//checkleft first
+	for(index = 0; index < len; index += 2)
+	{
+		
+		if((pcmLeftChannel[index] >= checkValue+50)||(pcmLeftChannel[index] <= checkValue-50))
+		{
+			leftValid++;// = 0x01;
+		        //printf("-->pcmLeftChannel[%d] = %d checkValue %d leftValid %d",index,pcmLeftChannel[index],checkValue,leftValid);
+			//break;
+		}	
+	}
+
+	if(leftValid >20)
+		leftValid = 0x01;
+	else
+		leftValid = 0;
+	checkValue = *pcmRightChannel;
+
+		//then check right 
+	for(index = 0; index < len; index += 2)
+	{
+		
+		if((pcmRightChannel[index] >= checkValue+50)||(pcmRightChannel[index] <= checkValue-50))
+		{
+			rightValid++;//= 0x02;
+			//printf("-->pcmRightChannel[%d] = %d checkValue %d rightValid %d",index,pcmRightChannel[index],checkValue,rightValid);
+			//break;
+		}	
+	}
+
+	if(rightValid >20)
+		rightValid = 0x02;
+	else
+		rightValid = 0;
+	printf("leftValid %d rightValid %d \n",leftValid,rightValid);
+	return leftValid|rightValid;
+}
+
+void channel_fixed(void * data, unsigned len, int chFlag)
+{
+	//we just fixed when chFlag is 1 or 2.
+	if(chFlag <= 0 || chFlag > 2 )
+		return;
+
+	short * pcmValid = (short *)data;
+	short * pcmInvalid = pcmValid;
+	
+	if(chFlag == 1)
+		pcmInvalid += 1;
+	else if (chFlag == 2)
+		pcmValid += 1;
+	
+	unsigned index ;
+	
+	for(index = 0; index < len; index += 2)
+	{
+		pcmInvalid[index] = pcmValid[index];
+	}
+	return;
+}
+
+static int cont = 0;
+int pcm_read(struct pcm *pcm, void *data, unsigned count)
+{
+    struct snd_xferi x;
+    int ret = 0;
+	char *recdata = NULL;
+	int xy = 0;
+
+    if (!(pcm->flags & PCM_IN))
+        return -EINVAL;
+
+    x.buf = data;
+    x.frames = (pcm->flags & PCM_MONO) ? (count / 2) : (count / 4);
+
+//    printf("read() %d frames", x.frames);
+    for (;;) {
+        if (!pcm->running) {
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE))
+                return oops(pcm, errno, "cannot prepare channel");
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_START))
+                return oops(pcm, errno, "cannot start channel");
+            pcm->running = 1;
+        }
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_READI_FRAMES, &x)) {
+//#ifdef SUPPORT_USB
+            if (((pcm->flags & PCM_CARD_MASK) >> PCM_CARD_SHIFT) == PCM_CARD2) {
+                //usb sound card out, so set data to 0, and sleep for data
+                int need_usleep_time;
+                unsigned int usleep_time = 0;
+                unsigned int frames = (pcm->flags & PCM_MONO) ? (count / 2) : (count / 4);
+
+                if ((pcm->flags & PCM_RATE_MASK) == PCM_8000HZ)
+                    usleep_time = frames * 1000 * 1000 / 8000;
+                else if ((pcm->flags & PCM_RATE_MASK) == PCM_48000HZ)
+                    usleep_time = frames * 1000 * 1000 / 48000;
+                else
+                    usleep_time = frames * 1000 * 1000 / 44100;
+
+                memset(data, 0, count);
+
+                if (last_read_time == 0)
+                    last_read_time = systemTime();
+
+                need_usleep_time = usleep_time - (systemTime() - last_read_time) / 1000;
+                if (need_usleep_time > 0)
+                    usleep(need_usleep_time);
+
+                last_read_time = systemTime();
+
+                return 0;
+            }
+//#endif
+            pcm->running = 0;
+            if (errno == EPIPE) {
+                    /* we failed to make our window -- try to restart */
+                pcm->underruns++;
+                continue;
+            }
+            return oops(pcm, errno, "cannot read stream data");
+        }
+        last_read_time = systemTime();
+//        printf("read() got %d frames", x.frames);
+		if(!(pcm->flags & PCM_MONO))
+		{
+				//LOGI("read() get %d", x.frames);
+			if(channalFlags == -1 )	
+			{
+				if(startCheckCount < SAMPLECOUNT)
+				{
+					startCheckCount += count;
+				}
+				else
+				{
+					channalFlags = channel_check(data,count/2);
+				}
+			}//if(channalFlags == -1)
+
+			channel_fixed(data,count/2, channalFlags);
+		}
+
+		if (0){
+			cont ++;
+			recdata = data;
+			for (;xy <= 1000;xy++){
+				if ((xy%22) == 21)
+					printf("\n");
+					printf("0x%02x ",*recdata++);
+			}
+		}
+        return 0;
+    }
+}
+
+
+
+static struct pcm bad_pcm = {
+    .fd = -1,
+};
+
+int pcm_close(struct pcm *pcm)
+{
+    printf("pcm_close() card %u, device %u, %s \n",
+        (pcm->flags & PCM_CARD_MASK) >> PCM_CARD_SHIFT,
+        (pcm->flags & PCM_DEVICE_MASK) >> PCM_DEVICE_SHIFT,
+        (pcm->flags & PCM_IN) ? "Capture" : "Playback");
+
+    if (pcm == &bad_pcm)
+        return 0;
+
+    if (pcm->fd >= 0)
+        close(pcm->fd);
+    pcm->running = 0;
+    pcm->buffer_size = 0;
+    pcm->fd = -1;
+    free(pcm);
+    return 0;
+}
+
+struct pcm *pcm_open(unsigned flags)
+{
+    const char *dfmt = "/dev/snd/pcmC%uD%u%c";
+    char dname[sizeof(dfmt) + 20];
+    struct pcm *pcm;
+    struct snd_pcm_info info;
+    struct snd_pcm_hw_params params;
+    struct snd_pcm_sw_params sparams;
+    unsigned card;
+    unsigned device;
+    unsigned period_sz;
+    unsigned period_cnt;
+
+    printf("pcm_open(0x%08x) \n", flags);
+
+    pcm = calloc(1, sizeof(struct pcm));
+    if (!pcm)
+        return &bad_pcm;
+
+__open_again:
+
+    card = (flags & PCM_CARD_MASK) >> PCM_CARD_SHIFT;
+    device = (flags & PCM_DEVICE_MASK) >> PCM_DEVICE_SHIFT;
+
+    sprintf(dname, dfmt, card, device, flags & PCM_IN ? 'c' : 'p');
+
+    printf("pcm_open(%s) card %u, device %u, %s \n", dname,
+        card, device, (flags & PCM_IN) ? "Capture" : "Playback");
+
+    pcm->flags = flags;
+    pcm->fd = open(dname, O_RDWR|O_CLOEXEC);
+    if (pcm->fd < 0) {
+        oops(pcm, errno, "cannot open device '%s'", dname);
+        if ((flags & PCM_CARD_MASK) == PCM_CARD1) {
+            printf("Open sound card1 for HDMI error, open sound card0");
+            flags &= ~PCM_CARD_MASK;
+            goto __open_again;
+        }
+        return pcm;
+    }
+
+    while(pcm->fd == 0 || pcm->fd == 1 || pcm->fd == 2)
+    {
+        printf("pcm_open old_fd=%d \n",pcm->fd);
+        int tmp_fd = pcm->fd;
+        pcm->fd = dup(tmp_fd);
+        close(tmp_fd);
+        printf("pcm_open new_fd=%d \n",pcm->fd);
+    }
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_INFO, &info)) {
+        oops(pcm, errno, "cannot get info - %s", dname);
+        goto fail;
+    }
+    info_dump(&info);
+
+    printf("pcm_open() period sz multiplier %d \n",
+         ((flags & PCM_PERIOD_SZ_MASK) >> PCM_PERIOD_SZ_SHIFT) + 1);
+    period_sz = PCM_PERIOD_SZ_MIN * (((flags & PCM_PERIOD_SZ_MASK) >> PCM_PERIOD_SZ_SHIFT) + 1);
+    printf("pcm_open() period cnt %d \n",
+         ((flags & PCM_PERIOD_CNT_MASK) >> PCM_PERIOD_CNT_SHIFT) + PCM_PERIOD_CNT_MIN);
+    period_cnt = ((flags & PCM_PERIOD_CNT_MASK) >> PCM_PERIOD_CNT_SHIFT) + PCM_PERIOD_CNT_MIN;
+
+    printf("pcm_open() period_cnt %d period_sz %d channels %d \n",
+         period_cnt, period_sz, (flags & PCM_MONO) ? 1 : 2);
+
+    param_init(&params);
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                   SNDRV_PCM_ACCESS_RW_INTERLEAVED);
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_FORMAT,
+                   SNDRV_PCM_FORMAT_S16_LE);
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_SUBFORMAT,
+                   SNDRV_PCM_SUBFORMAT_STD);
+	
+    param_set_min(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, period_sz);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS, 16);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
+                  (flags & PCM_MONO) ? 16 : 32);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_CHANNELS,
+                  (flags & PCM_MONO) ? 1 : 2);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, period_cnt);
+    if ((flags & PCM_RATE_MASK) == PCM_8000HZ) {
+        printf("set audio rate 8KHz \n");
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, 8000);
+    } else if ((flags & PCM_RATE_MASK) == PCM_48000HZ) {
+        printf("set audio rate 48KHz \n");
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, 48000);
+    } else
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, 44100);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params)) {
+        oops(pcm, errno, "cannot set hw params");
+        goto fail;
+    }
+    param_dump(&params);
+
+    memset(&sparams, 0, sizeof(sparams));
+    sparams.tstamp_mode = SNDRV_PCM_TSTAMP_NONE;
+    sparams.period_step = 1;
+    sparams.avail_min = 1;
+    sparams.start_threshold = period_cnt * period_sz;
+    sparams.stop_threshold = period_cnt * period_sz;
+    sparams.xfer_align = period_sz / 2; /* needed for old kernels */
+    sparams.silence_size = 0;
+    sparams.silence_threshold = 0;
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SW_PARAMS, &sparams)) {
+        oops(pcm, errno, "cannot set sw params");
+        goto fail;
+    }
+
+    //Set prepare for device 1/2 of codec
+    if (device != 0 && card == 0) {
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE))
+            printf("pcm_open() cannot set prepare for card %d, device %d \n", card, device);
+    }
+
+    pcm->buffer_size = period_cnt * period_sz;
+    pcm->underruns = 0;
+    return pcm;
+
+fail:
+    close(pcm->fd);
+    pcm->fd = -1;
+    return pcm;
+}
+
+int pcm_ready(struct pcm *pcm)
+{
+    return pcm->fd >= 0;
+}
diff --git a/bootable/recovery/pcba_core/rk32_codec/alsa_route.c b/bootable/recovery/pcba_core/rk32_codec/alsa_route.c
new file mode 100644
index 0000000000..c4f407cb6a
--- /dev/null
+++ b/bootable/recovery/pcba_core/rk32_codec/alsa_route.c
@@ -0,0 +1,575 @@
+/*
+** open sound card and route, add by Jear.Chen.
+*/
+
+#define LOG_TAG "alsa_route"
+
+#define LOG_NDEBUG 0
+
+#include <cutils/log.h>
+#include <cutils/config_utils.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <math.h>
+
+#include <linux/ioctl.h>
+#include "alsa_audio.h"
+
+#define __force
+#define __bitwise
+#define __user
+#include "../asound.h"
+
+#include "../codec_config/config_list.h"
+
+#define PCM_DEVICE0_PLAYBACK 0
+#define PCM_DEVICE0_CAPTURE 1
+#define PCM_DEVICE1_PLAYBACK 2
+#define PCM_DEVICE1_CAPTURE 3
+#define PCM_DEVICE2_PLAYBACK 4
+#define PCM_DEVICE2_CAPTURE 5
+
+#define PCM_MAX PCM_DEVICE2_CAPTURE
+
+const struct config_route_table *route_table;
+
+struct pcm* mPcm[PCM_MAX + 1];
+struct mixer* mMixerPlayback;
+struct mixer* mMixerCapture;
+
+int route_init(void)
+{
+    char soundCardID[20] = "";
+    static FILE * fp;
+    unsigned i, config_count = sizeof(sound_card_config_list) / sizeof(struct alsa_sound_card_config);
+    size_t read_size;
+
+    printf("route_init()\n");
+    printf("################################!\n");
+    fp = fopen("/proc/asound/card0/id", "rt");
+    if (!fp) {
+        printf("Open sound card0 id error!\n");
+    } else {
+
+	printf("################################!\n");
+        read_size = fread(soundCardID, sizeof(char), sizeof(soundCardID), fp);
+        fclose(fp);
+
+        if (soundCardID[read_size - 1] == '\n') {
+            read_size--;
+            soundCardID[read_size] = '\0';
+        }
+
+        printf("Sound card0 is %s\n", soundCardID);
+
+        for (i = 0; i < config_count; i++) {
+            if (!(sound_card_config_list + i) || !sound_card_config_list[i].sound_card_name ||
+                !sound_card_config_list[i].route_table)
+                continue;
+
+		printf("SOUND_CARD_NAME:%s\n",sound_card_config_list[i].sound_card_name);
+            if (strncmp(sound_card_config_list[i].sound_card_name, soundCardID, 
+                read_size) == 0) {
+                route_table = sound_card_config_list[i].route_table;
+                printf("Get route table for sound card0 %s\n", soundCardID);
+            }
+        }
+    }
+
+    if (!route_table) {
+        route_table = &default_config_table;
+        ALOGD("Can not get config table for sound card0 %s, so get default config table.", soundCardID);
+    }
+
+    for (i = PCM_DEVICE0_PLAYBACK; i < PCM_MAX; i++)
+         mPcm[i] = NULL;
+
+    return 0;
+}
+
+void route_uninit(void)
+{
+    ALOGV("route_uninit()");
+
+    if (mPcm[PCM_DEVICE0_PLAYBACK]) {
+        route_pcm_close(PLAYBACK_OFF_ROUTE);
+    }
+
+    if (mPcm[PCM_DEVICE0_CAPTURE]) {
+        route_pcm_close(CAPTURE_OFF_ROUTE);
+    }
+}
+
+int is_playback_route(unsigned route)
+{
+    switch (route) {
+    case MAIN_MIC_CAPTURE_ROUTE:
+    case HANDS_FREE_MIC_CAPTURE_ROUTE:
+    case BLUETOOTH_SOC_MIC_CAPTURE_ROUTE:
+    case CAPTURE_OFF_ROUTE:
+    case USB_CAPTURE_ROUTE:
+        return 0;
+    case SPEAKER_NORMAL_ROUTE:
+    case SPEAKER_INCALL_ROUTE:
+    case SPEAKER_RINGTONE_ROUTE:
+    case SPEAKER_VOIP_ROUTE:
+    case EARPIECE_NORMAL_ROUTE:
+    case EARPIECE_INCALL_ROUTE:
+    case EARPIECE_RINGTONE_ROUTE:
+    case EARPIECE_VOIP_ROUTE:
+    case HEADPHONE_NORMAL_ROUTE:
+    case HEADPHONE_INCALL_ROUTE:
+    case HEADPHONE_RINGTONE_ROUTE:
+    case SPEAKER_HEADPHONE_NORMAL_ROUTE:
+    case SPEAKER_HEADPHONE_RINGTONE_ROUTE:
+    case HEADPHONE_VOIP_ROUTE:
+    case HEADSET_NORMAL_ROUTE:
+    case HEADSET_INCALL_ROUTE:
+    case HEADSET_RINGTONE_ROUTE:
+    case HEADSET_VOIP_ROUTE:
+    case BLUETOOTH_NORMAL_ROUTE:
+    case BLUETOOTH_INCALL_ROUTE:
+    case BLUETOOTH_VOIP_ROUTE:
+    case PLAYBACK_OFF_ROUTE:
+    case INCALL_OFF_ROUTE:
+    case VOIP_OFF_ROUTE:
+    case HDMI_NORMAL_ROUTE:
+    case USB_NORMAL_ROUTE:
+        return 1;
+    default:
+        ALOGE("is_playback_route() Error route %d", route);
+        return -EINVAL;
+    }
+}
+
+int route_set_input_source(const char *source)
+{
+    struct mixer* mMixer = mMixerCapture;
+
+    if (mMixer == NULL || source[0] == '\0') return 0;
+
+    struct mixer_ctl *ctl= mixer_get_control(mMixer, "Input Source", 0);
+
+    if (ctl == NULL)
+        return 0;
+
+    ALOGV("mixer_ctl_select, Input Source, (%s)", source);
+    return mixer_ctl_select(ctl, source);
+}
+
+int route_set_voice_volume(const char *ctlName, float volume)
+{
+    struct mixer* mMixer = mMixerPlayback;
+
+    if (mMixer == NULL || ctlName[0] == '\0')
+        return 0;
+
+    struct mixer_ctl *ctl = mixer_get_control(mMixer, ctlName, 0);
+    if (ctl == NULL)
+        return 0;
+
+    long long vol, vol_min, vol_max;
+    unsigned int Nmax = 6, N = volume * 5 + 1;
+    float e = 2.71828, dB_min, dB_max, dB_vol, dB_step, volFloat;
+
+    ALOGD("route_set_voice_volume() set incall voice volume %f to control %s", volume, ctlName);
+
+    if (mixer_get_ctl_minmax(ctl, &vol_min, &vol_max) < 0) {
+        ALOGE("mixer_get_dB_range() get control min max value fail");
+        return 0;
+    }
+
+    mixer_get_dB_range(ctl, (long)vol_min, (long)vol_max, &dB_min, &dB_max, &dB_step);
+
+    dB_vol = 20 * log((Nmax * pow(e, dB_min / 20) + N * (pow(e, dB_max / 20) - pow(e, dB_min / 20))) / Nmax);
+
+    volFloat = vol_min + (dB_vol - dB_min) / dB_step;
+    vol = (long long)volFloat;
+
+    if (((unsigned)(volFloat * 10) % 10) >= 5)
+        vol++;
+
+    ALOGV("dB_min = %f, dB_step = %f, dB_max = %f, dB_vol = %f",
+        dB_min,
+        dB_step,
+        dB_max,
+        dB_vol);
+
+    ALOGV("N = %u, volFloat = %f, vol = %lld", N, volFloat, vol);
+
+    return mixer_ctl_set_int(ctl, vol);
+}
+
+const struct config_route *get_route_config(unsigned route)
+{
+    ALOGV("get_route_config() route %d", route);
+
+    if (!route_table) {
+        ALOGE("get_route_config() route_table is NULL!");
+        return NULL;
+    }
+    switch (route) {
+    case SPEAKER_NORMAL_ROUTE:
+        return &(route_table->speaker_normal);
+    case SPEAKER_INCALL_ROUTE:
+        return &(route_table->speaker_incall);
+    case SPEAKER_RINGTONE_ROUTE:
+        return &(route_table->speaker_ringtone);
+    case SPEAKER_VOIP_ROUTE:
+        return &(route_table->speaker_voip);
+    case EARPIECE_NORMAL_ROUTE:
+        return &(route_table->earpiece_normal);
+    case EARPIECE_INCALL_ROUTE:
+        return &(route_table->earpiece_incall);
+    case EARPIECE_RINGTONE_ROUTE:
+        return &(route_table->earpiece_ringtone);
+    case EARPIECE_VOIP_ROUTE:
+        return &(route_table->earpiece_voip);
+    case HEADPHONE_NORMAL_ROUTE:
+        return &(route_table->headphone_normal);
+    case HEADPHONE_INCALL_ROUTE:
+        return &(route_table->headphone_incall);
+    case HEADPHONE_RINGTONE_ROUTE:
+        return &(route_table->headphone_ringtone);
+    case SPEAKER_HEADPHONE_NORMAL_ROUTE:
+        return &(route_table->speaker_headphone_normal);
+    case SPEAKER_HEADPHONE_RINGTONE_ROUTE:
+        return &(route_table->speaker_headphone_ringtone);
+    case HEADPHONE_VOIP_ROUTE:
+        return &(route_table->headphone_voip);
+    case HEADSET_NORMAL_ROUTE:
+        return &(route_table->headset_normal);
+    case HEADSET_INCALL_ROUTE:
+        return &(route_table->headset_incall);
+    case HEADSET_RINGTONE_ROUTE:
+        return &(route_table->headset_ringtone);
+    case HEADSET_VOIP_ROUTE:
+        return &(route_table->headset_voip);
+    case BLUETOOTH_NORMAL_ROUTE:
+        return &(route_table->bluetooth_normal);
+    case BLUETOOTH_INCALL_ROUTE:
+        return &(route_table->bluetooth_incall);
+    case BLUETOOTH_VOIP_ROUTE:
+        return &(route_table->bluetooth_voip);
+    case MAIN_MIC_CAPTURE_ROUTE:
+        return &(route_table->main_mic_capture);
+    case HANDS_FREE_MIC_CAPTURE_ROUTE:
+        return &(route_table->hands_free_mic_capture);
+    case BLUETOOTH_SOC_MIC_CAPTURE_ROUTE:
+        return &(route_table->bluetooth_sco_mic_capture);
+    case PLAYBACK_OFF_ROUTE:
+        return &(route_table->playback_off);
+    case CAPTURE_OFF_ROUTE:
+        return &(route_table->capture_off);
+    case INCALL_OFF_ROUTE:
+        return &(route_table->incall_off);
+    case VOIP_OFF_ROUTE:
+        return &(route_table->voip_off);
+    case HDMI_NORMAL_ROUTE:
+        return &(route_table->hdmi_normal);
+    case USB_NORMAL_ROUTE:
+        return &(route_table->usb_normal);
+    case USB_CAPTURE_ROUTE:
+        return &(route_table->usb_capture);
+    default:
+        ALOGE("get_route_config() Error route %d", route);
+        return NULL;
+    }
+}
+
+int set_controls(struct mixer *mixer, const struct config_control *ctls, const unsigned ctls_count)
+{
+    struct mixer_ctl *ctl;
+    unsigned i;
+
+    ALOGV("set_controls() ctls_count %d", ctls_count);
+
+    if (!ctls || ctls_count <= 0) {
+        ALOGV("set_controls() ctls is NULL");
+        return 0;
+    }
+
+    for (i = 0; i < ctls_count; i++) {
+        ctl = mixer_get_control(mixer, ctls[i].ctl_name, 0);
+        ALOGE("========ctls[%d].ctl_name:%s=========",i,ctls[i].ctl_name);
+        if (!ctl) {
+            ALOGE_IF(route_table != &default_config_table, "set_controls() Can not get ctl : %s", ctls[i].ctl_name);
+            ALOGV_IF(route_table == &default_config_table, "set_controls() Can not get ctl : %s", ctls[i].ctl_name);
+            return -EINVAL;
+        }
+
+        if (ctl->info->type != SNDRV_CTL_ELEM_TYPE_BOOLEAN &&
+            ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER &&
+            ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER64 &&
+            ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+            ALOGE("set_controls() ctl %s is not a type of INT or ENUMERATED", ctls[i].ctl_name);
+            return -EINVAL;
+        }
+
+        if (ctls[i].str_val) {
+            if (ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+                ALOGE("set_controls() ctl %s is not a type of ENUMERATED", ctls[i].ctl_name);
+                return -EINVAL;
+            }
+            if (mixer_ctl_select(ctl, ctls[i].str_val) != 0) {
+                ALOGE("set_controls() Can not set ctl %s to %s", ctls[i].ctl_name, ctls[i].str_val);
+                return -EINVAL;
+            }
+            ALOGE("set_controls() set ctl %s to %s", ctls[i].ctl_name, ctls[i].str_val);
+        } else {
+            if (mixer_ctl_set_int_double(ctl, ctls[i].int_val[0], ctls[i].int_val[1]) != 0) {
+                ALOGE("set_controls() can not set ctl %s to %d", ctls[i].ctl_name, ctls[i].int_val[0]);
+                return -EINVAL;
+            }
+            ALOGE("set_controls() set ctl %s to %d", ctls[i].ctl_name, ctls[i].int_val[0]);
+        }
+    }
+
+    return 0;
+}
+
+int route_set_controls(unsigned route)
+{
+    struct mixer* mMixer;
+
+    if (route >= MAX_ROUTE) {
+        ALOGE("route_set_controls() route %d error!", route);
+        return -EINVAL;
+    }
+
+#ifdef SUPPORT_USB //usb input maybe used for primary
+    if (route != USB_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != MAIN_MIC_CAPTURE_ROUTE &&
+        route != HANDS_FREE_MIC_CAPTURE_ROUTE &&
+        route != BLUETOOTH_SOC_MIC_CAPTURE_ROUTE) {
+        ALOGV("route %d error for usb sound card!", route);
+        return -EINVAL;
+    }
+#else //primary input maybe used for usb
+    if (route > HDMI_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE) {
+        ALOGV("route %d error for codec or hdmi!", route);
+        return -EINVAL;
+    }
+#endif
+
+    ALOGD("route_set_controls() set route %d", route);
+
+    mMixer = is_playback_route(route) ? mMixerPlayback : mMixerCapture;
+
+    if (!mMixer) {
+        ALOGE("route_set_controls() mMixer is NULL!");
+        return -EINVAL;
+    }
+
+    const struct config_route *route_info = get_route_config(route);
+    if (!route_info) {
+        ALOGE("route_set_controls() Can not get config of route");
+        return -EINVAL;
+    }
+
+    if (route_info->controls_count > 0)
+        set_controls(mMixer, route_info->controls, route_info->controls_count);
+
+    return 0;
+}
+
+struct pcm *route_pcm_open(unsigned route, unsigned int flags)
+{
+    int is_playback;
+
+    if (route >= MAX_ROUTE) {
+        ALOGE("route_pcm_open() route %d error!", route);
+        return NULL;
+    }
+
+#ifdef SUPPORT_USB //usb input maybe used for primary
+    if (route != USB_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != MAIN_MIC_CAPTURE_ROUTE &&
+        route != HANDS_FREE_MIC_CAPTURE_ROUTE &&
+        route != BLUETOOTH_SOC_MIC_CAPTURE_ROUTE) {
+        ALOGV("route %d error for usb sound card!", route);
+        return NULL;
+    }
+#else //primary input maybe used for usb
+    if (route > BLUETOOTH_SOC_MIC_CAPTURE_ROUTE &&
+        route != HDMI_NORMAL_ROUTE &&
+        route != USB_CAPTURE_ROUTE) {
+        ALOGV("route %d error for codec or hdmi!", route);
+        return NULL;
+    }
+#endif
+
+    ALOGV("route_pcm_open() route %d", route);
+
+    is_playback = is_playback_route(route);
+
+	if (route_table) {
+		ALOGD("route_table:%s",route_table->speaker_normal.controls->ctl_name);
+	}
+
+    if (!route_table) {
+        route_init();
+    }
+
+    const struct config_route *route_info = get_route_config(route);
+    if (!route_info) {
+        ALOGE("route_pcm_open() Can not get config of route");
+        return NULL;
+    }
+
+    ALOGD("route_info->sound_card %d, route_info->devices 0 %s %s",
+        route_info->sound_card,
+        (route_info->devices == DEVICES_0_1 || route_info->devices == DEVICES_0_2 ||
+        route_info->devices == DEVICES_0_1_2) ? (route_info->devices == DEVICES_0_2 ? "2" : "1") : "",
+        route_info->devices == DEVICES_0_1_2 ? "2" : "");
+
+    flags &= ~PCM_CARD_MASK;
+    switch(route_info->sound_card) {
+    case 1:
+        flags |= PCM_CARD1;
+        break;
+    case 2:
+        flags |= PCM_CARD2;
+        break;
+    default:
+        flags |= PCM_CARD0;
+        break;
+    }
+
+    flags &= ~PCM_DEVICE_MASK;
+    flags |= PCM_DEVICE0;
+
+    if (is_playback) {
+        //close all route and pcm
+        if (mMixerPlayback) {
+            route_set_controls(INCALL_OFF_ROUTE);
+            route_set_controls(VOIP_OFF_ROUTE);
+        }
+        route_pcm_close(PLAYBACK_OFF_ROUTE);
+
+        mPcm[PCM_DEVICE0_PLAYBACK] = pcm_open(flags);
+
+        //Open playback and capture of device 1
+        if (((flags & PCM_CARD_MASK) == PCM_CARD0) &&
+            (route_info->devices == DEVICES_0_1 ||
+            route_info->devices == DEVICES_0_1_2)) {
+            unsigned int open_flags = flags;
+
+            open_flags &= ~PCM_DEVICE_MASK;
+            open_flags |= PCM_DEVICE1;
+
+            if (mPcm[PCM_DEVICE1_PLAYBACK] == NULL)
+                mPcm[PCM_DEVICE1_PLAYBACK] = pcm_open(open_flags);
+
+            open_flags |= PCM_IN;
+
+            if (mPcm[PCM_DEVICE1_CAPTURE] == NULL)
+                mPcm[PCM_DEVICE1_CAPTURE] = pcm_open(open_flags);
+        }
+
+        //Open playback and capture of device 2
+        if (((flags & PCM_CARD_MASK) == PCM_CARD0) &&
+            (route_info->devices == DEVICES_0_2 ||
+            route_info->devices == DEVICES_0_1_2)) {
+            unsigned int open_flags = flags;
+
+            open_flags &= ~PCM_DEVICE_MASK;
+            open_flags |= PCM_DEVICE2;
+
+            if (mPcm[PCM_DEVICE2_PLAYBACK] == NULL)
+                mPcm[PCM_DEVICE2_PLAYBACK] = pcm_open(open_flags);
+
+            open_flags |= PCM_IN;
+
+            if (mPcm[PCM_DEVICE2_CAPTURE] == NULL)
+                mPcm[PCM_DEVICE2_CAPTURE] = pcm_open(open_flags);
+        }
+    } else {
+        route_pcm_close(CAPTURE_OFF_ROUTE);
+
+        if (mPcm[PCM_DEVICE0_CAPTURE] == NULL)
+            mPcm[PCM_DEVICE0_CAPTURE] = pcm_open(flags);
+    }
+
+    //update mMixer
+    if (is_playback) {
+        if (mMixerPlayback == NULL)
+            mMixerPlayback = mixer_open(route_info->sound_card == 1 ? 0 : route_info->sound_card);
+    } else {
+        if (mMixerCapture == NULL)
+            mMixerCapture = mixer_open(route_info->sound_card == 1 ? 0 : route_info->sound_card);
+    }
+
+    //set controls
+    if (route_info->controls_count > 0)
+        route_set_controls(route);
+
+    return is_playback ? mPcm[PCM_DEVICE0_PLAYBACK] : mPcm[PCM_DEVICE0_CAPTURE];
+}
+
+int route_pcm_close(unsigned route)
+{
+    unsigned i;
+
+    if (route != PLAYBACK_OFF_ROUTE &&
+        route != CAPTURE_OFF_ROUTE &&
+        route != INCALL_OFF_ROUTE &&
+        route != VOIP_OFF_ROUTE) {
+        ALOGE("route_pcm_close() is not a off route");
+        return 0;
+    }
+
+    ALOGV("route_pcm_close() route %d", route);
+
+    //close pcm
+    if (route == PLAYBACK_OFF_ROUTE) {
+        if (mPcm[PCM_DEVICE0_PLAYBACK]) {
+            pcm_close(mPcm[PCM_DEVICE0_PLAYBACK]);
+            mPcm[PCM_DEVICE0_PLAYBACK] = NULL;
+        }
+
+        //close playback, we need to close device 1 and device 2
+        for (i = PCM_DEVICE1_PLAYBACK; i < PCM_MAX; i++) {
+            if (mPcm[i]) {
+                pcm_close(mPcm[i]);
+                mPcm[i] = NULL;
+            }
+        }
+    } else if (route == CAPTURE_OFF_ROUTE) {
+        if (mPcm[PCM_DEVICE0_CAPTURE]) {
+            pcm_close(mPcm[PCM_DEVICE0_CAPTURE]);
+            mPcm[PCM_DEVICE0_CAPTURE] = NULL;
+        }
+    }
+
+    //set controls
+    if (is_playback_route(route) ? mMixerPlayback : mMixerCapture)
+        route_set_controls(route);
+
+    //close mixer
+    if (route == PLAYBACK_OFF_ROUTE) {
+        if (mMixerPlayback) {
+            mixer_close(mMixerPlayback);
+            mMixerPlayback = NULL;
+        }
+    } else if (route == CAPTURE_OFF_ROUTE) {
+        if (mMixerCapture) {
+            mixer_close(mMixerCapture);
+            mMixerCapture = NULL;
+        }
+    }
+
+    return 0;
+}
+
diff --git a/bootable/recovery/pcba_core/rk32_codec/codec_test.c b/bootable/recovery/pcba_core/rk32_codec/codec_test.c
new file mode 100644
index 0000000000..110632d2b2
--- /dev/null
+++ b/bootable/recovery/pcba_core/rk32_codec/codec_test.c
@@ -0,0 +1,433 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <poll.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <pthread.h>
+#include <sys/types.h>
+
+#include "codec_test.h"
+#include "../test_case.h"
+#include "alsa_audio.h"
+#include "../Language/language.h"
+#include "../common.h"
+#include "../extra-functions.h"
+
+#define AUDIO_HW_OUT_PERIOD_MULT 8 // (8 * 128 = 1024 frames)
+#define AUDIO_HW_OUT_PERIOD_CNT 4
+#define FILE_PATH "/res/codectest.pcm"
+#define REC_DUR 3 //the unit is second
+#define RECORD_FILE_PATH "/res/record.pcm"
+static FILE * alsa_in_fp = NULL;
+
+
+pthread_t rec_disp_tid;  
+int codec_err = -1;
+extern pid_t g_codec_pid;
+
+static int maxRecPcm = 0;
+static int maxRecPcmPeriod = 0;
+static int nTime = 0;
+static struct testcase_info  *tc_info = NULL;
+static void calcAndDispRecAudioStrenth(short *pcm, int len)
+{	
+	short i, data;
+	
+	// calc mac rec value
+	for(i = 0; i < len/2; i++) {
+		data = abs(*pcm++);
+		if(maxRecPcmPeriod < data) {
+			maxRecPcmPeriod = data;
+		}
+	}
+	
+	//printf("---- maxRecPcmPeriod = %d\n", maxRecPcmPeriod);
+	if(nTime++ >= 10) {
+		nTime = 0;
+		maxRecPcm = maxRecPcmPeriod;
+		maxRecPcmPeriod = 0;
+	}
+}
+
+
+
+
+// ¼߷ģʽ,ʹöʱѡģʽ
+void* rec_play_test_1(void *argv)
+{		
+	struct pcm* pcmIn;
+	struct pcm* pcmOut;
+	unsigned bufsize;
+	char *data;
+	FILE *fp = NULL;
+	char recData[4*REC_DUR*44100];	
+	unsigned inFlags = PCM_IN;
+	unsigned outFlags = PCM_OUT;
+	unsigned flags =  PCM_STEREO;
+
+	struct mixer*   mMixer = NULL;
+	struct mixer_ctl* mRouteCtl = NULL;
+	char mString[10] = "";
+	static FILE * HWFile;
+	int headsetState = 0;
+	unsigned isNeedChangeRate = 0;
+
+	char *recdata = NULL;
+	int xy = 0;
+	//printf("<xiaoyao>\n");
+
+	route_init();
+
+	//read HP state
+	HWFile = fopen("/sys/class/switch/h2w/state", "rt");
+	if (!HWFile) {
+		fprintf(stderr, "Open headset state error!\n");
+	} else {
+		fread(mString, sizeof(char), sizeof(mString), HWFile);
+		fclose(HWFile);
+		headsetState = mString[0] - '0';
+		fprintf(stderr, "headsetState %d\n", headsetState);
+	}
+	printf("headsetState:%d.\n",headsetState);
+	
+	//read HDMI state
+	HWFile = fopen("/sys/class/switch/hdmi/state", "rt");
+	if (!HWFile) {
+		fprintf(stderr, "Open hdmi state error!\n");
+	} else {
+		fread(mString, sizeof(char), sizeof(mString), HWFile);
+		fclose(HWFile);
+		if (mString[0] - '0' == 1) {
+			fprintf(stderr, "HDMI is in\n");
+			if (isNeedChangeRate)
+				inFlags = (~PCM_RATE_MASK & inFlags) | PCM_8000HZ;
+			outFlags = (~PCM_CARD_MASK & outFlags) | PCM_CARD1;
+		} else {
+			fprintf(stderr, "HDMI is out\n");
+			if (isNeedChangeRate)
+				inFlags = (~PCM_RATE_MASK & inFlags) | PCM_44100HZ;
+			outFlags = (~PCM_CARD_MASK & outFlags) | PCM_CARD0;
+		}
+	}
+
+	flags |= (AUDIO_HW_OUT_PERIOD_MULT - 1) << PCM_PERIOD_SZ_SHIFT;
+	flags |= (AUDIO_HW_OUT_PERIOD_CNT - PCM_PERIOD_CNT_MIN)<< PCM_PERIOD_CNT_SHIFT;
+
+	inFlags |= flags;
+	outFlags |= flags;
+
+
+	//0x10027000  0x1003f000
+	inFlags = 0x1003f000;
+	pcmIn = pcm_open(inFlags);
+	if (!pcm_ready(pcmIn)) {
+	pcm_close(pcmIn);
+	goto fail;
+	}
+
+	//0x00027000  0x0001f000
+	outFlags = 0x0001f000;	
+	pcmOut = pcm_open(outFlags);
+	if (!pcm_ready(pcmOut)) {
+	pcm_close(pcmOut);
+	goto fail;
+	}
+
+	//open route
+    if (mMixerPlayback == NULL)
+        mMixerPlayback = mixer_open(0);
+
+    if (mMixerCapture == NULL)
+        mMixerCapture = mixer_open(0);
+
+ 	route_set_controls(HEADSET_NORMAL_ROUTE);
+	fp = fopen(FILE_PATH,"rb");
+	if(NULL == fp)
+	{
+		fprintf(stderr,"could not open %s file, will go to fail\n", FILE_PATH);
+		goto fail;
+	}
+
+	bufsize = pcm_buffer_size(pcmOut);
+	usleep(10000);
+	fseek(fp,0,SEEK_SET);
+	
+	while(bufsize == fread(recData,1,bufsize,fp)){
+		if (pcm_write(pcmOut, recData, bufsize)) {
+			fprintf(stderr,"the pcmOut could not write %d bytes file data,will go to fail\n", bufsize);
+			goto fail;
+		}
+	}
+
+	bufsize = pcm_buffer_size(pcmIn);
+	data = malloc(bufsize);
+	if (!data) {
+		fprintf(stderr,"could not allocate %d bytes\n", bufsize);
+		return 0;
+	}
+
+	//route_set_controls(MAIN_MIC_CAPTURE_ROUTE);
+	route_set_controls(HANDS_FREE_MIC_CAPTURE_ROUTE);
+	printf("###############################################\n");
+	while (!pcm_read(pcmIn, data, bufsize)) {
+
+		route_set_controls(HEADSET_NORMAL_ROUTE);
+		calcAndDispRecAudioStrenth(data, bufsize);
+		if (pcm_write(pcmOut, data, bufsize)) {
+			fprintf(stderr,"could not write %d bytes\n", bufsize);
+		        free(data);
+			return 0;
+		}
+		
+	}
+	fail:
+	//close route
+	if (mMixer) {
+		mRouteCtl = mixer_get_control(mMixer, "Playback Path", 0);
+		if (mRouteCtl) {
+			mixer_ctl_select(mRouteCtl, "OFF");
+		}
+
+		mRouteCtl = mixer_get_control(mMixer, "Capture MIC Path", 0);
+		if (mRouteCtl) {
+			mixer_ctl_select(mRouteCtl, "MIC OFF");
+		}
+	}
+	mixer_close(mMixer);
+	mMixer = NULL;
+	pcm_close(pcmIn);
+	pcm_close(pcmOut);
+	return 0;
+}
+
+
+
+// ¼߷ģʽ,ʹʱѡģʽ
+void* rec_play_test_2(void *argv)
+{		
+	struct pcm* pcmIn;
+	struct pcm* pcmOut;
+	unsigned bufsize;
+	char *data;
+	FILE *fp = NULL;
+	FILE *outfp = NULL;
+	char recData[4*REC_DUR*44100];	
+	unsigned inFlags = PCM_IN;
+	unsigned outFlags = PCM_OUT;
+	unsigned flags =  PCM_STEREO;
+
+	struct mixer*   mMixer = NULL;
+	struct mixer_ctl* mRouteCtl = NULL;
+	char mString[10] = "";
+	static FILE * HWFile;
+	int headsetState = 0;
+	unsigned isNeedChangeRate = 0;
+	static int count = 500;
+
+	char *recdata = NULL;
+	int xy = 0;
+	
+	//printf("<xiaoyao>\n");
+
+	route_init();
+
+	//read HP state
+	HWFile = fopen("/sys/class/switch/h2w/state", "rt");
+	if (!HWFile) {
+		fprintf(stderr, "Open headset state error!\n");
+	} else {
+		fread(mString, sizeof(char), sizeof(mString), HWFile);
+		fclose(HWFile);
+		headsetState = mString[0] - '0';
+		fprintf(stderr, "headsetState %d\n", headsetState);
+	}
+	printf("headsetState:%d.\n",headsetState);
+	
+	//read HDMI state
+	HWFile = fopen("/sys/class/switch/hdmi/state", "rt");
+	if (!HWFile) {
+		fprintf(stderr, "Open hdmi state error!\n");
+	} else {
+		fread(mString, sizeof(char), sizeof(mString), HWFile);
+		fclose(HWFile);
+		if (mString[0] - '0' == 1) {
+			fprintf(stderr, "HDMI is in\n");
+			if (isNeedChangeRate)
+				inFlags = (~PCM_RATE_MASK & inFlags) | PCM_8000HZ;
+			outFlags = (~PCM_CARD_MASK & outFlags) | PCM_CARD1;
+		} else {
+			fprintf(stderr, "HDMI is out\n");
+			if (isNeedChangeRate)
+				inFlags = (~PCM_RATE_MASK & inFlags) | PCM_44100HZ;
+			outFlags = (~PCM_CARD_MASK & outFlags) | PCM_CARD0;
+		}
+	}
+
+	flags |= (AUDIO_HW_OUT_PERIOD_MULT - 1) << PCM_PERIOD_SZ_SHIFT;
+	flags |= (AUDIO_HW_OUT_PERIOD_CNT - PCM_PERIOD_CNT_MIN)<< PCM_PERIOD_CNT_SHIFT;
+
+	inFlags |= flags;
+	outFlags |= flags;
+
+
+	//0x10027000  0x1003f000
+	inFlags = 0x1003f000;
+	pcmIn = pcm_open(inFlags);
+	if (!pcm_ready(pcmIn)) {
+	pcm_close(pcmIn);
+	goto fail;
+	}
+
+	//0x00027000  0x0001f000
+	outFlags = 0x0001f000;	
+	pcmOut = pcm_open(outFlags);
+	if (!pcm_ready(pcmOut)) {
+	pcm_close(pcmOut);
+	goto fail;
+	}
+
+	//open route
+    if (mMixerPlayback == NULL)
+        mMixerPlayback = mixer_open(0);
+
+    if (mMixerCapture == NULL)
+        mMixerCapture = mixer_open(0);
+
+	route_set_controls(SPEAKER_NORMAL_ROUTE);
+	route_set_controls(MAIN_MIC_CAPTURE_ROUTE);
+#if 1
+	fp = fopen(FILE_PATH,"rb");
+	if(NULL == fp)
+	{
+		fprintf(stderr,"could not open %s file, will go to fail\n", FILE_PATH);
+		goto fail;
+	}
+
+	bufsize = pcm_buffer_size(pcmOut);
+	usleep(10000);
+	fseek(fp,0,SEEK_SET);
+	
+	while(bufsize == fread(recData,1,bufsize,fp)){
+		if (pcm_write(pcmOut, recData, bufsize)) {
+			fprintf(stderr,"the pcmOut could not write %d bytes file data,will go to fail\n", bufsize);
+			goto fail;
+		}
+	}
+#endif
+	bufsize = pcm_buffer_size(pcmIn);
+	data = malloc(bufsize);
+	if (!data) {
+		fprintf(stderr,"could not allocate %d bytes\n", bufsize);
+		return 0;
+	}
+	alsa_in_fp = fopen(RECORD_FILE_PATH,"wrb");
+	if(NULL == alsa_in_fp)
+	{
+		fprintf(stderr,"could not open %s file, will go to fail\n", RECORD_FILE_PATH);
+		goto fail;
+	}
+	while (!pcm_read(pcmIn, data, bufsize) && count > 0) {	
+			calcAndDispRecAudioStrenth(data, bufsize);
+			fwrite(data,1,bufsize,alsa_in_fp);
+			count--;
+			fprintf(stderr,"read data\n");
+
+	}
+	fprintf(stderr,"read data ok\n");
+	fclose(alsa_in_fp);
+	
+	usleep(100000);
+	outfp = fopen(RECORD_FILE_PATH,"rb");
+	if(NULL == outfp)
+	{
+		fprintf(stderr,"could not open %s file, will go to fail\n", RECORD_FILE_PATH);
+		goto fail;
+	}
+
+	int freadsize = fread(data, 1, bufsize, outfp);
+	fprintf(stderr,"freadsize = %d; bufsize = %d\n", freadsize, bufsize);
+
+	while(bufsize == fread(data,1,bufsize,outfp)){
+		fprintf(stderr,"write data\n");
+			if (pcm_write(pcmOut, data, bufsize)) {
+					fprintf(stderr,"the pcmOut could not write %d bytes file data,will go to fail\n", bufsize);
+					free(data);
+
+			}
+	}
+	return 0;		
+	//}
+	fail:
+	//close route
+	if (mMixer) {
+		mRouteCtl = mixer_get_control(mMixer, "Playback Path", 0);
+		if (mRouteCtl) {
+			mixer_ctl_select(mRouteCtl, "OFF");
+		}
+
+		mRouteCtl = mixer_get_control(mMixer, "Capture MIC Path", 0);
+		if (mRouteCtl) {
+			mixer_ctl_select(mRouteCtl, "MIC OFF");
+		}
+	}
+	mixer_close(mMixer);
+	mMixer = NULL;
+	pcm_close(pcmIn);
+	pcm_close(pcmOut);
+	return 0;
+}
+
+void rec_volum_display(void)
+{
+	int volume;
+	int y_offset = tc_info->y;
+	
+	printf("enter rec_volum_display thread.\n");
+	while(1) {
+		usleep(300000);
+		volume = 20 + ((maxRecPcm*100)/32768);
+		if(volume > 100) volume = 100;
+		//ui_print_xy_rgba(0,y_offset,0,255,0,255,"%s:[%s:%d%%]\n",PCBA_RECORD,PCBA_VOLUME,volume);
+		ui_display_sync(0,y_offset,0,255,0,255,"%s:[%s:%d%%]\n",PCBA_RECORD,PCBA_VOLUME,volume);
+		//printf("---- display maxRecPcm = %d\n", maxRecPcm);
+	}
+}
+
+void* codec_test(void *argv)
+{
+    int ret = -1;
+    char dt[32] = {0};
+
+	tc_info = (struct testcase_info *)argv;
+			
+	if(tc_info->y <= 0)
+		tc_info->y  = get_cur_print_y();	
+
+	ui_print_xy_rgba(0,tc_info->y,255,255,0,255,"%s \n",PCBA_RECORD);
+	sleep(3);    
+	
+	if(script_fetch("Codec", "program", (int *)dt, 8) == 0) {
+		printf("script_fetch program = %s.\n", dt);
+	}	
+	
+	codec_err = pthread_create(&rec_disp_tid, NULL, rec_volum_display,NULL); //
+	if(codec_err != 0)
+	{  
+	   printf("create rec_volum_display thread error: %s/n",strerror(codec_err));  
+	} 
+
+	{
+	    printf ("\r\nBEGIN CODEC TEST ---------------- \r\n");
+	    if(strcmp(dt, "case2") == 0) {
+	    	rec_play_test_2(NULL);
+		} else {
+			rec_play_test_1(NULL);
+		}
+	    printf ("\r\nEND CODEC TEST\r\n");
+	}
+	//printf("pcba-test codec pid %d\n",g_codec_pid);
+	
+    return NULL;
+}
diff --git a/bootable/recovery/pcba_core/rk32_codec/codec_test.h b/bootable/recovery/pcba_core/rk32_codec/codec_test.h
new file mode 100644
index 0000000000..d173840281
--- /dev/null
+++ b/bootable/recovery/pcba_core/rk32_codec/codec_test.h
@@ -0,0 +1,4 @@
+#ifndef __CODEC_TEST_H_
+#define __CODEC_TEST_H_
+void * codec_test(void *argc);
+#endif
diff --git a/bootable/recovery/pcba_core/rkfactory_test.cpp b/bootable/recovery/pcba_core/rkfactory_test.cpp
new file mode 100644
index 0000000000..8d10132fe6
--- /dev/null
+++ b/bootable/recovery/pcba_core/rkfactory_test.cpp
@@ -0,0 +1,389 @@
+#include "rkfactory_test.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+#include <android-base/logging.h>
+#include <android-base/properties.h>
+#include <bootloader_message/bootloader_message.h>
+
+#include "recovery_ui/ui.h"
+#include "debug.h"
+#include "Language/language.h"
+
+#include "wlan_test.h"
+#include "rtc_test.h"
+#include "display_callback.h"
+#include "gsensor_test.h"
+#include "bt_test.h"
+#include "udisk_test.h"
+#include "sdcard_test.h"
+#include "battery_test.h"
+#include "audiodev_test/codec_test.h"
+#include "rkhal3_camera/camera_test.h"
+#include "ddr_emmc_test.h"
+
+extern "C" {
+    #include "script.h"
+    #include "test_case.h"
+    #include "script_parser.h"
+}
+
+static const std::vector<std::pair<std::string, Device::BuiltinAction>> rkFactoryMenuActions{
+    { "Power off", Device::SHUTDOWN },
+    { "Reboot system now", Device::REBOOT },
+    { "Enter recovery", Device::ENTER_RECOVERY },
+    { "Reboot to bootloader", Device::REBOOT_BOOTLOADER },
+};
+
+RKFactory::RKFactory(){
+    bRKFactory = true;
+}
+bool RKFactory::isRKFactory(){
+    return bRKFactory;
+}
+
+int manual_p_y = 1;
+/* current position for auto test tiem in y direction */
+
+int simCounts = 2;
+
+#define SCRIPT_NAME    "/pcba/test_config.cfg"
+
+RecoveryUI* pcba_ui;
+std::vector<std::string> pcba_title_lines;
+std::vector<RecoveryUI::TestResultEnum> pcba_result_lines;
+
+void init_title_lines_for_testcase(const char *test_name, struct testcase_info *tc_info) {
+    std::string *msg = new std::string();
+    msg->append("Device ").append(test_name).append(":[...] {...}");
+    pcba_title_lines.push_back(*msg);
+    pcba_result_lines.push_back(RecoveryUI::TestResultEnum::TESTING);
+    // save index
+    tc_info->y = pcba_title_lines.size() - 1;
+}
+
+void refresh_screen_hl_hook(int index, std::string msg, bool highlight) {
+    if (highlight) {
+        // Test failed
+        pcba_result_lines[index] = RecoveryUI::TestResultEnum::FAILED;
+    } else {
+        // Test passed
+        pcba_result_lines[index] = RecoveryUI::TestResultEnum::PASS;
+    }
+    pcba_title_lines[index] = msg;
+    pcba_ui->ResetKeyInterruptStatus();
+    pcba_ui->SetTitle(pcba_title_lines);
+    pcba_ui->SetTitleResult(pcba_result_lines);
+    pcba_ui->ShowText(true);
+}
+
+void refresh_screen_hook(int index, std::string msg) {
+    pcba_title_lines[index] = msg;
+    pcba_ui->ResetKeyInterruptStatus();
+    pcba_ui->SetTitle(pcba_title_lines);
+    pcba_ui->SetTitleResult(pcba_result_lines);
+    pcba_ui->ShowText(true);
+}
+
+display_callback *display_hook = new display_callback {
+    .handle_refresh_screen_hl = refresh_screen_hl_hook,
+    .handle_refresh_screen = refresh_screen_hook,
+};
+
+display_callback *get_display_hook() {
+    return display_hook;
+}
+
+static int total_testcases;
+//static struct testcase_base_info *base_info;
+static struct list_head auto_test_list_head;
+static struct list_head manual_test_list_head;
+
+int start_test_pthread(struct testcase_info *tc_info)
+{
+    printf("%s\n", tc_info->base_info->name);
+    if (!strcmp(tc_info->base_info->name, "ddr")) {
+        // emmc test
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&ddr_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "emmc")) {
+        // flash_test
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&flash_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "wifi")) {
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&wlan_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "rtc")) {
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&rtc_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "gsensor")) {
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&gsensor_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "bluetooth")) {
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&bt_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "udisk")) {
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&udisk_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "sdcard")) {
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&sdcard_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "battery")) {
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&battery_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "camera")) {
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&camera_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else if (!strcmp(tc_info->base_info->name, "Codec")) {
+        init_title_lines_for_testcase(tc_info->base_info->name, tc_info);
+        std::thread *temp = new std::thread(&codec_test, tc_info, get_display_hook());
+        if (!temp) {
+            printf("create %s test thread error/n", tc_info->base_info->name);
+        }
+    } else {
+        printf("unsupport test item:%s\n", tc_info->base_info->name);
+        return -1;
+    }
+
+    return 0;
+}
+
+int init_manual_test_item(struct testcase_info *tc_info)
+{
+    printf("start_manual_test_item : %d, %s \r\n", tc_info->y,
+           tc_info->base_info->name);
+
+    manual_p_y += 1;
+    tc_info->y = manual_p_y;
+
+    start_test_pthread(tc_info);
+
+    return 0;
+}
+int start_auto_test_item(struct testcase_info *tc_info)
+{
+    printf("start_auto_test_item : %d, %s \r\n", tc_info->y,
+           tc_info->base_info->name);
+
+    start_test_pthread(tc_info);
+
+    return 0;
+}
+
+
+static int parse_testcase(void)
+{
+    int i, j, mainkey_cnt;
+    struct testcase_base_info *info;
+    char mainkey_name[32], display_name[64], binary[16];
+    int activated, category, run_type, sim_counts;
+    int len;
+
+    mainkey_cnt = script_mainkey_cnt();
+    info = (struct testcase_base_info *)
+    malloc(sizeof(struct testcase_base_info) * mainkey_cnt);
+    if (info == NULL) {
+        db_error("core: allocate memory for temporary test case basic "
+                 "information failed(%s)\n", strerror(errno));
+        return -1;
+    }
+    memset(info, 0, sizeof(struct testcase_base_info) * mainkey_cnt);
+
+    for (i = 0, j = 0; i < mainkey_cnt; i++) {
+        struct testcase_info *tc_info;
+
+        memset(mainkey_name, 0, 32);
+        script_mainkey_name(i, mainkey_name);
+
+        if (script_fetch(mainkey_name, (char*)"display_name", (int *)display_name, 16))
+            continue;
+
+        if (script_fetch(mainkey_name, (char*)"activated", &activated, 1))
+            continue;
+
+        if (display_name[0] && activated == 1) {
+            strncpy(info[j].name, mainkey_name, 32);
+            strncpy(info[j].display_name, display_name, 64);
+            info[j].activated = activated;
+
+            if (script_fetch
+                (mainkey_name, (char*)"program", (int *)binary, 4) == 0) {
+                    strncpy(info[j].binary, binary, 16);
+                }
+
+            info[j].id = j;
+
+            if (script_fetch(mainkey_name, (char*)"category", &category, 1)
+                == 0) {
+                    info[j].category = category;
+                }
+
+            if (script_fetch(mainkey_name, (char*)"run_type", &run_type, 1)
+                == 0) {
+                    info[j].run_type = run_type;
+                }
+
+            if (script_fetch
+                (mainkey_name, (char*)"sim_counts", &sim_counts, 1) == 0) {
+                    simCounts = sim_counts;
+                }
+            tc_info = (struct testcase_info *)
+            malloc(sizeof(struct testcase_info));
+            if (tc_info == NULL) {
+                printf("malloc for tc_info[%d] fail\n", j);
+                return -1;
+            }
+            tc_info->x = 0;
+            tc_info->y = 0;
+            tc_info->base_info = &info[j];
+            if (tc_info->base_info->category)
+            list_add(&tc_info->list,
+                     &manual_test_list_head);
+            else
+            list_add(&tc_info->list, &auto_test_list_head);
+            j++;
+        }
+    }
+    total_testcases = j;
+    db_msg("core: total test cases #%d\n", total_testcases);
+    if (total_testcases == 0) return 0;
+    len = sizeof(struct testcase_base_info) * total_testcases;
+    return total_testcases;
+}
+
+int RKFactory::StartFactorytest(Device* device) {
+    int ret;
+    char *script_buf;
+    struct list_head *pos;
+    //int success = 0;
+    //char rfCalResult[10];
+
+    pcba_ui = device->GetUI();
+    pcba_ui->SetRkFactoryStart(true);
+    pcba_ui->SetEnableTouchEvent(true, false);
+    pcba_title_lines = { PCBA_VERSION_NAME};
+    pcba_result_lines.push_back(RecoveryUI::TestResultEnum::TESTING);
+    pcba_title_lines.push_back("Serial number - " + android::base::GetProperty("ro.serialno", ""));
+    pcba_result_lines.push_back(RecoveryUI::TestResultEnum::TESTING);
+
+    pcba_ui->ResetKeyInterruptStatus();
+    pcba_ui->SetTitle(pcba_title_lines);
+    pcba_ui->ShowText(true);
+    printf("parse script failed\n");
+    INIT_LIST_HEAD(&manual_test_list_head);
+    INIT_LIST_HEAD(&auto_test_list_head);
+    pcba_title_lines.push_back("=======================================================");
+    pcba_result_lines.push_back(RecoveryUI::TestResultEnum::TESTING);
+
+    pcba_ui->ResetKeyInterruptStatus();
+    pcba_ui->SetTitle(pcba_title_lines);
+    pcba_ui->ShowText(true);
+    script_buf = parse_script((char*)SCRIPT_NAME);
+    if (!script_buf) {
+        printf("parse script failed\n");
+        return -1;
+    }
+
+    ret = init_script(script_buf);
+    if (ret) {
+        db_error("core: init script failed(%d)\n", ret);
+        return -1;
+    }
+
+    ret = parse_testcase();
+    if (ret < 0) {
+        db_error("core: parse all test case from script failed(%d)\n",
+                 ret);
+        return -1;
+    } else if (ret == 0) {
+        db_warn("core: NO TEST CASE to be run\n");
+        return -1;
+    }
+
+    printf("manual testcase:\n");
+    pcba_title_lines.push_back(PCBA_MANUAL_TEST);
+    pcba_result_lines.push_back(RecoveryUI::TestResultEnum::TESTING);
+    list_for_each(pos, &manual_test_list_head) {
+        struct testcase_info *tc_info =
+        list_entry(pos, struct testcase_info, list);
+        init_manual_test_item(tc_info);
+    }
+
+    pcba_title_lines.push_back("=======================================================");
+    pcba_result_lines.push_back(RecoveryUI::TestResultEnum::TESTING);
+    pcba_title_lines.push_back(PCBA_AUTO_TEST);
+    pcba_result_lines.push_back(RecoveryUI::TestResultEnum::TESTING);
+    pcba_ui->ResetKeyInterruptStatus();
+    pcba_ui->SetTitle(pcba_title_lines);
+    pcba_ui->ShowText(true);
+    printf("\n\nauto testcase:\n");
+    list_for_each(pos, &auto_test_list_head) {
+        struct testcase_info *tc_info =
+        list_entry(pos, struct testcase_info, list);
+        start_auto_test_item(tc_info);
+    }
+    //start_input_thread();
+
+    printf("pcba test over!\n");
+    pcba_title_lines.push_back("=======================================================");
+    pcba_result_lines.push_back(RecoveryUI::TestResultEnum::TESTING);
+    pcba_ui->ResetKeyInterruptStatus();
+    pcba_ui->SetTitle(pcba_title_lines);
+    pcba_ui->ShowText(true);
+
+  //std::string err;
+  //if (!clear_bootloader_message(&err)) {
+  //    LOG(ERROR) << "Failed to clear BCB message: " << err;
+  //}
+    printf("display menukey\n");
+    std::vector<std::string> rkFactory_menu_items;
+    std::transform(rkFactoryMenuActions.cbegin(), rkFactoryMenuActions.cend(),
+                    std::back_inserter(rkFactory_menu_items),
+                    [](const auto& entry) { return entry.first; });
+
+    auto chosen_item = pcba_ui->ShowMenu(
+                                {}, rkFactory_menu_items, 0, false,
+                                std::bind(&Device::HandleMenuKey, device,
+                                std::placeholders::_1, std::placeholders::_2));
+
+    if (chosen_item == static_cast<size_t>(RecoveryUI::KeyError::INTERRUPTED)) {
+        return 0;//Device::KEY_INTERRUPTED;
+    }
+
+    return 0;//kFastbootMenuActions[chosen_item].second;
+}
diff --git a/bootable/recovery/pcba_core/rkfactory_test.h b/bootable/recovery/pcba_core/rkfactory_test.h
new file mode 100644
index 0000000000..cec93e4a89
--- /dev/null
+++ b/bootable/recovery/pcba_core/rkfactory_test.h
@@ -0,0 +1,23 @@
+/*
+* Copyright 2020 Rockchip Electronics Co., Ltd
+* Kenjc <kenjc.bian@rock-chips.com>
+*
+* SPDX-License-Identifier:	GPL-2.0+
+*/
+
+#ifndef RKFACTORY_TEST_HEADER
+#define RKFACTORY_TEST_HEADER
+#include <string>
+#include <vector>
+
+#include "recovery_ui/device.h"
+Device::BuiltinAction StartFactorytest(Device* device);
+class RKFactory{
+    public:
+    RKFactory();
+    int StartFactorytest(Device* device);
+    bool isRKFactory();
+    bool bRKFactory;
+};
+
+#endif
diff --git a/bootable/recovery/pcba_core/rkhal3_camera/camera_test.cpp b/bootable/recovery/pcba_core/rkhal3_camera/camera_test.cpp
new file mode 100644
index 0000000000..8ce9f7325a
--- /dev/null
+++ b/bootable/recovery/pcba_core/rkhal3_camera/camera_test.cpp
@@ -0,0 +1,856 @@
+#include <thread>
+#include <hardware/rga.h>
+#define virtual vir
+#include <drm.h>
+#include <drm_mode.h>
+#undef virtual
+
+#include "camera_test.h"
+extern "C" {
+    #include "../script.h"
+    #include "../test_case.h"
+    #include "../script_parser.h"
+}
+
+static char iq_file[255] = "/etc/cam_iq.xml";
+static char out_file[255];
+static char dev_name[255];
+static int width = 640;
+static int height = 480;
+static int format = V4L2_PIX_FMT_NV12;
+static int fd = -1;
+static int drm_fd = -1;
+static int io = IO_METHOD_MMAP;
+static enum v4l2_buf_type buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+struct buffer *buffers;
+static unsigned int n_buffers;
+static int frame_count = 5;
+static float mae_gain = 0.0f;
+static float mae_expo = 0.0f;
+FILE *fp;
+static int silent;
+static unsigned int drm_handle;
+
+#define DBG(...) do { if(!silent) printf(__VA_ARGS__); } while(0)
+#define ERR(...) do { fprintf(stderr, __VA_ARGS__); } while (0)
+#ifdef ANDROID
+#ifdef ANDROID_VERSION_ABOVE_8_X
+#define LIBRKISP "/vendor/lib64/librkisp.so"
+#else
+#define LIBRKISP "/system/lib/librkisp.so"
+#endif
+#else
+#define LIBRKISP "/usr/lib/librkisp.so"
+#endif
+
+#define VIDEO_DEV_NAME   "/dev/video0"
+#define PMEM_DEV_NAME    "/dev/pmem_cam"
+#define DISP_DEV_NAME    "/dev/graphics/fb1"
+#define ION_DEVICE          "/dev/ion"
+
+#define FBIOSET_ENABLE			0x5019	
+
+#define CAM_OVERLAY_BUF_NEW  1
+#define RK29_CAM_VERSION_CODE_1 KERNEL_VERSION(0, 0, 1)
+#define RK29_CAM_VERSION_CODE_2 KERNEL_VERSION(0, 0, 2)
+
+static void *m_v4l2Buffer[4];
+static void *m_v4l2buffer_display[4];
+static int v4l2Buffer_phy_addr[4] = {0};
+static int v4l2Buffer_phy_addr_display;
+static int SharedFd_display[4];
+
+static int iCamFd = 0, iDispFd =-1;
+static int preview_w,preview_h;
+
+static char videodevice[20] ={0};
+static struct v4l2_capability mCamDriverCapability;
+static unsigned int pix_format;
+
+static void* vaddr = NULL;
+static volatile int isstoped = 0;
+static int hasstoped = 1;
+enum {
+    FD_INIT = -1,
+};
+
+
+#define RK30_PLAT 1
+#define RK29_PLAT 0
+static int is_rk30_plat = RK30_PLAT;
+#define  FB_NONSTAND ((is_rk30_plat == RK29_PLAT)?0x2:0x20)
+static int cam_id = 0;
+
+static int camera_x=0,camera_y=0,camera_w=0,camera_h=0,camera_num=0;
+static struct testcase_info *tc_info = NULL;
+
+static void errno_exit(const char *s)
+{
+    ERR("%s error %d, %s\n", s, errno, strerror(errno));
+    //exit(EXIT_FAILURE);
+}
+
+static int init_drm()
+{
+    int drm_fd = drmOpen("rockchip", NULL);
+    if (drm_fd < 0) {
+        ERR("failed to open rockchip drm: %s\n", strerror(errno));
+        exit(EXIT_FAILURE);
+    }
+    return drm_fd;
+}
+
+static void deinit_drm(int drm_fd)
+{
+    drmClose(drm_fd);
+}
+
+static void* get_drm_buf(int drm_fd, int width, int height, int bpp)
+{
+    struct drm_mode_create_dumb alloc_arg;
+    struct drm_mode_map_dumb mmap_arg;
+    struct drm_mode_destroy_dumb destory_arg;
+    int ret;
+    void *map;
+
+    CLEAR(alloc_arg);
+    alloc_arg.bpp = bpp;
+    alloc_arg.width = width;
+    alloc_arg.height = height;
+    #define ROCKCHIP_BO_CONTIG  1            
+    #define ROCKCHIP_BO_CACHABLE (1<<1)
+    alloc_arg.flags = ROCKCHIP_BO_CONTIG | ROCKCHIP_BO_CACHABLE;
+
+    ret = drmIoctl(drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, &alloc_arg);
+    if (ret) {
+        ERR("failed to create dumb buffer: %s\n", strerror(errno));
+        exit(EXIT_FAILURE);
+    }
+
+    CLEAR(mmap_arg);
+    mmap_arg.handle = alloc_arg.handle;
+
+    ret = drmIoctl(drm_fd, DRM_IOCTL_MODE_MAP_DUMB, &mmap_arg);
+    if (ret) {
+        ERR("failed to create map dumb: %s\n", strerror(errno));
+        ret = -EINVAL;
+        goto destory_dumb;
+    }
+
+    map = mmap(0, alloc_arg.size, PROT_READ | PROT_WRITE, MAP_SHARED, drm_fd, mmap_arg.offset);
+    if (map == MAP_FAILED) {
+        ERR("failed to mmap buffer: %s\n", strerror(errno));
+        ret = -EINVAL;
+        goto destory_dumb;
+    }
+
+    assert(alloc_arg.size == width * height * bpp / 8);
+
+    destory_dumb:
+    CLEAR(destory_arg);
+    destory_arg.handle = alloc_arg.handle;
+    drmIoctl(drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destory_arg);
+    if (ret)
+    return NULL;
+
+    return map;
+}
+
+static void* get_drm_fd(int drm_fd, int width, int height, int bpp, int *export_dmafd)
+{
+    struct drm_mode_create_dumb alloc_arg;
+    struct drm_mode_map_dumb mmap_arg;
+    struct drm_mode_destroy_dumb destory_arg;
+    int ret;
+    void *map;
+
+    CLEAR(alloc_arg);
+    alloc_arg.bpp = bpp;
+    alloc_arg.width = width;
+    alloc_arg.height = height;
+    #define ROCKCHIP_BO_CONTIG  1
+    #define ROCKCHIP_BO_CACHABLE (1<<1)
+    alloc_arg.flags = ROCKCHIP_BO_CONTIG | ROCKCHIP_BO_CACHABLE;
+
+    ret = drmIoctl(drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, &alloc_arg);
+    if (ret) {
+        ERR("failed to create dumb buffer: %s\n", strerror(errno));
+        exit(EXIT_FAILURE);
+    }
+
+    CLEAR(mmap_arg);
+    mmap_arg.handle = alloc_arg.handle;
+    ret = drmIoctl(drm_fd, DRM_IOCTL_MODE_MAP_DUMB, &mmap_arg);
+    if (ret) {
+        ERR("failed to create map dumb: %s\n", strerror(errno));
+        ret = -EINVAL;
+        goto destory_dumb;
+    }
+
+    map = mmap(0, alloc_arg.size, PROT_READ | PROT_WRITE, MAP_SHARED, drm_fd, mmap_arg.offset);
+    if (map == MAP_FAILED) {
+        ERR("failed to mmap buffer: %s\n", strerror(errno));
+        ret = -EINVAL;
+        goto destory_dumb;
+    }
+
+    assert(alloc_arg.size == width * height * bpp / 8);
+    ret = drmPrimeHandleToFD(drm_fd, alloc_arg.handle, 0, export_dmafd);
+    if (ret) {
+        ERR("failed to export fd: %s\n", strerror(errno));
+        ret = -EINVAL;
+        goto destory_dumb;
+    }
+
+    drm_handle = alloc_arg.handle;
+    return map;
+
+destory_dumb:
+    CLEAR(destory_arg);
+    destory_arg.handle = alloc_arg.handle;
+    drmIoctl(drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destory_arg);
+
+    return NULL;
+}
+
+static int xioctl(int fh, int request, void *arg)
+{
+    int r;
+    do {
+        r = ioctl(fh, request, arg);
+    } while (-1 == r && EINTR == errno);
+    return r;
+}
+
+static void process_image(const void *p, int size)
+{
+    DBG("process_image size: %d\n",size);
+    fwrite(p, size, 1, fp);
+    fflush(fp);
+}
+
+static int read_frame(FILE *fp)
+{
+    struct v4l2_buffer buf;
+    int i, bytesused;
+
+    CLEAR(buf);
+
+    buf.type = buf_type;
+    if (io == IO_METHOD_MMAP)
+    buf.memory = V4L2_MEMORY_MMAP;
+    else if (io == IO_METHOD_DMABUF)
+    buf.memory = V4L2_MEMORY_DMABUF;
+    else
+    buf.memory = V4L2_MEMORY_USERPTR;
+
+    if (V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE == buf_type) {
+        struct v4l2_plane planes[FMT_NUM_PLANES];
+        buf.m.planes = planes;
+        buf.length = FMT_NUM_PLANES;
+    }
+
+    if (-1 == xioctl(fd, VIDIOC_DQBUF, &buf)) {
+        errno_exit("VIDIOC_DQBUF");
+        return 1;
+    }
+
+    i = buf.index;
+
+    if (V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE == buf_type)
+    bytesused = buf.m.planes[0].bytesused;
+    else
+    bytesused = buf.bytesused;
+    process_image(buffers[i].start, bytesused);
+    DBG("bytesused %d\n", bytesused);
+
+    if (-1 == xioctl(fd, VIDIOC_QBUF, &buf)) {
+        errno_exit("VIDIOC_QBUF");
+        return 1;
+    }
+
+    return 0;
+}
+
+static int mainloop(void)
+{
+    unsigned int count = frame_count;
+    float exptime, expgain;
+    int64_t frame_id, frame_sof;
+
+    while (count-- > 0) {
+        DBG("No.%d\n",frame_count - count);        //ʾǰ֡Ŀ
+
+        if (read_frame(fp) > 0)
+        return 1;
+    }
+    DBG("\nREAD AND SAVE DONE!\n");
+    return 0;
+}
+
+static int stop_capturing(void)
+{
+    enum v4l2_buf_type type;
+    type = buf_type;
+    if (-1 == xioctl(fd, VIDIOC_STREAMOFF, &type)) {
+        errno_exit("VIDIOC_STREAMOFF");
+        return 1;
+    }
+    return 0;
+}
+
+static int start_capturing(void)
+{
+    unsigned int i;
+    enum v4l2_buf_type type;
+
+    for (i = 0; i < n_buffers; ++i) {
+        struct v4l2_buffer buf;
+
+        CLEAR(buf);
+        buf.type = buf_type;
+        if (io == IO_METHOD_MMAP)
+        buf.memory = V4L2_MEMORY_MMAP;
+        else if (io == IO_METHOD_DMABUF)
+        buf.memory = V4L2_MEMORY_DMABUF;
+        else
+        buf.memory = V4L2_MEMORY_USERPTR;
+        buf.index = i;
+
+        if (io == IO_METHOD_USERPTR) {
+            buf.m.userptr = (unsigned long)buffers[i].start;
+            buf.length = buffers[i].length;
+        } else if (io == IO_METHOD_DMABUF) {
+            buf.m.fd = buffers[i].v4l2_buf.m.fd;
+            buf.length = buffers[i].length;
+        }
+
+        if (V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE == buf_type) {
+            struct v4l2_plane planes[FMT_NUM_PLANES];
+
+            if (io == IO_METHOD_USERPTR) {
+                planes[0].m.userptr = (unsigned long)buffers[i].start;
+                planes[0].length = buffers[i].length;
+            } else if (io == IO_METHOD_DMABUF) {
+                planes[0].m.fd = buffers[i].v4l2_buf.m.fd;
+                planes[0].length = buffers[i].length;
+            }
+            buf.m.planes = planes;
+            buf.length = FMT_NUM_PLANES;
+        }
+        if (-1 == xioctl(fd, VIDIOC_QBUF, &buf)) {
+            errno_exit("VIDIOC_QBUF");
+            return 1;
+        }
+    }
+    type = buf_type;
+    if (-1 == xioctl(fd, VIDIOC_STREAMON, &type)) {
+        errno_exit("VIDIOC_STREAMON");
+        return 1;
+    }
+    return 0;
+}
+
+static int uninit_device(void)
+{
+    unsigned int i;
+    struct drm_mode_destroy_dumb destory_arg;
+
+    for (i = 0; i < n_buffers; ++i) {
+        if (-1 == munmap(buffers[i].start, buffers[i].length)) {
+            errno_exit("munmap");
+            return 1;
+        }
+
+        if (io == IO_METHOD_DMABUF) {
+            close(buffers[i].v4l2_buf.m.fd);
+            CLEAR(destory_arg);
+            destory_arg.handle = drm_handle;
+            drmIoctl(drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destory_arg);
+        }
+    }
+
+    free(buffers);
+
+    if (drm_fd != -1) deinit_drm(drm_fd);
+    return 0;
+}
+
+static void init_mmap(void)
+{
+    struct v4l2_requestbuffers req;
+
+    CLEAR(req);
+
+    req.count = BUFFER_COUNT;
+    req.type = buf_type;
+    req.memory = V4L2_MEMORY_MMAP;
+
+    if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {
+        if (EINVAL == errno) {
+            ERR("%s does not support "
+                "memory mapping\n", dev_name);
+            exit(EXIT_FAILURE);
+        } else {
+            errno_exit("VIDIOC_REQBUFS");
+        }
+    }
+
+    if (req.count < 2) {
+        ERR("Insufficient buffer memory on %s\n",
+            dev_name);
+        exit(EXIT_FAILURE);
+    }
+
+    buffers = (struct buffer*)calloc(req.count, sizeof(*buffers));
+
+    if (!buffers) {
+        ERR("Out of memory\n");
+        exit(EXIT_FAILURE);
+    }
+
+    for (n_buffers = 0; n_buffers < req.count; ++n_buffers) {
+        struct v4l2_buffer buf;
+        struct v4l2_plane planes[FMT_NUM_PLANES];
+        CLEAR(buf);
+        CLEAR(planes);
+
+        buf.type = buf_type;
+        buf.memory = V4L2_MEMORY_MMAP;
+        buf.index = n_buffers;
+
+        if (V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE == buf_type) {
+            buf.m.planes = planes;
+            buf.length = FMT_NUM_PLANES;
+        }
+
+        if (-1 == xioctl(fd, VIDIOC_QUERYBUF, &buf)) errno_exit("VIDIOC_QUERYBUF");
+
+        if (V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE == buf_type) {
+            buffers[n_buffers].length = buf.m.planes[0].length;
+            buffers[n_buffers].start =
+            mmap(NULL /* start anywhere */,
+                 buf.m.planes[0].length,
+                 PROT_READ | PROT_WRITE /* required */,
+                 MAP_SHARED /* recommended */,
+                 fd, buf.m.planes[0].m.mem_offset);
+        } else {
+            buffers[n_buffers].length = buf.length;
+            buffers[n_buffers].start =
+            mmap(NULL /* start anywhere */,
+                 buf.length,
+                 PROT_READ | PROT_WRITE /* required */,
+                 MAP_SHARED /* recommended */,
+                 fd, buf.m.offset);
+        }
+
+        if (MAP_FAILED == buffers[n_buffers].start) errno_exit("mmap");
+    }
+}
+
+static void init_dmabuf(int buffer_size, int width, int height)
+{
+    struct v4l2_requestbuffers req;
+    int bpp;
+    int export_dmafd;
+
+    CLEAR(req);
+
+    req.count  = BUFFER_COUNT;
+    req.memory = V4L2_MEMORY_DMABUF;
+    req.type = buf_type;
+
+    if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {
+        if (EINVAL == errno) {
+            ERR("%s does not support dmabuf i/on\n", dev_name);
+            exit(EXIT_FAILURE);
+        } else {
+            errno_exit("VIDIOC_REQBUFS");
+        }
+    }
+
+    buffers = (struct buffer*)calloc(req.count, sizeof(*buffers));
+
+    if (!buffers) {
+        ERR("Out of memory\n");
+        exit(EXIT_FAILURE);
+    }
+
+    drm_fd = init_drm();
+    bpp = buffer_size * 8 / width / height;
+    for (n_buffers = 0; n_buffers < req.count; ++n_buffers) {
+        buffers[n_buffers].length = buffer_size;
+        buffers[n_buffers].start = get_drm_fd(drm_fd, width, height, bpp, &export_dmafd);
+
+        buffers[n_buffers].v4l2_buf.m.fd = export_dmafd;
+        buffers[n_buffers].v4l2_buf.length = buffer_size;
+    }
+}
+
+static void init_userp(int buffer_size, int width, int height)
+{
+    struct v4l2_requestbuffers req;
+    int bpp;
+
+    CLEAR(req);
+
+    req.count  = BUFFER_COUNT;
+    req.memory = V4L2_MEMORY_USERPTR;
+    req.type = buf_type;
+
+    if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {
+        if (EINVAL == errno) {
+            ERR("%s does not support user pointer i/on\n", dev_name);
+            exit(EXIT_FAILURE);
+        } else {
+            errno_exit("VIDIOC_REQBUFS");
+        }
+    }
+
+    buffers = (struct buffer*)calloc(req.count, sizeof(*buffers));
+
+    if (!buffers) {
+        ERR("Out of memory\n");
+        exit(EXIT_FAILURE);
+    }
+
+    drm_fd = init_drm();
+    bpp = buffer_size * 8 / width / height;
+    for (n_buffers = 0; n_buffers < req.count; ++n_buffers) {
+        buffers[n_buffers].length = buffer_size;
+        buffers[n_buffers].start = get_drm_buf(drm_fd, width, height, bpp);
+
+        if (!buffers[n_buffers].start) {
+            exit(EXIT_FAILURE);
+        }
+    }
+}
+
+static int init_device(void)
+{
+    struct v4l2_capability cap;
+    struct v4l2_format fmt;
+
+    if (-1 == xioctl(fd, VIDIOC_QUERYCAP, &cap)) {
+        if (EINVAL == errno) {
+            ERR("%s is no V4L2 device\n",
+                dev_name);
+            exit(EXIT_FAILURE);
+            return 1;
+        } else {
+            errno_exit("VIDIOC_QUERYCAP");
+            return 1;
+        }
+    }
+
+    if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) &&
+        !(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE)) {
+            ERR("%s is not a video capture device, capabilities: %x\n",
+                dev_name, cap.capabilities);
+            exit(EXIT_FAILURE);
+            return 1;
+        }
+
+    if (!(cap.capabilities & V4L2_CAP_STREAMING)) {
+        ERR("%s does not support streaming i/o\n",
+            dev_name);
+        exit(EXIT_FAILURE);
+        return 1;
+    }
+
+    DBG(" %s capabilities driver: %s name:%s\n", dev_name, (char*) &cap.driver[0], (char*) &cap.card[0]);
+
+    if (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) {
+        buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    }
+    else if (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE) {
+        buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+    }
+
+    CLEAR(fmt);
+    fmt.type = buf_type;
+    fmt.fmt.pix.width = width;
+    fmt.fmt.pix.height = height;
+    fmt.fmt.pix.pixelformat = format;
+    fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
+
+    if (-1 == xioctl(fd, VIDIOC_S_FMT, &fmt)) {
+        errno_exit("VIDIOC_S_FMT");
+        return 1;
+    }
+
+    if (io == IO_METHOD_MMAP) {
+        init_mmap();
+    } else if (io == IO_METHOD_USERPTR) {
+        init_userp(fmt.fmt.pix.sizeimage, width, height);
+    } else if (io == IO_METHOD_DMABUF) {
+        init_dmabuf(fmt.fmt.pix.sizeimage, width, height);
+    }
+    return 0;
+}
+
+static int close_device(void)
+{
+    if (-1 == close(fd)) {
+        errno_exit("close");
+        return 1;
+    }
+
+    fd = -1;
+    return 0;
+}
+
+static int open_device(void)
+{
+    fd = open(dev_name, O_RDWR /* required */ /*| O_NONBLOCK*/, 0);
+
+    if (-1 == fd) {
+        ERR("Cannot open '%s': %d, %s\n",
+            dev_name, errno, strerror(errno));
+        exit(EXIT_FAILURE);
+        return 1;
+    }
+    return 0;
+}
+
+void parse_args(int argc, char **argv)                                                                                                       
+{
+    int c;
+    int digit_optind = 0;
+
+    while (1) {
+        int this_option_optind = optind ? optind : 1;
+        int option_index = 0;
+        static struct option long_options[] = {
+            {"width",    required_argument, 0, 'w' },
+            {"height",   required_argument, 0, 'h' },
+            {"memory",   required_argument, 0, 'm' },
+            {"format",   required_argument, 0, 'f' },
+            {"iqfile",   required_argument, 0, 'i' },
+            {"device",   required_argument, 0, 'd' },
+            {"output",   required_argument, 0, 'o' },
+            {"count",    required_argument, 0, 'c' },
+            {"expo",     required_argument, 0, 'e' },
+            {"gain",     required_argument, 0, 'g' },
+            {"help",     no_argument,       0, 'p' },
+            {"silent",   no_argument,       0, 's' },
+            {0,          0,                 0,  0  }
+        };
+
+        c = getopt_long(argc, argv, "w:h:m:f:i:d:o:c:e:g:ps",
+                        long_options, &option_index);
+        if (c == -1)
+        break;
+
+        switch (c) {
+            case 'c':
+                frame_count = atoi(optarg);
+                break;
+            case 'e':
+                mae_expo = atof(optarg);
+                DBG("target expo: %f\n", mae_expo);
+                break;
+            case 'm':
+                if (!strcmp("drm", optarg))
+                    io = IO_METHOD_USERPTR;
+                else if(!strcmp("dmabuf", optarg))
+                    io = IO_METHOD_DMABUF;
+                else
+                    io = IO_METHOD_MMAP;
+                break;                                                                                                                            
+            case 'g':
+                mae_gain = atof(optarg);
+                DBG("target gain: %f\n", mae_gain);
+                break;
+            case 'w':
+                width = atoi(optarg);
+                break;
+            case 'h':
+                height = atoi(optarg);
+                break;
+            case 'f':
+                format = v4l2_fourcc(optarg[0], optarg[1], optarg[2], optarg[3]);
+                break;
+            case 'i':
+                strcpy(iq_file, optarg);
+                break;
+            case 'd':
+                strcpy(dev_name, optarg);
+                break;
+            case 'o':
+                strcpy(out_file, optarg);
+                break;
+            case 's':
+                silent = 1;
+                break;
+            case '?':
+            case 'p':
+                ERR("Usage: %s to capture rkisp1 frames\n"
+                "         --width,  default 640,             optional, width of image\n"
+                "         --height, default 480,             optional, height of image\n"
+                "         --memory, default mmap,            optional, use 'mmap' or 'drm' to alloc buffers\n"
+                "         --format, default NV12,            optional, fourcc of format\n"
+                "         --count,  default    5,            optional, how many frames to capture\n"
+                "         --iqfile, default /etc/cam_iq.xml, optional, camera IQ file\n"
+                "         --device,                          required, path of video device\n"
+                "         --output,                          required, output file path, if <file> is '-', then the data is written to     stdout\n"
+                "         --gain,   default 0,               optional\n"
+                "         --expo,   default 0,               optional\n"
+                "                   Manually AE is enable only if --gain and --expo are not zero\n"
+                "         --silent,                          optional, subpress debug log\n",
+                argv[0]);
+                exit(-1);
+            default:
+                ERR("?? getopt returned character code 0%o ??\n", c);
+        }
+    }
+    if (strlen(out_file) == 0 || strlen(dev_name) == 0) {
+        ERR("arguments --output and --device are required\n");
+        exit(-1);
+    }
+}
+
+void *camera_test(void *argc, display_callback *hook)
+{
+    int err[2] = {0,0};
+    char msg[80];
+    int ret, num;
+    tc_info = (struct testcase_info *)argc; 
+
+    if (script_fetch("camera", "number",&num, 1) == 0) {
+        printf("camera_test num:%d\r\n",num);
+        camera_num = num;	
+    }
+    
+    snprintf(msg, sizeof(msg), "%s:[%s]", PCBA_CAMERA, PCBA_TESTING);
+    hook->handle_refresh_screen(tc_info->y, msg);
+
+    system("/system/bin/media-ctl -r");
+
+    sleep(1);
+
+    strcpy(out_file, "/data/1.yuv");
+    strcpy(dev_name, "/dev/video0");
+    width = 2112;
+    height = 1568;
+
+    if (!strcmp(out_file, "-")) {
+        fp = stdout;
+        silent = 1;
+    } else if ((fp = fopen(out_file, "w")) == NULL) {
+        perror("Creat file failed");
+        exit(0);
+    }
+    //media-ctl setup links
+    err[0] = system("/system/bin/media-ctl -l '\"m00_b_ov13850 1-0010\":0->\"rockchip-mipi-dphy-rx\":0[1]'");
+    err[0] = system("/system/bin/media-ctl -l '\"rockchip-mipi-dphy-rx\":1->\"rkisp1-isp-subdev\":0[1]'");
+    err[0] = system("/system/bin/media-ctl -l '\"rkisp1-input-params\":0->\"rkisp1-isp-subdev\":1[1]'");
+    err[0] = system("/system/bin/media-ctl -l '\"rkisp1-isp-subdev\":2->\"rkisp1_selfpath\":0[1]'");
+    err[0] = system("/system/bin/media-ctl -l '\"rkisp1-isp-subdev\":2->\"rkisp1_mainpath\":0[1]'");
+    err[0] = system("/system/bin/media-ctl -l '\"rkisp1-isp-subdev\":3->\"rkisp1-statistics\":0[1]'");
+
+    sleep(1);
+
+    if (err[0]) goto end;
+
+    //set v4l2 format / size and so on
+    err[0] = system("/system/bin/media-ctl --set-v4l2 '\"m00_b_ov13850 1-0010\":0[fmt:SBGGR10/2112x1568]'");
+    err[0] = system("/system/bin/media-ctl --set-v4l2 '\"rkisp1-isp-subdev\":0[fmt:SBGGR10/2112x1568]'");
+    err[0] = system("/system/bin/media-ctl --set-v4l2 '\"rkisp1-isp-subdev\":0[fmt:SBGGR10/2112x1568]' --set-v4l2 '\"rkisp1-isp-subdev\":0[crop:(0,0)/2112x1568]'");
+    err[0] = system("/system/bin/media-ctl --set-v4l2 '\"rkisp1-isp-subdev\":2[fmt:YUYV2X8/2112x1568]'");
+    err[0] = system("/system/bin/media-ctl --set-v4l2 '\"rkisp1-isp-subdev\":2[fmt:YUYV2X8/2112x1568]' --set-v4l2 '\"rkisp1-isp-subdev\":2[crop:(0,0)/2112x1568]'");
+
+    sleep(1);
+
+    if (err[0]) goto end;
+
+    err[0] = open_device();
+    if (err[0]) goto end;
+
+    err[0] = init_device();
+    if (err[0]) goto end;
+
+    err[0] = start_capturing();
+    if (err[0]) goto end;
+
+    err[0] = mainloop();
+    if (err[0]) goto end;
+
+    fclose(fp);
+    stop_capturing();
+    uninit_device();
+    close_device();
+
+    if (camera_num > 1) {
+        system("/system/bin/media-ctl -r");
+
+        sleep(1);
+
+        strcpy(out_file, "/data/2.yuv");
+        strcpy(dev_name, "/dev/video0");
+        width = 2112;
+        height = 1568;
+
+        if (!strcmp(out_file, "-")) {
+            fp = stdout;
+            silent = 1;
+        } else if ((fp = fopen(out_file, "w")) == NULL) {
+            perror("Creat file failed");
+            exit(0);
+        }
+        //media-ctl setup links
+        err[1] = system("/system/bin/media-ctl -l '\"m00_b_ov13850 1-0010\":0->\"rockchip-mipi-dphy-rx\":0[1]'");
+        err[1] = system("/system/bin/media-ctl -l '\"rockchip-mipi-dphy-rx\":1->\"rkisp1-isp-subdev\":0[1]'");
+        err[1] = system("/system/bin/media-ctl -l '\"rkisp1-input-params\":0->\"rkisp1-isp-subdev\":1[1]'");
+        err[1] = system("/system/bin/media-ctl -l '\"rkisp1-isp-subdev\":2->\"rkisp1_selfpath\":0[1]'");
+        err[1] = system("/system/bin/media-ctl -l '\"rkisp1-isp-subdev\":2->\"rkisp1_mainpath\":0[1]'");
+        err[1] = system("/system/bin/media-ctl -l '\"rkisp1-isp-subdev\":3->\"rkisp1-statistics\":0[1]'");
+
+        sleep(1);
+
+        if (err[1]) goto end;
+
+        //set v4l2 format / size and so on
+        err[1] = system("/system/bin/media-ctl --set-v4l2 '\"m00_b_ov13850 1-0010\":0[fmt:SBGGR10/2112x1568]'");
+        err[1] = system("/system/bin/media-ctl --set-v4l2 '\"rkisp1-isp-subdev\":0[fmt:SBGGR10/2112x1568]'");
+        err[1] = system("/system/bin/media-ctl --set-v4l2 '\"rkisp1-isp-subdev\":0[fmt:SBGGR10/2112x1568]' --set-v4l2 '\"rkisp1-isp-subdev\":0[crop:(0,0)/2112x1568]'");
+        err[1] = system("/system/bin/media-ctl --set-v4l2 '\"rkisp1-isp-subdev\":2[fmt:YUYV2X8/2112x1568]'");
+        err[1] = system("/system/bin/media-ctl --set-v4l2 '\"rkisp1-isp-subdev\":2[fmt:YUYV2X8/2112x1568]' --set-v4l2 '\"rkisp1-isp-subdev\":2[crop:(0,0)/2112x1568]'");
+
+        sleep(1);
+
+        if (err[1]) goto end;
+
+        err[1] = open_device();
+        if (err[1]) goto end;
+
+        err[1] = init_device();
+        if (err[1]) goto end;
+
+        err[1] = start_capturing();
+        if (err[1]) goto end;
+
+        err[1] = mainloop();
+        if (err[1]) goto end;
+
+        fclose(fp);
+        stop_capturing();
+        uninit_device();
+        close_device();
+    }
+
+end:	
+    if (camera_num > 1) {
+        bool failed = (err[0] < 0) || (err[1] < 0);
+        snprintf(msg, sizeof(msg), "Back Camera:[%s] { ID:0x%x } Front Camera:[%s] { ID:0x%x }",
+                 err[0] < 0 ? PCBA_FAILED : PCBA_SECCESS, 0,
+                 err[1] < 0 ? PCBA_FAILED : PCBA_SECCESS, 1);
+        hook->handle_refresh_screen_hl(tc_info->y, msg, failed);
+    } else {
+        bool failed = err[0] < 0;
+        snprintf(msg, sizeof(msg), "Back Camera:[%s] { ID:0x%x }",
+                 failed?PCBA_FAILED:PCBA_SECCESS, 0, failed);
+        hook->handle_refresh_screen_hl(tc_info->y, msg, failed);
+    }
+    return argc;
+}
diff --git a/bootable/recovery/pcba_core/rkhal3_camera/camera_test.h b/bootable/recovery/pcba_core/rkhal3_camera/camera_test.h
new file mode 100644
index 0000000000..6c2ca4f9f1
--- /dev/null
+++ b/bootable/recovery/pcba_core/rkhal3_camera/camera_test.h
@@ -0,0 +1,75 @@
+#ifndef __CAMERA_TEST_H__
+#define __CAMERA_TEST_H__
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <getopt.h> /* getopt_long() */
+#include <fcntl.h> /* low-level i/o */
+#include <unistd.h>
+#include <time.h>
+#include <fcntl.h>
+#include <dlfcn.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/file.h>
+#include <string.h>
+#include <pthread.h>
+//#include <linux/videodev.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <time.h>
+#include <sys/time.h>
+#include <signal.h>
+
+#include <linux/videodev2.h>
+#include <linux/fb.h>
+#include <linux/version.h>
+#include "../test_case.h"
+#include "../language.h"
+#include "../display_callback.h"
+
+#include <xf86drm.h>
+#include <xf86drmMode.h>
+
+#define CLEAR(x) memset(&(x), 0, sizeof(x))
+#define FMT_NUM_PLANES 1
+
+#define BUFFER_COUNT 4
+
+enum io_method {
+    IO_METHOD_MMAP,
+    IO_METHOD_USERPTR,
+    IO_METHOD_DMABUF,
+};
+struct buffer {
+    void *start;
+    size_t length;
+    struct v4l2_buffer v4l2_buf;
+};
+
+// the func is a while loop func , MUST  run in a single thread.
+//return value: 0 is ok ,-1 erro
+
+struct camera_msg {
+    struct testcase_info *tc_info;
+    int result;
+    int id;
+    int x;
+    int y;
+    int w;
+    int h;
+};
+
+void* camera_test(void *argc, display_callback *hook);
+//return value: 0 is ok ,-1 erro
+extern int stopCameraTest();
+extern void finishCameraTest();
+extern int Camera_Click_Event(int x,int y);
+#endif
diff --git a/bootable/recovery/pcba_core/rkhal3_camera/media-ctl b/bootable/recovery/pcba_core/rkhal3_camera/media-ctl
new file mode 100644
index 0000000000..2dca137763
Binary files /dev/null and b/bootable/recovery/pcba_core/rkhal3_camera/media-ctl differ
diff --git a/bootable/recovery/pcba_core/rkhal3_camera/rkisp_demo b/bootable/recovery/pcba_core/rkhal3_camera/rkisp_demo
new file mode 100644
index 0000000000..7f08e297af
Binary files /dev/null and b/bootable/recovery/pcba_core/rkhal3_camera/rkisp_demo differ
diff --git a/bootable/recovery/pcba_core/rklist.h b/bootable/recovery/pcba_core/rklist.h
new file mode 100644
index 0000000000..b072c6dc46
--- /dev/null
+++ b/bootable/recovery/pcba_core/rklist.h
@@ -0,0 +1,775 @@
+#ifndef _LINUX_LIST_H
+#define _LINUX_LIST_H
+
+#if 0
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/poison.h>
+#include <linux/const.h>
+#else
+
+#undef offsetof
+#ifdef __compiler_offsetof
+#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
+#else
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+/**
+ * container_of - cast a member of a structure out to the containing structure
+ * @ptr:    the pointer to the member.
+ * @type:   the type of the container struct this is embedded in.
+ * @member: the name of the member within the struct.
+ *
+ */
+#define container_of(ptr, type, member) ({          \
+    const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
+    (type *)( (char *)__mptr - offsetof(type,member) );})
+
+typedef struct  list_head {
+		struct list_head *next;
+		struct list_head *prev;
+}list_head;
+
+typedef struct hlist_node {
+   struct hlist_node *next, **pprev;
+}hlist_node;
+
+
+typedef struct hlist_head {
+   struct hlist_node *first;
+}hlist_head;
+
+
+
+/*
+ * Architectures might want to move the poison pointer offset
+ * into some well-recognized area such as 0xdead000000000000,
+ * that is also not mappable by user-space exploits:
+ */
+#ifdef CONFIG_ILLEGAL_POINTER_VALUE
+# define POISON_POINTER_DELTA _AC(CONFIG_ILLEGAL_POINTER_VALUE, UL)
+#else
+# define POISON_POINTER_DELTA 0
+#endif
+
+/*
+ * These are non-NULL pointers that will result in page faults
+ * under normal circumstances, used to verify that nobody uses
+ * non-initialized list entries.
+ */
+//#define LIST_POISON1  ((void *) 0x00100100 + POISON_POINTER_DELTA)
+//#define LIST_POISON2  ((void *) 0x00200200 + POISON_POINTER_DELTA)
+
+#endif /* 0 */
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+static inline void INIT_LIST_HEAD(struct list_head *list)
+{
+	list->next = list;
+	list->prev = list;
+}
+
+/*
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+#ifndef CONFIG_DEBUG_LIST
+static inline void __list_add(list_head *cnew, 
+				list_head *prev,
+				list_head *next) {
+	next->prev = cnew;
+	cnew->next = next;
+	cnew->prev = prev;
+	prev->next = cnew;
+}
+#else
+extern void __list_add(struct list_head *cnew,
+			      struct list_head *prev,
+			      struct list_head *next);
+#endif
+
+/**
+ * list_add - add a new entry
+ * @cnew: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static inline void list_add(struct list_head *cnew, struct list_head *head)
+{
+	__list_add(cnew, head, head->next);
+}
+
+
+/**
+ * list_add_tail - add a new entry
+ * @cnew: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static inline void list_add_tail(struct list_head *cnew, struct list_head *head)
+{
+	__list_add(cnew, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_del(struct list_head * prev, struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty() on entry does not return true after this, the entry is
+ * in an undefined state.
+ */
+#ifndef CONFIG_DEBUG_LIST
+static inline void __list_del_entry(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+static inline void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	entry->next = NULL;//(list_head *)LIST_POISON1;
+	entry->prev = NULL;//(list_head *)LIST_POISON2;
+}
+#else
+extern void __list_del_entry(struct list_head *entry);
+extern void list_del(struct list_head *entry);
+#endif
+
+/**
+ * list_replace - replace old entry by new one
+ * @old : the element to be replaced
+ * @cnew : the new element to insert
+ *
+ * If @old was empty, it will be overwritten.
+ */
+static inline void list_replace(struct list_head *old,
+				struct list_head *cnew)
+{
+	cnew->next = old->next;
+	cnew->next->prev = cnew;
+	cnew->prev = old->prev;
+	cnew->prev->next = cnew;
+}
+
+static inline void list_replace_init(struct list_head *old,
+					struct list_head *cnew)
+{
+	list_replace(old, cnew);
+	INIT_LIST_HEAD(old);
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static inline void list_del_init(struct list_head *entry)
+{
+	__list_del_entry(entry);
+	INIT_LIST_HEAD(entry);
+}
+
+/**
+ * list_move - delete from one list and add as another's head
+ * @list: the entry to move
+ * @head: the head that will precede our entry
+ */
+static inline void list_move(struct list_head *list, struct list_head *head)
+{
+	__list_del_entry(list);
+	list_add(list, head);
+}
+
+/**
+ * list_move_tail - delete from one list and add as another's tail
+ * @list: the entry to move
+ * @head: the head that will follow our entry
+ */
+static inline void list_move_tail(struct list_head *list,
+				  struct list_head *head)
+{
+	__list_del_entry(list);
+	list_add_tail(list, head);
+}
+
+/**
+ * list_is_last - tests whether @list is the last entry in list @head
+ * @list: the entry to test
+ * @head: the head of the list
+ */
+static inline int list_is_last(const struct list_head *list,
+				const struct list_head *head)
+{
+	return list->next == head;
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static inline int list_empty(const struct list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * list_empty_careful - tests whether a list is empty and not being modified
+ * @head: the list to test
+ *
+ * Description:
+ * tests whether a list is empty _and_ checks that no other CPU might be
+ * in the process of modifying either member (next or prev)
+ *
+ * NOTE: using list_empty_careful() without synchronization
+ * can only be safe if the only activity that can happen
+ * to the list entry is list_del_init(). Eg. it cannot be used
+ * if another CPU could re-list_add() it.
+ */
+static inline int list_empty_careful(const struct list_head *head)
+{
+	struct list_head *next = head->next;
+	return (next == head) && (next == head->prev);
+}
+
+/**
+ * list_rotate_left - rotate the list to the left
+ * @head: the head of the list
+ */
+static inline void list_rotate_left(struct list_head *head)
+{
+	struct list_head *first;
+
+	if (!list_empty(head)) {
+		first = head->next;
+		list_move_tail(first, head);
+	}
+}
+
+/**
+ * list_is_singular - tests whether a list has just one entry.
+ * @head: the list to test.
+ */
+static inline int list_is_singular(const struct list_head *head)
+{
+	return !list_empty(head) && (head->next == head->prev);
+}
+
+static inline void __list_cut_position(struct list_head *list,
+		struct list_head *head, struct list_head *entry)
+{
+	struct list_head *new_first = entry->next;
+	list->next = head->next;
+	list->next->prev = list;
+	list->prev = entry;
+	entry->next = list;
+	head->next = new_first;
+	new_first->prev = head;
+}
+
+/**
+ * list_cut_position - cut a list into two
+ * @list: a new list to add all removed entries
+ * @head: a list with entries
+ * @entry: an entry within head, could be the head itself
+ *	and if so we won't cut the list
+ *
+ * This helper moves the initial part of @head, up to and
+ * including @entry, from @head to @list. You should
+ * pass on @entry an element you know is on @head. @list
+ * should be an empty list or a list you do not care about
+ * losing its data.
+ *
+ */
+static inline void list_cut_position(struct list_head *list,
+		struct list_head *head, struct list_head *entry)
+{
+	if (list_empty(head))
+		return;
+	if (list_is_singular(head) &&
+		(head->next != entry && head != entry))
+		return;
+	if (entry == head)
+		INIT_LIST_HEAD(list);
+	else
+		__list_cut_position(list, head, entry);
+}
+
+static inline void __list_splice(const struct list_head *list,
+				 struct list_head *prev,
+				 struct list_head *next)
+{
+	struct list_head *first = list->next;
+	struct list_head *last = list->prev;
+
+	first->prev = prev;
+	prev->next = first;
+
+	last->next = next;
+	next->prev = last;
+}
+
+/**
+ * list_splice - join two lists, this is designed for stacks
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static inline void list_splice(const struct list_head *list,
+				struct list_head *head)
+{
+	if (!list_empty(list))
+		__list_splice(list, head, head->next);
+}
+
+/**
+ * list_splice_tail - join two lists, each list being a queue
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static inline void list_splice_tail(struct list_head *list,
+				struct list_head *head)
+{
+	if (!list_empty(list))
+		__list_splice(list, head->prev, head);
+}
+
+/**
+ * list_splice_init - join two lists and reinitialise the emptied list.
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ *
+ * The list at @list is reinitialised
+ */
+static inline void list_splice_init(struct list_head *list,
+				    struct list_head *head)
+{
+	if (!list_empty(list)) {
+		__list_splice(list, head, head->next);
+		INIT_LIST_HEAD(list);
+	}
+}
+
+/**
+ * list_splice_tail_init - join two lists and reinitialise the emptied list
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ *
+ * Each of the lists is a queue.
+ * The list at @list is reinitialised
+ */
+static inline void list_splice_tail_init(struct list_head *list,
+					 struct list_head *head)
+{
+	if (!list_empty(list)) {
+		__list_splice(list, head->prev, head);
+		INIT_LIST_HEAD(list);
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
+
+/**
+ * list_first_entry - get the first element from a list
+ * @ptr:	the list head to take the element from.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ *
+ * Note, that list is expected to be not empty.
+ */
+#define list_first_entry(ptr, type, member) \
+	list_entry((ptr)->next, type, member)
+
+/**
+ * list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop cursor.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+/**
+ * __list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop cursor.
+ * @head:	the head for your list.
+ *
+ * This variant doesn't differ from list_for_each() any more.
+ * We don't do prefetching in either case.
+ */
+#define __list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+/**
+ * list_for_each_prev	-	iterate over a list backwards
+ * @pos:	the &struct list_head to use as a loop cursor.
+ * @head:	the head for your list.
+ */
+#define list_for_each_prev(pos, head) \
+	for (pos = (head)->prev; pos != (head); pos = pos->prev)
+
+/**
+ * list_for_each_safe - iterate over a list safe against removal of list entry
+ * @pos:	the &struct list_head to use as a loop cursor.
+ * @n:		another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+
+/**
+ * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry
+ * @pos:	the &struct list_head to use as a loop cursor.
+ * @n:		another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define list_for_each_prev_safe(pos, n, head) \
+	for (pos = (head)->prev, n = pos->prev; \
+	     pos != (head); \
+	     pos = n, n = pos->prev)
+
+/**
+ * list_for_each_entry	-	iterate over list of given type
+ * @pos:	the type * to use as a loop cursor.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member);	\
+	     &pos->member != (head); 	\
+	     pos = list_entry(pos->member.next, typeof(*pos), member))
+
+/**
+ * list_for_each_entry_reverse - iterate backwards over list of given type.
+ * @pos:	the type * to use as a loop cursor.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_reverse(pos, head, member)			\
+	for (pos = list_entry((head)->prev, typeof(*pos), member);	\
+	     &pos->member != (head); 	\
+	     pos = list_entry(pos->member.prev, typeof(*pos), member))
+
+/**
+ * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()
+ * @pos:	the type * to use as a start point
+ * @head:	the head of the list
+ * @member:	the name of the list_struct within the struct.
+ *
+ * Prepares a pos entry for use as a start point in list_for_each_entry_continue().
+ */
+#define list_prepare_entry(pos, head, member) \
+	((pos) ? : list_entry(head, typeof(*pos), member))
+
+/**
+ * list_for_each_entry_continue - continue iteration over list of given type
+ * @pos:	the type * to use as a loop cursor.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ *
+ * Continue to iterate over list of given type, continuing after
+ * the current position.
+ */
+#define list_for_each_entry_continue(pos, head, member) 		\
+	for (pos = list_entry(pos->member.next, typeof(*pos), member);	\
+	     &pos->member != (head);	\
+	     pos = list_entry(pos->member.next, typeof(*pos), member))
+
+/**
+ * list_for_each_entry_continue_reverse - iterate backwards from the given point
+ * @pos:	the type * to use as a loop cursor.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ *
+ * Start to iterate over list of given type backwards, continuing after
+ * the current position.
+ */
+#define list_for_each_entry_continue_reverse(pos, head, member)		\
+	for (pos = list_entry(pos->member.prev, typeof(*pos), member);	\
+	     &pos->member != (head);	\
+	     pos = list_entry(pos->member.prev, typeof(*pos), member))
+
+/**
+ * list_for_each_entry_from - iterate over list of given type from the current point
+ * @pos:	the type * to use as a loop cursor.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ *
+ * Iterate over list of given type, continuing from current position.
+ */
+#define list_for_each_entry_from(pos, head, member) 			\
+	for (; &pos->member != (head);	\
+	     pos = list_entry(pos->member.next, typeof(*pos), member))
+
+/**
+ * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @pos:	the type * to use as a loop cursor.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		n = list_entry(pos->member.next, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+/**
+ * list_for_each_entry_safe_continue - continue list iteration safe against removal
+ * @pos:	the type * to use as a loop cursor.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ *
+ * Iterate over list of given type, continuing after current point,
+ * safe against removal of list entry.
+ */
+#define list_for_each_entry_safe_continue(pos, n, head, member) 		\
+	for (pos = list_entry(pos->member.next, typeof(*pos), member), 		\
+		n = list_entry(pos->member.next, typeof(*pos), member);		\
+	     &pos->member != (head);						\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+/**
+ * list_for_each_entry_safe_from - iterate over list from current point safe against removal
+ * @pos:	the type * to use as a loop cursor.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ *
+ * Iterate over list of given type from current point, safe against
+ * removal of list entry.
+ */
+#define list_for_each_entry_safe_from(pos, n, head, member) 			\
+	for (n = list_entry(pos->member.next, typeof(*pos), member);		\
+	     &pos->member != (head);						\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+/**
+ * list_for_each_entry_safe_reverse - iterate backwards over list safe against removal
+ * @pos:	the type * to use as a loop cursor.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ *
+ * Iterate backwards over list of given type, safe against removal
+ * of list entry.
+ */
+#define list_for_each_entry_safe_reverse(pos, n, head, member)		\
+	for (pos = list_entry((head)->prev, typeof(*pos), member),	\
+		n = list_entry(pos->member.prev, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = n, n = list_entry(n->member.prev, typeof(*n), member))
+
+/**
+ * list_safe_reset_next - reset a stale list_for_each_entry_safe loop
+ * @pos:	the loop cursor used in the list_for_each_entry_safe loop
+ * @n:		temporary storage used in list_for_each_entry_safe
+ * @member:	the name of the list_struct within the struct.
+ *
+ * list_safe_reset_next is not safe to use in general if the list may be
+ * modified concurrently (eg. the lock is dropped in the loop body). An
+ * exception to this is if the cursor element (pos) is pinned in the list,
+ * and list_safe_reset_next is called after re-taking the lock and before
+ * completing the current iteration of the loop body.
+ */
+#define list_safe_reset_next(pos, n, member)				\
+	n = list_entry(pos->member.next, typeof(*pos), member)
+
+/*
+ * Double linked lists with a single pointer list head.
+ * Mostly useful for hash tables where the two pointer list head is
+ * too wasteful.
+ * You lose the ability to access the tail in O(1).
+ */
+
+#define HLIST_HEAD_INIT { .first = NULL }
+#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }
+#define INIT_HLIST_HEAD(ptr) ((ptr)->first = NULL)
+static inline void INIT_HLIST_NODE(struct hlist_node *h)
+{
+	h->next = NULL;
+	h->pprev = NULL;
+}
+
+static inline int hlist_unhashed(const struct hlist_node *h)
+{
+	return !h->pprev;
+}
+
+static inline int hlist_empty(const struct hlist_head *h)
+{
+	return !h->first;
+}
+
+static inline void __hlist_del(struct hlist_node *n)
+{
+	struct hlist_node *next = n->next;
+	struct hlist_node **pprev = n->pprev;
+	*pprev = next;
+	if (next)
+		next->pprev = pprev;
+}
+
+static inline void hlist_del(struct hlist_node *n)
+{
+	__hlist_del(n);
+	n->next = NULL;//LIST_POISON1;
+	n->pprev = NULL;//LIST_POISON2;
+}
+
+static inline void hlist_del_init(struct hlist_node *n)
+{
+	if (!hlist_unhashed(n)) {
+		__hlist_del(n);
+		INIT_HLIST_NODE(n);
+	}
+}
+
+static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
+{
+	struct hlist_node *first = h->first;
+	n->next = first;
+	if (first)
+		first->pprev = &n->next;
+	h->first = n;
+	n->pprev = &h->first;
+}
+
+/* next must be != NULL */
+static inline void hlist_add_before(struct hlist_node *n,
+					struct hlist_node *next)
+{
+	n->pprev = next->pprev;
+	n->next = next;
+	next->pprev = &n->next;
+	*(n->pprev) = n;
+}
+
+static inline void hlist_add_after(struct hlist_node *n,
+					struct hlist_node *next)
+{
+	next->next = n->next;
+	n->next = next;
+	next->pprev = &n->next;
+
+	if(next->next)
+		next->next->pprev  = &next->next;
+}
+
+/* after that we'll appear to be on some hlist and hlist_del will work */
+static inline void hlist_add_fake(struct hlist_node *n)
+{
+	n->pprev = &n->next;
+}
+
+/*
+ * Move a list from one list head to another. Fixup the pprev
+ * reference of the first entry if it exists.
+ */
+static inline void hlist_move_list(struct hlist_head *old,
+				   struct hlist_head *cnew)
+{
+	cnew->first = old->first;
+	if (cnew->first)
+		cnew->first->pprev = &cnew->first;
+	old->first = NULL;
+}
+
+#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
+
+#define hlist_for_each(pos, head) \
+	for (pos = (head)->first; pos ; pos = pos->next)
+
+#define hlist_for_each_safe(pos, n, head) \
+	for (pos = (head)->first; pos && ({ n = pos->next; 1; }); \
+	     pos = n)
+
+/**
+ * hlist_for_each_entry	- iterate over list of given type
+ * @tpos:	the type * to use as a loop cursor.
+ * @pos:	the &struct hlist_node to use as a loop cursor.
+ * @head:	the head for your list.
+ * @member:	the name of the hlist_node within the struct.
+ */
+#define hlist_for_each_entry(tpos, pos, head, member)			 \
+	for (pos = (head)->first;					 \
+	     pos &&							 \
+		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+	     pos = pos->next)
+
+/**
+ * hlist_for_each_entry_continue - iterate over a hlist continuing after current point
+ * @tpos:	the type * to use as a loop cursor.
+ * @pos:	the &struct hlist_node to use as a loop cursor.
+ * @member:	the name of the hlist_node within the struct.
+ */
+#define hlist_for_each_entry_continue(tpos, pos, member)		 \
+	for (pos = (pos)->next;						 \
+	     pos &&							 \
+		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+	     pos = pos->next)
+
+/**
+ * hlist_for_each_entry_from - iterate over a hlist continuing from current point
+ * @tpos:	the type * to use as a loop cursor.
+ * @pos:	the &struct hlist_node to use as a loop cursor.
+ * @member:	the name of the hlist_node within the struct.
+ */
+#define hlist_for_each_entry_from(tpos, pos, member)			 \
+	for (; pos &&							 \
+		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+	     pos = pos->next)
+
+/**
+ * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @tpos:	the type * to use as a loop cursor.
+ * @pos:	the &struct hlist_node to use as a loop cursor.
+ * @n:		another &struct hlist_node to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the hlist_node within the struct.
+ */
+#define hlist_for_each_entry_safe(tpos, pos, n, head, member) 		 \
+	for (pos = (head)->first;					 \
+	     pos && ({ n = pos->next; 1; }) && 				 \
+		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+	     pos = n)
+
+#endif
diff --git a/bootable/recovery/pcba_core/rtc_test.cpp b/bootable/recovery/pcba_core/rtc_test.cpp
new file mode 100644
index 0000000000..08d61ba9c1
--- /dev/null
+++ b/bootable/recovery/pcba_core/rtc_test.cpp
@@ -0,0 +1,201 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <linux/rtc.h>
+#include <string>
+
+#include "common.h"
+#include "rtc_test.h"
+#include "test_case.h"
+#include "language.h"
+
+extern "C" {
+    #include "script.h"
+}
+
+using namespace std;
+
+int rtc_xopen(int flags)
+{
+    int rtc;
+    char major_rtc[] = "/dev/rtc";
+    char minor_rtc[] = "/dev/rtc0";
+
+    rtc = open(major_rtc, flags);
+    if (rtc < 0) {
+        rtc = open(minor_rtc, flags);
+        if (rtc < 0) {
+            printf("open %s failed:%s\n", minor_rtc,
+                   strerror(errno));
+        }
+    }
+
+    else {
+        printf("open %s\n", major_rtc);
+    }
+    return rtc;
+}
+
+int rtc_read_tm(struct tm *ptm, int fd)
+{
+    int ret;
+
+    memset(ptm, 0, sizeof(*ptm));
+
+    ret = ioctl(fd, RTC_RD_TIME, ptm);
+    if (ret < 0)
+    printf("read rtc failed:%s\n", strerror(errno));
+    else
+    ptm->tm_isdst = -1;	/* "not known" */
+
+    return ret;
+}
+
+static int read_rtc(time_t *time_p)
+{
+    int fd;
+    int ret;
+    struct tm tm_time;
+
+    fd = rtc_xopen(O_RDONLY);
+    if (fd < 0)
+    return fd;
+    else
+    ret = rtc_read_tm(&tm_time, fd);
+
+    close(fd);
+
+    if (ret < 0)
+    return ret;
+
+    else
+    *time_p = mktime(&tm_time);
+
+    return 0;
+}
+
+int get_system_time(char *dt)
+{
+    int ret;
+    int fd;
+    time_t t;
+    time_t timep;
+    struct tm *p;
+
+    ret = read_rtc(&timep);
+    if (ret < 0)
+    return ret;
+
+    else
+    p = localtime(&timep);
+    sprintf(dt, "%04d-%02d-%02d %02d:%02d:%02d", (1900 + p->tm_year),
+            (1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);
+
+    return 0;
+}
+
+int set_system_time(struct rtc_time *rtc_time)
+{
+    int ret;
+    int fd;
+
+    fd = open("/dev/rtc0", O_RDWR);
+    if (fd < 0) {
+        printf("open /dev/rtc0 failed:%s\n", strerror(errno));
+        return -1;
+    }
+    ret = ioctl(fd, RTC_SET_TIME, rtc_time);
+    if (ret < 0) {
+        printf("set rtc failed:%s\n", strerror(errno));
+        return -1;
+    }
+
+    close(fd);
+
+    return 0;
+}
+
+void *rtc_test(void *argc, display_callback *hook)
+{
+    struct testcase_info *tc_info = (struct testcase_info *)argc;
+    char dt[32] = { "20120926.132600" };
+    int ret, y;
+    struct tm tm;
+    struct timeval tv;
+    char *s;
+    int day, hour;
+    time_t t;
+    struct tm *p;
+    struct timespec ts;
+    struct rtc_time rtc;  
+
+    char msg[50];
+    snprintf(msg, sizeof(msg), "%s:[%s]", PCBA_RTC, PCBA_TESTING);
+    y = tc_info->y;
+    hook->handle_refresh_screen(tc_info->y, msg);
+    s = (char *)malloc(32);
+    if (script_fetch("rtc", "module_args", (int *)dt, 8) == 0)
+    strncpy(s, dt, 32);
+    day = atoi(s);
+    while (*s && *s != '.')
+    s++;
+    if (*s)
+    s++;
+    hour = atoi(s);
+
+    tm.tm_year = day / 10000 - 1900;
+    tm.tm_mon = (day % 10000) / 100 - 1;
+    tm.tm_mday = (day % 100);
+    tm.tm_hour = hour / 10000;
+    tm.tm_min = (hour % 10000) / 100;
+    tm.tm_sec = (hour % 100);
+    tm.tm_isdst = -1;
+    tv.tv_sec = mktime(&tm);
+    tv.tv_usec = 0;
+    printf("set rtc time :%lu\n", tv.tv_sec);
+    rtc.tm_sec = tm.tm_sec;
+    rtc.tm_min = tm.tm_min;
+    rtc.tm_hour = tm.tm_hour;
+    rtc.tm_mday = tm.tm_mday;
+    rtc.tm_mon = tm.tm_mon;
+    rtc.tm_year = tm.tm_year;
+
+    ret = set_system_time(&rtc);
+    if (ret < 0) {
+        printf("test rtc failed:set_system_time failed\n");
+        ret = -1;
+    } else {
+        usleep(1000000);
+
+        while (1) {
+            t = get_system_time(dt);
+            if (t < 0) {
+                ret = -1;
+                break;
+            }
+            p = localtime(&t);
+            char current_time[50];
+            snprintf(current_time, sizeof(current_time), "%s:[%s] { %04d/%02d/%02d %02d:%02d:%02d }",
+                    PCBA_RTC, PCBA_SECCESS,
+                    (1900 + p->tm_year),
+                    (1 + p->tm_mon), p->tm_mday,
+                    p->tm_hour, p->tm_min, p->tm_sec);
+            hook->handle_refresh_screen_hl(tc_info->y, current_time, false);
+            usleep(1000000);
+        }
+    }
+
+    if (ret == 0) {
+        tc_info->result = 0;
+    } else {
+        tc_info->result = -1;
+        snprintf(msg, sizeof(msg), "%s:[%s]", PCBA_RTC, PCBA_FAILED);
+        hook->handle_refresh_screen_hl(tc_info->y, msg, true);
+    }
+    return argc;
+}
diff --git a/bootable/recovery/pcba_core/rtc_test.h b/bootable/recovery/pcba_core/rtc_test.h
new file mode 100644
index 0000000000..a078b6787a
--- /dev/null
+++ b/bootable/recovery/pcba_core/rtc_test.h
@@ -0,0 +1,13 @@
+#ifndef __RTC_TEST_H_
+#define __RTC_TEST_H_
+
+#include "display_callback.h"
+
+void *rtc_test(void *argc, display_callback *hook);
+
+struct rtc_msg {
+	int result;
+	char *date;
+};
+
+#endif
diff --git a/bootable/recovery/pcba_core/sbin/busybox b/bootable/recovery/pcba_core/sbin/busybox
new file mode 100644
index 0000000000..b8dfdf6d22
Binary files /dev/null and b/bootable/recovery/pcba_core/sbin/busybox differ
diff --git a/bootable/recovery/pcba_core/screen_test.c b/bootable/recovery/pcba_core/screen_test.c
new file mode 100644
index 0000000000..e8d05acc6c
--- /dev/null
+++ b/bootable/recovery/pcba_core/screen_test.c
@@ -0,0 +1,188 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "screen_test.h"
+#include "test_case.h"
+#include "common.h"
+#include "language.h"
+#include <minui.h>
+
+#include <linux/input.h>
+#include "script.h"
+
+/*  variable for test_config.cfg  */
+int key_times;
+int all_key_change;
+unsigned int start_key;
+
+unsigned int code_tmp = 0;
+unsigned int picture_change_key;
+
+unsigned char code_cnt = 0;
+unsigned char screen_start = 0;
+
+int w1, h1, lcd_y;
+
+void screen_change(uint8_t screen_cnt)
+{
+	switch (screen_cnt) {
+	case  0:
+		FillColor(255, 0, 0, 255, 0, 0, w1, h1);/*red*/
+		break;
+	case  1:
+		tiles_count--;
+		FillColor(0, 255, 0, 255, 0, 0, w1, h1);/*green*/
+		break;
+	case  2:
+		tiles_count--;
+		FillColor(0, 0, 255, 255, 0, 0, w1, h1);/*blue*/
+		break;
+	case  3:
+		tiles_count--;
+		FillColor(0, 0, 0, 255, 0, 0, w1, h1);/*black*/
+		break;
+	case  4:
+		tiles_count--;
+		FillColor(255, 255, 255, 255, 0, 0, w1, h1);/*white*/
+		break;
+	case  5:
+		tiles_count--;
+		ui_print_xy_rgba(0, lcd_y, 0, 255, 0, 255,
+			"%s:[%s]\n", PCBA_LCD, PCBA_TESTED);
+		break;
+	default:
+		screen_start = 0;
+		ui_print_xy_rgba(0, lcd_y, 0, 255, 0, 255,
+			"%s:[%s]\n", PCBA_LCD, PCBA_TESTED);
+		break;
+	}
+	/*printf("-----------%s--%s---screen_cnt=%d----------\n",
+		__FILE__,__FUNCTION__,screen_cnt);*/
+}
+
+unsigned int get_key_code(char *key_char)
+{
+	if (!strcmp(key_char, "KEY_VOLUMEDOWN"))
+		return KEY_VOLUMEDOWN;
+	else if (!strcmp(key_char, "KEY_VOLUMEUP"))
+		return KEY_VOLUMEUP;
+	else if (!strcmp(key_char, "KEY_POWER"))
+		return KEY_POWER;
+	else if (!strcmp(key_char, "KEY_F1"))
+		return KEY_F1;
+	else if (!strcmp(key_char, "KEY_HOME"))
+		return KEY_HOME;
+	else if (!strcmp(key_char, "KEY_BACK"))
+		return KEY_BACK;
+	else if (!strcmp(key_char, "KEY_UP"))
+		return KEY_UP;
+	else if (!strcmp(key_char, "KEY_DOWN"))
+		return KEY_DOWN;
+	else if (!strcmp(key_char, "KEY_LEFT"))
+		return KEY_LEFT;
+	else if (!strcmp(key_char, "KEY_RIGHT"))
+		return KEY_RIGHT;
+	else if (!strcmp(key_char, "KEY_MENU"))
+		return KEY_MENU;
+	else if (!strcmp(key_char, "KEY_ENTER"))
+		return KEY_ENTER;
+	else if (!strcmp(key_char, "KEY_ALL"))
+		return 0;
+	else {
+		printf("un supported key:%s\n", key_char);
+		return 0;
+	}
+}
+
+/*  key detect
+*   start the test and change the picture
+*/
+void screenTest_key_detect(unsigned int code)
+{
+	if (!screen_start) {
+		if (code != code_tmp) {
+			code_tmp = code;
+			code_cnt = 0;
+		} else {
+			if ((!start_key) || (code == start_key)) {
+				if (++code_cnt >= (key_times-1)) {
+					picture_change_key = code;
+					screen_start = 1;
+					code_cnt = 0;
+					screen_change(code_cnt);
+				}
+			}
+		}
+	} else {
+		if ((code == picture_change_key) || all_key_change) {
+			code_cnt++;
+			screen_change(code_cnt);
+			if (code_cnt >= 5) {
+				code_cnt = 0;
+				screen_start = 0;
+				code_tmp = !code;
+			}
+		}
+	}
+}
+
+void *screen_test(void *argv)
+{
+	struct testcase_info *tc_info = (struct testcase_info *)argv;
+	char key_name[16];
+
+	if (script_fetch("Lcd", "start_key", (int *)key_name, 4) != 0) {
+			printf("%s: key_times err : %s !!!\r\n",
+				__func__, key_name);
+			strcpy(key_name, "KEY_ALL");
+	}
+	printf("=========== code_cnt is:   %d ==========\n", code_cnt);
+	start_key = get_key_code(key_name);
+
+	if (script_fetch("Lcd", "key_times", &key_times, 1) != 0) {
+			printf("%s: key_times err : %d !!!\r\n",
+				__func__, key_times);
+			key_times = 3;
+	}
+	if (script_fetch("Lcd", "all_key_change", &all_key_change, 1) != 0) {
+			printf("%s: all_key_change err : %d !!!\r\n",
+				__func__, all_key_change);
+			all_key_change = 0;
+	}
+
+	w1 =  gr_fb_width();
+	h1 =  gr_fb_height();
+
+	if (tc_info->y <= 0)
+		tc_info->y = get_cur_print_y();
+
+	ui_print_xy_rgba(0, tc_info->y, 255, 255, 0, 255, "%s\n", PCBA_LCD);
+	lcd_y = tc_info->y;
+	int x,y,w,h;
+	x = gr_fb_width();
+	y = gr_fb_height();
+	if (x > y) {
+		x = gr_fb_width() - gr_fb_height()/3;
+		y = 0;
+		w = gr_fb_height()/3;
+		h = gr_fb_height()/3;
+
+		FillColor(255, 0, 0, 255, x, y, w, h);
+		FillColor(0, 255, 0, 255, x, y+h, w, h);
+		FillColor(0, 0, 255, 255, x, y+(2*h), w, h);
+	} else {
+		x = 0;
+		y = gr_fb_height() - gr_fb_width()/3;;
+		w = gr_fb_width()/3;
+		h = gr_fb_width()/3;
+
+		FillColor(255, 0, 0, 255, x, y, w, h);
+		FillColor(0, 255, 0, 255, x+w, y, w, h);
+		FillColor(0, 0, 255, 255, x+(2*w), y, w, h);
+	}
+	sleep(3);
+
+	tc_info->result = 0;
+	return argv;
+}
+
diff --git a/bootable/recovery/pcba_core/screen_test.h b/bootable/recovery/pcba_core/screen_test.h
new file mode 100644
index 0000000000..d88f363deb
--- /dev/null
+++ b/bootable/recovery/pcba_core/screen_test.h
@@ -0,0 +1,19 @@
+#ifndef _SCREEN_TEST_H_
+#define _SCREEN_TEST_H_
+
+void *screen_test(void *argc);
+void screenTest_key_detect(unsigned int code);
+
+extern uint8_t key_press;
+extern int tiles_count;
+
+struct  screen_msg {
+	int result;
+	int x;
+	int y;
+	int w;
+	int h;
+};
+
+#endif
+
diff --git a/bootable/recovery/pcba_core/script.c b/bootable/recovery/pcba_core/script.c
new file mode 100644
index 0000000000..3b4301ca9a
--- /dev/null
+++ b/bootable/recovery/pcba_core/script.c
@@ -0,0 +1,171 @@
+
+
+#include <sys/types.h>
+#include <sys/ipc.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+//#include "shm.h"
+#include "script.h"
+#include "debug.h"
+
+
+#define DATA_TYPE_SINGLE_WORD           1
+#define DATA_TYPE_STRING                2
+#define DATA_TYPE_MULTI_WORD            3
+#define DATA_TYPE_GPIO                  4
+
+struct script_head
+{
+    int mainkey_cnt;
+    int version[3];
+};
+
+struct script_mainkey
+{
+    char name[32];
+    int length;
+    int offset;
+};
+
+struct script_subkey
+{
+    char name[32];
+    int offset;
+    int pattern;
+};
+
+static char *script_buf = NULL;
+static int mainkey_cnt = 0;
+
+int init_script(char* buf)
+{
+#if 0
+    script_buf = shmat(shmid, 0, 0);
+    if (script_buf == (void *)-1) {
+        db_error("script: attach the share memory segment failed(%s)\n", 
+                strerror(errno));
+        return -1;
+    }
+#else
+   script_buf = buf;
+#endif
+    struct script_head *head = (struct script_head *)script_buf;
+
+    mainkey_cnt = head->mainkey_cnt;
+    db_debug("script: main key count #%d\n", mainkey_cnt);
+    db_msg("script: V%d.%d.%d\n", head->version[0], 
+            head->version[1], head->version[2]);
+
+    return 0;
+}
+
+void deinit_script(void)
+{
+    if (script_buf) {
+       // shmdt(script_buf);
+        script_buf = NULL;
+    }
+
+    mainkey_cnt = 0;
+}
+
+int script_mainkey_cnt(void)
+{
+    return mainkey_cnt;
+}
+
+int script_mainkey_name(int idx, char *name)
+{
+    struct script_mainkey *mainkey;
+
+    if (script_buf == NULL) {
+        return -1;
+    }
+
+    mainkey = (struct script_mainkey *)(script_buf + sizeof(struct script_head) + 
+            idx * sizeof(struct script_mainkey));
+
+    strncpy(name, mainkey->name, 32);
+
+    return 0;
+}
+
+int script_fetch(char *main_name, char *sub_name, int value[], int count)
+{
+    int i, j;
+    struct script_mainkey *mainkey;
+    struct script_subkey *subkey;
+    int pattern, wordcnt;
+    
+    /* check parameter */
+    if (script_buf == NULL) {
+        return -1;
+    }
+
+    if (main_name == NULL || sub_name == NULL) {
+        return -1;
+    }
+
+    if (value == NULL) {
+        return -1;
+    }
+
+    memset(value, 0, sizeof(int) * count);
+
+    /* search main key */
+    for (i = 0; i < mainkey_cnt; i++) {
+        mainkey = (struct script_mainkey *)(script_buf + 
+                sizeof(struct script_head) + i * sizeof(struct script_mainkey));
+        if (strncmp(mainkey->name, main_name, 31)) {
+            continue;
+        }
+
+        /* search sub key */
+        for (j = 0; j < mainkey->length; j++) {
+            subkey = (struct script_subkey *)(script_buf + 
+                     (mainkey->offset << 2) + 
+                     (j * sizeof(struct script_subkey)));
+            if (strncmp(subkey->name, sub_name, 31)) {
+                continue;
+            }
+
+            pattern = (subkey->pattern >> 16) & 0xffff;
+            wordcnt = subkey->pattern & 0xffff;
+
+            switch (pattern) {
+                case DATA_TYPE_SINGLE_WORD:
+                    value[0] = *(int *)(script_buf + (subkey->offset << 2));
+                    break;
+
+                case DATA_TYPE_STRING:
+                    if (wordcnt == 0)
+                        break;
+
+                    if (wordcnt > count)
+                        wordcnt = count;
+
+                    memcpy((char *)value, script_buf + (subkey->offset << 2),
+                            wordcnt << 2);
+                    break;
+
+                case DATA_TYPE_GPIO:
+                    db_debug("%s: L%d fix me\n", __func__, __LINE__);
+                    break;
+
+                default:
+                    db_debug("%s: L%d fix me\n", __func__, __LINE__);
+                    break;
+            }
+
+            return 0;
+        }
+    }
+
+    return -1;
+}
+
diff --git a/bootable/recovery/pcba_core/script.h b/bootable/recovery/pcba_core/script.h
new file mode 100644
index 0000000000..1f61d21957
--- /dev/null
+++ b/bootable/recovery/pcba_core/script.h
@@ -0,0 +1,50 @@
+
+#ifndef __SCRIPT_H__
+#define __SCRIPT_H__
+
+struct script_gpio_set
+{
+    char name[32];
+    int port;
+    int port_num;
+    int mul_sel;
+    int pull;
+    int drv_level;
+    int data;
+};
+
+/*
+ * init script. called before other function.
+ * \param shmid.
+ */
+int init_script(char* shmid);
+
+/*
+ * deinit script.
+ */
+void deinit_script(void);
+
+/*
+ * get the number of main key in script.
+ */
+int script_mainkey_cnt(void);
+
+/*
+ * get the name of specified index main key.
+ */
+int script_mainkey_name(int idx, char *name);
+
+/* 
+ * fetch word, string, gpio from script.
+ */
+int script_fetch(char *main_name, char *sub_name, int value[], int count);
+
+/*
+ * fetch gpio set from script.
+ */
+int script_fetch_gpio_set(char *main_name, struct script_gpio_set *gpio_set, 
+        int gpio_cnt);
+
+
+#endif /* __SCRIPT_H__ */
+
diff --git a/bootable/recovery/pcba_core/script_parser.c b/bootable/recovery/pcba_core/script_parser.c
new file mode 100644
index 0000000000..80bdbf2c2e
--- /dev/null
+++ b/bootable/recovery/pcba_core/script_parser.c
@@ -0,0 +1,734 @@
+
+#include <sys/types.h>
+#include <ctype.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "script_parser.h"
+#include "debug.h"
+
+
+#define ITEM_NAME_MAX_LEN               32
+
+#define KEY_MAX_LEN                     32
+#define VALUE_MAX_LEN                   128
+
+#define ITEM_MAX_COUNT                  128
+
+#define LINE_MAX_LEN                    512
+
+#define LINE_ERROR                      -1
+#define LINE_COMMENT                    0
+#define LINE_NULL                       1
+#define LINE_MAINKEY                    2
+#define LINE_SUBKEY                     3
+
+#define DATA_TYPE_SINGLE_WORD           1
+#define DATA_TYPE_STRING                2
+#define DATA_TYPE_MULTI_WORD            3
+#define DATA_TYPE_GPIO                  4
+
+struct script_head
+{
+    int mainkey_cnt;
+    int version[3];
+};
+
+struct script_item
+{
+    char name[32];
+    int length;
+    int offset;
+};
+
+/*
+ * get value data type.
+ */
+static int __get_str2int(char *buf, int value[])
+{
+    char *src;
+    char ch;
+    unsigned int temp;
+    int sign;
+    int i;
+    int idx;
+    char str[128];
+
+    src = buf;
+
+    if (strncasecmp(src, "port:p", 6) == 0) {
+        /* handle gpio */
+        src += 6;
+        if (strncasecmp(src, "ower", 4) == 0) {
+            value[0] = 0xffff;
+            src += 4;
+        }
+        else {
+            ch = *src++;
+            if (islower(ch))
+                value[0] = ch - 'a' + 1;
+            else if (isupper(ch))
+                value[0] = ch - 'A' + 1;
+            else
+                return -1;
+        }
+
+        temp = 0;
+        ch = *src++;
+        while (ch != '<') {
+            if (isdigit(ch)) {
+                temp = temp * 10 + (ch - '0');
+                ch = *src++;
+            }
+            else if (ch == '\0') {
+                src--;
+                break;
+            }
+            else {
+                return -1;
+            }
+        }
+        value[1] = temp;
+
+        idx = 2;
+        ch = *src++;
+        while (ch != '\0') {
+            i = 0;
+            memset(str, 0, sizeof(str));
+            while (ch != '>') {
+                if (isupper(ch))
+                    ch = tolower(ch);
+                str[i++] = ch;
+                ch = *src++;
+            }
+
+            if (strcmp(str, "default") == 0 || 
+                strcmp(str, "none") == 0 || 
+                strcmp(str, "null") == 0 || 
+                strcmp(str, "-1") == 0) {
+                value[idx] = -1;
+            }
+            else {
+                i = 0;
+                ch = str[i++];
+                temp = 0;
+                if (ch == '-') {
+                    sign = -1;
+                    ch = str[i++];
+                }
+                else {
+                    sign = 1;
+                }
+
+                while (ch != '\0') {
+                    if (isdigit(ch))
+                        temp = temp * 10 + (ch - '0');
+                    else
+                        return -1;
+
+                    ch = str[i++];
+                }
+
+                value[idx] = temp * sign;
+            }
+
+            idx++;
+            ch = *src++;
+            if (ch == '<') {
+                ch = *src++;
+            }
+            else if (ch == '\0') {
+                ;
+            }
+            else {
+                return -1;
+            }
+        }
+
+        switch (idx) {
+            case 3:
+                value[3] = -1;
+            case 4:
+                value[4] = -1;
+            case 5:
+                value[5] = -1;
+            case 6:
+                break;
+            default:
+                return -1;
+        }
+
+        return DATA_TYPE_GPIO;
+    }
+    else if (strncasecmp(src, "string:", 7) == 0) {
+        src += 7;
+        idx = 0;
+        while (src[idx] != '\0') {
+            idx++;
+            if (idx > 127)
+                break;
+        }
+
+        if (idx & 0x03)
+            idx = (idx & (~0x03)) + 4;
+
+        value[0] = idx >> 2;
+        value[1] = 1;
+
+        return DATA_TYPE_STRING;
+    }
+    else if (src[0] == '"') {
+        src += 1;
+        idx = 0;
+        while (src[idx] != '"') {
+            idx++;
+            if (idx > 127)
+                break;
+        }
+
+        src[idx] = '\0';
+        if (idx & 0x03)
+            idx = (idx & (~0x03)) + 4;
+        
+        value[0] = idx >> 2;
+        value[1] = 2;
+
+        return DATA_TYPE_STRING;
+    }
+    else if (isdigit(src[0]) && (src[1] == 'x' || src[2] == 'X')) {
+        temp = 0;
+        ch = *src++;
+        while (ch != '\0') {
+            if (isdigit(ch)) {
+                temp = temp * 16 + (ch - '0');
+                ch = *src++;
+            }
+            else if (isupper(ch)) {
+                temp = temp * 16 + (ch - 'A' + 10);
+                ch = *src++;
+            }
+            else if (islower(ch)) {
+                temp = temp * 16 + (ch - 'a' + 10);
+                ch = *src++;
+            }
+            else {
+                break;
+            }
+        }
+        value[0] = temp;
+
+        return DATA_TYPE_SINGLE_WORD;
+    }
+    else if (isdigit(src[0]) || 
+            (isdigit(src[1]) && src[0] == '-')) {
+        if (src[0] == '-') {
+            sign = -1;
+            ch = *src++;
+        }
+        else {
+            sign = 1;
+        }
+
+        temp = 0;
+        ch = *src++;
+        while (ch != '\0') {
+            if (isdigit(ch)) {
+                temp = temp * 10 + (ch - '0');
+                ch = *src++;
+            }
+            else {
+                break;
+            }
+        }
+        value[0] = temp * sign;
+
+        return DATA_TYPE_SINGLE_WORD;
+    }
+    else {
+        idx = 0;
+        while (src[idx] != '\0') {
+            idx++;
+            if (idx > 127)
+                break;
+        }
+
+        if (idx & 0x03)
+            idx = (idx & (~0x03)) + 4;
+
+        value[0] = idx >> 2;
+
+        return DATA_TYPE_STRING;
+    }
+}
+
+/*
+ * get key[32] and value[128], end with '\0'.
+ * \retval -1 empty line.
+ * \retval 0 OK
+ */
+static int __get_key_value(char *buf, char *key, char *value)
+{
+    char *src;
+    int key_idx;
+    int value_idx;
+
+    /* check line */
+    src = buf;
+    key_idx = value_idx = 0;
+    while (1) {
+        if (*src == ' ' || *src == '\t') {
+            src++;
+        }
+        else if (*src == 0x0a || *src == 0x0d) {
+            key[key_idx] = '\0';
+            value[value_idx] = '\0';
+            return -1;
+        }
+        else {
+            break;
+        }
+    }
+
+    /* get key */
+    while (*src != '=') {
+        key[key_idx++] = *src++;
+        if (key_idx >= 31) {
+            key[key_idx] = '\0';
+            break;
+        }
+    }
+
+    for (key_idx--; key_idx > 0; key_idx--) {
+        if (key[key_idx] == ' ' || key[key_idx] == '\t') {
+            key[key_idx] = '\0';
+        }
+        else {
+            key[key_idx + 1] = '\0';
+            break;
+        }
+    }
+
+    for (; *src != '='; src++);
+
+    /* check line */
+    src++;
+    while (1) {
+        if (*src == ' ' || *src == '\t') {
+            src++;
+        }
+        else if (*src == 0x0a || *src == 0x0d) {
+            value[value_idx] = '\0';
+            return 0;
+        }
+        else {
+            break;
+        }
+    }
+
+    /* get value */
+    while (*src != 0x0a && *src != 0x0d) {
+        value[value_idx++] = *src++;
+        if (value_idx >= 127) {
+            value[value_idx] = '\0';
+            break;
+        }
+    }
+
+    for (value_idx--; value_idx > 0; value_idx--) {
+        if (value[value_idx] == ' ' || value[value_idx] == '\t') {
+            value[value_idx] = '\0';
+        }
+        else {
+            value[value_idx + 1] = '\0';
+            break;
+        }
+    }
+
+    return 0;
+}
+
+static int __fill_mainkey(char *buf, struct script_item *item)
+{
+    char *src;
+    char ch;
+    int i;
+
+    src = buf + 1;
+    for (ch = *src++, i = 0; ch != ']'; i++, ch = *src++) {
+        item->name[i] = ch;
+        if (i + 1 >= ITEM_NAME_MAX_LEN) {
+            item->name[i] = '\0';
+            break;
+        }
+    }
+
+    if (item->name[0] == '\0')
+        return -1;
+
+    return 0;
+}
+
+static int __getline(char *buf, int len, int *flag)
+{
+    char *src;
+    char ch;
+    char prev_ch;
+    int line_len;
+
+    /* get line flag */
+    src = buf;
+    ch = *src++;
+    switch (ch) {
+        case ';':
+            *flag = LINE_COMMENT;
+            break;
+
+        case 0x0a:
+        case 0x0d:
+            *flag = LINE_NULL;
+            break;
+
+        case '[':
+            *flag = LINE_MAINKEY;
+            break;
+
+        default:
+            *flag = LINE_SUBKEY;
+            break;
+    }
+
+    /* get line length */
+    if (*flag == LINE_NULL) {
+        ch = *src++;
+        if (ch == 0x0a)
+            return 2;
+        else
+            return 1;
+    }
+
+    ch = *src++;
+    line_len = 1;
+    while (line_len < len) {
+        if (ch == 0x0a || ch == 0x0d)
+            break;
+
+        ch = *src++;
+        line_len++;
+        if (line_len >= LINE_MAX_LEN) {
+            *flag = LINE_ERROR;
+            return 0;
+        }
+    }
+    line_len++;
+
+    prev_ch = ch;
+    ch = *src++;
+    if (prev_ch == 0x0d) {
+        if (ch == 0x0a)
+            line_len++;
+    }
+
+    return line_len;
+}
+
+static char*  __parse_script(char *buf, int len)
+{
+    char *src;
+    int rest_len, line_num;
+    struct script_item *item_table = NULL;
+    struct script_head head;
+    unsigned int mainkey_idx, subkey_idx;
+    int new_mainkey;
+    char key[KEY_MAX_LEN];
+    char value[VALUE_MAX_LEN];
+    char *key_data = NULL, *key_addr;
+    int *value_data = NULL, *value_addr;
+    int value_idx;
+    int fmt_value[8];
+    unsigned int i;
+    int ret;
+    char *script_buf, *pos;
+
+    db_debug("the length of script is %d\n", len);
+
+    /* allocate memory for key and value */
+    item_table = malloc(sizeof(struct script_item) * ITEM_MAX_COUNT);
+    if (item_table == NULL) {
+        db_debug("allocate memory for main key failed(%s)\n", strerror(errno));
+        ret = -1;
+        goto out;
+    }
+    memset(item_table, 0, sizeof(struct script_item) * ITEM_MAX_COUNT);
+
+    key_data = malloc(512 * 1024);
+    if (key_data == NULL) {
+        db_debug("allocate memory for key data failed(%s)\n", strerror(errno));
+        ret = -1;
+        goto out;
+    }
+    memset(key_data, 0, 512 * 1024);
+    key_addr = key_data;
+
+    value_data = malloc(512 * 1024);
+    if (value_data == NULL) {
+        db_debug("allocate memory for value data failed(%s)\n", 
+                strerror(errno));
+        ret = -1;
+        goto out;
+    }
+    memset(value_data, 0, 512 * 1024);
+    value_addr = value_data;
+
+    /* parse script main loop */
+    src = buf;
+    rest_len = len;
+    mainkey_idx = subkey_idx = value_idx = 0;
+    new_mainkey = 0;
+    line_num = 0;
+    while (rest_len) {
+        int line_len;
+        int flag;
+        
+        /* get current line */
+        line_len = __getline(src, rest_len, &flag);
+        rest_len -= line_len;
+        line_num++;
+        switch (flag) {
+            case LINE_COMMENT:
+            case LINE_NULL:
+                break;
+
+            case LINE_MAINKEY:
+                /* get main key */
+                if (__fill_mainkey(src, &item_table[mainkey_idx])) {
+                    ret = -1;
+                    goto out;
+                }
+
+                if (new_mainkey) {
+                    item_table[mainkey_idx].offset = 
+                        item_table[mainkey_idx-1].offset + 
+                        item_table[mainkey_idx-1].length * 10;
+                }
+                else {
+                    /* first main key */
+                    new_mainkey = 1;
+                    item_table[mainkey_idx].offset = 0;
+                }
+
+                mainkey_idx++;
+                break;
+
+            case LINE_SUBKEY:
+                /* get key[32] and value[128] */
+                memset(key, 0, KEY_MAX_LEN);
+                memset(value, 0, VALUE_MAX_LEN);
+                ret = __get_key_value(src, key, value);
+                if (ret == -1)
+                    continue;
+
+                /* stores key[32], stores value's offset in the next 4 bytes, 
+                 * stores value's length[31;16] and type[0:15] in the next 
+                 * next 4 bytes. there are total 40 bytes for one key data.
+                 *
+                 * the unit of value data length is int
+                 */
+                strcpy(key_addr, key);
+                key_addr += KEY_MAX_LEN;
+
+                /* get value data type */
+                memset(fmt_value, 0, sizeof(int) * 8);
+                ret = __get_str2int(value, fmt_value);
+                switch (ret) {
+                    case DATA_TYPE_SINGLE_WORD:
+                        *value_addr = fmt_value[0];
+                        *(unsigned int *)key_addr = value_idx;
+                        key_addr += 4;
+                        *(unsigned int *)key_addr = (1 << 0) | 
+                            (DATA_TYPE_SINGLE_WORD << 16);
+                        value_addr++;
+                        value_idx++;
+                        break;
+
+                    case DATA_TYPE_STRING:
+                        if (fmt_value[0]) {
+                            if (fmt_value[1] == 1) {
+                                strncpy((char *)value_addr, value + 
+                                        sizeof("string:") - 1, fmt_value[0] << 2);
+                            }
+                            else if (fmt_value[1] == 2) {
+                                strncpy((char *)value_addr, value + 1, 
+                                        fmt_value[0] << 2);
+                            }
+                            else{
+                                strncpy((char *)value_addr, value, 
+                                        fmt_value[0] << 2);
+                            }
+                        }
+
+                        *(unsigned int *)key_addr = value_idx;
+                        key_addr += 4;
+                        *(unsigned int *)key_addr = (fmt_value[0] << 0) | 
+                            (DATA_TYPE_STRING << 16);
+                        value_addr += fmt_value[0];
+                        value_idx += fmt_value[0];
+                        break;
+
+                    case DATA_TYPE_GPIO:
+                        for (i = 0; i < 6; i++)
+                            *value_addr++ = fmt_value[i];
+                        *(unsigned int *)key_addr = value_idx;
+                        key_addr += 4;
+                        *(unsigned int *)key_addr = (6 << 0) | 
+                            (DATA_TYPE_GPIO << 16);
+                        value_idx += 6;
+                        break;
+
+                    default:
+                        db_debug("%s: L%d: fix me\n", __func__, __LINE__);
+                }
+
+                subkey_idx++;
+                key_addr += 4;
+                item_table[mainkey_idx - 1].length++;
+                break;
+
+            default:
+                db_debug("script format error at line %d\n", line_num);
+                ret = -1;
+                goto out;
+        }
+
+        src += line_len;
+    }
+
+    if (mainkey_idx <= 0) {
+        db_debug("mainkey_idx = %d\n", mainkey_idx);
+        ret = -1;
+        goto out;
+    }
+
+    /* recalc first subkey offset */
+    for (i = 0; i < mainkey_idx; i++) {
+        item_table[i].offset += (sizeof(struct script_head) >> 2) + 
+            ((sizeof(struct script_item) * mainkey_idx) >> 2);
+    }
+
+    /* recalc every subkey offset */
+    key_addr = key_data;
+    i = 0;
+    while (i < subkey_idx * 10 * sizeof(int)) {
+        key_addr += ITEM_NAME_MAX_LEN;
+        *(unsigned int *)key_addr += (sizeof(struct script_head) >> 2) + 
+            ((sizeof(struct script_item) * mainkey_idx) >> 2) + 
+            (subkey_idx * 10);
+        i += 10 * sizeof(int); /* the sizeof each subkey data */
+        key_addr += 8;
+    }
+
+    /* init script head */
+    head.mainkey_cnt = mainkey_idx;
+    head.version[0] = SCRIPT_VERSION0;
+    head.version[1] = SCRIPT_VERSION1;
+    head.version[2] = SCRIPT_VERSION2;
+
+    /* allocate share memory segment for script buffer */
+    i = sizeof(struct script_head) + sizeof(struct script_item) * 
+        mainkey_idx + 10 * sizeof(int) * subkey_idx + sizeof(int) * value_idx;
+    #if 0
+    shmid = shmget(IPC_PRIVATE, i, IPC_CREAT | 0666);
+    if (shmid == -1) {
+        db_debug("allocate share memory segment for script buffer "
+                "failed(%s)\n", strerror(errno));
+        ret = -1;
+        goto out;
+    }
+    db_debug("script shmid = %d\n", shmid);
+
+    script_buf = pos = shmat(shmid, 0, 0);
+    if (script_buf == (void *)-1) {
+        db_debug("attach the share memory segment failed(%s)\n", 
+                strerror(errno));
+        shmctl(shmid, IPC_RMID, 0);
+        ret = -1;
+        goto out;
+    }
+#else
+	script_buf = pos =  malloc(i);
+#endif
+    /* stores script buffer */
+    memcpy(pos, &head, sizeof(struct script_head));
+    pos += sizeof(struct script_head);
+    memcpy(pos, item_table, sizeof(struct script_item) * mainkey_idx);
+    pos += sizeof(struct script_item) * mainkey_idx;
+    memcpy(pos, key_data, 10 * sizeof(int) * subkey_idx);
+    pos += 10 * sizeof(int) * subkey_idx;
+    memcpy(pos, value_data, sizeof(int) * value_idx);
+
+    //shmdt(script_buf);
+  //  ret = shmid;
+  return script_buf;
+
+out:
+    /* free memory */
+    if (item_table)
+        free(item_table);
+    if (key_data)
+        free(key_data);
+    if (value_data)
+        free(value_data);
+
+    return NULL;
+}
+
+char * parse_script(const char *name)
+{
+    FILE *fscript;
+    int len;
+    char *buf;
+    int read_len;
+    char *script_buf;
+
+    if (name == NULL) {
+        db_error("script: invalid file name(null)\n");
+        return NULL;
+    }
+
+    /* read script data */
+    fscript = fopen(name, "rb");
+    if (fscript == NULL) {
+        db_error("script: can't open %s(%s)\n", name, strerror(errno));
+        return NULL;
+    }
+
+    fseek(fscript, 0, SEEK_END);
+    len = ftell(fscript);
+    fseek(fscript, 0, SEEK_SET);
+ 
+    buf = malloc(len);
+    if (buf == NULL) {
+        db_error("script: allocate memory for script data failed(%s)\n", 
+                strerror(errno));
+        fclose(fscript);
+        return NULL;
+    }
+
+    read_len = fread(buf, 1, len, fscript);
+    if (read_len < len) {
+        db_debug("len = %d, read_len = %d, fix me\n", len, read_len);
+    }
+    fclose(fscript);
+
+    /* parse script */
+    script_buf = __parse_script(buf, len);
+    free(buf);
+
+    return script_buf;
+}
+
+void deparse_script()
+{
+    //shmctl(shmid, IPC_RMID, 0);
+}
diff --git a/bootable/recovery/pcba_core/script_parser.h b/bootable/recovery/pcba_core/script_parser.h
new file mode 100644
index 0000000000..4ef2b065f8
--- /dev/null
+++ b/bootable/recovery/pcba_core/script_parser.h
@@ -0,0 +1,21 @@
+
+#ifndef __SCRIPT_PARSER_H__
+#define __SCRIPT_PARSER_H__
+
+#define SCRIPT_VERSION0                 1
+#define SCRIPT_VERSION1                 0
+#define SCRIPT_VERSION2                 0
+
+/*
+ * init script. called before other function.
+ * \param name the name of script.
+ * \return the id of script share memory segment, on error -1 is returned.
+ */
+char* parse_script(const char *name);
+
+/*
+ * deparse script.
+ */
+void deparse_script();
+
+#endif /* __SCRIPT_PARSER_H__ */
diff --git a/bootable/recovery/pcba_core/sdcard_test.cpp b/bootable/recovery/pcba_core/sdcard_test.cpp
new file mode 100644
index 0000000000..e9a89ae664
--- /dev/null
+++ b/bootable/recovery/pcba_core/sdcard_test.cpp
@@ -0,0 +1,73 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <android-base/logging.h>
+
+#include "extra-functions.h"
+#include "common.h"
+#include "sdcard_test.h"
+#include "test_case.h"
+#include "language.h"
+
+#define LOG_TAG	"[sdcard]: "
+#define LOG(x...)	printf(LOG_TAG x)
+
+#define SCAN_RESULT_LENGTH	128
+#define SCAN_RESULT_FILE	"/data/sd_capacity"
+#define SD_INSERT_RESULT_FILE	"/data/sd_insert_info"
+
+void *sdcard_test(void *argv, display_callback *hook)
+{
+    struct testcase_info *tc_info = (struct testcase_info *)argv;
+    int ret, y;
+    double cap;
+    FILE *fp;
+    char results[SCAN_RESULT_LENGTH];
+
+    LOG("start sdcard test.");
+    hook->handle_refresh_screen(tc_info->y, PCBA_SDCARD);
+
+    #if defined(RK3288_PCBA)
+    ret = system("busybox chmod 777 /pcba/emmctester.sh");
+    #else
+    ret = system("busybox chmod 777 /pcba/mmctester.sh");
+    #endif
+
+    if (ret) PLOG(ERROR) << "chmod mmctester.sh failed :" << ret;
+
+    #if defined(RK3288_PCBA)
+    ret = system("/pcba/emmctester.sh");
+    #else
+    ret = system("/pcba/mmctester.sh");
+    #endif
+    char failed_msg[50];
+    snprintf(failed_msg, sizeof(failed_msg), "%s:[%s]",PCBA_SDCARD, PCBA_FAILED);
+
+    if (ret < 0) {
+        LOG("mmc test failed.\n");
+        hook->handle_refresh_screen_hl(tc_info->y, PCBA_SDCARD, true);
+        tc_info->result = -1;
+        return argv;
+    }
+
+    fp = fopen(SCAN_RESULT_FILE, "r");
+    if (fp == NULL) {
+        LOG("can not open %s.\n", SCAN_RESULT_FILE);
+        hook->handle_refresh_screen_hl(tc_info->y, PCBA_SDCARD, true);
+        tc_info->result = -1;
+        return argv;
+    }
+
+    memset(results, 0, SCAN_RESULT_LENGTH);
+    fgets(results, 50, fp);
+
+    cap = strtod(results, NULL);
+    if (cap) {
+        snprintf(failed_msg, sizeof(failed_msg), "%s:[%s] { %2fG }", 
+                 PCBA_SDCARD, PCBA_SECCESS,
+                 cap * 1.0 / 1024 / 1024);
+        hook->handle_refresh_screen_hl(tc_info->y, failed_msg, false);
+        tc_info->result = 0;
+    }
+    fclose(fp);
+    return argv;
+}
diff --git a/bootable/recovery/pcba_core/sdcard_test.h b/bootable/recovery/pcba_core/sdcard_test.h
new file mode 100644
index 0000000000..fa3cf5b3c9
--- /dev/null
+++ b/bootable/recovery/pcba_core/sdcard_test.h
@@ -0,0 +1,13 @@
+#ifndef __SDCARD_TEST_H
+#define __SDCARD_TEST_H
+
+#include "display_callback.h"
+
+struct sd_msg {
+	int result;
+	int y;
+};
+
+void *sdcard_test(void *argv, display_callback *hook);
+
+#endif
diff --git a/bootable/recovery/pcba_core/test_case.h b/bootable/recovery/pcba_core/test_case.h
new file mode 100644
index 0000000000..79c6e51425
--- /dev/null
+++ b/bootable/recovery/pcba_core/test_case.h
@@ -0,0 +1,69 @@
+
+#ifndef __TEST_CASE_H__
+#define __TEST_CASE_H__
+
+#include<pthread.h>
+#include"rklist.h"
+
+#define CATEGORY_AUTO                   0
+#define CATEGORY_MANUAL                 1
+
+#define WAIT_COMPLETION                 0
+#define NO_WAIT_COMPLETION              1
+
+struct testcase_base_info
+{
+    char name[32];
+    char display_name[68];
+    int activated;
+    char binary[20];
+    int id;
+    int category; /* 0: auto, 1: manual */
+    int run_type;
+};
+
+struct testcase_info
+{
+	pthread_t tid;
+	int 	err;
+	struct testcase_base_info *base_info;
+	int x;			//x,y positon and width height on the screen
+	int y;
+	int w;
+	int h;
+	int dev_id;		//default 0,but some device have double,such as camera
+	int result;
+	void *msg;		//this is for testcase spefic msg struct
+	void* (*func)(void *argv); //test function
+	struct list_head list;
+};
+
+#define INIT_CMD_PIPE()                                         \
+    FILE *cmd_pipe;                                             \
+    int test_case_id;                                           \
+    if (argc < 4) {                                             \
+        db_error("%s: invalid parameter, #%d\n", argv[0], argc);\
+        return -1;                                              \
+    }                                                           \
+    cmd_pipe = fopen(CMD_PIPE_NAME, "w");                       \
+    setlinebuf(cmd_pipe);                                       \
+    test_case_id = atoi(argv[3])
+
+#define SEND_CMD_PIPE_OK()                                      \
+    fprintf(cmd_pipe, "%d 0\n", test_case_id)
+
+#define SEND_CMD_PIPE_OK_EX(exdata)                             \
+    fprintf(cmd_pipe, "%d 0 %s\n", test_case_id, exdata)
+
+#define SEND_CMD_PIPE_FAIL()                                    \
+    fprintf(cmd_pipe, "%d 1\n", test_case_id)
+
+#define SEND_CMD_PIPE_FAIL_EX(exdata)                           \
+    fprintf(cmd_pipe, "%d 1 %s\n", test_case_id, exdata)
+
+#define EXIT_CMD_PIPE()                                         \
+    fclose(cmd_pipe)
+    
+
+#endif /* __TEST_CASE_H__ */
+
diff --git a/bootable/recovery/pcba_core/udisk_test.cpp b/bootable/recovery/pcba_core/udisk_test.cpp
new file mode 100644
index 0000000000..00fec47340
--- /dev/null
+++ b/bootable/recovery/pcba_core/udisk_test.cpp
@@ -0,0 +1,61 @@
+#include<stdio.h>
+#include <stdlib.h>
+
+#include"common.h"
+#include"extra-functions.h"
+
+#include"udisk_test.h"
+#include"test_case.h"
+#include "language.h"
+
+#define SCAN_RESULT_LENGTH 128
+#define SCAN_RESULT_FILE "/data/udisk_capacity.txt"
+
+void * udisk_test(void * argv, display_callback *hook)
+{
+
+    struct testcase_info *tc_info = (struct testcase_info*)argv;
+    int ret,y;
+    double cap;
+    FILE *fp;
+    char results[SCAN_RESULT_LENGTH];
+
+    hook->handle_refresh_screen(tc_info->y, PCBA_UCARD);
+    ret =  system("busybox chmod 777 /pcba/udisktester.sh");
+    if(ret) printf("chmod udisktester.sh failed :%d\n",ret);
+
+    char failed_msg[50];
+    snprintf(failed_msg, sizeof(failed_msg), "%s:[%s]",PCBA_UCARD,PCBA_FAILED);
+    ret = system("/pcba/udisktester.sh");
+    if(ret < 0) {
+        printf("udisk test failed.\n");
+        hook->handle_refresh_screen_hl(tc_info->y, failed_msg, true);
+        tc_info->result = -1;
+        return argv;
+    }
+
+    fp = fopen(SCAN_RESULT_FILE, "r");
+    if(fp == NULL) {
+        printf("can not open %s.\n", SCAN_RESULT_FILE);
+        hook->handle_refresh_screen_hl(tc_info->y, failed_msg, true);
+        tc_info->result = -1;
+        return argv;
+    }
+
+    memset(results, 0, SCAN_RESULT_LENGTH);
+    fgets(results,50,fp);
+
+    cap = strtod(results,NULL);
+    printf("capacity : %s\n", results);
+    if(cap > 0) {
+        snprintf(failed_msg, sizeof(failed_msg), "%s:[%s] { %2fG }",PCBA_UCARD,PCBA_SECCESS,cap*1.0/1024/1024);
+        tc_info->result = 0;
+    }
+    else {
+        tc_info->result = -1;
+    }
+    hook->handle_refresh_screen_hl(tc_info->y, failed_msg, tc_info->result != 0);
+
+    fclose(fp);
+    return argv;
+}
diff --git a/bootable/recovery/pcba_core/udisk_test.h b/bootable/recovery/pcba_core/udisk_test.h
new file mode 100644
index 0000000000..9a043de5b9
--- /dev/null
+++ b/bootable/recovery/pcba_core/udisk_test.h
@@ -0,0 +1,14 @@
+#ifndef __UDISK_TEST_H
+#define __UDISK_TEST_H
+
+#include "display_callback.h"
+
+void * udisk_test(void * argv, display_callback *hook);
+
+struct udisk_msg 
+{
+	int result;
+	int y;
+};
+#endif
+
diff --git a/bootable/recovery/pcba_core/variables.h b/bootable/recovery/pcba_core/variables.h
new file mode 100644
index 0000000000..3af1bab84a
--- /dev/null
+++ b/bootable/recovery/pcba_core/variables.h
@@ -0,0 +1,149 @@
+#ifndef _VARIABLES_HEADER_
+#define _VARIABLES_HEADER_
+
+#define TW_VERSION_STR              "2.2.2.1"
+
+#define TW_USE_COMPRESSION_VAR      "tw_use_compression"
+#define TW_IGNORE_IMAGE_SIZE        "tw_ignore_image_size"
+#define TW_FILENAME                 "tw_filename"
+#define TW_ZIP_INDEX                "tw_zip_index"
+#define TW_ZIP_QUEUE_COUNT			"tw_zip_queue_count"
+
+#define MAX_BACKUP_NAME_LEN 64
+#define TW_BACKUP_NAME		        "tw_backup_name"
+#define TW_BACKUP_SYSTEM_VAR        "tw_backup_system"
+#define TW_BACKUP_DATA_VAR          "tw_backup_data"
+#define TW_BACKUP_BOOT_VAR          "tw_backup_boot"
+#define TW_BACKUP_RECOVERY_VAR      "tw_backup_recovery"
+#define TW_BACKUP_CACHE_VAR         "tw_backup_cache"
+#define TW_BACKUP_ANDSEC_VAR        "tw_backup_andsec"
+#define TW_BACKUP_SDEXT_VAR         "tw_backup_sdext"
+#define TW_BACKUP_SP1_VAR           "tw_backup_sp1"
+#define TW_BACKUP_SP2_VAR           "tw_backup_sp2"
+#define TW_BACKUP_SP3_VAR           "tw_backup_sp3"
+#define TW_BACKUP_AVG_IMG_RATE      "tw_backup_avg_img_rate"
+#define TW_BACKUP_AVG_FILE_RATE     "tw_backup_avg_file_rate"
+#define TW_BACKUP_AVG_FILE_COMP_RATE    "tw_backup_avg_file_comp_rate"
+#define TW_BACKUP_SYSTEM_SIZE       "tw_backup_system_size"
+#define TW_BACKUP_DATA_SIZE         "tw_backup_data_size"
+#define TW_BACKUP_BOOT_SIZE         "tw_backup_boot_size"
+#define TW_BACKUP_RECOVERY_SIZE     "tw_backup_recovery_size"
+#define TW_BACKUP_CACHE_SIZE        "tw_backup_cache_size"
+#define TW_BACKUP_ANDSEC_SIZE       "tw_backup_andsec_size"
+#define TW_BACKUP_SDEXT_SIZE        "tw_backup_sdext_size"
+#define TW_BACKUP_SP1_SIZE          "tw_backup_sp1_size"
+#define TW_BACKUP_SP2_SIZE          "tw_backup_sp2_size"
+#define TW_BACKUP_SP3_SIZE          "tw_backup_sp3_size"
+#define TW_STORAGE_FREE_SIZE        "tw_storage_free_size"
+
+#define TW_RESTORE_SYSTEM_VAR       "tw_restore_system"
+#define TW_RESTORE_DATA_VAR         "tw_restore_data"
+#define TW_RESTORE_BOOT_VAR         "tw_restore_boot"
+#define TW_RESTORE_RECOVERY_VAR     "tw_restore_recovery"
+#define TW_RESTORE_CACHE_VAR        "tw_restore_cache"
+#define TW_RESTORE_ANDSEC_VAR       "tw_restore_andsec"
+#define TW_RESTORE_SDEXT_VAR        "tw_restore_sdext"
+#define TW_RESTORE_SP1_VAR          "tw_restore_sp1"
+#define TW_RESTORE_SP2_VAR          "tw_restore_sp2"
+#define TW_RESTORE_SP3_VAR          "tw_restore_sp3"
+#define TW_RESTORE_AVG_IMG_RATE     "tw_restore_avg_img_rate"
+#define TW_RESTORE_AVG_FILE_RATE    "tw_restore_avg_file_rate"
+#define TW_RESTORE_AVG_FILE_COMP_RATE    "tw_restore_avg_file_comp_rate"
+#define TW_RESTORE_FILE_DATE        "tw_restore_file_date"
+
+#define TW_SHOW_SPAM_VAR            "tw_show_spam"
+#define TW_COLOR_THEME_VAR          "tw_color_theme"
+#define TW_VERSION_VAR              "tw_version"
+#define TW_SORT_FILES_BY_DATE_VAR   "tw_sort_files_by_date"
+#define TW_GUI_SORT_ORDER           "tw_gui_sort_order"
+#define TW_ZIP_LOCATION_VAR         "tw_zip_location"
+#define TW_ZIP_INTERNAL_VAR         "tw_zip_internal"
+#define TW_ZIP_EXTERNAL_VAR         "tw_zip_external"
+#define TW_FORCE_MD5_CHECK_VAR      "tw_force_md5_check"
+#define TW_SKIP_MD5_CHECK_VAR       "tw_skip_md5_check"
+#define TW_SKIP_MD5_GENERATE_VAR    "tw_skip_md5_generate"
+#define TW_SIGNED_ZIP_VERIFY_VAR    "tw_signed_zip_verify"
+#define TW_REBOOT_AFTER_FLASH_VAR   "tw_reboot_after_flash_option"
+#define TW_TIME_ZONE_VAR            "tw_time_zone"
+#define TW_RM_RF_VAR                "tw_rm_rf"
+
+#define TW_BACKUPS_FOLDER_VAR       "tw_backups_folder"
+
+#define TW_SP1_PARTITION_NAME_VAR   "tw_sp1_name"
+#define TW_SP2_PARTITION_NAME_VAR   "tw_sp2_name"
+#define TW_SP3_PARTITION_NAME_VAR   "tw_sp3_name"
+
+#define TW_SDEXT_SIZE               "tw_sdext_size"
+#define TW_SWAP_SIZE                "tw_swap_size"
+#define TW_SDPART_FILE_SYSTEM       "tw_sdpart_file_system"
+#define TW_TIME_ZONE_GUISEL         "tw_time_zone_guisel"
+#define TW_TIME_ZONE_GUIOFFSET      "tw_time_zone_guioffset"
+#define TW_TIME_ZONE_GUIDST         "tw_time_zone_guidst"
+
+#define TW_ACTION_BUSY              "tw_busy"
+
+#define TW_ALLOW_PARTITION_SDCARD   "tw_allow_partition_sdcard"
+
+#define TW_SCREEN_OFF               "tw_screen_off"
+
+#define TW_REBOOT_SYSTEM            "tw_reboot_system"
+#define TW_REBOOT_RECOVERY          "tw_reboot_recovery"
+#define TW_REBOOT_POWEROFF          "tw_reboot_poweroff"
+#define TW_REBOOT_BOOTLOADER        "tw_reboot_bootloader"
+
+#define TW_HAS_DUAL_STORAGE         "tw_has_dual_storage"
+#define TW_USE_EXTERNAL_STORAGE     "tw_use_external_storage"
+#define TW_HAS_INTERNAL             "tw_has_internal"
+#define TW_INTERNAL_PATH            "tw_internal_path"         // /data/media or /internal
+#define TW_INTERNAL_MOUNT           "tw_internal_mount"        // /data or /internal
+#define TW_INTERNAL_LABEL           "tw_internal_label"        // data or internal
+#define TW_HAS_EXTERNAL             "tw_has_external"
+#define TW_EXTERNAL_PATH            "tw_external_path"         // /sdcard or /external/sdcard2
+#define TW_EXTERNAL_MOUNT           "tw_external_mount"        // /sdcard or /external
+#define TW_EXTERNAL_LABEL           "tw_external_label"        // sdcard or external
+
+#define TW_HAS_DATA_MEDIA           "tw_has_data_media"
+
+#define TW_HAS_BOOT_PARTITION       "tw_has_boot_partition"
+#define TW_HAS_RECOVERY_PARTITION   "tw_has_recovery_partition"
+#define TW_HAS_ANDROID_SECURE       "tw_has_android_secure"
+#define TW_HAS_SDEXT_PARTITION      "tw_has_sdext_partition"
+#define TW_HAS_USB_STORAGE          "tw_has_usb_storage"
+#define TW_NO_BATTERY_PERCENT       "tw_no_battery_percent"
+#define TW_POWER_BUTTON             "tw_power_button"
+#define TW_SIMULATE_ACTIONS         "tw_simulate_actions"
+#define TW_SIMULATE_FAIL            "tw_simulate_fail"
+#define TW_DONT_UNMOUNT_SYSTEM      "tw_dont_unmount_system"
+// #define TW_ALWAYS_RMRF              "tw_always_rmrf"
+
+#define TW_SHOW_DUMLOCK             "tw_show_dumlock"
+#define TW_HAS_INJECTTWRP           "tw_has_injecttwrp"
+#define TW_INJECT_AFTER_ZIP         "tw_inject_after_zip"
+#define TW_HAS_DATADATA             "tw_has_datadata"
+#define TW_FLASH_ZIP_IN_PLACE       "tw_flash_zip_in_place"
+#define TW_MIN_SYSTEM_SIZE          "50" // minimum system size to allow a reboot
+#define TW_MIN_SYSTEM_VAR           "tw_min_system"
+#define TW_DOWNLOAD_MODE            "tw_download_mode"
+#define TW_IS_ENCRYPTED             "tw_is_encrypted"
+#define TW_IS_DECRYPTED             "tw_is_decrypted"
+#define TW_HAS_CRYPTO               "tw_has_crypto"
+#define TW_CRYPTO_PASSWORD          "tw_crypto_password"
+#define TW_DATA_BLK_DEVICE          "tw_data_blk_device"  // Original block device - not decrypted
+#define TW_SDEXT_DISABLE_EXT4       "tw_sdext_disable_ext4"
+
+// Also used:
+//   tw_boot_is_mountable
+//   tw_system_is_mountable
+//   tw_data_is_mountable
+//   tw_cache_is_mountable
+//   tw_sdcext_is_mountable
+//   tw_sdcint_is_mountable
+//   tw_sd-ext_is_mountable
+//   tw_sp1_is_mountable
+//   tw_sp2_is_mountable
+//   tw_sp3_is_mountable
+
+// Max archive size for tar backups before we split (1.5GB)
+#define MAX_ARCHIVE_SIZE 1610612736LLU
+
+#endif  // _VARIABLES_HEADER_
diff --git a/bootable/recovery/pcba_core/wlan_test.cpp b/bootable/recovery/pcba_core/wlan_test.cpp
new file mode 100644
index 0000000000..dfd9a00bd7
--- /dev/null
+++ b/bootable/recovery/pcba_core/wlan_test.cpp
@@ -0,0 +1,245 @@
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <utime.h>
+#include <fcntl.h>
+#include <cutils/log.h>
+#include "common.h"
+#include "extra-functions.h"
+#include "wlan_test.h"
+#include "test_case.h"
+#include "language.h"
+#include "recovery_ui/ui.h"
+#include "display_callback.h"
+
+#include <hardware_legacy/rk_wifi.h>
+
+#define TAG	"[PCBA,WIFI]: "
+#define LOG(x...)	printf(TAG x)
+
+#define MAX_SCAN_COUNTS	(64)
+#define SCAN_RESULT_LENGTH	(128 * MAX_SCAN_COUNTS)
+#define SCAN_RESULT_FILE	"/data/scan_result.txt"
+#define SCAN_RESULT_FILE2	"/data/scan_result2.txt"
+
+static char ssids[MAX_SCAN_COUNTS][128];
+static char rssis[MAX_SCAN_COUNTS][128];
+
+static char wifi_type[64] = {0};
+extern int system (const char *__command) __wur;
+static const char RECOGNIZE_WIFI_CHIP[] = "/data/wifi_chip";
+
+/*
+* RSSI Levels as used by notification icon
+*
+* Level 4  -55 <= RSSI
+* Level 3  -66 <= RSSI < -55
+* Level 2  -77 <= RSSI < -67
+* Level 1  -88 <= RSSI < -78
+* Level 0         RSSI < -88
+*/
+static int calc_rssi_lvl(int rssi)
+{
+    rssi *= -1;
+
+    if (rssi >= -55)
+    return 4;
+    else if (rssi >= -66)
+    return 3;
+    else if (rssi >= -77)
+    return 2;
+    else if (rssi >= -88)
+    return 1;
+    else
+    return 0;
+}
+
+static void process_ssid(char *dst, char *src, char *src2)
+{
+    char *p, *p2, *tmp, *tmp2;
+    int i, j, dbm, dbm2 = 99, index = 0, rssi;
+
+    for (i = 0; i < MAX_SCAN_COUNTS; i++) {
+        /* ESSID:"PocketAP_Home" */
+        tmp = &ssids[i][0];
+        p = strstr(src, "ESSID:");
+        if (p == NULL)
+        break;
+        /* skip "ESSID:" */
+        p += strlen("ESSID:");
+        while ((*p != '\0') && (*p != '\n'))
+        *tmp++ = *p++;
+        *tmp++ = '\0';
+        src = p;
+        /* LOG("src = %s\n", src); */
+
+        /* Quality:4/5  Signal level:-59 dBm  Noise level:-96 dBm */
+        tmp2 = &rssis[i][0];
+        p2 = strstr(src2, "Signal level");
+        if (p2 == NULL)
+        break;
+        /* skip "level=" */
+        p2 += strlen("Signal level") + 1;
+        /* like "-90 dBm", total 3 chars */
+        *tmp2++ = *p2++;	/* '-' */
+        *tmp2++ = *p2++;	/* '9' */
+        *tmp2++ = *p2++;	/* '0' */
+        *tmp2++ = *p2++;	/* ' ' */
+        *tmp2++ = *p2++;	/* 'd' */
+        *tmp2++ = *p2++;	/* 'B' */
+        *tmp2++ = *p2++;	/* 'm' */
+        *tmp2++ = '\0';
+        src2 = p2;
+        /* LOG("src2 = %s\n", src2); */
+        LOG("i = %d, %s, %s\n", i, &ssids[i][0], &rssis[i][0]);
+    }
+
+    LOG("total = %d\n", i);
+    if (i == 0)
+    return;
+
+    for (j = 0; j < i; j++) {
+        dbm = atoi(&rssis[j][1]);	/* skip '-' */
+        if (dbm == 0)
+        continue;
+        if (dbm < dbm2) {		/* get max rssi */
+                         dbm2 = dbm;
+                         index = j;
+                        }
+    }
+
+    LOG("index = %d, dbm = %d\n", index, dbm2);
+    LOG("select ap: %s, %s\n", &ssids[index][0], &rssis[index][0]);
+
+    rssi = calc_rssi_lvl(atoi(&rssis[index][1]));
+
+    sprintf(dst, "{ %s \"%d\" }", &ssids[index][0], rssi);
+    }
+
+int save_wifi_chip_type(char *type)
+{
+    int ret;
+    int fd;
+    int len;
+    char buf[64];
+    ret = access(RECOGNIZE_WIFI_CHIP, R_OK|W_OK);
+    if ((ret == 0) || (errno == EACCES)) {
+        if ((ret != 0) && (chmod(RECOGNIZE_WIFI_CHIP, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) != 0)) {
+            LOG("Cannot set RW to %s : %s\n", RECOGNIZE_WIFI_CHIP,strerror(errno));
+            return -1;
+        }
+        LOG("%s is exit\n", RECOGNIZE_WIFI_CHIP);
+        return 0;
+    }
+
+    fd = TEMP_FAILURE_RETRY(open(RECOGNIZE_WIFI_CHIP, O_CREAT|O_RDWR, 0664));
+    if (fd < 0) {
+        LOG("Cannot create %s : %s\n", RECOGNIZE_WIFI_CHIP,strerror(errno));
+        return -1;
+    }
+    LOG("is not exit,save wifi chip %s\n", RECOGNIZE_WIFI_CHIP);
+    strcpy(buf, type);
+    LOG("recognized wifi chip = %s , save to %s\n",buf, RECOGNIZE_WIFI_CHIP);
+    len = strlen(buf)+1;
+    if (TEMP_FAILURE_RETRY(write(fd, buf, len)) != len) {
+        LOG("Error writing %s : %s\n", RECOGNIZE_WIFI_CHIP, strerror(errno));
+        close(fd);
+        return -1;
+    }
+    close(fd);
+    if (chmod(RECOGNIZE_WIFI_CHIP, 0664) < 0) {
+        LOG("Error changing permissions of %s to 0664: %s\n", RECOGNIZE_WIFI_CHIP, strerror(errno));
+        unlink(RECOGNIZE_WIFI_CHIP);
+        return -1;
+    }
+    return 1;
+}
+
+void *wlan_test(void *argv, display_callback *hook)
+{
+    int ret = 0, y;
+    FILE *fp = NULL;
+    FILE *fp2 = NULL;
+    char *results = NULL;
+    char *results2 = NULL;
+    char ssid[100];
+    struct testcase_info *tc_info = (struct testcase_info *)argv;
+    char msg[50];
+    snprintf(msg, sizeof(msg), "%s:[%s..]", PCBA_WIFI, PCBA_TESTING);
+
+    y = tc_info->y;
+    hook->handle_refresh_screen(tc_info->y, msg);
+    usleep(2000000);
+
+    if (wifi_type[0] == 0) {
+        check_wifi_chip_type_string(wifi_type);
+        save_wifi_chip_type(wifi_type);
+    }
+    ret = system("busybox chmod 777 /pcba/wifi.sh");
+    if (ret)
+        LOG("chmod wifi.sh failed :%d\n", ret);
+
+    ret = system("/pcba/wifi.sh");
+    if (ret <= 0)
+    goto error_exit;
+
+    results = (char *)malloc(SCAN_RESULT_LENGTH);
+    results2 = (char *)malloc(SCAN_RESULT_LENGTH);
+    if (results == NULL || results2 == NULL)
+    goto error_exit;
+
+    fp = fopen(SCAN_RESULT_FILE, "r");
+    fp2 = fopen(SCAN_RESULT_FILE2, "r");
+    if (fp == NULL || fp2 == NULL)
+    goto error_exit;
+
+    memset(results, 0, SCAN_RESULT_LENGTH);
+    fread(results, SCAN_RESULT_LENGTH, 1, fp);
+    results[SCAN_RESULT_LENGTH - 1] = '\0';
+
+    memset(results2, 0, SCAN_RESULT_LENGTH);
+    fread(results2, SCAN_RESULT_LENGTH, 1, fp2);
+    results2[SCAN_RESULT_LENGTH - 1] = '\0';
+
+    memset(ssid, 0, 100);
+
+    process_ssid(ssid, results, results2);
+
+    snprintf(msg, sizeof(msg), "%s:[%s] %s", PCBA_WIFI, PCBA_SECCESS, ssid);
+    hook->handle_refresh_screen_hl(tc_info->y, msg, false);
+    usleep(1000000);
+    tc_info->result = 0;
+
+    fclose(fp);
+    fclose(fp2);
+    free(results);
+    free(results2);
+
+    LOG("wlan_test success.\n");
+
+    return 0;
+
+error_exit:
+    if (fp)
+    fclose(fp);
+    if (fp2)
+    fclose(fp2);
+    if (results)
+    free(results);
+    if (results2)
+    free(results2);
+
+    snprintf(msg, sizeof(msg), "%s:[%s] %s", PCBA_WIFI, PCBA_FAILED, ssid);
+    hook->handle_refresh_screen_hl(tc_info->y, msg, true);
+    usleep(1000000);
+    tc_info->result = -1;
+
+    LOG("wlan_test failed.\n");
+
+    return argv;
+}
diff --git a/bootable/recovery/pcba_core/wlan_test.h b/bootable/recovery/pcba_core/wlan_test.h
new file mode 100644
index 0000000000..3db4000a70
--- /dev/null
+++ b/bootable/recovery/pcba_core/wlan_test.h
@@ -0,0 +1,17 @@
+#ifndef __WLAN_TEST_H_
+#define __WLAN_TEST_H_
+
+#include "display_callback.h"
+
+struct wlan_msg {
+	int result;
+	int x;
+	int y;
+	int w;
+	int h;
+	char *ssid;
+};
+
+void *wlan_test(void *argv, display_callback *hook);
+
+#endif
diff --git a/bootable/recovery/rkupdate/Android.bp b/bootable/recovery/rkupdate/Android.bp
new file mode 100755
index 0000000000..51adb7e639
--- /dev/null
+++ b/bootable/recovery/rkupdate/Android.bp
@@ -0,0 +1,91 @@
+//
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//prebuilt_stdcxx_PATH = ["prebuilts/ndk/current/sources/cxx-stl"]
+cc_defaults {
+    name: "librkupdate_defaults",
+
+    defaults: [
+        "recovery_defaults",
+    ],
+
+    static_libs: [
+        "libbootloader_message",
+        "libotautil",
+        "libext4_utils",
+        "libfs_mgr",
+        "liblog",
+        "liblp",
+        "libselinux",
+        "libsparse",
+        "libbrotli",
+        "libbz",
+        "libbase",
+        "libcrypto",
+        "libcrypto_utils",
+        "libcutils",
+        "libutils",
+
+        "libext2_com_err",
+        "libext2_blkid",
+        "libext2_quota",
+        "libext2_uuid",
+        "libext2_e2p",
+        "libext2fs",
+        "libmtdutils",
+        "librkutility",
+        "librecovery_ui_default",
+    ],
+}
+
+cc_library_static {
+    name: "librkupdate",
+
+    defaults: [
+        "recovery_defaults",
+        "librkupdate_defaults",
+    ],
+
+    shared_libs: [
+        "librecovery_ui",
+    ],
+
+    srcs: [
+        "CRC.cpp",
+        "MD5Checksum.cpp",
+        "RKBoot.cpp",
+        "RKImage.cpp",
+        "RKLog.cpp",
+        "RKComm.cpp",
+        "RKDevice.cpp",
+        "RKAndroidDevice.cpp",
+        "Upgrade.cpp",
+        "RKSparse.cpp",
+    ],
+
+    include_dirs: [
+        "external/e2fsprogs/misc",
+        "external/e2fsprogs/lib",
+        "system/extras/ext4_utils/include/ext4_utils",
+        "system/core/base/include",
+        "system/vold",
+        "system/core/fs_mgr/include/",
+    ],
+
+    export_include_dirs: [
+        "include",
+    ],
+    recovery_available: true,
+}
diff --git a/bootable/recovery/rkupdate/CRC.cpp b/bootable/recovery/rkupdate/CRC.cpp
new file mode 100755
index 0000000000..a0b54e93a3
--- /dev/null
+++ b/bootable/recovery/rkupdate/CRC.cpp
@@ -0,0 +1,359 @@
+#include "rkupdate/DefineHeader.h"
+UINT gTable_Crc32[256] =
+{
+		0x00000000, 0x04c10db7, 0x09821b6e, 0x0d4316d9,
+		0x130436dc, 0x17c53b6b, 0x1a862db2, 0x1e472005,
+		0x26086db8, 0x22c9600f, 0x2f8a76d6, 0x2b4b7b61,
+		0x350c5b64, 0x31cd56d3, 0x3c8e400a, 0x384f4dbd,
+		0x4c10db70, 0x48d1d6c7, 0x4592c01e, 0x4153cda9,
+		0x5f14edac, 0x5bd5e01b, 0x5696f6c2, 0x5257fb75,
+		0x6a18b6c8, 0x6ed9bb7f, 0x639aada6, 0x675ba011,
+		0x791c8014, 0x7ddd8da3, 0x709e9b7a, 0x745f96cd,
+		0x9821b6e0, 0x9ce0bb57, 0x91a3ad8e, 0x9562a039,
+		0x8b25803c, 0x8fe48d8b, 0x82a79b52, 0x866696e5,
+		0xbe29db58, 0xbae8d6ef, 0xb7abc036, 0xb36acd81,
+		0xad2ded84, 0xa9ece033, 0xa4aff6ea, 0xa06efb5d,
+		0xd4316d90, 0xd0f06027, 0xddb376fe, 0xd9727b49,
+		0xc7355b4c, 0xc3f456fb, 0xceb74022, 0xca764d95,
+		0xf2390028, 0xf6f80d9f, 0xfbbb1b46, 0xff7a16f1,
+		0xe13d36f4, 0xe5fc3b43, 0xe8bf2d9a, 0xec7e202d,
+		0x34826077, 0x30436dc0, 0x3d007b19, 0x39c176ae,
+		0x278656ab, 0x23475b1c, 0x2e044dc5, 0x2ac54072,
+		0x128a0dcf, 0x164b0078, 0x1b0816a1, 0x1fc91b16,
+		0x018e3b13, 0x054f36a4, 0x080c207d, 0x0ccd2dca,
+		0x7892bb07, 0x7c53b6b0, 0x7110a069, 0x75d1adde,
+		0x6b968ddb, 0x6f57806c, 0x621496b5, 0x66d59b02,
+		0x5e9ad6bf, 0x5a5bdb08, 0x5718cdd1, 0x53d9c066,
+		0x4d9ee063, 0x495fedd4, 0x441cfb0d, 0x40ddf6ba,
+		0xaca3d697, 0xa862db20, 0xa521cdf9, 0xa1e0c04e,
+		0xbfa7e04b, 0xbb66edfc, 0xb625fb25, 0xb2e4f692,
+		0x8aabbb2f, 0x8e6ab698, 0x8329a041, 0x87e8adf6,
+		0x99af8df3, 0x9d6e8044, 0x902d969d, 0x94ec9b2a,
+		0xe0b30de7, 0xe4720050, 0xe9311689, 0xedf01b3e,
+		0xf3b73b3b, 0xf776368c, 0xfa352055, 0xfef42de2,
+		0xc6bb605f, 0xc27a6de8, 0xcf397b31, 0xcbf87686,
+		0xd5bf5683, 0xd17e5b34, 0xdc3d4ded, 0xd8fc405a,
+		0x6904c0ee, 0x6dc5cd59, 0x6086db80, 0x6447d637,
+		0x7a00f632, 0x7ec1fb85, 0x7382ed5c, 0x7743e0eb,
+		0x4f0cad56, 0x4bcda0e1, 0x468eb638, 0x424fbb8f,
+		0x5c089b8a, 0x58c9963d, 0x558a80e4, 0x514b8d53,
+		0x25141b9e, 0x21d51629, 0x2c9600f0, 0x28570d47,
+		0x36102d42, 0x32d120f5, 0x3f92362c, 0x3b533b9b,
+		0x031c7626, 0x07dd7b91, 0x0a9e6d48, 0x0e5f60ff,
+		0x101840fa, 0x14d94d4d, 0x199a5b94, 0x1d5b5623,
+		0xf125760e, 0xf5e47bb9, 0xf8a76d60, 0xfc6660d7,
+		0xe22140d2, 0xe6e04d65, 0xeba35bbc, 0xef62560b,
+		0xd72d1bb6, 0xd3ec1601, 0xdeaf00d8, 0xda6e0d6f,
+		0xc4292d6a, 0xc0e820dd, 0xcdab3604, 0xc96a3bb3,
+		0xbd35ad7e, 0xb9f4a0c9, 0xb4b7b610, 0xb076bba7,
+		0xae319ba2, 0xaaf09615, 0xa7b380cc, 0xa3728d7b,
+		0x9b3dc0c6, 0x9ffccd71, 0x92bfdba8, 0x967ed61f,
+		0x8839f61a, 0x8cf8fbad, 0x81bbed74, 0x857ae0c3,
+		0x5d86a099, 0x5947ad2e, 0x5404bbf7, 0x50c5b640,
+		0x4e829645, 0x4a439bf2, 0x47008d2b, 0x43c1809c,
+		0x7b8ecd21, 0x7f4fc096, 0x720cd64f, 0x76cddbf8,
+		0x688afbfd, 0x6c4bf64a, 0x6108e093, 0x65c9ed24,
+		0x11967be9, 0x1557765e, 0x18146087, 0x1cd56d30,
+		0x02924d35, 0x06534082, 0x0b10565b, 0x0fd15bec,
+		0x379e1651, 0x335f1be6, 0x3e1c0d3f, 0x3add0088,
+		0x249a208d, 0x205b2d3a, 0x2d183be3, 0x29d93654,
+		0xc5a71679, 0xc1661bce, 0xcc250d17, 0xc8e400a0,
+		0xd6a320a5, 0xd2622d12, 0xdf213bcb, 0xdbe0367c,
+		0xe3af7bc1, 0xe76e7676, 0xea2d60af, 0xeeec6d18,
+		0xf0ab4d1d, 0xf46a40aa, 0xf9295673, 0xfde85bc4,
+		0x89b7cd09, 0x8d76c0be, 0x8035d667, 0x84f4dbd0,
+		0x9ab3fbd5, 0x9e72f662, 0x9331e0bb, 0x97f0ed0c,
+		0xafbfa0b1, 0xab7ead06, 0xa63dbbdf, 0xa2fcb668,
+		0xbcbb966d, 0xb87a9bda, 0xb5398d03, 0xb1f880b4,
+};
+#define rr_max  104	/* Number of parity checks, rr = deg[g(x)] */
+#define parallel 8 //bit count 
+#define mm 13//limit count
+#define nn 8191//code size
+#define kk 4120//info length
+#define tt 8//correct count	
+
+#define tt2 2*tt
+UINT s[tt2+1]; // Syndrome values
+
+UINT rr;//redundant length		// BCH code parameters
+
+
+UINT p[mm + 1];
+UINT alpha_to[nn+1], index_of[nn+1] ;	// Galois field
+UINT gg[rr_max+1] ;		// Generator polynomial
+
+UINT ggx1=0;
+UINT ggx2=0;
+UINT ggx3=0;
+UINT ggx4=0;
+// get crc32 value
+UINT CRC_32(unsigned char* pData, UINT ulSize,UINT uiPreviousValue=0)
+{
+    UINT i;
+    UINT nAccum = uiPreviousValue;
+
+    for ( i=0; i<ulSize; i++)
+        nAccum = (nAccum<<8)^gTable_Crc32[(nAccum>>24)^(*pData++)];
+    return nAccum;
+}
+#define CRC16_CCITT         0x1021  //CRC operator
+void CRCBuildTable16(unsigned short aPoly , unsigned short *crcTable)
+{
+    unsigned short i, j;
+    unsigned short nData;
+    unsigned short nAccum;
+	
+    for (i = 0; i < 256; i++)
+    {
+        nData = (unsigned short)(i << 8);
+        nAccum = 0;
+        for (j = 0; j < 8; j++)
+        {
+            if ((nData ^ nAccum) & 0x8000)
+                nAccum = (nAccum << 1) ^ aPoly;
+            else
+                nAccum <<= 1;
+            nData <<= 1;
+        }
+        crcTable[i] = nAccum;
+    }
+}
+
+unsigned short CRC_16(unsigned char* aData, UINT aSize)
+{
+    UINT i;
+    unsigned short nAccum = 0;
+    unsigned short crcTable[256];
+	
+    CRCBuildTable16(CRC16_CCITT , crcTable);
+    for (i = 0; i < aSize; i++)
+        nAccum = (nAccum << 8) ^ crcTable[(nAccum >> 8) ^ *aData++];
+
+    return nAccum;
+}
+
+void P_RC4(unsigned char* buf, unsigned short len)
+{
+	unsigned char S[256],K[256],temp;
+	unsigned short i,j,t,x;
+	unsigned char key[16]={124,78,3,4,85,5,9,7,45,44,123,56,23,13,23,17};
+	
+	j = 0;
+	for(i=0; i<256; i++){
+		S[i] = (unsigned char)i;
+		j&=0x0f;
+		K[i] = key[j];
+		j++;
+	}
+	
+	j = 0;
+	for(i=0; i<256; i++){
+		j = (j + S[i] + K[i]) % 256;
+		temp = S[i];
+		S[i] = S[j];
+		S[j] = temp;
+	}
+	
+	i = j = 0;
+	for(x=0; x<len; x++){
+		i = (i+1) % 256;
+		j = (j + S[i]) % 256;
+		temp = S[i];
+		S[i] = S[j];
+		S[j] = temp;
+		t = (S[i] + (S[j] % 256)) % 256;
+		buf[x] = buf[x] ^ S[t];
+	}
+}
+
+void bch_encode(unsigned char* encode_in, unsigned char* encode_out)
+{
+	UINT i,j;
+	bool feed_back;
+	UINT bch1=0;
+	UINT bch2=0;
+	UINT bch3=0;
+	UINT bch4=0;
+	
+	for (i=0;i<515;i++)
+	{   	
+		for (j=0;j<8;j++) 
+		{
+			feed_back = (bch1&1) ^ ((encode_in[i]>>j) & 1);  
+			
+			bch1=((bch1>>1)|((bch2&1)*0x80000000))^(ggx1*feed_back);                                     
+			bch2=((bch2>>1)|((bch3&1)*0x80000000))^(ggx2*feed_back);
+			bch3=((bch3>>1)|((bch4&1)*0x80000000))^(ggx3*feed_back);                                    
+			bch4=(((bch4>>1)^(ggx4*feed_back))) | (feed_back*0x80);                            
+		}
+	} 
+	
+	//********Handle FF***********************
+	bch1 = ~(bch1 ^ 0xad6273b1);
+	bch2 = ~(bch2 ^ 0x348393d2);
+	bch3 = ~(bch3 ^ 0xe6ebed3c);
+	bch4 = ~(bch4 ^ 0xc8);
+	//*********************************************
+	
+	for (i=0;i<515;i++)
+		encode_out[i] = encode_in[i];
+	encode_out[515] = bch1&0x000000ff;
+	encode_out[516] = (bch1&0x0000ff00)>>8;
+	encode_out[517] = (bch1&0x00ff0000)>>16;      
+	encode_out[518] = (bch1&0xff000000)>>24;
+	encode_out[519] = bch2&0x000000ff;
+	encode_out[520] = (bch2&0x0000ff00)>>8;
+	encode_out[521] = (bch2&0x00ff0000)>>16;      
+	encode_out[522] = (bch2&0xff000000)>>24;
+	encode_out[523] = bch3&0x000000ff;
+	encode_out[524] = (bch3&0x0000ff00)>>8;
+	encode_out[525] = (bch3&0x00ff0000)>>16;      
+	encode_out[526] = (bch3&0xff000000)>>24;
+	encode_out[527] = bch4&0x000000ff;
+}
+
+#define poly16_CCITT	0x1021          /* crc-ccitt mask */ 
+
+unsigned short CRC_Calculate(unsigned short crc, unsigned char ch)
+{
+	UINT i;
+	for(i=0x80; i!=0; i>>=1)
+	{
+		if((crc & 0x8000) != 0)
+		{
+			crc <<= 1;
+			crc ^= poly16_CCITT;
+		}
+		else 
+			crc <<= 1;
+		
+		if((ch & i)!=0) 
+			crc ^= poly16_CCITT;
+	}
+	return crc;
+}
+unsigned short CRC_CCITT(unsigned char* p, UINT CalculateNumber)
+{
+    unsigned short crc = 0xffff;
+    while(CalculateNumber--)
+	{
+		crc = CRC_Calculate(crc, *p);
+		p++;
+    }
+    return crc;
+}
+
+void gen_poly()
+{	
+	UINT gen_roots[nn + 1], gen_roots_true[nn + 1] ; 	// Roots of generator polynomial
+	UINT i, j, Temp ;
+
+// Initialization of gen_roots
+	for (i = 0; i <= nn; i++) 
+	{	gen_roots_true[i] = 0;
+		gen_roots[i] = 0;
+	}
+
+// Cyclotomic cosets of gen_roots
+	for (i = 1; i <= 2*tt ; i++)
+	{	
+		for (j = 0; j < mm; j++) 
+		{	
+			Temp = ((1<<j)*i)%nn;
+			gen_roots_true[Temp] = 1;
+		}
+	}
+	rr = 0;		// Count thenumber of parity check bits
+	for (i = 0; i < nn; i++) 
+	{	
+		if (gen_roots_true[i] == 1) 
+		{	
+			rr++;
+		gen_roots[rr] = i;
+		}
+	}
+// Compute generator polynomial based on its roots
+	gg[0] = 2 ;	// g(x) = (X + alpha) initially
+	gg[1] = 1 ;
+	for (i = 2; i <= rr; i++)
+	{ 	
+		gg[i] = 1 ;
+		for (j = i - 1; j > 0; j--)
+			if (gg[j] != 0)  
+				gg[j] = gg[j-1]^ alpha_to[(index_of[gg[j]] + index_of[alpha_to[gen_roots[i]]]) % nn] ;
+			else 
+				gg[j] = gg[j-1] ;
+		gg[0] = alpha_to[(index_of[gg[0]] + index_of[alpha_to[gen_roots[i]]]) % nn] ;
+	}	
+
+ggx1 = gg[103] | (gg[102]<<1) | (gg[101]<<2) | (gg[100]<<3) | (gg[99]<<4) |(gg[98]<<5)| (gg[97]<<6)|(gg[96]<<7)
+	| (gg[95]<<8) | (gg[94]<<9) | (gg[93]<<10) | (gg[92]<<11) |(gg[91]<<12)| (gg[90]<<13)|(gg[89]<<14) |(gg[88]<<15)
+	| (gg[87]<<16) | (gg[86]<<17) | (gg[85]<<18) | (gg[84]<<19) | (gg[83]<<20) |(gg[82]<<21)| (gg[81]<<22)|(gg[80]<<23)
+	| (gg[79]<<24) | (gg[78]<<25) | (gg[77]<<26) | (gg[76]<<27) |(gg[75]<<28)| (gg[74]<<29)|(gg[73]<<30) |(gg[72]<<31);
+ggx2 = gg[71] | (gg[70]<<1) | (gg[69]<<2) | (gg[68]<<3) | (gg[67]<<4) |(gg[66]<<5)| (gg[65]<<6)|(gg[64]<<7)
+	| (gg[63]<<8) | (gg[62]<<9) | (gg[61]<<10) | (gg[60]<<11) |(gg[59]<<12)| (gg[58]<<13)|(gg[57]<<14) |(gg[56]<<15)
+	| (gg[55]<<16) | (gg[54]<<17) | (gg[53]<<18) | (gg[52]<<19) | (gg[51]<<20) |(gg[50]<<21)| (gg[49]<<22)|(gg[48]<<23)
+	| (gg[47]<<24) | (gg[46]<<25) | (gg[45]<<26) | (gg[44]<<27) |(gg[43]<<28)| (gg[42]<<29)|(gg[41]<<30) |(gg[40]<<31);
+ggx3 = gg[39] | (gg[38]<<1) | (gg[37]<<2) | (gg[36]<<3) | (gg[35]<<4) |(gg[34]<<5)| (gg[33]<<6)|(gg[32]<<7)
+	| (gg[31]<<8) | (gg[30]<<9) | (gg[29]<<10) | (gg[28]<<11) |(gg[27]<<12)| (gg[26]<<13)|(gg[25]<<14) |(gg[24]<<15)
+	| (gg[23]<<16) | (gg[22]<<17) | (gg[21]<<18) | (gg[20]<<19) | (gg[19]<<20) |(gg[18]<<21)| (gg[17]<<22)|(gg[16]<<23)
+	| (gg[15]<<24) | (gg[14]<<25) | (gg[13]<<26) | (gg[12]<<27) |(gg[11]<<28)| (gg[10]<<29)|(gg[9]<<30) |(gg[8]<<31); 
+ggx4 = gg[7] | (gg[6]<<1) | (gg[5]<<2) | (gg[4]<<3) | (gg[3]<<4) |(gg[2]<<5)| (gg[1]<<6);
+
+}
+
+void generate_gf()
+{	
+	UINT i;
+	UINT mask ;	// Register states
+
+	// Primitive polynomials
+	for (i = 1; i < mm; i++)
+		p[i] = 0;
+	p[0] = p[mm] = 1;
+	if (mm == 2)		p[1] = 1;
+	else if (mm == 3)	p[1] = 1;
+	else if (mm == 4)	p[1] = 1;
+	else if (mm == 5)	p[2] = 1;
+	else if (mm == 6)	p[1] = 1;
+	else if (mm == 7)	p[1] = 1;
+	else if (mm == 8)	p[4] = p[5] = p[6] = 1;
+	else if (mm == 9)	p[4] = 1;
+	else if (mm == 10)	p[3] = 1;
+	else if (mm == 11)	p[2] = 1;
+	else if (mm == 12)	p[3] = p[4] = p[7] = 1;
+	else if (mm == 13)	p[1] = p[2] = p[3] = p[5] = p[7] = p[8] = p[10] = 1;	// 25AF
+	else if (mm == 14)	p[2] = p[4] = p[6] = p[7] = p[8] = 1;	// 41D5
+	else if (mm == 15)	p[1] = 1;
+	else if (mm == 16)	p[2] = p[3] = p[5] = 1;
+	else if (mm == 17)	p[3] = 1;
+	else if (mm == 18)	p[7] = 1;
+	else if (mm == 19)	p[1] = p[5] = p[6] = 1;
+	else if (mm == 20)	p[3] = 1;	
+	// Galois field implementation with shift registers
+	// Ref: L&C, Chapter 6.7, pp. 217
+	mask = 1 ;
+	alpha_to[mm] = 0 ;
+	for (i = 0; i < mm; i++)
+	{ 	
+		alpha_to[i] = mask ;
+		index_of[alpha_to[i]] = i ;
+		if (p[i] != 0)
+			alpha_to[mm] ^= mask ;
+		mask <<= 1 ;
+	}
+
+	index_of[alpha_to[mm]] = mm ;
+	mask >>= 1 ;
+	for (i = mm + 1; i < nn; i++)
+	{ 	
+		if (alpha_to[i-1] >= mask)
+			alpha_to[i] = alpha_to[mm] ^ ((alpha_to[i-1] ^ mask) << 1) ;
+		else 
+			alpha_to[i] = alpha_to[i-1] << 1 ;
+
+		index_of[alpha_to[i]] = i ;
+	}
+	index_of[0] = -1 ;	
+}
\ No newline at end of file
diff --git a/bootable/recovery/rkupdate/MD5Checksum.cpp b/bootable/recovery/rkupdate/MD5Checksum.cpp
new file mode 100755
index 0000000000..45798bd74e
--- /dev/null
+++ b/bootable/recovery/rkupdate/MD5Checksum.cpp
@@ -0,0 +1,630 @@
+// MD5Checksum.cpp: implementation of the MD5Checksum class.
+//
+//////////////////////////////////////////////////////////////////////
+
+
+/****************************************************************************************
+This software is derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm. 
+Incorporation of this statement is a condition of use; please see the RSA
+Data Security Inc copyright notice below:-
+
+Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
+rights reserved.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+
+Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+rights reserved.
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+*****************************************************************************************/
+
+/****************************************************************************************
+This implementation of the RSA MD5 Algorithm was written by Langfine Ltd 
+(www.langfine.com).
+
+Langfine Ltd makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+In addition to the above, Langfine make no warrant or assurances regarding the 
+accuracy of this implementation of the MD5 checksum algorithm nor any assurances regarding
+its suitability for any purposes.
+
+This implementation may be used freely provided that Langfine is credited
+in a copyright or similar notices (eg, RSA MD5 Algorithm implemented by Langfine
+Ltd.) and provided that the RSA Data Security notices are complied with.
+*/
+#include "rkupdate/MD5Checksum.h"
+#include "rkupdate/MD5ChecksumDefines.h"
+
+
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::GetMD5
+DETAILS:		static, public
+DESCRIPTION:	Gets the MD5 checksum for a specified file
+RETURNS:		CString : the hexadecimal MD5 checksum for the specified file
+ARGUMENTS:		CString& strFilePath : the full pathname of the specified file
+NOTES:			Provides an interface to the CMD5Checksum class. 'strFilePath' name should 
+				hold the full pathname of the file, eg C:\My Documents\Arcticle.txt.
+				NB. If any problems occur with opening or reading this file, a CFileException
+				will be thrown; callers of this function should be ready to catch this 
+				exception.
+*****************************************************************************************/
+tstring CMD5Checksum::GetMD5(const tstring& strFilePath,long long nLength)
+{
+	//open the file as a binary file in readonly mode, denying write access 
+	FILE *file=NULL;
+	file = fopen(strFilePath.c_str(),_T("rb"));
+	if (!file)
+		return _T("");
+	//the file has been successfully opened, so now get and return its checksum
+	tstring strRet;
+	strRet = GetMD5(file,nLength);
+	fclose(file);
+	return strRet;
+}
+
+unsigned char * CMD5Checksum::_GetMD5(const tstring& strFilePath,long long nLength)
+{
+	//open the file as a binary file in readonly mode, denying write access 
+	FILE *file=NULL;
+	file = fopen(strFilePath.c_str(),_T("rb"));
+	if (!file)
+		return NULL;
+
+	//the file has been successfully opened, so now get and return its checksum
+	unsigned char *pRet;
+	pRet= _GetMD5(file,nLength);
+	fclose(file);
+	return pRet;
+}
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::GetMD5
+DETAILS:		static, public
+DESCRIPTION:	Gets the MD5 checksum for a specified file
+RETURNS:		CString : the hexadecimal MD5 checksum for the specified file
+ARGUMENTS:		CFile& File : the specified file
+NOTES:			Provides an interface to the CMD5Checksum class. 'File' should be open in 
+				binary readonly mode before calling this function. 
+				NB. Callers of this function should be ready to catch any CFileException
+				thrown by the CFile functions
+*****************************************************************************************/
+tstring CMD5Checksum::GetMD5(FILE *File,long long nLength)
+{
+	//try
+	//{
+		CMD5Checksum MD5Checksum;		//checksum object	
+		int nCount = 0;				//number of bytes read from the file
+		const int nBufferSize = 1024;	//checksum the file in blocks of 1024 bytes
+		BYTE Buffer[nBufferSize];		//buffer for data read from the file
+		
+		long long uiFileSize=nLength;
+		//fseeko(File,0,SEEK_END);
+		//uiFileSize = ftello(File);
+		fseeko(File,0,SEEK_SET);
+		//checksum the file in blocks of 1024 bytes
+		while ( uiFileSize>0 )
+		{
+			nCount = (uiFileSize>=nBufferSize)?nBufferSize:uiFileSize;
+			nCount= fread(Buffer,1,nCount,File);
+			uiFileSize -= nCount;
+			MD5Checksum.Update( Buffer, nCount);
+		}
+		//finalise the checksum and return it
+		return MD5Checksum.Final();
+	//}
+
+	//report any file exceptions in debug mode only
+	#if 0
+	catch (... )
+	{
+		return _T("");
+	}
+	#endif
+}
+
+unsigned char * CMD5Checksum::_GetMD5(FILE *File,long long nLength)
+{
+	//try
+	//{
+		CMD5Checksum MD5Checksum;		//checksum object	
+		int nCount = 0;				//number of bytes read from the file
+		const int nBufferSize = 1024;	//checksum the file in blocks of 1024 bytes
+		BYTE Buffer[nBufferSize];		//buffer for data read from the file
+
+		long long uiFileSize=nLength;
+//		fseeko(File,0,SEEK_END);
+//		uiFileSize = ftello(File);
+		fseeko(File,0,SEEK_SET);
+		//checksum the file in blocks of 1024 bytes
+		while ( uiFileSize>0 )
+		{
+			nCount = (uiFileSize>=nBufferSize)?nBufferSize:uiFileSize;
+			nCount= fread(Buffer,1,nCount,File);
+			uiFileSize -= nCount;
+			MD5Checksum.Update( Buffer, nCount);
+		}
+
+		//finalise the checksum and return it
+		return MD5Checksum.FinalChar();
+	//}
+
+	//report any file exceptions in debug mode only
+	#if 0
+	catch (...)
+	{
+		return NULL;
+	}
+	#endif
+}
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::GetMD5
+DETAILS:		static, public
+DESCRIPTION:	Gets the MD5 checksum for data in a BYTE array
+RETURNS:		CString : the hexadecimal MD5 checksum for the specified data
+ARGUMENTS:		BYTE* pBuf  :	pointer to the BYTE array
+				UINT nLength :	number of BYTEs of data to be checksumed
+NOTES:			Provides an interface to the CMD5Checksum class. Any data that can
+				be cast to a BYTE array of known length can be checksummed by this
+				function. Typically, CString and char arrays will be checksumed, 
+				although this function can be used to check the integrity of any BYTE array. 
+				A buffer of zero length can be checksummed; all buffers of zero length 
+				will return the same checksum. 
+*****************************************************************************************/
+tstring CMD5Checksum::GetMD5(BYTE* pBuf, UINT nLength)
+{
+
+	//calculate and return the checksum
+	CMD5Checksum MD5Checksum;
+	MD5Checksum.Update( pBuf, nLength );
+	return MD5Checksum.Final();
+}
+
+unsigned char *  CMD5Checksum::_GetMD5(BYTE* pBuf, UINT nLength)
+{
+	//calculate and return the checksum
+	CMD5Checksum MD5Checksum;
+	MD5Checksum.Update( pBuf, nLength );
+	return MD5Checksum.FinalChar();
+}
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::RotateLeft
+DETAILS:		private
+DESCRIPTION:	Rotates the bits in a 32 bit DWORD left by a specified amount
+RETURNS:		The rotated DWORD 
+ARGUMENTS:		DWORD x : the value to be rotated
+				int n   : the number of bits to rotate by
+*****************************************************************************************/
+DWORD CMD5Checksum::RotateLeft(DWORD x, int n)
+{
+	//check that DWORD is 4 bytes long - true in Visual C++ 6 and 32 bit Windows
+	assert( sizeof(x) == 4 );
+
+	//rotate and return x
+	return (x << n) | (x >> (32-n));
+}
+
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::FF
+DETAILS:		protected
+DESCRIPTION:	Implementation of basic MD5 transformation algorithm
+RETURNS:		none
+ARGUMENTS:		DWORD &A, B, C, D : Current (partial) checksum
+				DWORD X           : Input data
+				DWORD S			  : MD5_SXX Transformation constant
+				DWORD T			  :	MD5_TXX Transformation constant
+NOTES:			None
+*****************************************************************************************/
+void CMD5Checksum::FF( DWORD& A, DWORD B, DWORD C, DWORD D, DWORD X, DWORD S, DWORD T)
+{
+	DWORD F = (B & C) | (~B & D);
+	A += F + X + T;
+	A = RotateLeft(A, S);
+	A += B;
+}
+
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::GG
+DETAILS:		protected
+DESCRIPTION:	Implementation of basic MD5 transformation algorithm
+RETURNS:		none
+ARGUMENTS:		DWORD &A, B, C, D : Current (partial) checksum
+				DWORD X           : Input data
+				DWORD S			  : MD5_SXX Transformation constant
+				DWORD T			  :	MD5_TXX Transformation constant
+NOTES:			None
+*****************************************************************************************/
+void CMD5Checksum::GG( DWORD& A, DWORD B, DWORD C, DWORD D, DWORD X, DWORD S, DWORD T)
+{
+	DWORD G = (B & D) | (C & ~D);
+	A += G + X + T;
+	A = RotateLeft(A, S);
+	A += B;
+}
+
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::HH
+DETAILS:		protected
+DESCRIPTION:	Implementation of basic MD5 transformation algorithm
+RETURNS:		none
+ARGUMENTS:		DWORD &A, B, C, D : Current (partial) checksum
+				DWORD X           : Input data
+				DWORD S			  : MD5_SXX Transformation constant
+				DWORD T			  :	MD5_TXX Transformation constant
+NOTES:			None
+*****************************************************************************************/
+void CMD5Checksum::HH( DWORD& A, DWORD B, DWORD C, DWORD D, DWORD X, DWORD S, DWORD T)
+{
+	DWORD H = (B ^ C ^ D);
+	A += H + X + T;
+	A = RotateLeft(A, S);
+	A += B;
+}
+
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::II
+DETAILS:		protected
+DESCRIPTION:	Implementation of basic MD5 transformation algorithm
+RETURNS:		none
+ARGUMENTS:		DWORD &A, B, C, D : Current (partial) checksum
+				DWORD X           : Input data
+				DWORD S			  : MD5_SXX Transformation constant
+				DWORD T			  :	MD5_TXX Transformation constant
+NOTES:			None
+*****************************************************************************************/
+void CMD5Checksum::II( DWORD& A, DWORD B, DWORD C, DWORD D, DWORD X, DWORD S, DWORD T)
+{
+	DWORD I = (C ^ (B | ~D));
+	A += I + X + T;
+	A = RotateLeft(A, S);
+	A += B;
+}
+
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::ByteToDWord
+DETAILS:		private
+DESCRIPTION:	Transfers the data in an 8 bit array to a 32 bit array
+RETURNS:		void
+ARGUMENTS:		DWORD* Output : the 32 bit (unsigned long) destination array 
+				BYTE* Input	  : the 8 bit (unsigned char) source array
+				UINT nLength  : the number of 8 bit data items in the source array
+NOTES:			Four BYTES from the input array are transferred to each DWORD entry
+				of the output array. The first BYTE is transferred to the bits (0-7) 
+				of the output DWORD, the second BYTE to bits 8-15 etc. 
+				The algorithm assumes that the input array is a multiple of 4 bytes long
+				so that there is a perfect fit into the array of 32 bit words.
+*****************************************************************************************/
+void CMD5Checksum::ByteToDWord(DWORD* Output, BYTE* Input, UINT nLength)
+{
+
+	//initialisations
+	UINT i=0;	//index to Output array
+	UINT j=0;	//index to Input array
+
+	//transfer the data by shifting and copying
+	for ( ; j < nLength; i++, j += 4)
+	{
+		Output[i] = (UINT)Input[j]			| 
+					(UINT)Input[j+1] << 8	| 
+					(UINT)Input[j+2] << 16 | 
+					(UINT)Input[j+3] << 24;
+	}
+}
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::Transform
+DETAILS:		protected
+DESCRIPTION:	MD5 basic transformation algorithm;  transforms 'm_lMD5'
+RETURNS:		void
+ARGUMENTS:		BYTE Block[64]
+NOTES:			An MD5 checksum is calculated by four rounds of 'Transformation'.
+				The MD5 checksum currently held in m_lMD5 is merged by the 
+				transformation process with data passed in 'Block'.  
+*****************************************************************************************/
+void CMD5Checksum::Transform(BYTE Block[64])
+{
+	//initialise local data with current checksum
+	UINT a = m_lMD5[0];
+	UINT b = m_lMD5[1];
+	UINT c = m_lMD5[2];
+	UINT d = m_lMD5[3];
+
+	//copy BYTES from input 'Block' to an array of UINTS 'X'
+	UINT X[16];
+	ByteToDWord( X, Block, 64 );
+
+	//Perform Round 1 of the transformation
+	FF (a, b, c, d, X[ 0], MD5_S11, MD5_T01); 
+	FF (d, a, b, c, X[ 1], MD5_S12, MD5_T02); 
+	FF (c, d, a, b, X[ 2], MD5_S13, MD5_T03); 
+	FF (b, c, d, a, X[ 3], MD5_S14, MD5_T04); 
+	FF (a, b, c, d, X[ 4], MD5_S11, MD5_T05); 
+	FF (d, a, b, c, X[ 5], MD5_S12, MD5_T06); 
+	FF (c, d, a, b, X[ 6], MD5_S13, MD5_T07); 
+	FF (b, c, d, a, X[ 7], MD5_S14, MD5_T08); 
+	FF (a, b, c, d, X[ 8], MD5_S11, MD5_T09); 
+	FF (d, a, b, c, X[ 9], MD5_S12, MD5_T10); 
+	FF (c, d, a, b, X[10], MD5_S13, MD5_T11); 
+	FF (b, c, d, a, X[11], MD5_S14, MD5_T12); 
+	FF (a, b, c, d, X[12], MD5_S11, MD5_T13); 
+	FF (d, a, b, c, X[13], MD5_S12, MD5_T14); 
+	FF (c, d, a, b, X[14], MD5_S13, MD5_T15); 
+	FF (b, c, d, a, X[15], MD5_S14, MD5_T16); 
+
+	//Perform Round 2 of the transformation
+	GG (a, b, c, d, X[ 1], MD5_S21, MD5_T17); 
+	GG (d, a, b, c, X[ 6], MD5_S22, MD5_T18); 
+	GG (c, d, a, b, X[11], MD5_S23, MD5_T19); 
+	GG (b, c, d, a, X[ 0], MD5_S24, MD5_T20); 
+	GG (a, b, c, d, X[ 5], MD5_S21, MD5_T21); 
+	GG (d, a, b, c, X[10], MD5_S22, MD5_T22); 
+	GG (c, d, a, b, X[15], MD5_S23, MD5_T23); 
+	GG (b, c, d, a, X[ 4], MD5_S24, MD5_T24); 
+	GG (a, b, c, d, X[ 9], MD5_S21, MD5_T25); 
+	GG (d, a, b, c, X[14], MD5_S22, MD5_T26); 
+	GG (c, d, a, b, X[ 3], MD5_S23, MD5_T27); 
+	GG (b, c, d, a, X[ 8], MD5_S24, MD5_T28); 
+	GG (a, b, c, d, X[13], MD5_S21, MD5_T29); 
+	GG (d, a, b, c, X[ 2], MD5_S22, MD5_T30); 
+	GG (c, d, a, b, X[ 7], MD5_S23, MD5_T31); 
+	GG (b, c, d, a, X[12], MD5_S24, MD5_T32); 
+
+	//Perform Round 3 of the transformation
+	HH (a, b, c, d, X[ 5], MD5_S31, MD5_T33); 
+	HH (d, a, b, c, X[ 8], MD5_S32, MD5_T34); 
+	HH (c, d, a, b, X[11], MD5_S33, MD5_T35); 
+	HH (b, c, d, a, X[14], MD5_S34, MD5_T36); 
+	HH (a, b, c, d, X[ 1], MD5_S31, MD5_T37); 
+	HH (d, a, b, c, X[ 4], MD5_S32, MD5_T38); 
+	HH (c, d, a, b, X[ 7], MD5_S33, MD5_T39); 
+	HH (b, c, d, a, X[10], MD5_S34, MD5_T40); 
+	HH (a, b, c, d, X[13], MD5_S31, MD5_T41); 
+	HH (d, a, b, c, X[ 0], MD5_S32, MD5_T42); 
+	HH (c, d, a, b, X[ 3], MD5_S33, MD5_T43); 
+	HH (b, c, d, a, X[ 6], MD5_S34, MD5_T44); 
+	HH (a, b, c, d, X[ 9], MD5_S31, MD5_T45); 
+	HH (d, a, b, c, X[12], MD5_S32, MD5_T46); 
+	HH (c, d, a, b, X[15], MD5_S33, MD5_T47); 
+	HH (b, c, d, a, X[ 2], MD5_S34, MD5_T48); 
+
+	//Perform Round 4 of the transformation
+	II (a, b, c, d, X[ 0], MD5_S41, MD5_T49); 
+	II (d, a, b, c, X[ 7], MD5_S42, MD5_T50); 
+	II (c, d, a, b, X[14], MD5_S43, MD5_T51); 
+	II (b, c, d, a, X[ 5], MD5_S44, MD5_T52); 
+	II (a, b, c, d, X[12], MD5_S41, MD5_T53); 
+	II (d, a, b, c, X[ 3], MD5_S42, MD5_T54); 
+	II (c, d, a, b, X[10], MD5_S43, MD5_T55); 
+	II (b, c, d, a, X[ 1], MD5_S44, MD5_T56); 
+	II (a, b, c, d, X[ 8], MD5_S41, MD5_T57); 
+	II (d, a, b, c, X[15], MD5_S42, MD5_T58); 
+	II (c, d, a, b, X[ 6], MD5_S43, MD5_T59); 
+	II (b, c, d, a, X[13], MD5_S44, MD5_T60); 
+	II (a, b, c, d, X[ 4], MD5_S41, MD5_T61); 
+	II (d, a, b, c, X[11], MD5_S42, MD5_T62); 
+	II (c, d, a, b, X[ 2], MD5_S43, MD5_T63); 
+	II (b, c, d, a, X[ 9], MD5_S44, MD5_T64); 
+
+	//add the transformed values to the current checksum
+	m_lMD5[0] += a;
+	m_lMD5[1] += b;
+	m_lMD5[2] += c;
+	m_lMD5[3] += d;
+}
+
+
+/*****************************************************************************************
+CONSTRUCTOR:	CMD5Checksum
+DESCRIPTION:	Initialises member data
+ARGUMENTS:		None
+NOTES:			None
+*****************************************************************************************/
+CMD5Checksum::CMD5Checksum()
+{
+	// zero members
+	memset( m_lpszBuffer, 0, 64 );
+	m_nCount[0] = m_nCount[1] = 0;
+	m_pBuffer = NULL;
+	// Load magic state initialization constants
+	m_lMD5[0] = MD5_INIT_STATE_0;
+	m_lMD5[1] = MD5_INIT_STATE_1;
+	m_lMD5[2] = MD5_INIT_STATE_2;
+	m_lMD5[3] = MD5_INIT_STATE_3;
+	m_pBuffer = NULL;
+}
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::DWordToByte
+DETAILS:		private
+DESCRIPTION:	Transfers the data in an 32 bit array to a 8 bit array
+RETURNS:		void
+ARGUMENTS:		BYTE* Output  : the 8 bit destination array 
+				DWORD* Input  : the 32 bit source array
+				UINT nLength  : the number of 8 bit data items in the source array
+NOTES:			One DWORD from the input array is transferred into four BYTES 
+				in the output array. The first (0-7) bits of the first DWORD are 
+				transferred to the first output BYTE, bits bits 8-15 are transferred from
+				the second BYTE etc. 
+				
+				The algorithm assumes that the output array is a multiple of 4 bytes long
+				so that there is a perfect fit of 8 bit BYTES into the 32 bit DWORDs.
+*****************************************************************************************/
+void CMD5Checksum::DWordToByte(BYTE* Output, DWORD* Input, UINT nLength )
+{
+	//transfer the data by shifting and copying
+	UINT i = 0;
+	UINT j = 0;
+	for ( ; j < nLength; i++, j += 4) 
+	{
+		Output[j] =   (UCHAR)(Input[i] & 0xff);
+		Output[j+1] = (UCHAR)((Input[i] >> 8) & 0xff);
+		Output[j+2] = (UCHAR)((Input[i] >> 16) & 0xff);
+		Output[j+3] = (UCHAR)((Input[i] >> 24) & 0xff);
+	}
+}
+
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::Final
+DETAILS:		protected
+DESCRIPTION:	Implementation of main MD5 checksum algorithm; ends the checksum calculation.
+RETURNS:		CString : the final hexadecimal MD5 checksum result 
+ARGUMENTS:		None
+NOTES:			Performs the final MD5 checksum calculation ('Update' does most of the work,
+				this function just finishes the calculation.) 
+*****************************************************************************************/
+tstring CMD5Checksum::Final()
+{
+	//Save number of bits
+	BYTE Bits[8];
+	DWordToByte( Bits, m_nCount, 8 );
+
+	//Pad out to 56 mod 64.
+	UINT nIndex = (UINT)((m_nCount[0] >> 3) & 0x3f);
+	UINT nPadLen = (nIndex < 56) ? (56 - nIndex) : (120 - nIndex);
+	Update( PADDING, nPadLen );
+
+	//Append length (before padding)
+	Update( Bits, 8 );
+
+	//Store final state in 'lpszMD5'
+	const int nMD5Size = 16;
+	unsigned char lpszMD5[ nMD5Size ];
+	DWordToByte( lpszMD5, m_lMD5, nMD5Size );
+
+	//Convert the hexadecimal checksum to a CString
+	tstring strMD5;
+	tchar str[10];
+	strMD5=_T("");
+	for ( int i=0; i < nMD5Size; i++) 
+	{
+		if (lpszMD5[i] == 0) {
+			_tcscpy(str,_T("00"));
+		}
+		else if (lpszMD5[i] <= 15) 	{
+			_stprintf(str,_T("0%x"),lpszMD5[i]);
+		}
+		else {
+			_stprintf(str,_T("%x"),lpszMD5[i]);
+		}
+
+		assert( _tcslen(str)== 2 );
+		strMD5 += str;
+	}
+	assert( strMD5.size()== 32 );
+	return strMD5;
+}
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::Final
+DETAILS:		protected
+DESCRIPTION:	Implementation of main MD5 checksum algorithm; ends the checksum calculation.
+RETURNS:		CString : the final hexadecimal MD5 checksum result 
+ARGUMENTS:		None
+NOTES:			Performs the final MD5 checksum calculation ('Update' does most of the work,
+				this function just finishes the calculation.) 
+*****************************************************************************************/
+unsigned char * CMD5Checksum::FinalChar()
+{
+	//Save number of bits
+	BYTE Bits[8];
+	DWordToByte( Bits, m_nCount, 8 );
+
+	//Pad out to 56 mod 64.
+	UINT nIndex = (UINT)((m_nCount[0] >> 3) & 0x3f);
+	UINT nPadLen = (nIndex < 56) ? (56 - nIndex) : (120 - nIndex);
+	Update( PADDING, nPadLen );
+
+	//Append length (before padding)
+	Update( Bits, 8 );
+
+	//Store final state in 'lpszMD5'
+	const int nMD5Size = 16;
+	if (m_pBuffer)
+	{
+		delete []m_pBuffer;
+		m_pBuffer = NULL;
+	}
+	m_pBuffer = new BYTE[nMD5Size];
+	DWordToByte( m_pBuffer, m_lMD5, nMD5Size );
+	return m_pBuffer;
+//	unsigned char lpszMD5[ nMD5Size ];
+//	DWordToByte( lpszMD5, m_lMD5, nMD5Size );
+
+//	return lpszMD5;
+}
+
+/*****************************************************************************************
+FUNCTION:		CMD5Checksum::Update
+DETAILS:		protected
+DESCRIPTION:	Implementation of main MD5 checksum algorithm
+RETURNS:		void
+ARGUMENTS:		BYTE* Input    : input block
+				UINT nInputLen : length of input block
+NOTES:			Computes the partial MD5 checksum for 'nInputLen' bytes of data in 'Input'
+*****************************************************************************************/
+void CMD5Checksum::Update( BYTE* Input,	UINT nInputLen )
+{
+	//Compute number of bytes mod 64
+	UINT nIndex = (UINT)((m_nCount[0] >> 3) & 0x3F);
+
+	//Update number of bits
+	if ( ( m_nCount[0] += nInputLen << 3 )  <  ( nInputLen << 3) )
+	{
+		m_nCount[1]++;
+	}
+	m_nCount[1] += (nInputLen >> 29);
+
+	//Transform as many times as possible.
+	UINT i=0;		
+	UINT nPartLen = 64 - nIndex;
+	if (nInputLen >= nPartLen) 	
+	{
+		memcpy( &m_lpszBuffer[nIndex], Input, nPartLen );
+		Transform( m_lpszBuffer );
+		for (i = nPartLen; i + 63 < nInputLen; i += 64) 
+		{
+			Transform( &Input[i] );
+		}
+		nIndex = 0;
+	} 
+	else 
+	{
+		i = 0;
+	}
+
+	// Buffer remaining input
+	memcpy( &m_lpszBuffer[nIndex], &Input[i], nInputLen-i);
+}
+
+
diff --git a/bootable/recovery/rkupdate/RKAndroidDevice.cpp b/bootable/recovery/rkupdate/RKAndroidDevice.cpp
new file mode 100755
index 0000000000..8f48f164c9
--- /dev/null
+++ b/bootable/recovery/rkupdate/RKAndroidDevice.cpp
@@ -0,0 +1,3756 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "rkupdate/RKAndroidDevice.h"
+#define tole(x)		(x)
+/*factor is 0xedb88320*/
+bool CRKAndroidDevice::bGptFlag = 0;
+unsigned int crc32table_le[] = {
+	tole(0x00000000L), tole(0x77073096L), tole(0xee0e612cL), tole(0x990951baL),
+	tole(0x076dc419L), tole(0x706af48fL), tole(0xe963a535L), tole(0x9e6495a3L),
+	tole(0x0edb8832L), tole(0x79dcb8a4L), tole(0xe0d5e91eL), tole(0x97d2d988L),
+	tole(0x09b64c2bL), tole(0x7eb17cbdL), tole(0xe7b82d07L), tole(0x90bf1d91L),
+	tole(0x1db71064L), tole(0x6ab020f2L), tole(0xf3b97148L), tole(0x84be41deL),
+	tole(0x1adad47dL), tole(0x6ddde4ebL), tole(0xf4d4b551L), tole(0x83d385c7L),
+	tole(0x136c9856L), tole(0x646ba8c0L), tole(0xfd62f97aL), tole(0x8a65c9ecL),
+	tole(0x14015c4fL), tole(0x63066cd9L), tole(0xfa0f3d63L), tole(0x8d080df5L),
+	tole(0x3b6e20c8L), tole(0x4c69105eL), tole(0xd56041e4L), tole(0xa2677172L),
+	tole(0x3c03e4d1L), tole(0x4b04d447L), tole(0xd20d85fdL), tole(0xa50ab56bL),
+	tole(0x35b5a8faL), tole(0x42b2986cL), tole(0xdbbbc9d6L), tole(0xacbcf940L),
+	tole(0x32d86ce3L), tole(0x45df5c75L), tole(0xdcd60dcfL), tole(0xabd13d59L),
+	tole(0x26d930acL), tole(0x51de003aL), tole(0xc8d75180L), tole(0xbfd06116L),
+	tole(0x21b4f4b5L), tole(0x56b3c423L), tole(0xcfba9599L), tole(0xb8bda50fL),
+	tole(0x2802b89eL), tole(0x5f058808L), tole(0xc60cd9b2L), tole(0xb10be924L),
+	tole(0x2f6f7c87L), tole(0x58684c11L), tole(0xc1611dabL), tole(0xb6662d3dL),
+	tole(0x76dc4190L), tole(0x01db7106L), tole(0x98d220bcL), tole(0xefd5102aL),
+	tole(0x71b18589L), tole(0x06b6b51fL), tole(0x9fbfe4a5L), tole(0xe8b8d433L),
+	tole(0x7807c9a2L), tole(0x0f00f934L), tole(0x9609a88eL), tole(0xe10e9818L),
+	tole(0x7f6a0dbbL), tole(0x086d3d2dL), tole(0x91646c97L), tole(0xe6635c01L),
+	tole(0x6b6b51f4L), tole(0x1c6c6162L), tole(0x856530d8L), tole(0xf262004eL),
+	tole(0x6c0695edL), tole(0x1b01a57bL), tole(0x8208f4c1L), tole(0xf50fc457L),
+	tole(0x65b0d9c6L), tole(0x12b7e950L), tole(0x8bbeb8eaL), tole(0xfcb9887cL),
+	tole(0x62dd1ddfL), tole(0x15da2d49L), tole(0x8cd37cf3L), tole(0xfbd44c65L),
+	tole(0x4db26158L), tole(0x3ab551ceL), tole(0xa3bc0074L), tole(0xd4bb30e2L),
+	tole(0x4adfa541L), tole(0x3dd895d7L), tole(0xa4d1c46dL), tole(0xd3d6f4fbL),
+	tole(0x4369e96aL), tole(0x346ed9fcL), tole(0xad678846L), tole(0xda60b8d0L),
+	tole(0x44042d73L), tole(0x33031de5L), tole(0xaa0a4c5fL), tole(0xdd0d7cc9L),
+	tole(0x5005713cL), tole(0x270241aaL), tole(0xbe0b1010L), tole(0xc90c2086L),
+	tole(0x5768b525L), tole(0x206f85b3L), tole(0xb966d409L), tole(0xce61e49fL),
+	tole(0x5edef90eL), tole(0x29d9c998L), tole(0xb0d09822L), tole(0xc7d7a8b4L),
+	tole(0x59b33d17L), tole(0x2eb40d81L), tole(0xb7bd5c3bL), tole(0xc0ba6cadL),
+	tole(0xedb88320L), tole(0x9abfb3b6L), tole(0x03b6e20cL), tole(0x74b1d29aL),
+	tole(0xead54739L), tole(0x9dd277afL), tole(0x04db2615L), tole(0x73dc1683L),
+	tole(0xe3630b12L), tole(0x94643b84L), tole(0x0d6d6a3eL), tole(0x7a6a5aa8L),
+	tole(0xe40ecf0bL), tole(0x9309ff9dL), tole(0x0a00ae27L), tole(0x7d079eb1L),
+	tole(0xf00f9344L), tole(0x8708a3d2L), tole(0x1e01f268L), tole(0x6906c2feL),
+	tole(0xf762575dL), tole(0x806567cbL), tole(0x196c3671L), tole(0x6e6b06e7L),
+	tole(0xfed41b76L), tole(0x89d32be0L), tole(0x10da7a5aL), tole(0x67dd4accL),
+	tole(0xf9b9df6fL), tole(0x8ebeeff9L), tole(0x17b7be43L), tole(0x60b08ed5L),
+	tole(0xd6d6a3e8L), tole(0xa1d1937eL), tole(0x38d8c2c4L), tole(0x4fdff252L),
+	tole(0xd1bb67f1L), tole(0xa6bc5767L), tole(0x3fb506ddL), tole(0x48b2364bL),
+	tole(0xd80d2bdaL), tole(0xaf0a1b4cL), tole(0x36034af6L), tole(0x41047a60L),
+	tole(0xdf60efc3L), tole(0xa867df55L), tole(0x316e8eefL), tole(0x4669be79L),
+	tole(0xcb61b38cL), tole(0xbc66831aL), tole(0x256fd2a0L), tole(0x5268e236L),
+	tole(0xcc0c7795L), tole(0xbb0b4703L), tole(0x220216b9L), tole(0x5505262fL),
+	tole(0xc5ba3bbeL), tole(0xb2bd0b28L), tole(0x2bb45a92L), tole(0x5cb36a04L),
+	tole(0xc2d7ffa7L), tole(0xb5d0cf31L), tole(0x2cd99e8bL), tole(0x5bdeae1dL),
+	tole(0x9b64c2b0L), tole(0xec63f226L), tole(0x756aa39cL), tole(0x026d930aL),
+	tole(0x9c0906a9L), tole(0xeb0e363fL), tole(0x72076785L), tole(0x05005713L),
+	tole(0x95bf4a82L), tole(0xe2b87a14L), tole(0x7bb12baeL), tole(0x0cb61b38L),
+	tole(0x92d28e9bL), tole(0xe5d5be0dL), tole(0x7cdcefb7L), tole(0x0bdbdf21L),
+	tole(0x86d3d2d4L), tole(0xf1d4e242L), tole(0x68ddb3f8L), tole(0x1fda836eL),
+	tole(0x81be16cdL), tole(0xf6b9265bL), tole(0x6fb077e1L), tole(0x18b74777L),
+	tole(0x88085ae6L), tole(0xff0f6a70L), tole(0x66063bcaL), tole(0x11010b5cL),
+	tole(0x8f659effL), tole(0xf862ae69L), tole(0x616bffd3L), tole(0x166ccf45L),
+	tole(0xa00ae278L), tole(0xd70dd2eeL), tole(0x4e048354L), tole(0x3903b3c2L),
+	tole(0xa7672661L), tole(0xd06016f7L), tole(0x4969474dL), tole(0x3e6e77dbL),
+	tole(0xaed16a4aL), tole(0xd9d65adcL), tole(0x40df0b66L), tole(0x37d83bf0L),
+	tole(0xa9bcae53L), tole(0xdebb9ec5L), tole(0x47b2cf7fL), tole(0x30b5ffe9L),
+	tole(0xbdbdf21cL), tole(0xcabac28aL), tole(0x53b39330L), tole(0x24b4a3a6L),
+	tole(0xbad03605L), tole(0xcdd70693L), tole(0x54de5729L), tole(0x23d967bfL),
+	tole(0xb3667a2eL), tole(0xc4614ab8L), tole(0x5d681b02L), tole(0x2a6f2b94L),
+	tole(0xb40bbe37L), tole(0xc30c8ea1L), tole(0x5a05df1bL), tole(0x2d02ef8dL)
+};
+
+CHAR CRKAndroidDevice::FindIDBlock(char pos,char &IDBlockPos)
+{
+	BYTE bData[SECTOR_SIZE*4];
+	int iRet = ERR_SUCCESS;
+	int i = FindValidBlocks(pos,1);
+	if ( i<0 )
+		return -1;
+	for( ;i<IDBLOCK_TOP;i=FindValidBlocks(i+1,1) )
+	{
+		if ( i<0 )
+		{
+			break;
+		}
+		memset(bData,0,SECTOR_SIZE*4);
+		iRet = m_pComm->RKU_ReadSector( i*m_flashInfo.uiSectorPerBlock, 4, bData);
+
+		if(ERR_SUCCESS!=iRet)
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:FindIDBlock-->RKU_ReadSector %x failed,RetCode(%d)"),i*m_flashInfo.uiSectorPerBlock,iRet);
+			}
+			return -1;//ݶȡʧ
+		}
+		RKANDROID_IDB_SEC0 *pSec0;
+		pSec0 = (RKANDROID_IDB_SEC0 *)bData;
+		P_RC4((BYTE *)pSec0,SECTOR_SIZE);
+ //       if (bData[514]==0x69)//0x69='i'
+		if (pSec0->dwTag==0x0FF0AA55)
+		{
+			//жtag
+			RKANDROID_IDB_SEC1 *pSec;
+			pSec = (RKANDROID_IDB_SEC1 *)(bData+SECTOR_SIZE);
+			if (pSec->uiChipTag==0x38324B52)
+			{
+				IDBlockPos = i;
+				return 0;//ҵidb
+			}
+			else
+			{
+				continue;//tag
+			}
+        }
+
+	}
+	return -1;
+}
+char CRKAndroidDevice::FindAllIDB()
+{
+	char i,iIndex,iStart=0;
+	CHAR iRet;
+	m_oldIDBCounts = 0;
+	for( i=0; i<5; i++)
+	{
+		iRet = FindIDBlock( iStart,iIndex );
+		if ( iRet<0 )
+		{
+			return m_oldIDBCounts;
+		}
+
+		m_idBlockOffset[(int)i] = iIndex;
+		m_oldIDBCounts++;
+		iStart = iIndex+1;
+	}
+
+	return m_oldIDBCounts;
+}
+bool CRKAndroidDevice::ReserveIDBlock(char iBlockIndex,char iIdblockPos)
+{
+	char i;
+	CHAR iRet;
+	for(i=iIdblockPos; i<IDB_BLOCKS; i++)
+	{
+		iRet = iBlockIndex = FindValidBlocks(iBlockIndex,m_flashInfo.usPhyBlokcPerIDB);
+		if( iRet<0 )
+		{
+			return false;
+		}
+		m_idBlockOffset[(int)i] = iBlockIndex;
+		iBlockIndex += m_flashInfo.usPhyBlokcPerIDB;
+	}
+	return true;
+}
+bool CRKAndroidDevice::CalcIDBCount()
+{
+	bool bRet;
+	UINT uiIdSectorNum;//ID BLOCK
+
+	bRet = GetLoaderSize();
+	if (!bRet)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:CalcIDBCount-->GetLoaderSize failed"));
+		}
+		return false;
+	}
+	bRet = GetLoaderDataSize();
+	if (!bRet)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:CalcIDBCount-->GetLoaderDataSize failed"));
+		}
+		return false;
+	}
+	uiIdSectorNum = 4 + m_usFlashDataSec + m_usFlashBootSec;
+
+	m_flashInfo.uiSecNumPerIDB = uiIdSectorNum;
+	m_flashInfo.usPhyBlokcPerIDB = CALC_UNIT(uiIdSectorNum,m_flashInfo.usValidSecPerBlock);
+	return true;
+}
+bool CRKAndroidDevice::OffsetIDBlock(char pos)
+{
+	int iBlockIndex,i;
+	for ( i=0;i<m_flashInfo.usPhyBlokcPerIDB;i++)
+	{
+		m_flashInfo.blockState[m_idBlockOffset[(int)pos]+i]=1;//ϻ
+	}
+	iBlockIndex = m_idBlockOffset[(int)pos]+m_flashInfo.usPhyBlokcPerIDB;
+	for(i=pos; i<5; i++)
+	{
+		iBlockIndex = FindValidBlocks(iBlockIndex, m_flashInfo.usPhyBlokcPerIDB);
+		if ( iBlockIndex<0 )
+		{
+			return false;
+		}
+		m_idBlockOffset[i] = iBlockIndex;
+		iBlockIndex += m_flashInfo.usPhyBlokcPerIDB;
+	}
+
+	return true;
+}
+bool CRKAndroidDevice::GetLoaderSize()
+{
+	if (!m_pImage)
+	{
+		return false;
+	}
+	CHAR index;
+	bool bRet;
+	tchar loaderName[]=_T("FlashBoot");
+	index = m_pImage->m_bootObject->GetIndexByName(ENTRYLOADER,loaderName);
+	if (index==-1)
+	{
+		return false;
+	}
+	DWORD dwDelay;
+	bRet = m_pImage->m_bootObject->GetEntryProperty(ENTRYLOADER,index,m_dwLoaderSize,dwDelay);
+	if (bRet)
+	{
+		m_usFlashBootSec = PAGEALIGN(BYTE2SECTOR(m_dwLoaderSize))*4;
+	}
+	return bRet;
+}
+bool CRKAndroidDevice::GetLoaderDataSize()
+{
+	if (!m_pImage)
+	{
+		return false;
+	}
+	CHAR index;
+	bool bRet;
+	tchar loaderName[]=_T("FlashData");
+	index = m_pImage->m_bootObject->GetIndexByName(ENTRYLOADER,loaderName);
+	if (index==-1)
+	{
+		return false;
+	}
+	DWORD dwDelay;
+	bRet = m_pImage->m_bootObject->GetEntryProperty(ENTRYLOADER,index,m_dwLoaderDataSize,dwDelay);
+	if (bRet)
+	{
+		m_usFlashDataSec = PAGEALIGN(BYTE2SECTOR(m_dwLoaderDataSize))*4;
+	}
+	return bRet;
+}
+
+CRKAndroidDevice::CRKAndroidDevice(STRUCT_RKDEVICE_DESC &device):CRKDevice(device)
+{
+	m_oldSec0 = NULL;
+	m_oldSec1 = NULL;
+	m_oldSec2 = NULL;
+	m_oldSec3 = NULL;
+	m_dwLoaderSize = 0;
+	m_dwLoaderDataSize = 0;
+	m_oldIDBCounts = 0;
+	m_usFlashBootSec = 0;
+	m_usFlashDataSec = 0;
+	m_dwBackupOffset = 0xFFFFFFFF;
+	m_paramBuffer = NULL;
+	m_pCallback = NULL;
+	m_pProcessCallback = NULL;
+}
+CRKAndroidDevice::~CRKAndroidDevice()
+{
+	if (m_oldSec0)
+	{
+		delete m_oldSec0;
+		m_oldSec0 = NULL;
+	}
+	if (m_oldSec1)
+	{
+		delete m_oldSec1;
+		m_oldSec1 = NULL;
+	}
+	if (m_oldSec2)
+	{
+		delete m_oldSec2;
+		m_oldSec2 = NULL;
+	}
+	if (m_oldSec3)
+	{
+		delete m_oldSec3;
+		m_oldSec3 = NULL;
+	}
+	if (m_paramBuffer)
+	{
+		delete []m_paramBuffer;
+		m_paramBuffer = NULL;
+	}
+}
+bool CRKAndroidDevice::GetOldSectorData()
+{
+	BYTE bData[SECTOR_SIZE*4];
+
+	if (m_oldIDBCounts<=0)
+	{
+		return false;
+	}
+
+	if (!GetWriteBackData(m_oldIDBCounts,bData))
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:GetOldSectorData-->GetWriteBackData failed"));
+		}
+		return false;//ݶȡʧ
+	}
+	PBYTE pSec;
+	if (!m_oldSec0)
+	{
+		m_oldSec0 = new RKANDROID_IDB_SEC0;
+	}
+	pSec = (PBYTE)(m_oldSec0);
+	memset(pSec,0,SECTOR_SIZE);
+	memcpy(pSec,bData,SECTOR_SIZE);
+	P_RC4(pSec,SECTOR_SIZE);
+
+	if (!m_oldSec1)
+	{
+		m_oldSec1 = new RKANDROID_IDB_SEC1;
+	}
+	pSec = (PBYTE)(m_oldSec1);
+	memset(pSec,0,SECTOR_SIZE);
+	memcpy(pSec,bData+512,SECTOR_SIZE);
+
+	if (!m_oldSec2)
+	{
+		m_oldSec2 = new RKANDROID_IDB_SEC2;
+	}
+	pSec = (PBYTE)(m_oldSec2);
+	memset(pSec,0,SECTOR_SIZE);
+	memcpy(pSec,bData+512*2,SECTOR_SIZE);
+	P_RC4(pSec,SECTOR_SIZE);
+
+	if (!m_oldSec3)
+	{
+		m_oldSec3 = new RKANDROID_IDB_SEC3;
+	}
+	pSec = (PBYTE)(m_oldSec3);
+	memset(pSec,0,SECTOR_SIZE);
+	memcpy(pSec,bData+512*3,SECTOR_SIZE);
+	P_RC4(pSec,SECTOR_SIZE);
+
+	return true;
+
+}
+bool CRKAndroidDevice::MakeSector0(PBYTE pSector)
+{
+	PRKANDROID_IDB_SEC0 pSec0;
+	memset(pSector,0,SECTOR_SIZE);
+	pSec0 = (PRKANDROID_IDB_SEC0)pSector;
+
+	pSec0->dwTag = 0x0FF0AA55;
+	if (m_pImage->m_bootObject->Rc4DisableFlag)
+	{
+		pSec0->uiRc4Flag = 1;
+	}
+	pSec0->usBootCode1Offset = 0x4;
+	pSec0->usBootCode2Offset = 0x4;
+	pSec0->usBootDataSize = m_usFlashDataSec;
+	pSec0->usBootCodeSize = m_usFlashDataSec + m_usFlashBootSec;
+
+//	pSec0->usCrc = CRC_16(pSector,SECTOR_SIZE-2);
+	return true;
+}
+
+void CRKAndroidDevice::MakeSector1(PBYTE pSector)
+{
+	PRKANDROID_IDB_SEC1 pSec1;
+	memset(pSector,0,SECTOR_SIZE);
+	pSec1 = (PRKANDROID_IDB_SEC1)pSector;
+	USHORT usSysReserved;
+	if ((m_idBlockOffset[4]+1)%12==0)
+	{
+		usSysReserved=m_idBlockOffset[4]+13;
+	}
+	else
+	{
+		usSysReserved =((m_idBlockOffset[4]+1)/12+1)*12;
+	}
+	if (usSysReserved>IDBLOCK_TOP)
+	{
+		usSysReserved = IDBLOCK_TOP;
+	}
+	pSec1->usSysReservedBlock = usSysReserved;
+
+
+	pSec1->usDisk0Size = 0;
+	pSec1->usDisk1Size = 0;
+	pSec1->usDisk2Size = 0;
+	pSec1->usDisk3Size = 0;
+	pSec1->uiChipTag = 0x38324B52;
+	pSec1->uiMachineId = 0;
+	pSec1->usLoaderYear = UshortToBCD(((STRUCT_RKTIME)m_pImage->m_bootObject->ReleaseTime).usYear);
+	pSec1->usLoaderDate = ByteToBCD(((STRUCT_RKTIME)m_pImage->m_bootObject->ReleaseTime).ucMonth);
+	pSec1->usLoaderDate = (pSec1->usLoaderDate<<8)|ByteToBCD(((STRUCT_RKTIME)m_pImage->m_bootObject->ReleaseTime).ucDay);
+	pSec1->usLoaderVer =  m_pImage->m_bootObject->Version;
+	if (m_oldSec1)
+	{
+		pSec1->usLastLoaderVer = m_oldSec1->usLoaderVer;
+		pSec1->usReadWriteTimes = m_oldSec1->usReadWriteTimes+1;
+	}
+	else
+	{
+		pSec1->usLastLoaderVer = 0;
+		pSec1->usReadWriteTimes = 1;
+	}
+	pSec1->uiFlashSize = m_flashInfo.uiFlashSize*2*1024;
+	pSec1->usBlockSize = m_flashInfo.usBlockSize*2;
+	pSec1->bPageSize = m_flashInfo.uiPageSize*2;
+	pSec1->bECCBits = m_flashInfo.bECCBits;
+	pSec1->bAccessTime = m_flashInfo.bAccessTime;
+
+	pSec1->usFlashInfoLen = 0;
+	pSec1->usFlashInfoOffset = 0;
+
+
+	pSec1->usIdBlock0 = m_idBlockOffset[0];
+	pSec1->usIdBlock1 = m_idBlockOffset[1];
+	pSec1->usIdBlock2 = m_idBlockOffset[2];
+	pSec1->usIdBlock3 = m_idBlockOffset[3];
+	pSec1->usIdBlock4 = m_idBlockOffset[4];
+}
+bool CRKAndroidDevice::MakeSector2(PBYTE pSector)
+{
+	PRKANDROID_IDB_SEC2 pSec2;
+	pSec2 = (PRKANDROID_IDB_SEC2)pSector;
+
+	pSec2->usInfoSize = 0;
+	memset(pSec2->bChipInfo,0,CHIPINFO_LEN);
+
+	if (m_oldSec2)
+	{
+		memcpy(pSec2->reserved,m_oldSec2->reserved,RKANDROID_SEC2_RESERVED_LEN);
+		pSec2->usSec3CustomDataOffset = m_oldSec2->usSec3CustomDataOffset;
+		pSec2->usSec3CustomDataSize = m_oldSec2->usSec3CustomDataSize;
+	}
+	else
+	{
+		memset(pSec2->reserved,0,RKANDROID_SEC2_RESERVED_LEN);
+		pSec2->usSec3CustomDataOffset = m_usWriteBackCustomDataOffset;
+		pSec2->usSec3CustomDataSize = m_usWriteBackCustomDataSize;
+	}
+
+	strcpy(pSec2->szVcTag,"VC");
+	strcpy(pSec2->szCrcTag,"CRC");
+	return true;
+}
+bool CRKAndroidDevice::MakeSector3(PBYTE pSector)
+{
+	PRKANDROID_IDB_SEC3 pSec3;
+	memset(pSector,0,SECTOR_SIZE);
+	pSec3 = (PRKANDROID_IDB_SEC3)pSector;
+
+	if (m_oldSec3)
+	{
+		memcpy(pSector,(PBYTE)m_oldSec3,SECTOR_SIZE);
+	}
+	else
+	{
+		//if (m_backupBuffer)
+		//{
+			memcpy(pSector,(PBYTE)m_backupBuffer,SECTOR_SIZE);
+		//}
+	}
+
+
+	if (m_uid)
+	{
+		//if ((m_oldSec3)||(m_backupBuffer))
+		if ((m_oldSec3))
+		{
+			if (!CheckUid(pSec3->uidSize,pSec3->uid))
+			{
+				pSec3->uidSize = RKDEVICE_UID_LEN;
+				memcpy(pSec3->uid,m_uid,RKDEVICE_UID_LEN);
+			}
+		}
+		else
+		{
+			pSec3->uidSize = RKDEVICE_UID_LEN;
+			memcpy(pSec3->uid,m_uid,RKDEVICE_UID_LEN);
+		}
+	}
+
+	return true;
+}
+int CRKAndroidDevice::MakeIDBlockData(PBYTE lpIDBlock)
+{
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("INFO:MakeIDBlockData in"));
+	}
+ 	RKANDROID_IDB_SEC0 sector0Info;
+	RKANDROID_IDB_SEC1 sector1Info;
+	RKANDROID_IDB_SEC2 sector2Info;
+	RKANDROID_IDB_SEC3 sector3Info;
+
+	if (!m_pImage)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeIDBlockData-->Image is invalid"));
+		}
+		return -1;
+	}
+	CHAR index;
+	tchar loaderCodeName[]=_T("FlashBoot");
+	index = m_pImage->m_bootObject->GetIndexByName(ENTRYLOADER,loaderCodeName);
+	if (index==-1)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeIDBlockData-->Get LoaderCode Entry failed"));
+		}
+		return -2;
+	}
+	PBYTE loaderCodeBuffer;
+	loaderCodeBuffer = new BYTE[m_dwLoaderSize];
+	memset(loaderCodeBuffer,0,m_dwLoaderSize);
+	if ( !m_pImage->m_bootObject->GetEntryData(ENTRYLOADER,index,loaderCodeBuffer) )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeIDBlockData-->Get LoaderCode Data failed"));
+		}
+		delete []loaderCodeBuffer;
+		return -3;
+	}
+
+	tchar loaderDataName[]=_T("FlashData");
+	index = m_pImage->m_bootObject->GetIndexByName(ENTRYLOADER,loaderDataName);
+	if (index==-1)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeIDBlockData-->Get LoaderData Entry failed"));
+		}
+		delete []loaderCodeBuffer;
+		return -4;
+	}
+	PBYTE loaderDataBuffer;
+	loaderDataBuffer = new BYTE[m_dwLoaderDataSize];
+	memset(loaderDataBuffer,0,m_dwLoaderDataSize);
+	if ( !m_pImage->m_bootObject->GetEntryData(ENTRYLOADER,index,loaderDataBuffer) )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeIDBlockData-->Get LoaderData Data failed"));
+		}
+		delete []loaderDataBuffer;
+		delete []loaderCodeBuffer;
+		return -5;
+	}
+
+	//////////////  ////////////////////////////////////////////
+	UINT i;
+	MakeSector0((PBYTE)&sector0Info);
+	MakeSector1((PBYTE)&sector1Info);
+	if (!MakeSector2((PBYTE)&sector2Info))
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeIDBlockData-->MakeSector2 failed"));
+		}
+		return -6;
+	}
+	if (!MakeSector3((PBYTE)&sector3Info))
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeIDBlockData-->MakeSector3 failed"));
+		}
+		return -7;
+	}
+	sector2Info.usSec0Crc = CRC_16((PBYTE)&sector0Info,SECTOR_SIZE);
+	sector2Info.usSec1Crc = CRC_16((PBYTE)&sector1Info,SECTOR_SIZE);
+	sector2Info.usSec3Crc = CRC_16((PBYTE)&sector3Info,SECTOR_SIZE);
+
+	memcpy(lpIDBlock, &sector0Info, SECTOR_SIZE);
+	memcpy(lpIDBlock+SECTOR_SIZE, &sector1Info, SECTOR_SIZE);
+//	memcpy(lpIDBlock+SECTOR_SIZE*2, &sector2Info, SECTOR_SIZE);
+	memcpy(lpIDBlock+SECTOR_SIZE*3, &sector3Info, SECTOR_SIZE);
+
+	if (sector0Info.uiRc4Flag)
+	{//close rc4 encryption
+		for (i=0;i<m_dwLoaderDataSize/SECTOR_SIZE;i++)
+		{
+			P_RC4(loaderDataBuffer+SECTOR_SIZE*i,SECTOR_SIZE);
+		}
+		for (i=0;i<m_dwLoaderSize/SECTOR_SIZE;i++)
+		{
+			P_RC4(loaderCodeBuffer+SECTOR_SIZE*i,SECTOR_SIZE);
+		}
+	}
+
+	memcpy(lpIDBlock+SECTOR_SIZE*4, loaderDataBuffer, m_dwLoaderDataSize);
+	memcpy(lpIDBlock+SECTOR_SIZE*(4+m_usFlashDataSec), loaderCodeBuffer, m_dwLoaderSize);
+
+	sector2Info.uiBootCodeCrc = CRC_32((PBYTE)(lpIDBlock+SECTOR_SIZE*4),sector0Info.usBootCodeSize*SECTOR_SIZE);
+	memcpy(lpIDBlock+SECTOR_SIZE*2, &sector2Info, SECTOR_SIZE);
+
+    for(i=0; i<4; i++)
+	{
+        if(i == 1)
+		{
+            continue;
+        }
+        else
+		{
+			P_RC4(lpIDBlock+SECTOR_SIZE*i, SECTOR_SIZE);
+        }
+    }
+
+	delete []loaderDataBuffer;
+	delete []loaderCodeBuffer;
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("INFO:MakeIDBlockData out"));
+	}
+	return 0;
+}
+
+bool CRKAndroidDevice::MakeSpareData(PBYTE lpIDBlock,DWORD dwSectorNum,PBYTE lpSpareBuffer)
+{
+	int i = 0;
+	BYTE bchOutBuf[512+3+13];
+	BYTE bchInBuf[512+3];
+
+	for (i=0; i<dwSectorNum; i++)
+	{
+		memcpy(bchInBuf, lpIDBlock+512*i, 512);
+		bchInBuf[514] = ((i==0) ? 'i' : 0xff);
+		bchInBuf[512] = 0xff;
+		bchInBuf[513] = 0xff;
+		//bchInBufBCH루13ֽڵı룩ɵbchOutBuf(528 Bytes)
+		//bchInBuf(515 Bytes)BCH(13 Bytes)
+		bch_encode(bchInBuf, bchOutBuf);
+		memcpy(lpSpareBuffer+i*16+3, bchOutBuf+515, 13);
+	}
+    lpSpareBuffer[2] = 'i';
+	return true;
+}
+
+int CRKAndroidDevice::WriteIDBlock(PBYTE lpIDBlock,DWORD dwSectorNum,bool bErase)
+{
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("INFO:WriteIDBlock in"));
+	}
+	(void)bErase;
+	//STRUCT_END_WRITE_SECTOR end_write_sector_data;
+	//BYTE writeBuf[16*1024];
+	UINT uiOffset,uiTotal,uiBegin;
+	//UINT uiBufferSize=16*1024;
+	int iRet,i;
+	uiTotal = dwSectorNum*SECTOR_SIZE;
+	uiOffset = 0;
+	uiBegin = 0;
+	for(i=0;i<=4;i++)
+	{
+		iRet = m_pComm->RKU_WriteLBALoader(64+i*1024,dwSectorNum,lpIDBlock);
+		if (iRet!=ERR_SUCCESS)
+		{
+			if (m_pLog)
+				m_pLog->Record(_T("ERROR:WriteIDBlock-->RKU_WriteLBA failed!"));
+			return -1;
+		}
+	}
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("INFO:WriteIDBlock out"));
+	}
+	return 0;
+}
+
+int CRKAndroidDevice::
+	PrepareIDB()
+{
+	int i;
+	generate_gf();
+	gen_poly();
+	string strInfo="";
+	char szTmp[32];
+	bool bFirstCS=false;
+	for(i=0; i<8; i++)
+	{
+		if( m_flashInfo.bFlashCS&(1<<i) )
+		{
+			if (i==0)
+			{
+				bFirstCS = true;
+			}
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("INFO:CS(%d)\t\t(%dMB)\t\t(%s)"),i+1,m_flashInfo.uiFlashSize,m_flashInfo.szManufacturerName);
+			}
+		}
+	}
+	if (!bFirstCS)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:PrepareIDB-->No Found 1st Flash CS"));
+		}
+		return -1;
+	}
+
+	if ( !BuildBlockStateMap(0) )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:PrepareIDB-->BuildBlockStateMap failed"));
+		}
+		return -2;
+	}
+
+	FindAllIDB();
+
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("ERROR:PrepareIDB-->IDblock count=%d."),m_oldIDBCounts);
+	}
+
+
+
+	memset(m_backupBuffer,0,SECTOR_SIZE);
+
+	if (m_oldIDBCounts>0)
+	{
+		if (m_pLog)
+		{
+			strInfo = "";
+			for (i=0;i<m_oldIDBCounts;i++)
+			{
+				sprintf(szTmp,"%d ",m_idBlockOffset[i]);
+				strInfo += szTmp;
+			}
+			m_pLog->Record(_T("ERROR:PrepareIDB-->IDblock offset=%s."),strInfo.c_str());
+		}
+		BYTE buffer[4*SECTOR_SIZE];
+		PRKANDROID_IDB_SEC3 pSec;
+		PRKANDROID_IDB_SEC2 pSec2;
+		pSec2 = (PRKANDROID_IDB_SEC2)(buffer+2*SECTOR_SIZE);
+		pSec = (PRKANDROID_IDB_SEC3)(buffer+3*SECTOR_SIZE);
+
+		if (!GetWriteBackData(m_oldIDBCounts,buffer))
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:PrepareIDB-->GetWriteBackData failed"));
+			}
+			return -3;
+		}
+		P_RC4((PBYTE)pSec2,SECTOR_SIZE);
+		P_RC4((PBYTE)pSec,SECTOR_SIZE);
+		IsExistSector3Crc(pSec2);
+
+		m_usWriteBackCrc = CRC_16((PBYTE)pSec,SECTOR_SIZE);
+		if (m_bExistSector3Crc)
+		{
+			m_usWriteBackCustomDataOffset = pSec2->usSec3CustomDataOffset;
+			m_usWriteBackCustomDataSize = pSec2->usSec3CustomDataSize;
+			if (m_usSector3Crc!=m_usWriteBackCrc)
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("ERROR:PrepareIDB-->Check sector3 crc failed"));
+				}
+			}
+		}
+		memcpy(m_backupBuffer,pSec,SECTOR_SIZE);
+	}
+	else
+	{
+		FindBackupBuffer();
+	}
+
+	if (m_oldIDBCounts>0)
+	{
+		if ( !GetOldSectorData() )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:PrepareIDB-->GetOldSectorData failed"));
+			}
+			return -4;
+		}
+	}
+	if ( !CalcIDBCount() )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:PrepareIDB-->CalcIDBCount failed"));
+		}
+		return -5;
+	}
+	if ( !ReserveIDBlock() )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:PrepareIDB-->ReserveIDBlock failed"));
+		}
+		return -6;
+	}
+	if (m_pLog)
+	{
+		strInfo = "";
+		for (i=0;i<5;i++)
+		{
+			sprintf(szTmp,"%d ",m_idBlockOffset[i]);
+			strInfo += szTmp;
+		}
+		m_pLog->Record(_T("ERROR:PrepareIDB-->New IDblock offset=%s."),strInfo.c_str());
+	}
+
+	return 0;
+}
+
+int CRKAndroidDevice::DownloadIDBlock()
+{
+	DWORD dwSectorNum;
+	dwSectorNum = m_flashInfo.uiSecNumPerIDB;
+
+	PBYTE pIDBData=NULL;
+	pIDBData = new BYTE[dwSectorNum*SECTOR_SIZE];
+	if (!pIDBData)
+		return -1;
+
+	int iRet=0;
+	memset(pIDBData,0,dwSectorNum*SECTOR_SIZE);
+
+	iRet = MakeIDBlockData(pIDBData);
+	if ( iRet!=0 )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:DownloadIDBlock-->MakeIDBlockData failed,RetCode(%d)"),iRet);
+		}
+		return -2;
+	}
+
+	iRet = WriteIDBlock(pIDBData,dwSectorNum,false);
+	delete []pIDBData;
+	if (iRet==0)
+	{
+		return 0;
+	}
+	else
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:DownloadIDBlock-->WriteIDBlock failed,RetCode(%d)"),iRet);
+		}
+		//BufferWriteBack();
+		return -3;
+	}
+
+}
+int CRKAndroidDevice::DownloadImage()
+{
+	long long dwFwOffset;
+	bool  bRet;
+	dwFwOffset = m_pImage->FWOffset;
+	STRUCT_RKIMAGE_HDR rkImageHead;
+	int iHeadSize;
+	iHeadSize = sizeof(STRUCT_RKIMAGE_HDR);
+	char szPrompt[100];
+	if (m_pProcessCallback)
+		m_pProcessCallback(0.1,5);
+	bRet = m_pImage->GetData(dwFwOffset,iHeadSize,(PBYTE)&rkImageHead);
+	if ( !bRet )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:DownloadImage-->GetData failed"));
+		}
+		return -1;
+	}
+	if ( rkImageHead.item_count<=0 )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:DownloadImage-->No Found item"));
+		}
+		return -2;
+	}
+
+	m_dwBackupOffset = 0xFFFFFFFF;
+	int i;
+	bool bFound=false,bFoundSystem=false,bFoundUserData=false;
+	int iParamPos=-1;
+	long long uiTotalSize=0;
+	long long ulItemSize;
+	UINT uiSparseFlag = 0;
+	for ( i=0;i<rkImageHead.item_count;i++ )
+	{
+		if ( rkImageHead.item[i].flash_offset!=0xFFFFFFFF )
+		{
+			if ( strcmp(rkImageHead.item[i].name,PARTNAME_PARAMETER)==0)
+			{
+				bFound = true;
+				iParamPos = i;
+			}
+			else
+			{
+				if (strcmp(rkImageHead.item[i].name,PARTNAME_SYSTEM)==0)
+				{
+					bFoundSystem = true;
+				}
+				if (strcmp(rkImageHead.item[i].name,PARTNAME_USERDATA)==0)
+				{
+					bFoundUserData = true;
+				}
+				if (strcmp(rkImageHead.item[i].name,PARTNAME_BACKUP)==0)
+				{
+					m_dwBackupOffset = rkImageHead.item[i].flash_offset;
+				}
+				if (rkImageHead.item[i].file[55]=='H')
+				{
+					ulItemSize = *((DWORD *)(&rkImageHead.item[i].file[56]));
+					ulItemSize <<= 32;
+					ulItemSize += rkImageHead.item[i].size;
+				}
+				if (IsSparseImage(rkImageHead.item[i]))
+				{
+					uiSparseFlag += (1<<i);
+					ulItemSize = GetSparseImageSize(rkImageHead.item[i]);
+					if (ulItemSize==(long long)-1)
+					{
+						if (m_pLog)
+						{
+							m_pLog->Record(_T("ERROR:DownloadImage-->get sparse size failed,file=%s"),rkImageHead.item[i].name);
+						}
+						return -14;
+					}
+				}
+				else
+					ulItemSize = rkImageHead.item[i].size;
+				uiTotalSize += ulItemSize;
+			}
+
+		}
+	}
+
+	if ( !bFound )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:DownloadImage-->No Found Parameter file"));
+		}
+		return -3;
+	}
+
+	if (!MakeParamFileBuffer(rkImageHead.item[iParamPos]))
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:DownloadImage-->MakeParamFileBuffer failed"));
+		}
+		return -12;
+	}
+
+	GptFlag = GetParameterGptFlag(rkImageHead.item[iParamPos]);
+	bGptFlag = GptFlag;
+	if (!GptFlag)
+	{
+		if (!CheckParamPartSize(rkImageHead,iParamPos))
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:DownloadImage-->CheckParamPartSize failed"));
+			}
+			return -13;
+		}
+		uiTotalSize += (8*m_uiParamFileSize);
+	}
+	else
+		uiTotalSize += (SECTOR_SIZE*67);
+
+
+	m_uiLBATimes = 1;
+	if (m_pProcessCallback)
+		m_pProcessCallback(0.4,60);
+	long long uiCurrentByte=0;
+	for ( i=0;i<rkImageHead.item_count;i++ )
+	{
+		if (m_pProcessCallback)
+			m_pProcessCallback((double)uiCurrentByte/(double)uiTotalSize,0);
+		if ( rkImageHead.item[i].flash_offset==0xFFFFFFFF )
+		{
+			continue;
+		}
+		if (i==iParamPos)
+		{
+			if (m_pCallback)
+			{
+				sprintf(szPrompt,"%s writing... \n",rkImageHead.item[i].name);
+				m_pCallback(szPrompt);
+			}
+			if (GptFlag)
+			{
+				bRet = RKA_Gpt_Download(rkImageHead.item[i],uiCurrentByte,uiTotalSize);
+				if ( !bRet )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:DownloadImage-->RKA_Gpt_Download failed"));
+						m_pCallback("ERROR:DownloadImage-->RKA_Gpt_Download failed \n");
+					}
+					return -4;
+				}
+			}
+			else
+			{
+				bRet = RKA_Param_Download(rkImageHead.item[i],uiCurrentByte,uiTotalSize);
+				if ( !bRet )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T(" ERROR:DownloadImage-->RKA_Param_Download failed"));
+						m_pCallback("ERROR:DownloadImage-->RKA_Param_Download failed \n");
+					}
+	//				if(m_pCallback)
+	//				{
+	//					sprintf(szPrompt,"%s writing... failed",rkImageHead.item[i].name);
+	//					m_pCallback(szPrompt);
+	//				}
+					return -4;
+				}
+			}
+		}
+		else
+		{
+			if (rkImageHead.item[i].file[55]=='H')
+			{
+				ulItemSize = *((DWORD *)(&rkImageHead.item[i].file[56]));
+				ulItemSize <<= 32;
+				ulItemSize += rkImageHead.item[i].size;
+			}
+			else
+				ulItemSize = rkImageHead.item[i].size;
+
+			if (ulItemSize>0)
+			{
+				if (m_pCallback)
+				{
+					sprintf(szPrompt,"%s writing... \n",rkImageHead.item[i].name);
+					m_pCallback(szPrompt);
+				}
+				if (uiSparseFlag & (1<<i))
+				{
+					bRet = RKA_SparseFile_Download(rkImageHead.item[i],uiCurrentByte,uiTotalSize);
+				}
+				else
+					bRet = RKA_File_Download(rkImageHead.item[i],uiCurrentByte,uiTotalSize);
+				if ( !bRet )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:DownloadImage-->RKA_File_Download failed(%s)"),rkImageHead.item[i].name);
+					}
+					m_pCallback("ERROR:DownloadImage-->RKA_File_Download failed(%s) \n",rkImageHead.item[i].name);
+					return -5;
+				}
+			}
+		}
+	}
+	m_pComm->RKU_ReopenLBAHandle();
+	if (m_pProcessCallback)
+		m_pProcessCallback(1,0);
+	if (m_pProcessCallback)
+		m_pProcessCallback(0.4,60);
+	uiCurrentByte = 0;
+	for ( i=0;i<rkImageHead.item_count;i++ )
+	{
+		if (m_pProcessCallback)
+			m_pProcessCallback((double)uiCurrentByte/(double)uiTotalSize,0);
+		if ( rkImageHead.item[i].flash_offset==0xFFFFFFFF )
+		{
+			continue;
+		}
+		if (i==iParamPos)
+		{
+			if (m_pCallback)
+			{
+				sprintf(szPrompt,"%s checking... \n",rkImageHead.item[i].name);
+				m_pCallback(szPrompt);
+			}
+			if (GptFlag)
+			{
+				bRet = RKA_Gpt_Check(rkImageHead.item[i],uiCurrentByte,uiTotalSize);
+				if ( !bRet )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:DownloadImage-->RKA_Gpt_Check failed"));
+					}
+					m_pCallback("ERROR:DownloadImage-->RKA_Gpt_Check failed \n");
+					return -6;
+				}
+			}
+			else
+			{
+				bRet = RKA_Param_Check(rkImageHead.item[i],uiCurrentByte,uiTotalSize);
+				if ( !bRet )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:DownloadImage-->RKA_Param_Check failed"));
+					}
+					m_pCallback("ERROR:DownloadImage-->RKA_Param_Check failed \n");
+					return -6;
+				}
+			}
+		}
+		else
+		{
+			if (rkImageHead.item[i].file[55]=='H')
+			{
+				ulItemSize = *((DWORD *)(&rkImageHead.item[i].file[56]));
+				ulItemSize <<= 32;
+				ulItemSize += rkImageHead.item[i].size;
+			}
+			else
+				ulItemSize = rkImageHead.item[i].size;
+			if (ulItemSize>0)
+			{
+				if (m_pCallback)
+				{
+					sprintf(szPrompt,"%s checking... \n",rkImageHead.item[i].name);
+					m_pCallback(szPrompt);
+				}
+				if (uiSparseFlag & (1<<i))
+				{
+					bRet = RKA_SparseFile_Check(rkImageHead.item[i],uiCurrentByte,uiTotalSize);
+				}
+				else
+					bRet = RKA_File_Check(rkImageHead.item[i],uiCurrentByte,uiTotalSize);
+				if ( !bRet )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:DownloadImage-->RKA_File_Check failed(%s)"),rkImageHead.item[i].name);
+					}
+					m_pCallback("ERROR:DownloadImage-->RKA_File_Check failed(%s) \n",rkImageHead.item[i].name);
+					return -7;
+				}
+			}
+
+		}
+	}
+	if (m_pProcessCallback)
+		m_pProcessCallback(1,0);
+	return 0;
+}
+bool CRKAndroidDevice::write_partition_upgrade_flag(DWORD dwOffset,BYTE *pMd5,UINT uiFlag)
+{
+	BYTE flagSector[SECTOR_SIZE];
+	int iRet;
+	memset(flagSector,0,SECTOR_SIZE);
+	memcpy(flagSector,pMd5,32);
+	memcpy(flagSector+32,(BYTE *)(&uiFlag),4);
+	iRet = m_pComm->RKU_WriteLBA(dwOffset,1,flagSector);
+	if (iRet!=ERR_SUCCESS)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record("ERROR:write_partition_upgrade_flag-->RKU_WriteLBA failed,err=%d",iRet);
+		}
+		return false;
+	}
+	return true;
+}
+bool CRKAndroidDevice::read_partition_upgrade_flag(DWORD dwOffset,BYTE *pMd5,UINT *uiFlag)
+{
+	if (m_pLog)
+	{
+		m_pLog->Record("INFO:read_partition_upgrade_flag in");
+	}
+	BYTE flagSector[SECTOR_SIZE];
+	int iRet;
+	iRet = m_pComm->RKU_ReadLBA(dwOffset,1,flagSector);
+	if (iRet!=ERR_SUCCESS)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record("ERROR:read_partition_upgrade_flag-->RKU_ReadLBA failed,err=%d",iRet);
+		}
+		return false;
+	}
+	memcpy(pMd5,flagSector,32);
+	(*uiFlag) = *((UINT *)(flagSector+32));
+	if (m_pLog)
+	{
+		m_pLog->Record("INFO:read_partition_upgrade_flag out,flag=0x%x",*uiFlag);
+	}
+	return true;
+}
+
+int CRKAndroidDevice::UpgradePartition()
+{
+	long long dwFwOffset;
+	bool  bRet,bSameFw=false;
+	BYTE localMd5[32];
+	BYTE *fwMd5,*fwSignMd5;
+	UINT uiFlag;
+	DWORD dwFlagSector=0;
+	dwFwOffset = m_pImage->FWOffset;
+	STRUCT_RKIMAGE_HDR rkImageHead;
+	vector<int> vecUpgradePartition;
+	vecUpgradePartition.clear();
+	char szPrompt[100];
+	int iHeadSize;
+	iHeadSize = sizeof(STRUCT_RKIMAGE_HDR);
+	if (m_pProcessCallback)
+		m_pProcessCallback(0.1,5);
+
+	bRet = m_pImage->GetData(dwFwOffset,iHeadSize,(PBYTE)&rkImageHead);
+	if ( !bRet )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:UpgradePartition-->GetData failed"));
+		}
+		return -1;
+	}
+	if ( rkImageHead.item_count<=0 )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:UpgradePartition-->No Found item"));
+		}
+		return -2;
+	}
+
+	m_dwBackupOffset = 0xFFFFFFFF;
+	int i;
+	vector<int>::iterator iter;
+	bool bFound=false,bFoundSystem=false,bFoundUserData=false;
+	int iParamPos=-1;
+	long long uiTotalSize=0;
+	long long ulItemSize;
+	for ( i=0;i<rkImageHead.item_count;i++ )
+	{
+		if ( rkImageHead.item[i].flash_offset!=0xFFFFFFFF )
+		{
+			for (iter=vecUpgradePartition.begin();iter!=vecUpgradePartition.end();iter++)
+			{
+				if (rkImageHead.item[*iter].flash_offset>rkImageHead.item[i].flash_offset)
+				{
+					iter = vecUpgradePartition.insert(iter,i);
+					break;
+				}
+			}
+			if (iter==vecUpgradePartition.end())
+			{
+				vecUpgradePartition.push_back(i);
+			}
+			if ( strcmp(rkImageHead.item[i].name,PARTNAME_PARAMETER)==0)
+			{
+				bFound = true;
+				iParamPos = i;
+			}
+			else
+			{
+				if (strcmp(rkImageHead.item[i].name,PARTNAME_SYSTEM)==0)
+				{
+					bFoundSystem = true;
+				}
+				if (strcmp(rkImageHead.item[i].name,PARTNAME_MISC)==0)
+				{
+					dwFlagSector = rkImageHead.item[i].flash_offset + rkImageHead.item[i].part_size -4;
+				}
+				if (strcmp(rkImageHead.item[i].name,PARTNAME_USERDATA)==0)
+				{
+					bFoundUserData = true;
+				}
+				if (strcmp(rkImageHead.item[i].name,PARTNAME_BACKUP)==0)
+				{
+					m_dwBackupOffset = rkImageHead.item[i].flash_offset;
+				}
+				if (rkImageHead.item[i].file[55]=='H')
+				{
+					ulItemSize = *((DWORD *)(&rkImageHead.item[i].file[56]));
+					ulItemSize <<= 32;
+					ulItemSize += rkImageHead.item[i].size;
+				}
+				else
+					ulItemSize = rkImageHead.item[i].size;
+				uiTotalSize += ulItemSize;
+			}
+
+		}
+	}
+
+	if ( !bFound )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:UpgradePartition-->No Found Parameter file"));
+		}
+		return -3;
+	}
+
+	if (!MakeParamFileBuffer(rkImageHead.item[iParamPos]))
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:UpgradePartition-->MakeParamFileBuffer failed"));
+		}
+		return -12;
+	}
+
+	if (!CheckParamPartSize(rkImageHead,iParamPos))
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:UpgradePartition-->CheckParamPartSize failed"));
+		}
+		return -13;
+	}
+	uiTotalSize += (8*m_uiParamFileSize);//ϲļҪĴС
+	m_uiLBATimes = 1;
+	m_pImage->GetMd5Data(fwMd5,fwSignMd5);
+	if (dwFlagSector!=0)
+	{
+		if (read_partition_upgrade_flag(dwFlagSector,localMd5,&uiFlag))
+		{
+			if (memcmp(localMd5,fwMd5,32)==0)
+				bSameFw = true;
+		}
+	}
+	if (m_pProcessCallback)
+		m_pProcessCallback(0.8,90);
+	long long uiCurrentByte=0;
+	for ( i=0;i<vecUpgradePartition.size();i++ )
+	{
+		if (m_pProcessCallback)
+			m_pProcessCallback((double)uiCurrentByte/(double)uiTotalSize,0);
+		if (vecUpgradePartition[i]==iParamPos)
+		{
+			if ((bSameFw)&&(uiFlag>=rkImageHead.item[vecUpgradePartition[i]].flash_offset))
+			{
+				uiCurrentByte += (8*m_uiParamFileSize);
+				continue;
+			}
+			if (m_pCallback)
+			{
+				sprintf(szPrompt,"%s writing...\n",rkImageHead.item[vecUpgradePartition[i]].name);
+				m_pCallback(szPrompt);
+			}
+			bRet = RKA_Param_Download(rkImageHead.item[vecUpgradePartition[i]],uiCurrentByte,uiTotalSize);
+			if ( !bRet )
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T(" ERROR:UpgradePartition-->RKA_Param_Download failed"));
+				}
+				return -4;
+			}
+			m_pComm->RKU_ReopenLBAHandle();
+			if (m_pCallback)
+			{
+				sprintf(szPrompt,"%s checking...\n",rkImageHead.item[vecUpgradePartition[i]].name);
+				m_pCallback(szPrompt);
+			}
+			uiCurrentByte -= (8*m_uiParamFileSize);
+			bRet = RKA_Param_Check(rkImageHead.item[vecUpgradePartition[i]],uiCurrentByte,uiTotalSize);
+			if ( !bRet )
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("ERROR:UpgradePartition-->RKA_Param_Check failed"));
+				}
+				return -6;
+			}
+		}
+		else
+		{
+
+			if (rkImageHead.item[vecUpgradePartition[i]].file[55]=='H')
+			{
+				ulItemSize = *((DWORD *)(&rkImageHead.item[vecUpgradePartition[i]].file[56]));
+				ulItemSize <<= 32;
+				ulItemSize += rkImageHead.item[vecUpgradePartition[i]].size;
+			}
+			else
+				ulItemSize = rkImageHead.item[vecUpgradePartition[i]].size;
+			if ((bSameFw)&&(uiFlag>=rkImageHead.item[vecUpgradePartition[i]].flash_offset))
+			{
+				uiCurrentByte += ulItemSize;
+				continue;
+			}
+
+			if (ulItemSize>0)
+			{
+				if (m_pCallback)
+				{
+					sprintf(szPrompt,"%s writing...\n",rkImageHead.item[vecUpgradePartition[i]].name);
+					m_pCallback(szPrompt);
+				}
+				bRet = RKA_File_Download(rkImageHead.item[vecUpgradePartition[i]],uiCurrentByte,uiTotalSize);
+				if ( !bRet )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:UpgradePartition-->RKA_File_Download failed(%s)"),rkImageHead.item[vecUpgradePartition[i]].name);
+					}
+					return -5;
+				}
+				m_pComm->RKU_ReopenLBAHandle();
+				if (m_pCallback)
+				{
+					sprintf(szPrompt,"%s checking...\n",rkImageHead.item[vecUpgradePartition[i]].name);
+					m_pCallback(szPrompt);
+				}
+				uiCurrentByte -= ulItemSize;
+				bRet = RKA_File_Check(rkImageHead.item[vecUpgradePartition[i]],uiCurrentByte,uiTotalSize);
+				if ( !bRet )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:UpgradePartition-->RKA_File_Check failed(%s)"),rkImageHead.item[vecUpgradePartition[i]].name);
+					}
+					return -7;
+				}
+			}
+			else
+				continue;
+		}
+		if (dwFlagSector!=0)
+		{
+			write_partition_upgrade_flag(dwFlagSector,fwMd5,rkImageHead.item[vecUpgradePartition[i]].flash_offset);
+		}
+	}
+	if (m_pProcessCallback)
+		m_pProcessCallback(1,0);
+	return 0;
+}
+int CRKAndroidDevice::EraseIDB()
+{
+	DWORD dwEraseCounts;
+	if ( m_oldIDBCounts>0 )
+	{
+		dwEraseCounts = m_oldSec1->usSysReservedBlock;
+	}
+	else
+	{
+		dwEraseCounts = IDBLOCK_TOP;
+	}
+	if (m_bEmmc)
+	{
+		if(EraseEmmcBlock(0,0,dwEraseCounts)!=ERR_SUCCESS)
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:EraseIDB-->EraseEmmcBlock failed"));
+			}
+			return -1;
+		}
+	}
+	else
+	{
+		if ( !EraseMutilBlock(0,0,dwEraseCounts,false) )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:EraseIDB-->EraseMutilBlock failed"));
+			}
+			return -1;
+		}
+	}
+
+	return 0;
+}
+int CRKAndroidDevice::EraseAllBlocks()
+{
+	int i;
+	UINT uiBlockCount;
+	int iRet=ERR_SUCCESS,iErasePos=0,iEraseBlockNum=0,iEraseTimes=0,iCSIndex=0;
+	BYTE bCSCount=0;
+	for (i=0;i<8;i++)
+	{
+		if ( m_flashInfo.bFlashCS & (1<<i) )
+		{
+			bCSCount++;
+		}
+	}
+
+	for (i=0;i<8;i++)
+	{
+		if ( m_flashInfo.bFlashCS & (1<<i) )
+		{
+			uiBlockCount = m_flashInfo.uiBlockNum;
+			iErasePos=0;iEraseTimes=0;
+			while (uiBlockCount>0)
+			{
+				iEraseBlockNum = (uiBlockCount<MAX_ERASE_BLOCKS)?uiBlockCount:MAX_ERASE_BLOCKS;
+				if (m_bEmmc)
+				{
+					iRet = EraseEmmcBlock(i,iErasePos,iEraseBlockNum);
+					if (iRet!=ERR_SUCCESS)
+					{
+						if (m_pLog)
+						{
+							m_pLog->Record(_T("ERROR:EraseAllBlocks-->EraseEmmcBlock failed,RetCode(%d)"),iRet);
+						}
+						return -1;
+					}
+				}
+				else
+				{
+					iRet = m_pComm->RKU_EraseBlock(i,iErasePos,iEraseBlockNum,ERASE_FORCE);
+					if ((iRet!=ERR_SUCCESS)&&(iRet!=ERR_FOUND_BAD_BLOCK))
+					{
+						if (m_pLog)
+						{
+							m_pLog->Record(_T("ERROR:EraseAllBlocks-->RKU_EraseBlock failed,RetCode(%d)"),iRet);
+						}
+						return -1;
+					}
+				}
+
+				iErasePos += iEraseBlockNum;
+				uiBlockCount -= iEraseBlockNum;
+				iEraseTimes++;
+			}
+			iCSIndex++;
+		}
+	}
+
+	return 0;
+}
+
+
+
+bool CRKAndroidDevice::BufferWriteBack()
+{
+	FindAllIDB();
+	if (m_oldIDBCounts>0)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:BufferWriteBack-->Found IDB"));
+		}
+		return true;
+	}
+	if (m_usWriteBackCrc==0)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("INFO:BufferWriteBack-->Crc is zero"));
+		}
+		return true;
+	}
+	BYTE pWriteBackBuffer[2*SECTOR_SIZE];
+
+	char *pszTag = (char *)pWriteBackBuffer;
+	USHORT *pValue = (USHORT *)(pWriteBackBuffer+4);
+
+	memset(pWriteBackBuffer,0,2*SECTOR_SIZE);
+
+
+	strcpy(pszTag,"CRC");
+	*pValue = m_usWriteBackCrc;
+	pValue++;
+	*pValue = m_usWriteBackCustomDataOffset;
+	pValue++;
+	*pValue = m_usWriteBackCustomDataSize;
+	memcpy(pWriteBackBuffer+SECTOR_SIZE,m_backupBuffer,SECTOR_SIZE);
+
+	STRUCT_END_WRITE_SECTOR end_write_sector_data;
+	BYTE writeBuf[8*SECTOR_SIZE];
+	UINT uiOffset,uiTotal,uiWriteByte,uiCrc;
+	int iRet,i,nTryCount=3;
+	uiTotal = 2*SECTOR_SIZE;
+	uiCrc = CRC_32(pWriteBackBuffer,uiTotal);
+	end_write_sector_data.uiSize = uiTotal;
+	end_write_sector_data.uiCrc = uiCrc;
+	for(i=WBBUFFER_BOTTOM;i<WBBUFFER_TOP;i++)
+		end_write_sector_data.uiBlock[i] = i;
+	while (nTryCount>0)
+	{
+		uiOffset = 0;
+		uiTotal = 2 * SECTOR_SIZE;
+		while (uiTotal>0)
+		{
+			if (uiTotal>=2048)
+				uiWriteByte = 2048;
+			else
+				uiWriteByte = uiTotal;
+
+			memcpy(writeBuf+8,pWriteBackBuffer+uiOffset,uiWriteByte);
+			iRet = m_pComm->RKU_WriteLBA(64+uiOffset,uiWriteByte,writeBuf);
+			if (iRet!=ERR_SUCCESS)
+			{
+				if (m_pLog)
+					m_pLog->Record(_T("ERROR:BufferWriteBack-->RKU_WriteSector failed!"));
+				return false;
+			}
+			uiOffset += uiWriteByte;
+			uiTotal -= uiWriteByte;
+		}
+		//iRet = m_pComm->RKU_EndWriteSector((BYTE*)&end_write_sector_data);
+		if (iRet==ERR_SUCCESS)
+			break;
+		nTryCount--;
+	}
+	if (nTryCount<=0)
+		return false;
+
+	return true;
+}
+bool CRKAndroidDevice::FindBackupBuffer()
+{
+	int i,iRet;
+	bool bRet;
+	BYTE buffer[2*SECTOR_SIZE];
+	for (i=WBBUFFER_BOTTOM;i<WBBUFFER_TOP;i++)
+	{
+		memset(buffer,0,2*SECTOR_SIZE);
+		iRet = m_pComm->RKU_ReadSector(i*m_flashInfo.uiSectorPerBlock,2,buffer);
+		if (iRet!=ERR_SUCCESS)
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:FindBackupBuffer-->RKU_ReadSector failed,RetCode(%d)"),iRet);
+			}
+			continue;
+		}
+		else
+		{
+			PSTRUCT_RKANDROID_WBBUFFER pWriteBack;
+			pWriteBack = (PSTRUCT_RKANDROID_WBBUFFER)buffer;
+			char *pszCrcTag = (char *)buffer;
+			if (pWriteBack->dwTag==0x38324B52)
+			{
+				bRet = CheckCrc16(buffer,SECTOR_SIZE-2,pWriteBack->usCrc);
+				if (!bRet)
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:FindBackupBuffer-->Check Crc Failed"));
+					}
+//					continue;
+				}
+				PRKANDROID_IDB_SEC3 pSec = (PRKANDROID_IDB_SEC3)m_backupBuffer;
+				pSec->usSNSize = pWriteBack->usSnSize;
+				memcpy(pSec->sn,pWriteBack->btSnData,RKDEVICE_SN_LEN);
+				memset(pSec->reserved,0,RKANDROID_SEC3_RESERVED_LEN);
+				memcpy(pSec->reserved+6,pWriteBack->btReserve,RKANDROID_SEC3_RESERVED_LEN-6);
+				pSec->imeiSize = pWriteBack->btImeiSize;
+				memcpy(pSec->imei,pWriteBack->btImeiData,RKDEVICE_IMEI_LEN);
+				pSec->uidSize = pWriteBack->btUidSize;
+				memcpy(pSec->uid,pWriteBack->btUidData,RKDEVICE_UID_LEN);
+				pSec->blueToothSize = pWriteBack->btBlueToothSize;
+				memcpy(pSec->blueToothAddr,pWriteBack->btBlueToothData,RKDEVICE_BT_LEN);
+				pSec->macSize = pWriteBack->btMacSize;
+				memcpy(pSec->macAddr,pWriteBack->btMacData,RKDEVICE_MAC_LEN);
+				m_usWriteBackCrc = CRC_16(m_backupBuffer,SECTOR_SIZE);
+			}
+			else if (strcmp(pszCrcTag,"CRC")==0)
+			{
+				m_usWriteBackCrc = *((USHORT *)(buffer+4));
+				m_usWriteBackCustomDataOffset = *((USHORT *)(buffer+6));
+				m_usWriteBackCustomDataSize = *((USHORT *)(buffer+8));
+				bRet = CheckCrc16(buffer+SECTOR_SIZE,SECTOR_SIZE,m_usWriteBackCrc);
+				if (!bRet)
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:FindBackupBuffer-->Check Crc Failed"));
+					}
+					m_usWriteBackCrc = CRC_16(buffer+SECTOR_SIZE+SPARE_SIZE,SECTOR_SIZE);
+//					continue;
+				}
+				memcpy(m_backupBuffer,buffer+SECTOR_SIZE,SECTOR_SIZE);
+			}
+			else
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("INFO:FindBackupBuffer-->No Found Tag"));
+				}
+				continue;
+			}
+
+			break;
+		}
+	}
+	if ( i<WBBUFFER_TOP )
+	{
+		return true;
+	}
+	else
+		return false;
+}
+
+bool CRKAndroidDevice::RKA_File_Download(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte)
+{
+	UINT uiLBATransferSize=(LBA_TRANSFER_SIZE)*m_uiLBATimes;
+	UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+	int iRet;
+	bool bRet;
+	UINT uiBufferSize=uiLBATransferSize;
+	long long uifileBufferSize;
+	long long ulEntryStartOffset;
+	DWORD dwFWOffset;
+	(void)totalByte;
+
+	m_pCallback("RKA_File_Download entry.name=%s \n", entry.name);
+	dwFWOffset = m_pImage->FWOffset;
+	if (entry.file[50]=='H')
+	{
+		ulEntryStartOffset = *((DWORD *)(&entry.file[51]));
+		ulEntryStartOffset <<= 32;
+		ulEntryStartOffset += entry.offset;
+		ulEntryStartOffset += m_pImage->FWOffset;
+	}
+	else
+	{
+		ulEntryStartOffset = m_pImage->FWOffset;
+		ulEntryStartOffset += entry.offset;
+	}
+	if (entry.file[55]=='H')
+	{
+		uifileBufferSize = *((DWORD *)(&entry.file[56]));
+		uifileBufferSize <<= 32;
+		uifileBufferSize += entry.size;
+	}
+	else
+		uifileBufferSize = entry.size;
+	if (m_pLog)
+	{
+		m_pLog->Record(_T(" INFO:Start to download %s,offset=0x%x,size=%llu"),entry.name,entry.flash_offset,uifileBufferSize);
+	}
+
+	BYTE byRWMethod=RWMETHOD_IMAGE;
+	if (entry.flash_offset>m_dwBackupOffset)
+	{
+		byRWMethod = RWMETHOD_LBA;
+	}
+
+	PBYTE pBuffer=NULL;
+	pBuffer = new BYTE[uiBufferSize];
+	if (!pBuffer)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_File_Download-->New memory failed"));
+		}
+		return false;
+	}
+
+	bool bUser=false;
+//	if (strcmp(entry.name,PARTNAME_MISC)==0)
+//	{
+//		currentByte += uifileBufferSize;
+//		return true;
+//	}
+	if (strcmp(entry.name,PARTNAME_USER)==0)
+	{
+		bUser = true;
+	}
+
+	UINT uiBegin,uiLen,uiWriteByte;
+	long long uiEntryOffset;
+	uiBegin = entry.flash_offset;
+	uiLen = 0;uiWriteByte = 0;uiEntryOffset=0;
+	while ( uifileBufferSize>0 )
+	{
+		memset(pBuffer,0,uiBufferSize);
+		if ( uifileBufferSize<uiBufferSize )
+		{
+			uiWriteByte = uifileBufferSize;
+			uiLen = ( (uiWriteByte%SECTOR_SIZE==0) ? (uiWriteByte/SECTOR_SIZE) : (uiWriteByte/SECTOR_SIZE+1) );
+		}
+		else
+		{
+			uiWriteByte = uiBufferSize;
+			uiLen = uiLBASector;
+		}
+		bRet = m_pImage->GetData(dwFWOffset+entry.offset+uiEntryOffset,uiWriteByte,pBuffer);
+		if ( !bRet )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:RKA_File_Download-->GetFileData failed"));
+			}
+			delete []pBuffer;
+			pBuffer = NULL;
+			return false;
+		}
+		if (bUser)
+		{
+			if ((pBuffer[0]==0xEB)&&(pBuffer[1]==0x58)&&(pBuffer[2]==0x90))
+			{//fat user image
+				iRet = m_pComm->RKU_TestDeviceReady((DWORD *)&m_uiUserSectors,NULL,TU_GETUSERSECTOR_SUBCODE);
+				if (iRet!=ERR_SUCCESS)
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:RKA_File_Download-->Get user sectors failed,RetCode(%d)"),iRet);
+					}
+
+					delete []pBuffer;
+					pBuffer = NULL;
+					return false;
+				}
+				if ((m_uiUserSectors==0)||(m_uiUserSectors==(DWORD)-1))
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:RKA_File_Download-->User size is wrong,value=0x%x"),m_uiUserSectors);
+					}
+
+					delete []pBuffer;
+					pBuffer = NULL;
+					return false;
+				}
+				if (m_uiUserSectors<=uiBegin)
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:RKA_File_Download-->Available total is smaller than user offset"));
+					}
+
+					delete []pBuffer;
+					pBuffer = NULL;
+					return false;
+				}
+				m_uiUserSectors -= uiBegin;
+
+				PBYTE pDbr,pCopyDbr;
+				pDbr = pBuffer;
+				pCopyDbr = pBuffer + SECTOR_SIZE*6;
+				if (*(UINT *)(pDbr+32)<m_uiUserSectors)
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:RKA_File_Download-->Original size is smaller than current user size"));
+					}
+
+					delete []pBuffer;
+					pBuffer = NULL;
+					return false;
+				}
+
+				(*(UINT *)(pDbr+32)) = m_uiUserSectors;
+				(*(UINT *)(pCopyDbr+32)) = m_uiUserSectors;
+			}
+
+			bUser = false;
+		}
+
+		iRet = m_pComm->RKU_WriteLBA(uiBegin,uiLen,pBuffer,byRWMethod);
+		if( iRet!=ERR_SUCCESS )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:RKA_File_Download-->RKU_WriteLBA failed,Written(%d),RetCode(%d)"),uiEntryOffset,iRet);
+			}
+
+			delete []pBuffer;
+			pBuffer = NULL;
+			return false;
+		}
+		uifileBufferSize -= uiWriteByte;
+		uiEntryOffset += uiWriteByte;
+		uiBegin += uiLen;
+		currentByte += uiWriteByte;
+
+	}
+	delete []pBuffer;
+	pBuffer = NULL;
+	m_pCallback("RKA_File_Download entry.name=%s DONE! \n", entry.name);
+	return true;
+}
+
+bool CRKAndroidDevice::RKA_File_Check(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte)
+{
+	UINT uiLBATransferSize=(LBA_TRANSFER_SIZE)*m_uiLBATimes;
+	UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+	int iRet;
+	bool bRet;
+	UINT uiBufferSize=uiLBATransferSize;
+	long long uifileBufferSize;
+	long long ulEntryStartOffset;
+	DWORD dwFWOffset;
+	(void)totalByte;
+	m_pCallback("RKA_File_Check entry.name=%s \n", entry.name);
+	dwFWOffset = m_pImage->FWOffset;
+	if (entry.file[50]=='H')
+	{
+		ulEntryStartOffset = *((DWORD *)(&entry.file[51]));
+		ulEntryStartOffset <<= 32;
+		ulEntryStartOffset += entry.offset;
+		ulEntryStartOffset += m_pImage->FWOffset;
+	}
+	else
+	{
+		ulEntryStartOffset = m_pImage->FWOffset;
+		ulEntryStartOffset += entry.offset;
+	}
+	if (entry.file[55]=='H')
+	{
+		uifileBufferSize = *((DWORD *)(&entry.file[56]));
+		uifileBufferSize <<= 32;
+		uifileBufferSize += entry.size;
+	}
+	else
+		uifileBufferSize = entry.size;
+
+	BYTE byRWMethod=RWMETHOD_IMAGE;
+	if (entry.flash_offset>m_dwBackupOffset)
+	{
+		byRWMethod = RWMETHOD_LBA;
+	}
+
+	PBYTE pBufferFromFile=NULL;
+	pBufferFromFile = new BYTE[uiBufferSize];
+	if (!pBufferFromFile)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_File_Check-->New memory failed"));
+		}
+		return false;
+	}
+	PBYTE pBufferFromFlash=NULL;
+	pBufferFromFlash = new BYTE[uiBufferSize];
+	if (!pBufferFromFlash)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_File_Check-->New memory failed"));
+		}
+		delete []pBufferFromFile;
+		return false;
+	}
+	bool bUser=false;
+//	if (strcmp(entry.name,PARTNAME_MISC)==0)
+//	{
+//		currentByte += uifileBufferSize;
+//		return true;
+//	}
+	if (strcmp(entry.name,PARTNAME_USER)==0)
+	{
+		bUser = true;
+		if ((entry.name[PART_NAME-2]=='N')&&(entry.name[PART_NAME-1]=='C'))
+		{//no check user
+			currentByte += uifileBufferSize;
+			return true;
+		}
+	}
+
+	UINT uiBegin,uiLen,uiWriteByte;
+	long long uiEntryOffset;
+	uiBegin = entry.flash_offset;
+	uiLen = 0;uiWriteByte = 0;uiEntryOffset=0;
+	while ( uifileBufferSize>0 )
+	{
+		if ( uifileBufferSize<uiBufferSize )
+		{
+			uiWriteByte = uifileBufferSize;
+			uiLen = ( (uiWriteByte%SECTOR_SIZE==0) ? (uiWriteByte/SECTOR_SIZE) : (uiWriteByte/SECTOR_SIZE+1) );
+		}
+		else
+		{
+			uiWriteByte = uiBufferSize;
+			uiLen = uiLBASector;
+		}
+
+
+		memset(pBufferFromFile,0,uiBufferSize);
+		memset(pBufferFromFlash,0,uiBufferSize);
+
+		iRet = m_pComm->RKU_ReadLBA(uiBegin,uiLen,pBufferFromFlash,byRWMethod);
+		if( iRet!=ERR_SUCCESS )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:RKA_File_Check-->RKU_ReadLBA failed,Read(%d),RetCode(%d)"),uiEntryOffset,iRet);
+			}
+			delete []pBufferFromFile;
+			delete []pBufferFromFlash;
+			return false;
+		}
+		bRet = m_pImage->GetData(dwFWOffset+entry.offset+uiEntryOffset,uiWriteByte,pBufferFromFile);
+		if ( !bRet )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:RKA_File_Check-->GetFileData failed"));
+			}
+			delete []pBufferFromFile;
+			delete []pBufferFromFlash;
+			return false;
+		}
+		if (bUser)
+		{
+			if ((pBufferFromFile[0]==0xEB)&&(pBufferFromFile[1]==0x58)&&(pBufferFromFile[2]==0x90))
+			{//fat user image
+				PBYTE pDbr,pCopyDbr;
+				pDbr = pBufferFromFile;
+				pCopyDbr = pBufferFromFile + SECTOR_SIZE*6;
+
+				(*(UINT *)(pDbr+32)) = m_uiUserSectors;
+				(*(UINT *)(pCopyDbr+32)) = m_uiUserSectors;
+			}
+
+			bUser = false;
+		}
+
+		if ( memcmp(pBufferFromFile,pBufferFromFlash,uiWriteByte)!=0 )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:RKA_File_Check-->Memcmp failed,Read(%d)"),uiEntryOffset);
+				tchar szDateTime[100];
+				tstring strFile;
+				time_t	now;
+				struct tm timeNow;
+				time(&now);
+				localtime_r(&now,&timeNow);
+				_stprintf(szDateTime,_T("%02d-%02d-%02d"),timeNow.tm_hour,timeNow.tm_min,timeNow.tm_sec);
+
+				strFile = szDateTime;
+				strFile += _T("/tmp/file.bin");
+				m_pLog->SaveBuffer( strFile,pBufferFromFile,uiWriteByte );
+
+				strFile = szDateTime;
+				strFile += _T("/tmp/flash.bin");
+				m_pLog->SaveBuffer( strFile,pBufferFromFlash,uiWriteByte );
+			}
+			delete []pBufferFromFile;
+			delete []pBufferFromFlash;
+			return false;
+		}
+//		if (uiBegin == entry.flash_offset)
+//		{
+//			tstring strFile;
+//			strFile = "/tmp/";
+//			strFile += entry.name;
+//			strFile += ".img";
+//			m_pLog->SaveBuffer( strFile,pBufferFromFlash,uiWriteByte );
+//			m_pLog->Record("%s=%x %x %x %x",entry.name,pBufferFromFlash[0],pBufferFromFlash[1],pBufferFromFlash[2],pBufferFromFlash[3]);
+//		}
+
+		currentByte += uiWriteByte;
+		uiEntryOffset += uiWriteByte;
+		uifileBufferSize -= uiWriteByte;
+		uiBegin += uiLen;
+
+	}
+
+	m_pCallback("RKA_File_Check entry.name=%s DONE! \n", entry.name);
+	delete []pBufferFromFile;
+	delete []pBufferFromFlash;
+	return true;
+}
+
+bool CRKAndroidDevice::RKA_Param_Download(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte)
+{//д5ݲļ
+	UINT uiLBATransferSize=(LBA_TRANSFER_SIZE)*m_uiLBATimes;
+	UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+	int  iRet,i;
+	BYTE byRWMethod=RWMETHOD_IMAGE;
+	(void)totalByte;
+	if (entry.flash_offset>m_dwBackupOffset)
+	{
+		byRWMethod = RWMETHOD_LBA;
+	}
+
+	UINT uiTransfer;
+	UINT uiStepSec=entry.part_size/8;
+//	if (m_pLog)
+//	{
+//		m_pLog->Record(_T("INFO:RKA_Param_Download-->step=%d"),uiStepSec);
+//	}
+
+	UINT uiLen,uiWriteByte,uiFileSize;
+	UINT uiBegin;
+	for ( i=0;i<8;i++ )
+	{
+		uiFileSize = m_uiParamFileSize;
+		uiBegin = entry.flash_offset+uiStepSec*i;
+		uiLen = 0;
+		uiWriteByte = 0;
+		uiTransfer = 0;
+//		if (m_pLog)
+//		{
+//			m_pLog->Record(_T("INFO:RKA_Param_Download-->no %d,offset=%d"),i+1,uiBegin);
+//		}
+		while (uiFileSize>0)
+		{
+			if ( uiFileSize<uiLBATransferSize )
+			{
+				uiWriteByte = uiFileSize;
+				uiLen = ( (uiWriteByte%512==0) ? (uiWriteByte/512) : (uiWriteByte/512+1) );
+			}
+			else
+			{
+				uiWriteByte = uiLBATransferSize;
+				uiLen = uiLBASector;
+			}
+			iRet = m_pComm->RKU_WriteLBA(uiBegin,uiLen,m_paramBuffer+uiTransfer,byRWMethod);//ÿζҪд32,page
+			if( iRet!=ERR_SUCCESS )
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("ERROR:RKA_Param_Download-->RKU_WriteLBA failed,Written(%d),RetCode(%d)"),uiTransfer,iRet);
+				}
+
+				return false;
+			}
+
+			uiTransfer += uiWriteByte;
+			currentByte += uiWriteByte;
+			uiBegin += uiLen;
+			uiFileSize -= uiWriteByte;
+
+		}
+	}
+
+	return true;
+}
+bool CRKAndroidDevice::RKA_Param_Check(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte)
+{
+	UINT uiLBATransferSize=(LBA_TRANSFER_SIZE)*m_uiLBATimes;
+	UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+	int iRet,i;
+	UINT uiReadBufferSize=uiLBATransferSize;
+	BYTE byRWMethod=RWMETHOD_IMAGE;
+	(void)totalByte;
+	if (entry.flash_offset>m_dwBackupOffset)
+	{
+		byRWMethod = RWMETHOD_LBA;
+	}
+
+	PBYTE pRead=NULL;
+	pRead = new BYTE[uiReadBufferSize];
+	if (!pRead)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_Param_Check-->New ReadBuffer failed"));
+		}
+		return false;
+	}
+
+	UINT uiTransfer;
+	UINT uiStepSec=entry.part_size/8;
+
+	UINT uiLen,uiWriteByte,uiFileSize;
+	UINT uiBegin;
+	for ( i=0;i<8;i++ )
+	{
+		uiFileSize = m_uiParamFileSize;
+		uiBegin = entry.flash_offset+uiStepSec*i;
+		uiLen = 0;
+		uiWriteByte = 0;
+		uiTransfer = 0;
+//		if (m_pLog)
+//		{
+//			m_pLog->Record(_T("INFO:RKA_Param_Check-->no %d,offset=%d"),i+1,uiBegin);
+//		}
+		while (uiFileSize>0)
+		{
+			memset(pRead,0,uiReadBufferSize);
+			if ( uiFileSize<uiLBATransferSize )
+			{
+				uiWriteByte = uiFileSize;
+				uiLen = ( (uiWriteByte%512==0) ? (uiWriteByte/512) : (uiWriteByte/512+1) );
+			}
+			else
+			{
+				uiWriteByte = uiLBATransferSize;
+				uiLen = uiLBASector;
+			}
+			iRet = m_pComm->RKU_ReadLBA(uiBegin,uiLen,pRead,byRWMethod);
+			if( iRet!=ERR_SUCCESS )
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("ERROR:RKA_Param_Check-->RKU_ReadLBA failed,Read(%d),RetCode(%d)"),uiTransfer,iRet);
+				}
+				delete []pRead;
+				return false;
+			}
+			if ( memcmp(pRead,m_paramBuffer+uiTransfer,uiWriteByte)!=0 )
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("ERROR:RKA_Param_Check-->Memcmp failed,Read(%d)"),uiTransfer);
+					tchar szDateTime[100];
+					tstring strFile;
+					time_t	now;
+					struct tm timeNow;
+					time(&now);
+					localtime_r(&now,&timeNow);
+					_stprintf(szDateTime,_T("%02d-%02d-%02d"),timeNow.tm_hour+1,timeNow.tm_min+1,timeNow.tm_sec+1);
+
+					strFile = szDateTime;
+					strFile += _T("/tmp/file.bin");
+					m_pLog->SaveBuffer( strFile,m_paramBuffer+uiTransfer,uiWriteByte );
+
+					strFile = szDateTime;
+					strFile += _T("/tmp/flash.bin");
+					m_pLog->SaveBuffer( strFile,pRead,uiWriteByte );
+				}
+
+				delete []pRead;
+				return false;
+
+			}
+//			if (m_pLog)
+//			{
+//				string strSrc,strDst;
+//				if (uiWriteByte>16)
+//				{
+//					m_pLog->PrintBuffer(strSrc,pRead,16);
+//					m_pLog->PrintBuffer(strDst,m_paramBuffer+uiTransfer,16);
+//				}
+//				else
+//				{
+//					m_pLog->PrintBuffer(strSrc,pRead,uiWriteByte);
+//					m_pLog->PrintBuffer(strDst,m_paramBuffer+uiTransfer,uiWriteByte);
+//				}
+//				m_pLog->Record("Read:%s",strSrc.c_str());
+//				m_pLog->Record("Compare:%s",strDst.c_str());
+//			}
+			uiTransfer += uiWriteByte;
+			currentByte += uiWriteByte;
+			uiBegin += uiLen;
+			uiFileSize -= uiWriteByte;
+
+		}
+	}
+
+	delete []pRead;
+	return true;
+}
+
+bool CRKAndroidDevice::RKA_Gpt_Download(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte)
+{
+	//UINT uiLBATransferSize=(LBA_TRANSFER_SIZE)*m_uiLBATimes;
+	//UINT uiLBALoopLimit=(LBA_LOOP_SIZE)/uiLBATransferSize;
+	//UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+	int  iRet;
+	bool bRet;
+	PARAM_ITEM_VECTOR vecItems;
+	CONFIG_ITEM_VECTOR vecUuids;
+	//BYTE byRWMethod=RWMETHOD_IMAGE;
+	BYTE *backup_gpt;
+	(void)entry; (void)totalByte;
+	if (!m_gptBuffer)
+	{
+		m_gptBuffer = new BYTE[SECTOR_SIZE*67];
+		if (!m_gptBuffer)
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->new memory failed,err=%d)"),errno);
+			}
+			return false;
+		}
+	}
+	memset(m_gptBuffer,0,SECTOR_SIZE*67);
+	bRet = parse_parameter((char *)(m_paramBuffer+8),vecItems);
+	if (!bRet)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->parse_parameter failed)"));
+		}
+		return false;
+	}
+	bRet = get_uuid_from_parameter((char *)(m_paramBuffer+8),vecUuids);
+	backup_gpt = m_gptBuffer+34*SECTOR_SIZE;
+	create_gpt_buffer(m_gptBuffer,vecItems,vecUuids,m_flashInfo.uiFlashSize*2048);
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("INFO:RKA_Gpt_Download-->disk_sector=%u \n)"),m_flashInfo.uiFlashSize*2048);
+	}
+	memcpy(backup_gpt, m_gptBuffer + 2* SECTOR_SIZE, 32 * SECTOR_SIZE);
+	memcpy(backup_gpt + 32 * SECTOR_SIZE, m_gptBuffer + SECTOR_SIZE, SECTOR_SIZE);
+	prepare_gpt_backup(m_paramBuffer, backup_gpt, m_flashInfo.uiFlashSize*2048);
+
+	iRet = m_pComm->RKU_WriteLBA(0,34,m_gptBuffer);
+	if (iRet!=ERR_SUCCESS)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->write gpt master failed,RetCode(%d)"),iRet);
+		}
+		return false;
+	}
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->write gpt master successfully!"));
+	}
+	iRet = m_pComm->RKU_WriteLBA(m_flashInfo.uiFlashSize*2048-33,33,backup_gpt);
+	if (iRet!=ERR_SUCCESS)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->write gpt backup failed,RetCode(%d)"),iRet);
+		}
+		return false;
+	}
+	currentByte += (SECTOR_SIZE*67);
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->write gpt backup also successfully!"));
+	}
+
+	return true;
+}
+bool CRKAndroidDevice::RKA_Gpt_Check(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte)
+{
+	//UINT uiLBATransferSize=(LBA_TRANSFER_SIZE)*m_uiLBATimes;
+	//UINT uiLBALoopLimit=(LBA_LOOP_SIZE)/uiLBATransferSize;
+	//UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+	int iRet;
+	//BYTE byRWMethod=RWMETHOD_IMAGE;
+	(void)entry; (void)totalByte;
+	PBYTE pRead=NULL;
+	pRead = new BYTE[34*SECTOR_SIZE];
+	if (!pRead)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_Gpt_Check-->New ReadBuffer failed,err=%d"),errno);
+		}
+		return false;
+	}
+	iRet = m_pComm->RKU_ReadLBA(0,34,pRead);
+	if (iRet!=ERR_SUCCESS)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->read gpt master failed,RetCode(%d)"),iRet);
+		}
+		delete []pRead;
+		return false;
+	}
+	if (memcmp(m_gptBuffer,pRead,34*SECTOR_SIZE)!=0)
+	{
+		if (m_pLog)
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->compare gpt master failed"));
+			}
+			tchar szDateTime[100];
+			tstring strFile;
+			time_t	now;
+			struct tm timeNow;
+			time(&now);
+			localtime_r(&now,&timeNow);
+			_stprintf(szDateTime,_T("%02d-%02d-%02d"),timeNow.tm_hour+1,timeNow.tm_min+1,timeNow.tm_sec+1);
+			strFile = m_pLog->LogSavePath;
+			strFile += szDateTime;
+			strFile += _T("file.bin");
+			m_pLog->SaveBuffer( strFile,m_gptBuffer,34*SECTOR_SIZE );
+			strFile = m_pLog->LogSavePath;
+			strFile += szDateTime;
+			strFile += _T("flash.bin");
+			m_pLog->SaveBuffer( strFile,pRead,34*SECTOR_SIZE );
+		}
+		delete []pRead;
+		return false;
+	}
+	iRet = m_pComm->RKU_ReadLBA(m_flashInfo.uiFlashSize*2048-33,33,pRead);
+	if (iRet!=ERR_SUCCESS)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->read gpt backup failed,RetCode(%d)"),iRet);
+		}
+		delete []pRead;
+		return false;
+	}
+	if (memcmp(m_gptBuffer+34*SECTOR_SIZE,pRead,33*SECTOR_SIZE)!=0)
+	{
+		if (m_pLog)
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:RKA_Gpt_Download-->compare gpt backup failed"));
+			}
+			tchar szDateTime[100];
+			tstring strFile;
+			time_t	now;
+			struct tm timeNow;
+			time(&now);
+			localtime_r(&now,&timeNow);
+			_stprintf(szDateTime,_T("%02d-%02d-%02d"),timeNow.tm_hour+1,timeNow.tm_min+1,timeNow.tm_sec+1);
+			strFile = m_pLog->LogSavePath;
+			strFile += szDateTime;
+			strFile += _T("file.bin");
+			m_pLog->SaveBuffer( strFile,m_gptBuffer+34*SECTOR_SIZE,33*SECTOR_SIZE );
+			strFile = m_pLog->LogSavePath;
+			strFile += szDateTime;
+			strFile += _T("flash.bin");
+			m_pLog->SaveBuffer( strFile,pRead,33*SECTOR_SIZE );
+		}
+		delete []pRead;
+		return false;
+	}
+	currentByte += (SECTOR_SIZE*67);
+
+	delete []pRead;
+	return true;
+}
+
+bool CRKAndroidDevice::MakeParamFileBuffer(STRUCT_RKIMAGE_ITEM &entry)
+{
+	bool bRet;
+	UINT uiFileBufferSize;
+	DWORD dwFWOffset;
+
+	dwFWOffset = m_pImage->FWOffset;
+	uiFileBufferSize = 2*entry.size;
+	m_uiParamFileSize = entry.size;
+	PBYTE pBuffer=NULL;
+	pBuffer = new BYTE[uiFileBufferSize];
+	if (!pBuffer)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeParamFileBuffer-->New memory failed"));
+		}
+		return false;
+	}
+	memset(pBuffer,0,uiFileBufferSize);
+	bRet = m_pImage->GetData(dwFWOffset+entry.offset,entry.size,pBuffer);
+	if (!bRet)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeParamFileBuffer-->GetFileData failed"));
+		}
+		delete[] pBuffer;
+		pBuffer = NULL;
+		return false;
+	}
+	//жǷҪ޸Paramterļ,ֻҪparamterļеpartitionݸĳֽΪλƫ
+
+	UINT uiParamSec;
+	if (m_uiParamFileSize%512==0)
+	{
+		uiParamSec = m_uiParamFileSize/512;
+	}
+	else
+		uiParamSec = (m_uiParamFileSize+512)/512;
+
+	if (m_paramBuffer)
+	{
+		delete []m_paramBuffer;
+		m_paramBuffer = NULL;
+	}
+	m_paramBuffer = new BYTE[uiParamSec*512];
+	if (!m_paramBuffer)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:MakeParamFileBuffer-->new memory failed"));
+		}
+		delete []pBuffer;
+		return false;
+	}
+	memset(m_paramBuffer,0,uiParamSec*512);
+	memcpy(m_paramBuffer,pBuffer,m_uiParamFileSize);
+	delete []pBuffer;
+	return true;
+}
+bool CRKAndroidDevice::CheckParamPartSize(STRUCT_RKIMAGE_HDR &rkImageHead,int iParamPos)
+{
+//	UINT uiParamPartSize;
+//	int i;
+//	uiParamPartSize = 0xFFFFFFFF;
+//	for (i=0;i<rkImageHead.item_count;i++)
+//	{
+//		if (i!=iParamPos)
+//		{
+//			if (rkImageHead.item[i].flash_offset<uiParamPartSize)
+//			{
+//				uiParamPartSize = rkImageHead.item[i].flash_offset;
+//			}
+//		}
+//	}
+	if (!GetParameterPartSize(rkImageHead.item[iParamPos]))
+	{
+		return false;
+	}
+	if (m_uiParamFileSize>rkImageHead.item[iParamPos].part_size/8*512)//Ƿ8
+	{
+		return false;
+	}
+
+	return true;
+}
+bool CRKAndroidDevice::IsExistSector3Crc(PRKANDROID_IDB_SEC2 pSec)
+{
+	if (!pSec)
+	{
+		return false;
+	}
+
+	if (strcmp(pSec->szCrcTag,"CRC")==0)
+	{
+		m_bExistSector3Crc = true;
+		m_usSector3Crc = pSec->usSec3Crc;
+	}
+	return true;
+}
+bool CRKAndroidDevice::ParsePartitionInfo(string &strPartInfo,string &strName,UINT &uiOffset,UINT &uiLen)
+{
+	string::size_type pos,prevPos;
+	string strOffset,strLen;
+	int iCount;
+	prevPos = pos = 0;
+	if (strPartInfo.size()<=0)
+	{
+		return false;
+	}
+	pos = strPartInfo.find('@');
+	if (pos==string::npos)
+	{
+		return false;
+	}
+	strLen = strPartInfo.substr(prevPos,pos-prevPos);
+	strLen.erase(0,strLen.find_first_not_of(" "));
+	strLen.erase(strLen.find_last_not_of(" ")+1);
+	if (strchr(strLen.c_str(),'-'))
+	{
+		uiLen = 0xFFFFFFFF;
+	}
+	else
+	{
+		iCount = sscanf(strLen.c_str(),"0x%x",&uiLen);
+		if (iCount!=1)
+		{
+			return false;
+		}
+	}
+
+	prevPos = pos +1;
+	pos = strPartInfo.find('(',prevPos);
+	if (pos==string::npos)
+	{
+		return false;
+	}
+	strOffset = strPartInfo.substr(prevPos,pos-prevPos);
+	strOffset.erase(0,strOffset.find_first_not_of(" "));
+	strOffset.erase(strOffset.find_last_not_of(" ")+1);
+	iCount = sscanf(strOffset.c_str(),"0x%x",&uiOffset);
+	if (iCount!=1)
+	{
+		return false;
+	}
+
+	prevPos = pos +1;
+	pos = strPartInfo.find(')',prevPos);
+	if (pos==string::npos)
+	{
+		return false;
+	}
+	strName = strPartInfo.substr(prevPos,pos-prevPos);
+	strName.erase(0,strName.find_first_not_of(" "));
+	strName.erase(strName.find_last_not_of(" ")+1);
+
+	return true;
+}
+bool CRKAndroidDevice::GetParameterPartSize(STRUCT_RKIMAGE_ITEM &paramItem)
+{
+	PBYTE pParamBuf=NULL;
+	pParamBuf = new BYTE[paramItem.size-12+1];
+	if (!pParamBuf)
+	{
+		return false;
+	}
+	memset(pParamBuf,0,paramItem.size-12+1);
+	bool bRet;
+	bRet = m_pImage->GetData(m_pImage->FWOffset+paramItem.offset+8,paramItem.size-12,pParamBuf);
+	if (!bRet)
+	{
+		delete []pParamBuf;
+		return false;
+	}
+	string strParamFile = (char *)pParamBuf;
+	stringstream paramStream(strParamFile);
+	delete []pParamBuf;
+
+	string strLine,strPartition,strPartInfo,strPartName;
+	string::size_type line_size,pos,posColon,posComma;
+	UINT uiPartOffset,uiPartSize;
+	while (!paramStream.eof())
+	{
+		getline(paramStream,strLine);
+		line_size = strLine.size();
+		if (line_size<=0)
+		{
+			continue;
+		}
+		if (strLine[line_size-1]=='\r')
+		{
+			strLine = strLine.substr(0,line_size-1);
+		}
+		if (strLine.size()<=0)
+		{
+			continue;
+		}
+		if (strLine[0]=='#')
+		{
+			continue;
+		}
+		pos = strLine.find("mtdparts");
+		if (pos==string::npos)
+		{
+			continue;
+		}
+		posColon = strLine.find(':',pos);
+		if (posColon==string::npos)
+		{
+			continue;
+		}
+		strPartition = strLine.substr(posColon+1);
+		//ȡϢ
+		pos = 0;
+		posComma = strPartition.find(',',pos);
+		while (posComma!=string::npos)
+		{
+			strPartInfo = strPartition.substr(pos,posComma-pos);
+			bRet = ParsePartitionInfo(strPartInfo,strPartName,uiPartOffset,uiPartSize);
+			if (!bRet)
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("ERROR:GetParameterPartSize-->ParsePartitionInfo failed"));
+				}
+				return false;
+			}
+			paramItem.part_size = uiPartOffset;
+			return true;
+		}
+	}
+	return false;
+}
+
+bool CRKAndroidDevice::GetPublicKey(unsigned char *pKey,unsigned int &nKeySize)
+{
+	int i,j,iRet,nRsaByte;
+	bool bRet;
+	BYTE bData[SECTOR_SIZE*8];
+	PRKANDROID_IDB_SEC0 pSec0=(PRKANDROID_IDB_SEC0)bData;
+	PRK_SECURE_HEADER pSecureHdr=(PRK_SECURE_HEADER)(bData+SECTOR_SIZE*4);
+	string strOutput;
+	bRet = GetFlashInfo();
+	if (!bRet)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:GetPublicKey-->GetFlashInfo failed"));
+		}
+		return false;
+	}
+	if ( !BuildBlockStateMap(0) )
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:GetPublicKey-->BuildBlockStateMap failed"));
+		}
+		return false;
+	}
+
+	FindAllIDB();
+//	sleep(1);
+//	if (m_pLog)
+//	{
+//		m_pLog->Record(_T("INFO:GetPublicKey-->IDblock count=%d."),m_oldIDBCounts);
+//	}
+	if (m_oldIDBCounts<=0)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:GetPublicKey-->IDblock count=%d."),m_oldIDBCounts);
+		}
+		return false;
+	}
+	for(i=0;i<m_oldIDBCounts;i++)
+	{
+		iRet = m_pComm->RKU_ReadSector(m_idBlockOffset[i]*m_flashInfo.uiSectorPerBlock, 8,bData);
+//		sleep(1);
+		if( iRet!=ERR_SUCCESS )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:GetPublicKey-->RKU_ReadSector failed,RetCode(%d)"),iRet);
+			}
+			return false;
+		}
+
+		P_RC4(bData,SECTOR_SIZE);
+
+		if (pSec0->uiRc4Flag==0)
+		{
+//			if (m_pLog)
+//			{
+//				m_pLog->PrintBuffer(strOutput,bData+4*512,512,16);
+//				m_pLog->Record("INFO:secure header\n%s",strOutput.c_str());
+//			}
+			for(j=0;j<4;j++)
+				P_RC4(bData+SECTOR_SIZE*(j+4),SECTOR_SIZE);
+//			if (m_pLog)
+//			{
+//				m_pLog->PrintBuffer(strOutput,bData+4*512,512,16);
+//				m_pLog->Record("INFO:secure header rc4\n%s",strOutput.c_str());
+//			}
+		}
+//		if (m_pLog)
+//		{
+//			m_pLog->Record("INFO:secure header tag=0x%x",pSecureHdr->uiTag);
+//		}
+		if (pSecureHdr->uiTag==0x4B415352)
+		{
+			nRsaByte = pSecureHdr->usRsaBit/8;
+			*((USHORT *)pKey) = pSecureHdr->usRsaBit;
+			for(j=0;j<nRsaByte;j++)
+				*(pKey+j+2) = pSecureHdr->nFactor[nRsaByte-j-1];
+			for(j=0;j<nRsaByte;j++)
+				*(pKey+j+2+nRsaByte) = pSecureHdr->eFactor[nRsaByte-j-1];
+			nKeySize = nRsaByte*2+2;
+//			if (m_pLog)
+//			{
+//				m_pLog->PrintBuffer(strOutput,pKey,nKeySize,16);
+//				m_pLog->Record("INFO:Key\n%s",strOutput.c_str());
+//			}
+			return true;
+		}
+
+	}
+
+	return false;
+}
+long long CRKAndroidDevice::GetSparseImageSize(STRUCT_RKIMAGE_ITEM &entry)
+{
+	bool bRet;
+	sparse_header header;
+	DWORD dwFWOffset;
+	long long  ulEntryStartOffset;
+	dwFWOffset = m_pImage->FWOffset;
+	if (entry.file[50]=='H')
+	{
+		ulEntryStartOffset = *((DWORD *)(&entry.file[51]));
+		ulEntryStartOffset <<= 32;
+		ulEntryStartOffset += entry.offset;
+		ulEntryStartOffset += m_pImage->FWOffset;
+	}
+	else
+	{
+		ulEntryStartOffset = m_pImage->FWOffset;
+		ulEntryStartOffset += entry.offset;
+	}
+	bRet = m_pImage->GetData(ulEntryStartOffset,sizeof(header),(PBYTE)&header);
+	if (!bRet)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:IsSparseImage-->getdata failed"));
+		}
+		return -1;
+	}
+	return header.blk_sz * header.total_blks;
+
+}
+bool CRKAndroidDevice::IsSparseImage(STRUCT_RKIMAGE_ITEM &entry)
+{
+	bool bRet;
+	sparse_header header;
+	DWORD dwFWOffset;
+	long long ulEntryStartOffset;
+	dwFWOffset = m_pImage->FWOffset;
+	if (entry.file[50]=='H')
+	{
+		ulEntryStartOffset = *((DWORD *)(&entry.file[51]));
+		ulEntryStartOffset <<= 32;
+		ulEntryStartOffset += entry.offset;
+		ulEntryStartOffset += m_pImage->FWOffset;
+	}
+	else
+	{
+		ulEntryStartOffset = m_pImage->FWOffset;
+		ulEntryStartOffset += entry.offset;
+	}
+	bRet = m_pImage->GetData(ulEntryStartOffset,sizeof(header),(PBYTE)&header);
+	if (!bRet)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:IsSparseImage-->getdata failed"));
+		}
+		return false;
+	}
+	if (header.magic!=SPARSE_HEADER_MAGIC)
+	{
+		return false;
+	}
+	return true;
+}
+
+
+int CRKAndroidDevice:: getEmmc() {
+    char bootmode[256];
+    int result = 0;
+
+    property_get("ro.boot.mode", bootmode, "unknown");
+    printf("bootmode = %s \n", bootmode);
+
+    if(!strcmp(bootmode, "nvme")) {
+	result = 2;
+    } else if(!strcmp(bootmode, "emmc")) {
+        result = 1;
+    }else {
+        result = 0;
+    }
+
+    return result;
+}
+
+bool CRKAndroidDevice::ErasePartition_discard(STRUCT_RKIMAGE_ITEM &entry)
+{
+	u64 uifileBufferSize;
+	int iRet;
+
+	uifileBufferSize = entry.part_size * SECTOR_SIZE;
+	m_pCallback("INFO:ErasePartition %s,offset=0x%x,size=%llu, part_size=0x%x \n",
+				entry.name, entry.flash_offset, uifileBufferSize, entry.part_size);
+
+	iRet = m_pComm->RKU_EraseBlock_discard(entry.flash_offset, entry.part_size);
+
+	if( iRet!=ERR_SUCCESS ){
+		printf("erase block fail\n");
+		return false;
+	}
+	return true;
+}
+
+bool CRKAndroidDevice::ErasePartition(STRUCT_RKIMAGE_ITEM &entry)
+{
+	UINT uiLBATransferSize=(LBA_TRANSFER_SIZE)*m_uiLBATimes;
+	UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+	int iRet;
+	UINT uiBufferSize=uiLBATransferSize;
+	u64 uifileBufferSize;
+	BYTE byRWMethod=RWMETHOD_IMAGE;
+
+	uifileBufferSize = entry.part_size * SECTOR_SIZE;
+	if (m_pLog)
+	{
+		m_pLog->Record(_T(" INFO:ErasePartition %s,offset=0x%x,size=%llu, part_size=0x%x"),entry.name,entry.flash_offset,uifileBufferSize, entry.part_size);
+	}
+	m_pCallback("INFO:ErasePartition %s,offset=0x%x,size=%llu, part_size=0x%x \n",entry.name,entry.flash_offset,uifileBufferSize, entry.part_size);
+
+	PBYTE pBuffer=NULL;
+	pBuffer = new BYTE[uiBufferSize];
+	if (!pBuffer)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:ErasePartition-->New memory failed"));
+		}
+		m_pCallback("ERROR:ErasePartition-->New memory failed \n");
+		return false;
+	}
+
+	UINT uiBegin,uiLen,uiWriteByte;
+	long long uiEntryOffset;
+	uiBegin = entry.flash_offset;
+	uiLen = 0;uiWriteByte = 0;uiEntryOffset=0;
+	while ( uifileBufferSize>0 )
+	{
+		memset(pBuffer,0,uiBufferSize);
+		if ( uifileBufferSize<uiBufferSize )
+		{
+			uiWriteByte = uifileBufferSize;
+			uiLen = ( (uiWriteByte%SECTOR_SIZE==0) ? (uiWriteByte/SECTOR_SIZE) : (uiWriteByte/SECTOR_SIZE+1) );
+		}
+		else
+		{
+			uiWriteByte = uiBufferSize;
+			uiLen = uiLBASector;
+		}
+
+		iRet = m_pComm->RKU_WriteLBA(uiBegin,uiLen,pBuffer,byRWMethod);
+		if( iRet!=ERR_SUCCESS )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:ErasePartition-->RKU_WriteLBA failed,Written(%d),RetCode(%d)"),uiEntryOffset,iRet);
+			}
+			m_pCallback("ERROR:ErasePartition-->RKU_WriteLBA failed,Written(%d),RetCode(%d) \n",uiEntryOffset,iRet);
+
+			delete []pBuffer;
+			pBuffer = NULL;
+			return false;
+		}
+		uifileBufferSize -= uiWriteByte;
+		uiEntryOffset += uiWriteByte;
+		uiBegin += uiLen;
+	}
+	delete []pBuffer;
+	pBuffer = NULL;
+	return true;
+}
+
+bool CRKAndroidDevice::EraseSparseRegion(const char* volume,const char* directory)
+{
+	//bool bSuccess = true;
+    //if volume is system.then set volume is "",because system as root
+    if(strcmp("/system", volume) == 0)
+        volume = "/";
+    printf("EraseSparseRegion  volume is %s\n",volume);
+    if(format_volume(volume, directory) == 0){
+        printf("EraseSparseRegion format_volume is ok!!!\n");
+        return true;
+    }else{
+        printf("EraseSparseRegion format_volume is failed!!!\n");
+        return false;
+    }
+}
+bool CRKAndroidDevice::RKA_SparseFile_Download(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte)
+{
+	UINT uiLBATransferSize=(LBA_TRANSFER_SIZE)*m_uiLBATimes;
+	//UINT uiLBALoopLimit=(LBA_LOOP_SIZE)/uiLBATransferSize;
+	UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+	int iRet,i;
+	bool bRet;
+	UINT uiBufferSize=uiLBATransferSize;
+	long long  uifileBufferSize;
+	DWORD dwFWOffset;
+	long long ulEntryStartOffset;
+	sparse_header header;
+	chunk_header chunk;
+	//dwLayerID = GetLayerID();
+	(void)totalByte;
+
+	m_pCallback("RKA_SparseFile_Download entry.name=%s \n", entry.name);
+	dwFWOffset = m_pImage->FWOffset;
+	if (entry.file[50]=='H')
+	{
+		ulEntryStartOffset = *((DWORD *)(&entry.file[51]));
+		ulEntryStartOffset <<= 32;
+		ulEntryStartOffset += entry.offset;
+		ulEntryStartOffset += m_pImage->FWOffset;
+	}
+	else
+	{
+		ulEntryStartOffset = m_pImage->FWOffset;
+		ulEntryStartOffset += entry.offset;
+	}
+	if (entry.file[55]=='H')
+	{
+		uifileBufferSize = *((DWORD *)(&entry.file[56]));
+		uifileBufferSize <<= 32;
+		uifileBufferSize += entry.size;
+	}
+	else
+		uifileBufferSize = entry.size;
+
+	//get sparse header
+	bRet = m_pImage->GetData(ulEntryStartOffset,sizeof(header),(PBYTE)&header);
+	if (!bRet)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_SparseFile_Download-->get sparse header failed,partition=%s"),entry.name);
+			m_pCallback("ERROR:RKA_SparseFile_Download-->get sparse header failed,partition=%s \n",entry.name);
+		}
+		return false;
+	}
+	uifileBufferSize = header.blk_sz * header.total_blks;
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("INFO:Start to download %s,offset=0x%x,size=%llu"),entry.name,entry.flash_offset,uifileBufferSize);
+		m_pCallback("INFO:Start to download %s,offset=0x%x,size=%llu \n",entry.name,entry.flash_offset,uifileBufferSize);
+	}
+	//erase system partition
+#if 0
+	if ( !strcmp(entry.name, "system") && !EraseSparseRegion("/system",NULL))
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T(" ERROR:RKA_SparseFile_Download-->EraseSparseRegion failed"));
+		}
+		return false;
+	}
+#else
+	if(m_pComm->m_bEmmc == 1) {
+		if(!ErasePartition_discard(entry)) {
+			if (m_pLog) {
+				m_pLog->Record(_T(" ERROR:RKA_SparseFile_Download-->ErasePartition_discard failed"));
+			}
+			m_pCallback("ERROR:RKA_SparseFile_Download-->ErasePartition_discard failed \n");
+			return false;
+		}
+	} else {
+		if(!ErasePartition(entry)) {
+			if (m_pLog) {
+				m_pLog->Record(_T(" ERROR:RKA_SparseFile_Download-->ErasePartition failed"));
+			}
+			m_pCallback("ERROR:RKA_SparseFile_Download-->ErasePartition failed \n");
+			return false;
+		}
+	}
+#endif
+
+	BYTE byRWMethod=RWMETHOD_IMAGE;
+
+	if (entry.flash_offset>m_dwBackupOffset)
+	{
+		byRWMethod = RWMETHOD_LBA;
+	}
+	PBYTE pBuffer=NULL;
+	pBuffer = new BYTE[uiBufferSize];
+	if (!pBuffer)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T(" ERROR:RKA_SparseFile_Download-->New memory failed"));
+		}
+		m_pCallback("ERROR:RKA_SparseFile_Download-->New memory failed \n");
+		return false;
+	}
+
+	UINT uiBegin,uiLen,uiWriteByte,uiCurChunk,uiChunkDataSize,uiFillByte,uiCrc;
+	long long  uiEntryOffset;
+	uiCurChunk = 0;
+	uiBegin = entry.flash_offset;
+	uiLen = 0;uiWriteByte = 0;uiEntryOffset=sizeof(header);
+	m_pCallback("INFO:RKA_SparseFile_Download-->total_chunks=%u \n", header.total_chunks);
+	while ( uiCurChunk<header.total_chunks)
+	{
+		memset(&chunk, 0x0, sizeof(chunk));
+		bRet = m_pImage->GetData(ulEntryStartOffset+uiEntryOffset,sizeof(chunk),(PBYTE)&chunk);
+		if (!bRet)
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T(" ERROR:RKA_SparseFile_Download-->get sparse chunk failed"));
+			}
+			m_pCallback("ERROR:RKA_SparseFile_Download-->get sparse chunk failed \n");
+			delete []pBuffer;
+			pBuffer = NULL;
+			return false;
+		}
+		uiCurChunk++;
+		uiEntryOffset += sizeof(chunk);
+		switch (chunk.chunk_type)
+		{
+		case CHUNK_TYPE_RAW:
+			uiChunkDataSize = chunk.total_sz - sizeof(chunk_header);
+			while (uiChunkDataSize)
+			{
+				memset(pBuffer,0,uiBufferSize);
+				if ( uiChunkDataSize<uiBufferSize )
+				{
+					uiWriteByte = uiChunkDataSize;
+					uiLen = ( (uiWriteByte%SECTOR_SIZE==0) ? (uiWriteByte/SECTOR_SIZE) : (uiWriteByte/SECTOR_SIZE+1) );
+				}
+				else
+				{
+					uiWriteByte = uiBufferSize;
+					uiLen = uiLBASector;
+				}
+				if (!m_pImage->GetData(ulEntryStartOffset+uiEntryOffset,uiWriteByte,pBuffer))
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:RKA_SparseFile_Download-->get chunk data failed,chunk=%d"),uiCurChunk);
+					}
+					m_pCallback("ERROR:RKA_SparseFile_Download-->get chunk data failed,chunk=%d \n",uiCurChunk);
+					delete []pBuffer;
+					pBuffer = NULL;
+					return false;
+				}
+				uiEntryOffset += uiWriteByte;
+				iRet = m_pComm->RKU_WriteLBA(uiBegin,uiLen,pBuffer,byRWMethod);
+				if( iRet!=ERR_SUCCESS )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:RKA_SparseFile_Download-->RKU_WriteLBA failed,RetCode(%d),chunk=%d"),iRet,uiCurChunk);
+					}
+					m_pCallback("ERROR:RKA_SparseFile_Download-->RKU_WriteLBA failed,RetCode(%d),chunk=%d \n",iRet,uiCurChunk);
+					delete []pBuffer;
+					pBuffer = NULL;
+					return false;
+				}
+				uiBegin += uiLen;
+				currentByte += uiWriteByte;
+				uiChunkDataSize -= uiWriteByte;
+
+			}
+			break;
+		case CHUNK_TYPE_FILL:
+			uiChunkDataSize = chunk.chunk_sz * header.blk_sz;
+			if (!m_pImage->GetData(ulEntryStartOffset+uiEntryOffset,4,(PBYTE)&uiFillByte))
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("ERROR:RKA_SparseFile_Download-->get fill byte failed,chunk=%d"),uiCurChunk);
+				}
+				m_pCallback("ERROR:RKA_SparseFile_Download-->get fill byte failed,chunk=%d \n",uiCurChunk);
+				delete []pBuffer;
+				pBuffer = NULL;
+				return false;
+			}
+			uiEntryOffset += 4;
+			while (uiChunkDataSize)
+			{
+				memset(pBuffer,0,uiBufferSize);
+				if ( uiChunkDataSize<uiBufferSize )
+				{
+					uiWriteByte = uiChunkDataSize;
+					uiLen = ( (uiWriteByte%SECTOR_SIZE==0) ? (uiWriteByte/SECTOR_SIZE) : (uiWriteByte/SECTOR_SIZE+1) );
+				}
+				else
+				{
+					uiWriteByte = uiBufferSize;
+					uiLen = uiLBASector;
+				}
+				for (i=0;i<uiWriteByte/4;i++)
+				{
+					*(UINT *)(pBuffer + i*4) = uiFillByte;
+				}
+
+				iRet = m_pComm->RKU_WriteLBA(uiBegin,uiLen,pBuffer,byRWMethod);
+				if( iRet!=ERR_SUCCESS )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T(" ERROR:RKA_SparseFile_Download-->RKU_WriteLBA failed,RetCode(%d),chunk=%d"),iRet,uiCurChunk);
+					}
+					m_pCallback("ERROR:RKA_SparseFile_Download-->RKU_WriteLBA failed,RetCode(%d),chunk=%d \n",iRet,uiCurChunk);
+					delete []pBuffer;
+					pBuffer = NULL;
+					return false;
+				}
+				uiBegin += uiLen;
+				currentByte += uiWriteByte;
+				uiChunkDataSize -= uiWriteByte;
+
+			}
+			break;
+		case CHUNK_TYPE_DONT_CARE:
+			uiChunkDataSize = chunk.chunk_sz * header.blk_sz;
+			currentByte += uiChunkDataSize;
+			uiLen = ( (uiChunkDataSize%SECTOR_SIZE==0) ? (uiChunkDataSize/SECTOR_SIZE) : (uiChunkDataSize/SECTOR_SIZE+1) );
+			uiBegin += uiLen;
+
+			break;
+		case CHUNK_TYPE_CRC32:
+			bRet = m_pImage->GetData(ulEntryStartOffset+uiEntryOffset,4,(PBYTE)&uiCrc);
+			uiEntryOffset += 4;
+			break;
+		}
+	}
+	delete []pBuffer;
+	pBuffer = NULL;
+
+	m_pCallback("RKA_SparseFile_Download entry.name=%s DONE! \n", entry.name);
+	return true;
+}
+bool CRKAndroidDevice::RKA_SparseFile_Check(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte)
+{
+	UINT uiLBATransferSize=(LBA_TRANSFER_SIZE)*m_uiLBATimes;
+	//UINT uiLBALoopLimit=(LBA_LOOP_SIZE)/uiLBATransferSize;
+	UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+	int iRet,i;
+	bool bRet;
+	UINT uiBufferSize=uiLBATransferSize;
+	long long uifileBufferSize;
+	DWORD dwFWOffset;
+	long long ulEntryStartOffset;
+	sparse_header header;
+	chunk_header chunk;
+	(void)totalByte;
+	m_pCallback("RKA_SparseFile_Check entry.name=%s \n", entry.name);
+
+	dwFWOffset = m_pImage->FWOffset;
+	if (entry.file[50]=='H')
+	{
+		ulEntryStartOffset = *((DWORD *)(&entry.file[51]));
+		ulEntryStartOffset <<= 32;
+		ulEntryStartOffset += entry.offset;
+		ulEntryStartOffset += m_pImage->FWOffset;
+	}
+	else
+	{
+		ulEntryStartOffset = m_pImage->FWOffset;
+		ulEntryStartOffset += entry.offset;
+	}
+	if (entry.file[55]=='H')
+	{
+		uifileBufferSize = *((DWORD *)(&entry.file[56]));
+		uifileBufferSize <<= 32;
+		uifileBufferSize += entry.size;
+	}
+	else
+		uifileBufferSize = entry.size;
+	//get sparse header
+	bRet = m_pImage->GetData(ulEntryStartOffset,sizeof(header),(PBYTE)&header);
+	if (!bRet)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T(" ERROR:RKA_SparseFile_Check-->get sparse header failed,partition=%s"),entry.name);
+		}
+		m_pCallback("ERROR:RKA_SparseFile_Check-->get sparse header failed,partition=%s \n",entry.name);
+		return false;
+	}
+	uifileBufferSize = header.blk_sz * header.total_blks;
+	if (m_pLog)
+	{
+		m_pLog->Record(_T("INFO:Start to check %s,offset=0x%x,size=%I64u"),entry.name,entry.flash_offset,uifileBufferSize);
+	}
+	m_pCallback("INFO:Start to check %s,offset=0x%x,size=%I64u \n",entry.name,entry.flash_offset,uifileBufferSize);
+
+	BYTE byRWMethod=RWMETHOD_IMAGE;
+	if (entry.flash_offset>m_dwBackupOffset)
+	{
+		byRWMethod = RWMETHOD_LBA;
+	}
+
+	PBYTE pBufferFromFile=NULL;
+	pBufferFromFile = new BYTE[uiBufferSize];
+	if (!pBufferFromFile)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T(" ERROR:RKA_SparseFile_Check-->New memory failed"));
+		}
+		m_pCallback("ERROR:RKA_SparseFile_Check-->New memory failed \n");
+		return false;
+	}
+	PBYTE pBufferFromFlash=NULL;
+	pBufferFromFlash = new BYTE[uiBufferSize];
+	if (!pBufferFromFlash)
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:RKA_SparseFile_Check-->New memory failed"));
+		}
+		m_pCallback("ERROR:RKA_SparseFile_Check-->New memory failed \n");
+		delete []pBufferFromFile;
+		return false;
+	}
+
+	UINT uiBegin,uiLen,uiWriteByte,uiCurChunk,uiChunkDataSize,uiFillByte,uiCrc;
+	long long uiEntryOffset;
+	uiBegin = entry.flash_offset;
+	uiCurChunk = 0;
+	uiLen = 0;uiWriteByte = 0;uiEntryOffset=sizeof(header);
+	while ( uiCurChunk<header.total_chunks)
+	{
+		memset(&chunk, 0x0, sizeof(chunk));
+		bRet = m_pImage->GetData(ulEntryStartOffset+uiEntryOffset,sizeof(chunk),(PBYTE)&chunk);
+		if (!bRet)
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:RKA_SparseFile_Check-->get sparse chunk failed"));
+			}
+			m_pCallback("ERROR:RKA_SparseFile_Check-->get sparse chunk failed \n");
+			delete []pBufferFromFile;
+			delete []pBufferFromFlash;
+			return false;
+		}
+		uiCurChunk++;
+		uiEntryOffset += sizeof(chunk);
+		switch (chunk.chunk_type)
+		{
+		case CHUNK_TYPE_RAW:
+			uiChunkDataSize = chunk.total_sz - sizeof(chunk_header);
+			while (uiChunkDataSize)
+			{
+				if ( uiChunkDataSize<uiBufferSize )
+				{
+					uiWriteByte = uiChunkDataSize;
+					uiLen = ( (uiWriteByte%SECTOR_SIZE==0) ? (uiWriteByte/SECTOR_SIZE) : (uiWriteByte/SECTOR_SIZE+1) );
+				}
+				else
+				{
+					uiWriteByte = uiBufferSize;
+					uiLen = uiLBASector;
+				}
+				memset(pBufferFromFile,0,uiBufferSize);
+				memset(pBufferFromFlash,0,uiBufferSize);
+				if (!m_pImage->GetData(ulEntryStartOffset+uiEntryOffset,uiWriteByte,pBufferFromFile))
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T("ERROR:RKA_SparseFile_Check-->get chunk data failed,chunk=%d"),uiCurChunk);
+					}
+					m_pCallback("ERROR:RKA_SparseFile_Check-->get chunk data failed,chunk=%d \n",uiCurChunk);
+					delete []pBufferFromFile;
+					delete []pBufferFromFlash;
+					return false;
+				}
+				uiEntryOffset += uiWriteByte;
+				iRet = m_pComm->RKU_ReadLBA(uiBegin,uiLen,pBufferFromFlash,byRWMethod);
+				if( iRet!=ERR_SUCCESS )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T(" ERROR:RKA_SparseFile_Check-->RKU_ReadLBA failed,RetCode(%d),chunk=%d"),iRet,uiCurChunk);
+					}
+					m_pCallback("ERROR:RKA_SparseFile_Check-->RKU_ReadLBA failed,RetCode(%d),chunk=%d \n",iRet,uiCurChunk);
+					delete []pBufferFromFile;
+					delete []pBufferFromFlash;
+					return false;
+				}
+				if ( memcmp(pBufferFromFile,pBufferFromFlash,uiWriteByte)!=0 )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T(" ERROR:RKA_SparseFile_Check-->Memcmp failed,chunk=%d uiBegin=0x%x \n"),uiCurChunk, uiBegin);
+					}
+					m_pCallback("ERROR:RKA_SparseFile_Check-->Memcmp failed,chunk=%d uiBegin=0x%x\n",uiCurChunk, uiBegin);
+					if (m_pLog)
+					{
+						tchar szDateTime[100];
+						tstring strFile;
+						time_t	now;
+						struct tm timeNow;
+						time(&now);
+						localtime_r(&now,&timeNow);
+						_stprintf(szDateTime,_T("%02d-%02d-%02d"),timeNow.tm_hour,timeNow.tm_min,timeNow.tm_sec);
+						//strFile = m_pLog->LogSavePath;
+						strFile += szDateTime;
+						strFile += _T("file.bin");
+						m_pLog->SaveBuffer( strFile,pBufferFromFile,uiWriteByte );
+						//strFile = m_pLog->LogSavePath;
+						strFile += szDateTime;
+						strFile += _T("flash.bin");
+						m_pLog->SaveBuffer( strFile,pBufferFromFlash,uiWriteByte );
+					}
+					delete []pBufferFromFile;
+					delete []pBufferFromFlash;
+					return false;
+				}
+				currentByte += uiWriteByte;
+				uiChunkDataSize -= uiWriteByte;
+				uiBegin += uiLen;
+			}
+			break;
+		case CHUNK_TYPE_FILL:
+			uiChunkDataSize = chunk.chunk_sz * header.blk_sz;
+			if (!m_pImage->GetData(ulEntryStartOffset+uiEntryOffset,4,(PBYTE)&uiFillByte))
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T(" ERROR:RKA_SparseFile_Check-->get fill byte failed,chunk=%d"),uiCurChunk);
+				}
+				m_pCallback("ERROR:RKA_SparseFile_Check-->get fill byte failed,chunk=%d \n",uiCurChunk);
+				delete []pBufferFromFile;
+				delete []pBufferFromFlash;
+				return false;
+			}
+			uiEntryOffset += 4;
+			while (uiChunkDataSize)
+			{
+				if ( uiChunkDataSize<uiBufferSize )
+				{
+					uiWriteByte = uiChunkDataSize;
+					uiLen = ( (uiWriteByte%SECTOR_SIZE==0) ? (uiWriteByte/SECTOR_SIZE) : (uiWriteByte/SECTOR_SIZE+1) );
+				}
+				else
+				{
+					uiWriteByte = uiBufferSize;
+					uiLen = uiLBASector;
+				}
+				memset(pBufferFromFile,0,uiBufferSize);
+				memset(pBufferFromFlash,0,uiBufferSize);
+				for (i=0;i<uiWriteByte/4;i++)
+				{
+					*(UINT *)(pBufferFromFile + i*4) = uiFillByte;
+				}
+				iRet = m_pComm->RKU_ReadLBA(uiBegin,uiLen,pBufferFromFlash,byRWMethod);
+				if( iRet!=ERR_SUCCESS )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T(" ERROR:RKA_SparseFile_Check-->RKU_ReadLBA failed,RetCode(%d),chunk=%d"),iRet,uiCurChunk);
+					}
+					m_pCallback("ERROR:RKA_SparseFile_Check-->RKU_ReadLBA failed,RetCode(%d),chunk=%d \n",iRet,uiCurChunk);
+					delete []pBufferFromFile;
+					delete []pBufferFromFlash;
+					return false;
+				}
+				if ( memcmp(pBufferFromFile,pBufferFromFlash,uiWriteByte)!=0 )
+				{
+					if (m_pLog)
+					{
+						m_pLog->Record(_T(" ERROR:RKA_SparseFile_Check-->Memcmp failed,chunk=%d uiBegin=%0x%x"),uiCurChunk, uiBegin);
+					}
+					m_pCallback("ERROR:RKA_SparseFile_Check-->Memcmp failed,chunk=%d uiBegin=%0x%x",uiCurChunk, uiBegin);
+					if (m_pLog)
+					{
+						tchar szDateTime[100];
+						tstring strFile;
+						time_t	now;
+						struct tm timeNow;
+						time(&now);
+						localtime_r(&now,&timeNow);
+						_stprintf(szDateTime,_T("%02d-%02d-%02d"),timeNow.tm_hour,timeNow.tm_min,timeNow.tm_sec);
+						//strFile = m_pLog->LogSavePath;
+						strFile += szDateTime;
+						strFile += _T("file.bin");
+						m_pLog->SaveBuffer( strFile,pBufferFromFile,uiWriteByte );
+						//strFile = m_pLog->LogSavePath;
+						strFile += szDateTime;
+						strFile += _T("flash.bin");
+						m_pLog->SaveBuffer( strFile,pBufferFromFlash,uiWriteByte );
+					}
+					delete []pBufferFromFile;
+					delete []pBufferFromFlash;
+					return false;
+				}
+				currentByte += uiWriteByte;
+				uiChunkDataSize -= uiWriteByte;
+				uiBegin += uiLen;
+
+			}
+			break;
+		case CHUNK_TYPE_DONT_CARE:
+			uiChunkDataSize = chunk.chunk_sz * header.blk_sz;
+			currentByte += uiChunkDataSize;
+			uiLen = ( (uiChunkDataSize%SECTOR_SIZE==0) ? (uiChunkDataSize/SECTOR_SIZE) : (uiChunkDataSize/SECTOR_SIZE+1) );
+			uiBegin += uiLen;
+			break;
+		case CHUNK_TYPE_CRC32:
+			bRet = m_pImage->GetData(ulEntryStartOffset+uiEntryOffset,4,(PBYTE)&uiCrc);
+			uiEntryOffset += 4;
+			break;
+		}
+	}
+
+	delete []pBufferFromFile;
+	delete []pBufferFromFlash;
+	m_pCallback("RKA_SparseFile_Check entry.name=%s Done! \n", entry.name);
+	return true;
+}
+
+bool CRKAndroidDevice::GetParameterGptFlag(STRUCT_RKIMAGE_ITEM &paramItem)
+{
+	PBYTE pParamBuf=NULL;
+	bool bGpt = false;
+	pParamBuf = new BYTE[paramItem.size-12+1];
+	if (!pParamBuf)
+	{
+		return false;
+	}
+	memset(pParamBuf,0,paramItem.size-12+1);
+	bool bRet;
+	bRet = m_pImage->GetData(m_pImage->FWOffset+paramItem.offset+8,paramItem.size-12,pParamBuf);
+	if (!bRet)
+	{
+		delete []pParamBuf;
+		return false;
+	}
+	string strParamFile = (char *)pParamBuf;
+	stringstream paramStream(strParamFile);
+	delete []pParamBuf;
+
+
+	string strLine;
+	string::size_type pos,line_size;
+	while (!paramStream.eof())
+	{
+		getline(paramStream,strLine);
+		line_size = strLine.size();
+		if (line_size<=0)
+		{
+			continue;
+		}
+		if (strLine[line_size-1]=='\r')
+		{
+			strLine = strLine.substr(0,line_size-1);
+		}
+		if (strLine.size()<=0)
+		{
+			continue;
+		}
+		if (strLine[0]=='#')
+		{
+			continue;
+		}
+		transform(strLine.begin(),strLine.end(),strLine.begin(),(int(*)(int))toupper);
+		pos = strLine.find("TYPE");
+		if (pos==string::npos)
+		{
+			continue;
+		}
+		if ((pos = strLine.find("GPT"))!=string::npos)
+		{
+			bGpt = true;
+			break;
+		}
+		else
+			continue;
+	}
+	return bGpt;
+}
+#define DO_CRC(x) crc = tab[ (crc ^ (x)) & 255 ] ^ (crc>>8)
+unsigned int crc32_le(unsigned int crc, unsigned char *p, unsigned int len)
+{
+	unsigned int      *b =(unsigned int *)p;
+	unsigned int      *tab = crc32table_le;
+	crc = crc ^ 0xFFFFFFFF;
+	if((((long)b)&3 && len)){
+		do {
+			unsigned char *p = (unsigned char *)b;
+			DO_CRC(*p++);
+			b = (unsigned int *)p;
+		} while ((--len) && ((long)b)&3 );
+	}
+	if((len >= 4)){
+		unsigned int save_len = len & 3;
+		len = len >> 2;
+		--b;
+		do {
+			crc ^= *++b;
+			DO_CRC(0);
+			DO_CRC(0);
+			DO_CRC(0);
+			DO_CRC(0);
+		} while (--len);
+		b++;
+		len = save_len;
+	}
+	if(len){
+		do {
+			unsigned char *p = (unsigned char *)b;
+			DO_CRC(*p++);
+			b = (unsigned int *)p;
+		} while (--len);
+	}
+	crc = crc ^ 0xFFFFFFFF;
+	return crc;
+
+}
+void prepare_gpt_backup(u8 *master, u8 *backup, u64 diskSectors)
+{
+	gpt_header *gptBackupHead = (gpt_header *)(backup + 32 * SECTOR_SIZE);
+	u32 calc_crc32;
+	(void)master;
+
+	/* recalculate the values for the Backup GPT Header */
+	gptBackupHead->my_lba = cpu_to_le64(diskSectors - 1);
+	gptBackupHead->alternate_lba = cpu_to_le64(1);
+	gptBackupHead->partition_entry_lba = cpu_to_le64(diskSectors - 34 + 1);
+	gptBackupHead->header_crc32 = 0;
+
+	calc_crc32 = crc32_le(0, (unsigned char *)gptBackupHead, le32_to_cpu(gptBackupHead->header_size));
+	gptBackupHead->header_crc32 = cpu_to_le32(calc_crc32);
+}
+void gen_rand_uuid(unsigned char *uuid_bin)
+{
+	efi_guid_t id;
+	unsigned int *ptr = (unsigned int *)&id;
+	unsigned int i;
+
+	/* Set all fields randomly */
+	for (i = 0; i < sizeof(id) / sizeof(*ptr); i++)
+		*(ptr + i) = cpu_to_be32(rand());
+
+	id.uuid.time_hi_and_version = (id.uuid.time_hi_and_version & 0x0FFF) | 0x4000;
+	id.uuid.clock_seq_hi_and_reserved = id.uuid.clock_seq_hi_and_reserved | 0x80;
+
+	memcpy(uuid_bin, id.raw, sizeof(id));
+}
+void create_gpt_buffer(u8 *gpt, PARAM_ITEM_VECTOR &vecParts, CONFIG_ITEM_VECTOR &vecUuid, u64 diskSectors)
+{
+	legacy_mbr *mbr = (legacy_mbr *)gpt;
+	gpt_header *gptHead = (gpt_header *)(gpt + SECTOR_SIZE);
+	gpt_entry *gptEntry = (gpt_entry *)(gpt + 2 * SECTOR_SIZE);
+	u32 i,j;
+	int pos;
+	tstring strPartName;
+	string::size_type iPos;
+	/*1.protective mbr*/
+	memset(gpt, 0, SECTOR_SIZE);
+	mbr->signature = MSDOS_MBR_SIGNATURE;
+	mbr->partition_record[0].sys_ind = EFI_PMBR_OSTYPE_EFI_GPT;
+	mbr->partition_record[0].start_sect = 1;
+	mbr->partition_record[0].nr_sects = (u32)-1;
+	/*2.gpt header*/
+	memset(gpt + SECTOR_SIZE, 0, SECTOR_SIZE);
+	gptHead->signature = cpu_to_le64(GPT_HEADER_SIGNATURE);
+	gptHead->revision = cpu_to_le32(GPT_HEADER_REVISION_V1);
+	gptHead->header_size = cpu_to_le32(sizeof(gpt_header));
+	gptHead->my_lba = cpu_to_le64(1);
+	gptHead->alternate_lba = cpu_to_le64(diskSectors - 1);
+	gptHead->first_usable_lba = cpu_to_le64(34);
+	gptHead->last_usable_lba = cpu_to_le64(diskSectors - 34);
+	gptHead->partition_entry_lba = cpu_to_le64(2);
+	gptHead->num_partition_entries = cpu_to_le32(GPT_ENTRY_NUMBERS);
+	gptHead->sizeof_partition_entry = cpu_to_le32(GPT_ENTRY_SIZE);
+	gptHead->header_crc32 = 0;
+	gptHead->partition_entry_array_crc32 = 0;
+	gen_rand_uuid(gptHead->disk_guid.raw);
+
+	/*3.gpt partition entry*/
+	memset(gpt + 2 * SECTOR_SIZE, 0, 32 * SECTOR_SIZE);
+	for (i = 0; i < vecParts.size(); i++) {
+		gen_rand_uuid(gptEntry->partition_type_guid.raw);
+		gen_rand_uuid(gptEntry->unique_partition_guid.raw);
+		gptEntry->starting_lba = cpu_to_le64(vecParts[i].uiItemOffset);
+		gptEntry->ending_lba = cpu_to_le64(gptEntry->starting_lba + vecParts[i].uiItemSize - 1);
+		gptEntry->attributes.raw = 0;
+		strPartName = vecParts[i].szItemName;
+		iPos = strPartName.find(_T(':'));
+		if (iPos != tstring::npos) {
+			transform(strPartName.begin(),strPartName.end(),strPartName.begin(),(int(*)(int))tolower);
+			if (strPartName.find(_T("bootable")) != tstring::npos)
+				gptEntry->attributes.raw = PART_PROPERTY_BOOTABLE;
+			if (strPartName.find(_T("grow")) != tstring::npos)
+				gptEntry->ending_lba = cpu_to_le64(diskSectors - 34);
+			strPartName = strPartName.substr(0,iPos);
+			vecParts[i].szItemName[strPartName.size()] = 0;
+		}
+		for (j = 0; j < _tcslen(vecParts[i].szItemName); j++)
+			gptEntry->partition_name[j] = vecParts[i].szItemName[j];
+		if ((pos = find_uuid_item(vecUuid, vecParts[i].szItemName)) != -1)
+			memcpy(gptEntry->unique_partition_guid.raw, vecUuid[pos].szItemValue, 16);
+		gptEntry++;
+	}
+
+	gptHead->partition_entry_array_crc32 = cpu_to_le32(crc32_le(0, gpt + 2 * SECTOR_SIZE, GPT_ENTRY_SIZE * GPT_ENTRY_NUMBERS));
+	gptHead->header_crc32 = cpu_to_le32(crc32_le(0, gpt + SECTOR_SIZE, sizeof(gpt_header)));
+
+}
+bool ParseUuidInfo(string &strUuidInfo, string &strName, string &strUUid)
+{
+	string::size_type pos(0);
+
+	if (strUuidInfo.size() <= 0) {
+		return false;
+	}
+	pos = strUuidInfo.find('=');
+	if (pos == string::npos) {
+		return false;
+	}
+	strName = strUuidInfo.substr(0, pos);
+	strName.erase(0, strName.find_first_not_of(" "));
+	strName.erase(strName.find_last_not_of(" ") + 1);
+
+	strUUid = strUuidInfo.substr(pos+1);
+	strUUid.erase(0, strUUid.find_first_not_of(" "));
+	strUUid.erase(strUUid.find_last_not_of(" ") + 1);
+
+	while(true) {
+		pos = 0;
+		if( (pos = strUUid.find("-")) != string::npos)
+			strUUid.replace(pos,1,"");
+		else
+			break;
+	}
+	if (strUUid.size() != 32)
+		return false;
+	return true;
+}
+void string_to_uuid(string strUUid, char *uuid)
+{
+	unsigned int i;
+	char value;
+	memset(uuid, 0, 16);
+	for (i =0; i < strUUid.size(); i++) {
+		value = 0;
+		if ((strUUid[i] >= '0')&&(strUUid[i] <= '9'))
+			value = strUUid[i] - '0';
+		if ((strUUid[i] >= 'a')&&(strUUid[i] <= 'f'))
+			value = strUUid[i] - 'a' + 10;
+		if ((strUUid[i] >= 'A')&&(strUUid[i] <= 'F'))
+			value = strUUid[i] - 'A' + 10;
+		if ((i % 2) == 0)
+			uuid[i / 2] += (value << 4);
+		else
+			uuid[i / 2] += value;
+	}
+	unsigned int *p32;
+	unsigned short *p16;
+	p32 = (unsigned int*)uuid;
+	*p32 = cpu_to_be32(*p32);
+	p16 = (unsigned short *)(uuid + 4);
+	*p16 = cpu_to_be16(*p16);
+	p16 = (unsigned short *)(uuid + 6);
+	*p16 = cpu_to_be16(*p16);
+}
+bool get_uuid_from_parameter(char *pParameter,CONFIG_ITEM_VECTOR &vecItem)
+{
+	stringstream paramStream(pParameter);
+	bool bRet;
+	string strLine,strUUid,strPartInfo,strPartName;
+	string::size_type line_size,pos;
+	STRUCT_CONFIG_ITEM uuid_item;
+	vecItem.clear();
+	while (!paramStream.eof())
+	{
+		getline(paramStream,strLine);
+		line_size = strLine.size();
+		if (line_size==0)
+			continue;
+		if (strLine[line_size-1]=='\r')
+		{
+			strLine = strLine.substr(0,line_size-1);
+		}
+		pos = strLine.find("uuid:");
+		if (pos != string::npos) {
+			strPartInfo = strLine.substr(pos+5);
+			bRet = ParseUuidInfo(strPartInfo, strPartName, strUUid);
+			if (bRet) {
+				strcpy(uuid_item.szItemName, strPartName.c_str());
+				string_to_uuid(strUUid,uuid_item.szItemValue);
+				vecItem.push_back(uuid_item);
+			}
+		}
+	}
+	return (vecItem.size()>0);
+}
+int find_uuid_item(CONFIG_ITEM_VECTOR &vecItems, char *pszName)
+{
+	unsigned int i;
+	for(i = 0; i < vecItems.size(); i++){
+		if (strcasecmp(pszName, vecItems[i].szItemName) == 0){
+			return i;
+		}
+	}
+	return -1;
+}
+
diff --git a/bootable/recovery/rkupdate/RKBoot.cpp b/bootable/recovery/rkupdate/RKBoot.cpp
new file mode 100755
index 0000000000..721bb01f52
--- /dev/null
+++ b/bootable/recovery/rkupdate/RKBoot.cpp
@@ -0,0 +1,304 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "rkupdate/RKBoot.h"
+extern UINT CRC_32(PBYTE pData, UINT ulSize,UINT uiPreviousValue=0);
+
+bool CRKBoot::GetRc4DisableFlag()
+{
+	return m_bRc4Disable;
+}
+bool CRKBoot::GetSignFlag()
+{
+	return m_bSignFlag;
+}
+DWORD CRKBoot::GetVersion()
+{
+	return m_version;
+}
+DWORD CRKBoot::GetMergeVersion()
+{
+	return m_mergeVersion;
+}
+STRUCT_RKTIME CRKBoot::GetReleaseTime()
+{
+	return m_releaseTime;
+}
+ENUM_RKDEVICE_TYPE CRKBoot::GetSupportDevice()
+{
+	return m_supportDevice;
+}
+UCHAR CRKBoot::GetEntry471Count()
+{
+	return m_471Count;
+}
+UCHAR CRKBoot::GetEntry472Count()
+{
+	return m_472Count;
+}
+UCHAR CRKBoot::GetEntryLoaderCount()
+{
+	return m_loaderCount;
+}
+bool CRKBoot::CrcCheck()
+{
+	UINT*pOldCrc,ulNewCrc;
+	pOldCrc = (UINT*)(m_BootData+(m_BootSize-4));
+	ulNewCrc = CRC_32(m_BootData,m_BootSize-4);
+	return (*pOldCrc==ulNewCrc)?true:false;
+}
+bool CRKBoot::SaveEntryFile(ENUM_RKBOOTENTRY type,UCHAR ucIndex,tstring fileName)
+{
+	DWORD dwOffset;
+	UCHAR ucCount,ucSize;
+	switch ( type )
+	{
+	case ENTRY471:
+		dwOffset = m_471Offset;
+		ucCount = m_471Count;
+		ucSize = m_471Size;
+		break;
+	case ENTRY472:
+		dwOffset = m_472Offset;
+		ucCount = m_472Count;
+		ucSize = m_472Size;
+		break;
+	case ENTRYLOADER:
+		dwOffset = m_loaderOffset;
+		ucCount = m_loaderCount;
+		ucSize = m_loaderSize;
+		break;
+	default:
+		return false;
+	}
+	if(ucIndex>=ucCount)
+	{
+		return false;
+	}
+	PSTRUCT_RKBOOT_ENTRY pEntry;
+	pEntry = (PSTRUCT_RKBOOT_ENTRY)(m_BootData+dwOffset+(ucSize*ucIndex));
+	FILE *file=NULL;
+	file = fopen(fileName.c_str(),_T("wb+"));
+	if ( !file )
+	{
+		return false;
+	}
+	fwrite(m_BootData+pEntry->dwDataOffset,1,pEntry->dwDataSize,file);
+	fclose(file);
+	return true;
+}
+bool CRKBoot::GetEntryProperty(ENUM_RKBOOTENTRY type,UCHAR ucIndex,DWORD &dwSize,DWORD &dwDelay,tchar *pName)
+{
+	DWORD dwOffset;
+	UCHAR ucCount,ucSize;
+	switch ( type )
+	{
+	case ENTRY471:
+		dwOffset = m_471Offset;
+		ucCount = m_471Count;
+		ucSize = m_471Size;
+		break;
+	case ENTRY472:
+		dwOffset = m_472Offset;
+		ucCount = m_472Count;
+		ucSize = m_472Size;
+		break;
+	case ENTRYLOADER:
+		dwOffset = m_loaderOffset;
+		ucCount = m_loaderCount;
+		ucSize = m_loaderSize;//LoaderʱѾ512
+		break;
+	default:
+		return false;
+	}
+	if(ucIndex>=ucCount)
+	{
+		return false;
+	}
+	PSTRUCT_RKBOOT_ENTRY pEntry;
+	pEntry = (PSTRUCT_RKBOOT_ENTRY)(m_BootData+dwOffset+(ucSize*ucIndex));
+	dwDelay = pEntry->dwDataDelay;
+	dwSize = pEntry->dwDataSize;
+	if (pName)
+	{	
+		WCHAR_To_char(pEntry->szName,pName,20);
+	}
+	return true;
+}
+bool CRKBoot::GetEntryData(ENUM_RKBOOTENTRY type,UCHAR ucIndex,PBYTE lpData)
+{
+	DWORD dwOffset;
+	UCHAR ucCount,ucSize;
+	switch ( type )
+	{
+	case ENTRY471:
+		dwOffset = m_471Offset;
+		ucCount = m_471Count;
+		ucSize = m_471Size;
+		break;
+	case ENTRY472:
+		dwOffset = m_472Offset;
+		ucCount = m_472Count;
+		ucSize = m_472Size;
+		break;
+	case ENTRYLOADER:
+		dwOffset = m_loaderOffset;
+		ucCount = m_loaderCount;
+		ucSize = m_loaderSize;
+		break;
+	default:
+		return false;
+	}
+	if (ucIndex>=ucCount)
+	{
+		return false;
+	}
+	PSTRUCT_RKBOOT_ENTRY pEntry;
+	pEntry = (PSTRUCT_RKBOOT_ENTRY)(m_BootData+dwOffset+(ucSize*ucIndex));
+	memcpy(lpData,m_BootData+pEntry->dwDataOffset,pEntry->dwDataSize);
+	return true;
+}
+CHAR CRKBoot::GetIndexByName(ENUM_RKBOOTENTRY type,tchar *pName)
+{
+	DWORD dwOffset;
+	UCHAR ucCount,ucSize;
+	switch ( type )
+	{
+	case ENTRY471:
+		dwOffset = m_471Offset;
+		ucCount = m_471Count;
+		ucSize = m_471Size;
+		break;
+	case ENTRY472:
+		dwOffset = m_472Offset;
+		ucCount = m_472Count;
+		ucSize = m_472Size;
+		break;
+	case ENTRYLOADER:
+		dwOffset = m_loaderOffset;
+		ucCount = m_loaderCount;
+		ucSize = m_loaderSize;
+		break;
+	default:
+		return -1;
+	}
+
+	for (UCHAR i=0;i<ucCount;i++)
+	{
+		PSTRUCT_RKBOOT_ENTRY pEntry;
+		pEntry = (PSTRUCT_RKBOOT_ENTRY)(m_BootData+dwOffset+(ucSize*i));
+		
+		char szName[20];
+		WCHAR_To_char(pEntry->szName,szName,20);
+		if (_tcsicmp(pName,szName)==0)
+		{
+			return i;
+		}
+	}
+	return -1;
+}
+CRKBoot::~CRKBoot()
+{
+	if (m_BootData!=NULL)
+	{
+		delete []m_BootData;
+	}
+}
+
+CRKBoot::CRKBoot(PBYTE lpBootData,DWORD dwBootSize,bool &bCheck)
+{
+	Rc4DisableFlag.setContainer(this);
+	Rc4DisableFlag.getter(&CRKBoot::GetRc4DisableFlag);
+	SignFlag.setContainer(this);
+	SignFlag.getter(&CRKBoot::GetSignFlag);
+	Version.setContainer(this);
+	Version.getter(&CRKBoot::GetVersion);
+	MergeVersion.setContainer(this);
+	MergeVersion.getter(&CRKBoot::GetMergeVersion);
+	ReleaseTime.setContainer(this);
+	ReleaseTime.getter(&CRKBoot::GetReleaseTime);
+	SupportDevice.setContainer(this);
+	SupportDevice.getter(&CRKBoot::GetSupportDevice);
+	Entry471Count.setContainer(this);
+	Entry471Count.getter(&CRKBoot::GetEntry471Count);
+	Entry472Count.setContainer(this);
+	Entry472Count.getter(&CRKBoot::GetEntry472Count);
+	EntryLoaderCount.setContainer(this);
+	EntryLoaderCount.getter(&CRKBoot::GetEntryLoaderCount);
+	bCheck = true;
+	if (lpBootData!=NULL)
+	{
+		m_BootData=lpBootData;
+		m_BootSize=dwBootSize;
+		bCheck=CrcCheck();
+		if (!bCheck)
+		{
+			return;
+		}
+		PSTRUCT_RKBOOT_HEAD pBootHead;
+		pBootHead = (PSTRUCT_RKBOOT_HEAD)(m_BootData);
+		if ( pBootHead->uiTag!=0x544F4F42)
+		{
+			bCheck=false;
+			return;
+		}
+		if (pBootHead->ucRc4Flag)
+		{
+			m_bRc4Disable = true;
+		}
+		else
+			m_bRc4Disable = false;
+		if (pBootHead->ucSignFlag=='S')
+		{
+			m_bSignFlag = true;
+		}
+		else
+			m_bSignFlag = false;
+		m_version = pBootHead->dwVersion;
+		m_mergeVersion = pBootHead->dwMergeVersion;
+		m_BootHeadSize = pBootHead->usSize;
+		m_releaseTime.usYear = pBootHead->stReleaseTime.usYear;
+		m_releaseTime.ucMonth = pBootHead->stReleaseTime.ucMonth;
+		m_releaseTime.ucDay = pBootHead->stReleaseTime.ucDay;
+		m_releaseTime.ucHour = pBootHead->stReleaseTime.ucHour;
+		m_releaseTime.ucMinute = pBootHead->stReleaseTime.ucMinute;
+		m_releaseTime.ucSecond = pBootHead->stReleaseTime.ucSecond;
+		m_supportDevice = pBootHead->emSupportChip;
+
+		m_471Offset = pBootHead->dw471EntryOffset;
+		m_471Count = pBootHead->uc471EntryCount;
+		m_471Size = pBootHead->uc471EntrySize;
+
+		m_472Offset = pBootHead->dw472EntryOffset;
+		m_472Count = pBootHead->uc472EntryCount;
+		m_472Size = pBootHead->uc472EntrySize;
+
+		m_loaderOffset = pBootHead->dwLoaderEntryOffset;
+		m_loaderCount = pBootHead->ucLoaderEntryCount;
+		m_loaderSize = pBootHead->ucLoaderEntrySize;
+
+		memcpy(m_crc,m_BootData+(m_BootSize-4),4);
+	}
+	else
+	{
+		bCheck = false;
+		m_BootData=NULL;
+	}
+}
+
+void CRKBoot::WCHAR_To_char(WCHAR *src,char *dst,int len)
+{
+	int i;
+	memset(dst,0,len*sizeof(char));
+	for (i=0;i<len;i++)
+	{
+		memcpy(dst,src,1);
+		src++;
+		dst++;
+	}
+}
+
diff --git a/bootable/recovery/rkupdate/RKComm.cpp b/bootable/recovery/rkupdate/RKComm.cpp
new file mode 100755
index 0000000000..1126c70117
--- /dev/null
+++ b/bootable/recovery/rkupdate/RKComm.cpp
@@ -0,0 +1,641 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "rkupdate/RKComm.h"
+#include "rkupdate/RKLog.h"
+#include "rkupdate/RKAndroidDevice.h"
+#include <cinttypes>
+
+
+CRKComm::CRKComm(CRKLog *pLog)
+{
+	m_log = pLog;
+	m_bEmmc = false;
+	m_hDev = m_hLbaDev = -1;
+}
+CRKComm::~CRKComm()
+{
+}
+
+CRKUsbComm::CRKUsbComm(CRKLog *pLog):CRKComm(pLog)
+{
+	//char bootmode[100];
+	//property_get("ro.bootmode", bootmode, "unknown");
+	//if(!strcmp(bootmode, "emmc"))
+	//	m_bEmmc = true;
+	//else
+	//	m_bEmmc = false;
+    char *emmc_point = getenv(EMMC_POINT_NAME);
+    pLog->Record(_T("INFO:emmc_point-->is %s"),emmc_point);
+    m_hLbaDev = open(emmc_point, O_RDWR|O_SYNC,0);
+    if (m_hLbaDev<0){
+        if (pLog)
+            pLog->Record(_T("INFO:is nand devices..."));
+        m_bEmmc = false;
+    }else{
+        if (pLog)
+            pLog->Record(_T("INFO:is emmc devices..."));
+        m_bEmmc = true;
+        long long  filelen= lseek(m_hLbaDev,0L,SEEK_END);
+	lseek(m_hLbaDev,0L,SEEK_SET);
+	printf("flashSize is %lld\n",filelen);
+        m_FlashSize = filelen;
+        close(m_hLbaDev);
+    }
+
+	if (m_bEmmc)
+	{
+		if (pLog)
+			pLog->Record(_T("INFO:CRKUsbComm-->is emmc."));
+		m_hDev = open(EMMC_DRIVER_DEV_VENDOR,O_RDWR,0);
+		if (m_hDev<0)
+		{
+			if (pLog){
+				pLog->Record(_T("ERROR:CRKUsbComm-->open %s failed,err=%s"),EMMC_DRIVER_DEV_VENDOR, strerror(errno));
+			    pLog->Record(_T("ERROR:CRKUsbComm-->try to read %s."),EMMC_DRIVER_DEV);
+            }
+
+		    m_hDev = open(EMMC_DRIVER_DEV,O_RDWR,0);
+            if(m_hDev<0){
+			    if (pLog){
+				    pLog->Record(_T("ERROR:CRKUsbComm-->open %s failed,err=%s"),EMMC_DRIVER_DEV, strerror(errno));
+				    pLog->Record(_T("ERROR:CRKUsbComm-->please to check drmboot.ko."));
+                }
+            }
+            else
+            {
+                if (pLog)
+                    pLog->Record(_T("INFO:CRKUsbComm EMMC_DRIVER_DEV -->%s=%d"),EMMC_DRIVER_DEV,m_hDev);
+            }
+
+		}
+		else
+		{
+			if (pLog)
+				pLog->Record(_T("INFO:CRKUsbComm EMMC_DRIVER_DEV_VENDOR-->%s=%d"),EMMC_DRIVER_DEV_VENDOR,m_hDev);
+		}
+        //get EMMC_DRIVER_DEV_LBA from
+        m_hLbaDev= open(emmc_point, O_RDWR|O_SYNC,0);
+		if (m_hLbaDev<0)
+		{
+			if (pLog)
+				pLog->Record(_T("ERROR:CRKUsbComm-->open %s failed,err=%d"),emmc_point,errno);
+		}
+		else
+		{
+			if (pLog)
+				pLog->Record(_T("INFO:CRKUsbComm emmc_point-->%s=%d"),emmc_point,m_hLbaDev);
+		}
+
+	}
+	else
+	{
+		if (pLog)
+			pLog->Record(_T("INFO:CRKUsbComm-->is nand."));
+		m_hDev = open(NAND_DRIVER_DEV_VENDOR,O_RDWR,0);
+		if (m_hDev<0)
+		{
+			if (pLog){
+				pLog->Record(_T("ERROR:CRKUsbComm-->open %s failed,err=%d"),NAND_DRIVER_DEV_VENDOR,strerror(errno));
+				pLog->Record(_T("ERROR:CRKUsbComm-->try to read from %s."),NAND_DRIVER_DEV_VENDOR);
+            }
+		    m_hDev = open(NAND_DRIVER_DEV,O_RDWR,0);
+			if (pLog){
+				pLog->Record(_T("ERROR:CRKUsbComm-->open %s failed,err=%d"),NAND_DRIVER_DEV,strerror(errno));
+            }else{
+                if (pLog)
+                    pLog->Record(_T("INFO:CRKUsbComm-->%s=%d"),NAND_DRIVER_DEV,m_hDev);
+            }
+
+		}
+		else
+		{
+			if (pLog)
+				pLog->Record(_T("INFO:CRKUsbComm-->%s=%d"),NAND_DRIVER_DEV_VENDOR,m_hDev);
+		}
+
+//		m_hLbaDev= open(NAND_DRIVER_DEV_LBA,O_RDWR|O_SYNC,0);
+//		if (m_hLbaDev<0)
+//		{
+//			if (pLog)
+//				pLog->Record(_T("ERROR:CRKUsbComm-->open %s failed,err=%d"),NAND_DRIVER_DEV_LBA,errno);
+//		}
+//		else
+//		{
+//			//CtrlNandLbaRead();
+//			CtrlNandLbaWrite();
+//			if (pLog)
+//				pLog->Record(_T("INFO:CRKUsbComm-->%s=%d"),NAND_DRIVER_DEV_LBA,m_hLbaDev);
+//		}
+	}
+
+}
+void CRKUsbComm::RKU_ReopenLBAHandle()
+{
+	if (m_bEmmc)
+		return;
+	if (m_hLbaDev>0)
+	{
+		close(m_hLbaDev);
+		m_hLbaDev = -1;
+	}
+//	if (m_bEmmc)
+//	{
+//		m_hLbaDev= open(EMMC_DRIVER_DEV_LBA,O_RDWR|O_SYNC,0);
+//		if (m_hLbaDev<0)
+//		{
+//			if (m_log)
+//				m_log->Record(_T("ERROR:RKU_ReopenLBAHandle-->open %s failed,err=%d"),EMMC_DRIVER_DEV_LBA,errno);
+//		}
+//		else
+//		{
+//			if (m_log)
+//				m_log->Record(_T("INFO:RKU_ReopenLBAHandle-->%s=%d"),EMMC_DRIVER_DEV_LBA,m_hLbaDev);
+//		}
+
+//	}
+//	else
+//	{
+		m_hLbaDev= open(NAND_DRIVER_DEV_LBA,O_RDWR|O_SYNC,0);
+		if (m_hLbaDev<0)
+		{
+			if (m_log)
+				m_log->Record(_T("ERROR:RKU_ReopenLBAHandle-->open %s failed,err=%d"),NAND_DRIVER_DEV_LBA,errno);
+		}
+		else
+		{
+			if (m_log)
+				m_log->Record(_T("INFO:RKU_ReopenLBAHandle-->%s=%d"),NAND_DRIVER_DEV_LBA,m_hLbaDev);
+		}
+//	}
+
+}
+int CRKUsbComm::RKU_ShowNandLBADevice()
+{
+	if (m_bEmmc)
+		return ERR_SUCCESS;
+	BYTE blockState[64];
+	memset(blockState,0,64);
+	int iRet;
+	iRet = RKU_TestBadBlock(0,0,MAX_TEST_BLOCKS,blockState);
+	if (iRet!=ERR_SUCCESS)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_ShowNandLBADevice-->RKU_TestBadBlock failed,ret=%d"),iRet);
+	}
+	return iRet;
+}
+
+
+CRKUsbComm::~CRKUsbComm()
+{
+	if (m_hDev>0)
+		close(m_hDev);
+	if (m_hLbaDev>0)
+	{
+//		if (!m_bEmmc)
+//		{
+//			CtrlNandLbaRead(false);
+//			CtrlNandLbaWrite(false);
+//		}
+		close(m_hLbaDev);
+	}
+}
+
+int CRKUsbComm::RKU_EraseBlock(BYTE ucFlashCS,DWORD dwPos,DWORD dwCount,BYTE ucEraseType)
+{(void)ucFlashCS; (void)dwPos; (void)dwCount; (void)ucEraseType;
+	return ERR_SUCCESS;
+}
+
+int CRKUsbComm::RKU_EraseBlock_discard(unsigned int dwPos, unsigned int part_size)
+{
+	u64 range[2];
+	int ret;
+	range[0] = (off64_t)dwPos * 512;
+	range[1] = (off64_t)part_size * 512;
+
+	printf("dwPos = %" PRIu64 ", len=%" PRIu64 " \n", range[0], range[1]);
+
+	if (m_hLbaDev < 0)
+		return ERR_DEVICE_OPEN_FAILED;
+
+	ret = ioctl(m_hLbaDev, BLKDISCARD, &range);
+	if (ret < 0) {
+		printf("Discard failed\n");
+		return 1;
+	} else {
+		printf("Wipe used discard success\n");
+		return 0;
+	}
+}
+
+int CRKUsbComm::RKU_ReadChipInfo(BYTE* lpBuffer)
+{(void)lpBuffer;
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_ReadFlashID(BYTE* lpBuffer)
+{(void)lpBuffer;
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_ReadFlashInfo(BYTE* lpBuffer,UINT *puiRead)
+{
+	int ret;
+	if (m_hDev<0)
+		return ERR_DEVICE_OPEN_FAILED;
+	ret = ioctl(m_hDev,GET_FLASH_INFO_IO,lpBuffer);
+	if (ret)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_ReadFlashInfo ioctl failed,err=%d"),errno);
+		return ERR_FAILED;
+	}
+	*puiRead = 11;
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_ReadLBA(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer,BYTE bySubCode)
+{
+    long long ret;
+    long long dwPosBuf;
+	(void)bySubCode;
+	if (m_hLbaDev<0)
+	{
+		if (!m_bEmmc)
+		{
+			m_hLbaDev= open(NAND_DRIVER_DEV_LBA,O_RDWR|O_SYNC,0);
+			if (m_hLbaDev<0)
+			{
+				if (m_log)
+					m_log->Record(_T("ERROR:RKU_ReadLBA-->open %s failed,err=%d"),NAND_DRIVER_DEV_LBA,errno);
+				return ERR_DEVICE_OPEN_FAILED;
+			}
+			else
+			{
+				if (m_log)
+					m_log->Record(_T("INFO:RKU_ReadLBA-->open %s ok,handle=%d"),NAND_DRIVER_DEV_LBA,m_hLbaDev);
+			}
+		}
+		else
+			return ERR_DEVICE_OPEN_FAILED;
+	}
+	if (m_bEmmc && !CRKAndroidDevice::bGptFlag)
+		dwPos += 8192;
+
+    dwPosBuf = dwPos;
+	ret = lseek64(m_hLbaDev,(off64_t)dwPosBuf*512,SEEK_SET);
+	if (ret<0)
+	{
+		if (m_log){
+			m_log->Record(_T("ERROR:RKU_ReadLBA seek failed,err=%d,ret=%lld."),errno,ret);
+            m_log->Record(_T("the dwPosBuf = dwPosBuf*512,dwPosBuf:%lld!"), dwPosBuf*512);
+        }
+		return ERR_FAILED;
+	}
+	ret = read(m_hLbaDev,lpBuffer,dwCount*512);
+	if (ret!=dwCount*512)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_ReadLBA read failed,err=%d"),errno);
+		return ERR_FAILED;
+	}
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_ReadSector(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer)
+{
+	int ret;
+	if (m_hDev<0)
+		return ERR_DEVICE_OPEN_FAILED;
+	DWORD *pOffsetSec=(DWORD *)(lpBuffer);
+	DWORD *pCountSec=(DWORD *)(lpBuffer+4);
+	*pOffsetSec = dwPos;
+	*pCountSec = dwCount;
+	ret = ioctl(m_hDev,READ_SECTOR_IO,lpBuffer);
+	if (ret)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_ReadSector failed,err=%d"),errno);
+		return ERR_FAILED;
+	}
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_ResetDevice(BYTE bySubCode)
+{
+	(void)bySubCode;
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_TestBadBlock(BYTE ucFlashCS,DWORD dwPos,DWORD dwCount,BYTE* lpBuffer)
+{
+	int ret;
+	(void)ucFlashCS; (void)dwPos; (void)dwCount;
+	if (m_hDev<0)
+		return ERR_DEVICE_OPEN_FAILED;
+	ret = ioctl(m_hDev,GET_BAD_BLOCK_IO,lpBuffer);
+	if (ret)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_TestBadBlock failed,err=%d"),errno);
+		return ERR_FAILED;
+	}
+	if (m_log)
+	{
+		string strOutput;
+		m_log->PrintBuffer(strOutput,lpBuffer,64);
+		m_log->Record(_T("INFO:BadBlockState:\r\n%s"),strOutput.c_str());
+	}
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_TestDeviceReady(DWORD *dwTotal,DWORD *dwCurrent,BYTE bySubCode)
+{
+	(void)dwTotal; (void)dwCurrent; (void)bySubCode;
+	return ERR_DEVICE_READY;
+}
+int CRKUsbComm::RKU_WriteLBALoader(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer,BYTE bySubCode)
+{
+	long long ret;
+    long long dwPosBuf;
+	(void)bySubCode;
+	if (m_hLbaDev<0)
+	{
+		printf("---------m_hLbaDev<0\n");
+		if (!m_bEmmc)
+		{
+			printf("---------nand\n");
+			m_hLbaDev= open(NAND_DRIVER_DEV_LBA,O_RDWR|O_SYNC,0);
+			if (m_hLbaDev<0)
+			{
+				if (m_log)
+					m_log->Record(_T("ERROR:RKU_WriteLBA-->open %s failed,err=%d"),NAND_DRIVER_DEV_LBA,errno);
+				return ERR_DEVICE_OPEN_FAILED;
+			}
+			else
+			{
+				if (m_log)
+					m_log->Record(_T("INFO:RKU_WriteLBA-->open %s ok,handle=%d"),NAND_DRIVER_DEV_LBA,m_hLbaDev);
+			}
+		}
+		else
+			return ERR_DEVICE_OPEN_FAILED;
+	}
+	/*
+	if (m_bEmmc && !CRKAndroidDevice::bGptFlag)
+	{
+		m_log->Record(_T("add----8192"));
+		dwPos += 8192;
+	}*/
+	//ǷGPTҪ8192,ǵloaderҪ8192(4M)
+    /*
+	if (m_bEmmc)
+		if(!CRKAndroidDevice::bGptFlag && !CRKAndroidDevice::bOnlyLoader)
+		{
+			m_log->Record(_T("aaaaadd----8192"));
+			dwPos += 8192;
+		}*/
+    dwPosBuf = dwPos;
+	ret = lseek64(m_hLbaDev,(off64_t)dwPosBuf*512,SEEK_SET);
+	if (ret<0)
+	{
+		if (m_log){
+			m_log->Record(_T("ERROR:RKU_WriteLBA seek failed,err=%d,ret:%lld"),errno, ret);
+            m_log->Record(_T("ERROR:the dwPosBuf = dwPosBuf*512,dwPosBuf:%lld!"), dwPosBuf*512);
+        }
+		m_log->Record(_T("ERROR:RKU_WriteLBA seek failed,err=%d,ret:%lld"),errno, ret);
+        m_log->Record(_T("ERROR:the dwPosBuf = dwPosBuf*512,dwPosBuf:%lld!"), dwPosBuf*512);
+		return ERR_FAILED;
+
+	}
+	ret = write(m_hLbaDev,lpBuffer,dwCount*512);
+	if (ret!=dwCount*512)
+	{
+		sleep(1);
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_WriteLBA write failed,err=%d"),errno);
+		return ERR_FAILED;
+	}
+//	ret = fsync(m_hLbaDev);
+//	if (ret!=0)
+//	{
+//		if (m_log)
+//			m_log->Record(_T("ERROR:RKU_WriteLBA fsync failed,err=%d"),errno);
+//	}
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_WriteLBA(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer,BYTE bySubCode)
+{
+    long long ret;
+    long long dwPosBuf;
+	(void)bySubCode;
+        if (m_hLbaDev<0)
+        {
+                printf("---------m_hLbaDev<0\n");
+                if (!m_bEmmc)
+                {
+                        printf("---------nand\n");
+                        m_hLbaDev= open(NAND_DRIVER_DEV_LBA,O_RDWR|O_SYNC,0);
+                        if (m_hLbaDev<0)
+                        {
+                                if (m_log)
+                                        m_log->Record(_T("ERROR:RKU_WriteLBA-->open %s failed,err=%d"),NAND_DRIVER_DEV_LBA,errno);
+                                return ERR_DEVICE_OPEN_FAILED;
+                        }
+                        else
+                        {
+                                if (m_log)
+                                        m_log->Record(_T("INFO:RKU_WriteLBA-->open %s ok,handle=%d"),NAND_DRIVER_DEV_LBA,m_hLbaDev);
+                        }
+                }
+                else
+                        return ERR_DEVICE_OPEN_FAILED;
+        }
+        if (m_bEmmc && !CRKAndroidDevice::bGptFlag)
+        {
+                m_log->Record(_T("add----8192"));
+                dwPos += 8192;
+        }
+        //ǷGPTҪ8192,ǵloaderҪ8192(4M)
+    /*
+        if (m_bEmmc)
+                if(!CRKAndroidDevice::bGptFlag && !CRKAndroidDevice::bOnlyLoader)
+                {
+                        m_log->Record(_T("aaaaadd----8192"));
+                        dwPos += 8192;
+                }*/
+    dwPosBuf = dwPos;
+        ret = lseek64(m_hLbaDev,(off64_t)dwPosBuf*512,SEEK_SET);
+        if (ret<0)
+        {
+                if (m_log){
+                        m_log->Record(_T("ERROR:RKU_WriteLBA seek failed,err=%d,ret:%lld"),errno, ret);
+            m_log->Record(_T("ERROR:the dwPosBuf = dwPosBuf*512,dwPosBuf:%lld!"), dwPosBuf*512);
+        }
+                m_log->Record(_T("ERROR:RKU_WriteLBA seek failed,err=%d,ret:%lld"),errno, ret);
+        m_log->Record(_T("ERROR:the dwPosBuf = dwPosBuf*512,dwPosBuf:%lld!"), dwPosBuf*512);
+                return ERR_FAILED;
+
+        }
+        ret = write(m_hLbaDev,lpBuffer,dwCount*512);
+        if (ret!=dwCount*512)
+        {
+                sleep(1);
+                if (m_log)
+                        m_log->Record(_T("ERROR:RKU_WriteLBA write failed,err=%d"),errno);
+                return ERR_FAILED;
+        }
+//      ret = fsync(m_hLbaDev);
+//      if (ret!=0)
+//      {
+//              if (m_log)
+//                      m_log->Record(_T("ERROR:RKU_WriteLBA fsync failed,err=%d"),errno);
+//      }
+        return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_WriteSector(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer)
+{
+	int ret;
+	if (m_hDev<0)
+		return ERR_DEVICE_OPEN_FAILED;
+	DWORD *pOffset=(DWORD *)(lpBuffer);
+	DWORD *pCount=(DWORD *)(lpBuffer+4);
+	*pOffset = dwPos;
+	*pCount = dwCount;
+	ret = ioctl(m_hDev,WRITE_SECTOR_IO,lpBuffer);
+	if (ret)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_WriteSector failed,err=%d"),errno);
+		return ERR_FAILED;
+	}
+	return ERR_SUCCESS;
+}
+
+int CRKUsbComm::RKU_EndWriteSector(BYTE* lpBuffer)
+{
+	int ret;
+	if (m_hDev<0)
+		return ERR_DEVICE_OPEN_FAILED;
+	ret = ioctl(m_hDev,END_WRITE_SECTOR_IO,lpBuffer);
+	if (ret)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_EndWriteSector failed,err=%d"),errno);
+		return ERR_FAILED;
+	}
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_GetLockFlag(BYTE* lpBuffer)
+{
+	int ret;
+	if (m_hDev<0)
+		return ERR_DEVICE_OPEN_FAILED;
+	ret = ioctl(m_hDev,GET_LOCK_FLAG_IO,lpBuffer);
+	if (ret)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_GetLockFlag failed,err=%d"),errno);
+		return ERR_FAILED;
+	}
+	DWORD *pFlag=(DWORD *)lpBuffer;
+	if (m_log)
+	{
+		m_log->Record(_T("INFO:LockFlag:0x%08x"),*pFlag);
+	}
+	return ERR_SUCCESS;
+}
+int CRKUsbComm::RKU_GetPublicKey(BYTE* lpBuffer)
+{
+	int ret;
+	if (m_hDev<0)
+		return ERR_DEVICE_OPEN_FAILED;
+	ret = ioctl(m_hDev,GET_PUBLIC_KEY_IO,lpBuffer);
+	if (ret)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:RKU_GetPublicKey failed,err=%d"),errno);
+		return ERR_FAILED;
+	}
+	return ERR_SUCCESS;
+}
+bool CRKUsbComm::CtrlNandLbaWrite(bool bEnable)
+{
+	int ret;
+	if (m_bEmmc)
+		return false;
+	if (m_hLbaDev<0)
+		return false;
+	if (bEnable)
+		ret = ioctl(m_hLbaDev,ENABLE_NAND_LBA_WRITE_IO);
+	else
+		ret = ioctl(m_hLbaDev,DISABLE_NAND_LBA_WRITE_IO);
+	if (ret)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:CtrlNandLbaWrite failed,enable=%d,err=%d"),bEnable,errno);
+		return false;
+	}
+
+	return true;
+}
+bool CRKUsbComm::CtrlNandLbaRead(bool bEnable)
+{
+	int ret;
+	if (m_bEmmc)
+		return false;
+	if (m_hLbaDev<0)
+		return false;
+	if (bEnable)
+		ret = ioctl(m_hLbaDev,ENABLE_NAND_LBA_READ_IO);
+	else
+		ret = ioctl(m_hLbaDev,DISABLE_NAND_LBA_READ_IO);
+	if (ret)
+	{
+		if (m_log)
+			m_log->Record(_T("ERROR:CtrlNandLbaRead failed,enable=%d,err=%d"),bEnable,errno);
+		return false;
+	}
+	return true;
+}
+
+long long CRKUsbComm::RKU_GetFlashSize()
+{
+    long long length;
+
+	if (m_hLbaDev<0)
+	{
+		if (!m_bEmmc)
+		{
+			m_hLbaDev= open(NAND_DRIVER_DEV_LBA,O_RDWR|O_SYNC,0);
+			if (m_hLbaDev<0)
+			{
+				if (m_log)
+					m_log->Record(_T("ERROR:RKU_ReadLBA-->open %s failed,err=%d"),NAND_DRIVER_DEV_LBA,errno);
+				return ERR_DEVICE_OPEN_FAILED;
+			}
+			else
+			{
+				if (m_log)
+					m_log->Record(_T("INFO:RKU_ReadLBA-->open %s ok,handle=%d"),NAND_DRIVER_DEV_LBA,m_hLbaDev);
+			}
+		}
+		else
+			return ERR_DEVICE_OPEN_FAILED;
+	}
+
+
+
+
+	length = lseek64(m_hLbaDev,(off64_t)0,SEEK_END);
+	if (length < 0)
+	{
+		if (m_log){
+			m_log->Record(_T("RKU_GetFlashSize get flash size failed"));
+        }
+		return 0;
+	}
+
+	return (length/512);
+}
+
+
+
diff --git a/bootable/recovery/rkupdate/RKDevice.cpp b/bootable/recovery/rkupdate/RKDevice.cpp
new file mode 100755
index 0000000000..9a19a793a4
--- /dev/null
+++ b/bootable/recovery/rkupdate/RKDevice.cpp
@@ -0,0 +1,675 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include "rkupdate/RKDevice.h"
+
+const tchar* szManufName[] =
+{
+	_T("SAMSUNG"),
+	_T("TOSHIBA"),
+	_T("HYNIX"),
+	_T("INFINEON"),
+	_T("MICRON"),
+	_T("RENESAS"),
+	_T("ST"),
+	_T("INTEL")
+};
+
+void CRKDevice::SetPrepareEraseFlag(bool value)
+{
+	m_bEraseInPrepare = value;
+}
+
+void CRKDevice::SetWorkFlow(UINT value)
+{
+	m_uiWorkFlow = value;
+}
+
+void CRKDevice::SetUid(PBYTE value)
+{
+	if (value)
+	{
+		if (!m_uid)
+		{
+			m_uid = new BYTE[RKDEVICE_UID_LEN];
+			memset(m_uid,0,RKDEVICE_UID_LEN);
+		}
+		memcpy(m_uid,value,RKDEVICE_UID_LEN);
+	}
+	else
+	{
+		if (m_uid)
+		{
+			delete []m_uid;
+		}
+		m_uid = value;
+	}
+	
+}
+void CRKDevice::SetMiscModifyFlag(ENUM_MISC_MODIFY_FLAG value)
+{
+	m_emMiscModifyFlag = value;
+}
+
+void CRKDevice::SetOsType(ENUM_OS_TYPE value)
+{
+	m_os = value;
+}
+ENUM_OS_TYPE CRKDevice::GetOsType()
+{
+	return m_os;
+}
+
+CRKLog* CRKDevice::GetLogObjectPointer()
+{
+	return m_pLog;
+}
+
+CRKComm* CRKDevice::GetCommObjectPointer()
+{
+	return m_pComm;
+}
+
+CRKDevice::CRKDevice(STRUCT_RKDEVICE_DESC &device)
+{
+	OsType.setContainer(this);
+    	OsType.getter(&CRKDevice::GetOsType);
+ 	OsType.setter(&CRKDevice::SetOsType);
+
+	Uid.setContainer(this);
+	Uid.setter(&CRKDevice::SetUid);
+	
+	PrepareEraseFlag.setContainer(this);
+ 	PrepareEraseFlag.setter(&CRKDevice::SetPrepareEraseFlag);
+	
+	WorkFlow.setContainer(this);
+ 	WorkFlow.setter(&CRKDevice::SetWorkFlow);
+	
+	MiscModifyFlag.setContainer(this);
+ 	MiscModifyFlag.setter(&CRKDevice::SetMiscModifyFlag);
+	
+	LogObjectPointer.setContainer(this);
+    	LogObjectPointer.getter(&CRKDevice::GetLogObjectPointer);
+	
+	CommObjectPointer.setContainer(this);
+    	CommObjectPointer.getter(&CRKDevice::GetCommObjectPointer);
+	
+	m_usb = device.emUsbType;
+	m_device = device.emDeviceType;
+	m_bcdUsb = device.usbcdUsb;
+
+
+	memset(m_idBlockOffset,0,sizeof(DWORD)*5);
+	memset(m_flashInfo.blockState,0,IDBLOCK_TOP);
+	m_flashInfo.usPhyBlokcPerIDB = 1;
+	m_flashInfo.uiSecNumPerIDB = 0;
+	m_chipData = NULL;
+	m_pImage = NULL;
+	m_pLog = NULL;
+	m_pComm = NULL;
+	m_customData = NULL;
+	m_customDataSize = 0;
+	m_customDataOffset = 0;
+	m_sn = NULL;
+	m_snSize = 0;
+	m_mac = NULL;
+	m_imei = NULL;
+	m_blueTooth = NULL;
+	m_uid = NULL;
+	m_sysDiskSize = 0;
+	m_cfgDiskSize = 0;
+	m_bGetNewDiskSizeFlag = true;
+	m_pBlockState = NULL;
+	m_bWriteBack = false;
+	m_pFlashInfoData = NULL;
+	m_usFlashInfoDataLen = 0;
+	m_usFlashInfoDataOffset = 0;
+	memset(m_backupBuffer,0,SECTOR_SIZE);
+	memset(m_backupBuffer+SECTOR_SIZE,0xFF,SPARE_SIZE);
+	m_bUidWriteOK = false;
+	m_remallocDisk = false;
+	m_emMiscModifyFlag = MISC_MODIFY_NONE;
+	m_bQuickCheckMode = false;
+	m_bExistSector3Crc = false;
+	m_bEmmc = false;
+	m_usSector3Crc = 0;
+	m_usWriteBackCrc = 0;
+	m_usWriteBackCustomDataOffset = 0;
+	m_usWriteBackCustomDataSize = 0;
+}
+CRKDevice::~CRKDevice()
+{
+	if (m_pComm)
+	{
+		delete m_pComm;
+		m_pComm = NULL;
+	}
+	if (m_chipData)
+	{
+		delete []m_chipData;
+		m_chipData = NULL;
+	}
+	if (m_customData)
+	{
+		delete []m_customData;
+		m_customData = NULL;
+	}
+	if (m_sn)
+	{
+		delete []m_sn;
+		m_sn = NULL;
+	}
+	if (m_mac)
+	{
+		delete []m_mac;
+		m_mac = NULL;
+	}
+	if (m_imei)
+	{
+		delete []m_imei;
+		m_imei = NULL;
+	}
+	if (m_blueTooth)
+	{
+		delete []m_blueTooth;
+		m_blueTooth = NULL;
+	}
+	if (m_uid)
+	{
+		delete []m_uid;
+		m_uid = NULL;
+	}
+
+	if (m_pFlashInfoData)
+	{
+		delete []m_pFlashInfoData;
+		m_pFlashInfoData = NULL;
+	}
+	
+}
+bool CRKDevice::SetObject(CRKImage *pImage,CRKComm *pComm,CRKLog *pLog)
+{
+/*pImageΪ,ɲù̼Ĳ*/
+	if (!pComm)
+	{
+		return false;
+	}
+	m_pImage = pImage;
+	m_pComm = pComm;
+	m_pLog = pLog;
+	if (m_pImage)
+	{
+		m_os = m_pImage->OsType;
+	}
+	else
+		m_os = RK_OS;
+	return true;
+}
+int CRKDevice::EraseEmmcBlock(UCHAR ucFlashCS,DWORD dwPos,DWORD dwCount)
+{
+	int sectorOffset,nWrittenBlcok,iRet;
+	BYTE emptyData[4*(SECTOR_SIZE+SPARE_SIZE)];
+	memset(emptyData,0xff,4*(SECTOR_SIZE+SPARE_SIZE));
+	nWrittenBlcok = 0;
+	while (dwCount>0)
+	{
+		sectorOffset = (ucFlashCS*m_flashInfo.uiBlockNum+dwPos+nWrittenBlcok)*m_flashInfo.uiSectorPerBlock;
+		iRet = m_pComm->RKU_WriteSector(sectorOffset,4,emptyData);
+		if ((iRet!=ERR_SUCCESS)&&(iRet!=ERR_FOUND_BAD_BLOCK))
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:EraseEmmcBlock-->RKU_WriteSector failed,RetCode(%d)"),iRet);
+			}
+			return iRet;
+		}
+		dwCount--;
+		nWrittenBlcok++;
+	}
+	return ERR_SUCCESS;
+}
+bool CRKDevice::GetFlashInfo()
+{
+	STRUCT_FLASHINFO_CMD info;
+	//BYTE flashID[5];
+	int iRet;
+	UINT uiRead;
+	iRet = m_pComm->RKU_ReadFlashInfo((PBYTE)&info,&uiRead);
+	if( ERR_SUCCESS == iRet )
+	{
+		if (m_pLog)
+		{
+			tstring strFlashInfo;
+			m_pLog->PrintBuffer(strFlashInfo,(PBYTE)&info,11);
+			m_pLog->Record(_T("INFO:FlashInfo:%s"),strFlashInfo.c_str());
+		}
+		if ((info.usBlockSize==0)||(info.bPageSize==0))
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:GetFlashInfo-->RKU_ReadFlashInfo failed,pagesize or blocksize is zero"));
+			}
+			return false;
+		}
+		if ((info.bManufCode>=0)&&(info.bManufCode<=7))
+		{
+			_tcscpy(m_flashInfo.szManufacturerName,szManufName[info.bManufCode]);
+		}
+		else
+		{
+			_tcscpy(m_flashInfo.szManufacturerName,_T("UNKNOWN"));
+		}
+		
+		m_flashInfo.uiFlashSize = m_pComm->RKU_GetFlashSize()/2/1024;//MB
+		//m_flashInfo.uiFlashSize = info.uiFlashSize/2/1024;//MB
+		m_pLog->Record(_T("INFO:m_flashInfo.uiFlashSize=%u MB, RKU_GetFlashSize=%lld sectors"),m_flashInfo.uiFlashSize, m_pComm->RKU_GetFlashSize());
+		m_flashInfo.uiPageSize = info.bPageSize/2;//KB
+		m_flashInfo.usBlockSize = info.usBlockSize/2;//KB
+		m_flashInfo.bECCBits = info.bECCBits;
+		m_flashInfo.bAccessTime = info.bAccessTime;
+		m_flashInfo.uiBlockNum = m_flashInfo.uiFlashSize*1024/m_flashInfo.usBlockSize;
+		m_flashInfo.uiSectorPerBlock = info.usBlockSize;
+		m_flashInfo.bFlashCS = info.bFlashCS;
+		m_flashInfo.usValidSecPerBlock = (info.usBlockSize/info.bPageSize)*4;
+		if (m_pFlashInfoData)
+		{
+			delete []m_pFlashInfoData;
+			m_pFlashInfoData = NULL;
+		}
+		m_usFlashInfoDataLen = BYTE2SECTOR(uiRead);
+		m_pFlashInfoData = new BYTE[SECTOR_SIZE*m_usFlashInfoDataLen];
+		memset(m_pFlashInfoData,0,SECTOR_SIZE*m_usFlashInfoDataLen);
+		memcpy(m_pFlashInfoData,(PBYTE)&info,uiRead);
+		
+	}
+	else
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:GetFlashInfo-->RKU_ReadFlashInfo failed,RetCode(%d)"),iRet);
+		}
+		return false;
+	}
+	
+	return true;
+}
+bool CRKDevice::BuildBlockStateMap(BYTE bFlashCS)
+{
+	BYTE blockState[64];
+	int iRet,i,j ;
+	memset(blockState, 0, 64);
+	iRet = m_pComm->RKU_TestBadBlock( bFlashCS, 0, MAX_TEST_BLOCKS, blockState);
+	if(ERR_SUCCESS == iRet)//޻
+	{
+//		return true;
+//	}
+//	else if(ERR_FOUND_BAD_BLOCK == iRet)//л
+//	{
+		for(i=0; i<64; i++)
+		{
+			for(j=0; j<8; j++)
+			{
+				if( blockState[i] & (1<<j) )
+					m_flashInfo.blockState[i*8+j]=1;
+				if (i*8+j>(IDBLOCK_TOP-2))
+				{
+					break;
+				}
+			}
+			if (j<8)
+			{
+				break;
+			}
+		}
+		return true;
+	}
+	else//ʧ
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:BuildBlockStateMap-->RKU_TestBadBlock failed,RetCode(%d)"),iRet);
+		}
+		return false;
+	}
+}
+int CRKDevice::ReadMutilSector(DWORD dwPos,DWORD dwCount,PBYTE lpBuffer)
+{
+	DWORD dwReadSector=0,dwMaxReadWriteOnce;
+	int iUsedSecCount,iUsedBlockCount,iValidSecCount;
+	int iRet=0,iCurPos;
+	iUsedBlockCount = dwPos / m_flashInfo.uiSectorPerBlock;
+	iUsedSecCount = dwPos - (iUsedBlockCount*m_flashInfo.uiSectorPerBlock);
+	iValidSecCount = m_flashInfo.usValidSecPerBlock-iUsedSecCount;
+	
+	dwMaxReadWriteOnce = MAX_WRITE_SECTOR;
+		
+	while(dwCount>0)
+	{
+		dwReadSector = (dwCount>=dwMaxReadWriteOnce) ? dwMaxReadWriteOnce : dwCount;
+		if (dwReadSector>iValidSecCount)
+		{
+			dwReadSector = iValidSecCount;
+		}
+		iCurPos = iUsedBlockCount*m_flashInfo.uiSectorPerBlock+(m_flashInfo.usValidSecPerBlock-iValidSecCount);
+		iRet = m_pComm->RKU_ReadSector(iCurPos, dwReadSector,lpBuffer);
+		if( iRet!=ERR_SUCCESS )
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:ReadMutilSector-->RKU_ReadSector failed,RetCode(%d)"),iRet);
+			}
+			break;
+		}
+		
+		dwCount -= dwReadSector;
+		iUsedSecCount += dwReadSector;
+		iValidSecCount -= dwReadSector;
+		if (iValidSecCount<=0)
+		{
+			iUsedBlockCount++;
+			iValidSecCount = m_flashInfo.usValidSecPerBlock;
+		}
+		lpBuffer += dwReadSector * 512;
+	}
+	return iRet;
+}
+bool CRKDevice::EraseMutilBlock(BYTE bFlashCS,DWORD dwPos,DWORD dwCount,bool bForce)
+{
+	DWORD dwTimes = 0;
+	UCHAR eraseType;
+	eraseType = bForce?ERASE_FORCE:ERASE_NORMAL;
+	int iRet;
+	while(dwCount >= MAX_ERASE_BLOCKS)
+	{
+		iRet = m_pComm->RKU_EraseBlock( bFlashCS, dwPos+dwTimes*MAX_ERASE_BLOCKS, MAX_ERASE_BLOCKS, eraseType);
+		if(ERR_FOUND_BAD_BLOCK == iRet)
+		{
+			dwCount -= MAX_ERASE_BLOCKS;
+			++dwTimes;
+		}else if(ERR_SUCCESS == iRet)
+		{
+			dwCount -= MAX_ERASE_BLOCKS;
+			++dwTimes;
+		}
+		else
+		{//ʧ
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:EraseMutilBlock-->RKU_EraseBlock failed,RetCode(%d)"),iRet);
+			}
+			return false;
+		}
+	}
+	if(dwCount>0)
+	{
+		iRet = m_pComm->RKU_EraseBlock( bFlashCS, dwPos+dwTimes*MAX_ERASE_BLOCKS, dwCount, eraseType);
+		if(ERR_SUCCESS == iRet)
+		{
+			dwCount = 0;
+		}
+		else if(ERR_FOUND_BAD_BLOCK == iRet)
+		{
+			dwCount = 0;
+		}
+		else
+		{//ʧ
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:EraseMutilBlock-->RKU_EraseBlock failed,RetCode(%d)"),iRet);
+			}
+			return false;
+		}
+	}
+	return true;
+}
+
+
+bool CRKDevice::CheckChip()
+{
+	int iRet;
+	BYTE bChipInfo[CHIPINFO_LEN];
+	ENUM_RKDEVICE_TYPE curDeviceType=RKNONE_DEVICE;
+	memset(bChipInfo,0,CHIPINFO_LEN);
+	iRet = m_pComm->RKU_ReadChipInfo(bChipInfo);
+	if (iRet==ERR_SUCCESS)
+	{
+		if (!m_chipData)
+		{
+			m_chipData = new BYTE[CHIPINFO_LEN];
+		}
+		memset(m_chipData,0,CHIPINFO_LEN);
+		memcpy(m_chipData,bChipInfo,CHIPINFO_LEN);
+		DWORD *pValue;
+		pValue = (DWORD *)(&bChipInfo[0]);
+		
+		if ((ENUM_RKDEVICE_TYPE)(*pValue)==m_device)
+		{
+			return true;
+		}
+		
+		if (*pValue==0x524B3237)
+		{
+			curDeviceType = RK27_DEVICE;
+		}
+		else if (*pValue==0x32373341)
+		{
+			curDeviceType = RKCAYMAN_DEVICE;
+		}
+		else if (*pValue==0x524B3238)
+		{
+			curDeviceType = RK28_DEVICE;
+		}
+		else if (*pValue==0x32383158)
+		{
+			curDeviceType = RK281X_DEVICE;
+		}
+		else if (*pValue==0x32383242)
+		{
+			curDeviceType = RKPANDA_DEVICE;
+		}
+		else if (*pValue==0x32393058)
+		{
+			curDeviceType = RK29_DEVICE;
+		}
+		else if (*pValue==0x32393258)
+		{
+			curDeviceType = RK292X_DEVICE;
+		}
+		else if (*pValue==0x33303041)
+		{
+			curDeviceType = RK30_DEVICE;
+		}
+		else if (*pValue==0x33313041)
+		{
+			curDeviceType = RK30B_DEVICE;
+		}
+		else if (*pValue==0x33313042)
+		{
+			curDeviceType = RK31_DEVICE;
+		}
+		else if (*pValue==0x33323041)
+		{
+			curDeviceType = RK32_DEVICE;
+		}
+		else if (*pValue==0x32363243)
+		{
+			curDeviceType = RKSMART_DEVICE;
+		}
+		else if (*pValue==0x6E616E6F)
+		{
+			curDeviceType = RKNANO_DEVICE;
+		}
+		else if (*pValue==0x4E4F5243)
+		{
+			curDeviceType = RKCROWN_DEVICE;
+		}
+
+		if (curDeviceType==m_device)
+		{
+			return true;
+		}
+		else
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:CheckChip-->Chip is not match,firmware(0x%x),device(0x%x)"),m_device,*pValue);
+			}
+			return false;
+		}
+	}
+	else
+	{
+		if (m_pLog)
+		{
+			m_pLog->Record(_T("ERROR:CheckChip-->RKU_ReadChipInfo failed,RetCode(%d)"),iRet);
+		}
+		return false;
+	}
+}
+CHAR CRKDevice::FindValidBlocks(char bBegin, char bLen)
+{
+	char bCount = 0;
+	char bIndex = bBegin;
+	while(bBegin < IDBLOCK_TOP)
+	{
+		if(0 == m_flashInfo.blockState[(int)bBegin++])
+			++bCount;
+		else
+		{
+			bCount = 0;
+			bIndex = bBegin;
+		}
+		if(bCount >= bLen)
+			break;
+	}
+	if(bBegin >= IDBLOCK_TOP)
+		bIndex = -1;
+	
+	return bIndex;
+}
+USHORT UshortToBCD(USHORT num)
+{
+	USHORT bcd = 0;
+	bcd = (num % 10) | ( ((num/10 )% 10)<< 4 )|( ((num/100) %10) << 8)|( ((num/1000) %10) << 12);
+	return bcd;
+}
+BYTE   ByteToBCD(BYTE num)
+{
+	BYTE bcd = 0;
+	bcd = (num % 10) | ( ((num/10 )% 10)<< 4 );
+	return bcd;
+}
+BYTE CRKDevice::RandomByte(BYTE bLowLimit,BYTE bHighLimit)
+{
+	BYTE k;
+	double d;
+	
+	d = (double)rand() / ((double)RAND_MAX+1);
+	k = (BYTE)( d*(bHighLimit-bLowLimit+1) );
+	return (bLowLimit+k);
+}
+bool CRKDevice::CheckCrc16(PBYTE pCheckData,USHORT usDataLength,USHORT usOldCrc)
+{
+	USHORT usNewCrc;
+	usNewCrc = CRC_16(pCheckData,usDataLength);
+	return (usNewCrc==usOldCrc)?true:false;
+}
+bool CRKDevice::CheckUid(BYTE uidSize,BYTE *pUid)
+{
+	if (uidSize!=RKDEVICE_UID_LEN)
+	{
+		return false;
+	}
+	USHORT oldCrc,newCrc;
+	oldCrc = *(USHORT *)(pUid+RKDEVICE_UID_LEN-2);
+	newCrc = CRC_CCITT(pUid,RKDEVICE_UID_LEN-2);
+	if (oldCrc!=newCrc)
+	{
+		return false;
+	}
+	return true;
+}
+
+bool CRKDevice::GetIDBData(UINT uiIDBCount,PBYTE lpBuf,UINT uiSecCount)
+{
+	PBYTE pIDB;
+	pIDB = new BYTE[uiSecCount*512];
+	memset( pIDB, 0, uiSecCount*512 );
+	int i,j,iResult;
+	int nSrc=-1,nDst=-1;
+	bool bRet;
+	for (i=0;i<uiIDBCount;i++)
+	{
+		if (nSrc==-1)
+		{
+			iResult = ReadMutilSector( m_flashInfo.uiSectorPerBlock*m_idBlockOffset[i], uiSecCount, lpBuf );
+			if (iResult!=ERR_SUCCESS)
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("ERROR:GetIDBData-->RKU_ReadSector failed,RetCode(%d)"),iResult);
+				}
+				continue;
+			}
+			nSrc = i;
+			continue;
+		}
+		if (nDst==-1)
+		{
+			iResult = ReadMutilSector( m_flashInfo.uiSectorPerBlock*m_idBlockOffset[i], uiSecCount, pIDB );
+			if (iResult!=ERR_SUCCESS)
+			{
+				if (m_pLog)
+				{
+					m_pLog->Record(_T("ERROR:GetIDBData-->RKU_ReadSector failed,RetCode(%d)"),iResult);
+				}
+				continue;
+			}
+			nDst = i;
+		}
+		
+		bRet = true;
+		
+		for(j=0;j<uiSecCount;j++)
+		{
+			bRet = memcmp(lpBuf+512*j,pIDB+512*j,512)==0;
+			if (!bRet)
+				break;
+		}
+		
+		if (bRet)
+		{//ͬ
+			delete []pIDB;
+			pIDB = NULL;
+			return true;
+		}
+		else
+		{
+			if (m_pLog)
+			{
+				m_pLog->Record(_T("ERROR:GetIDBData-->memcmp failed,src(%d),Dst(%d)"),nSrc,nDst);
+			}
+			memcpy(lpBuf,pIDB,512*uiSecCount);
+			nSrc = nDst;
+			nDst = -1;
+			continue;
+		}
+	}
+	delete []pIDB;
+	pIDB = NULL;
+	if (nSrc!=-1)
+	{
+		return true;
+	}
+	return false;
+}
+
+bool CRKDevice::GetWriteBackData(UINT uiIDBCount,PBYTE lpBuf)
+{
+	bool bRet;
+	bRet = GetIDBData(uiIDBCount,lpBuf,4);
+	return bRet;
+}
\ No newline at end of file
diff --git a/bootable/recovery/rkupdate/RKImage.cpp b/bootable/recovery/rkupdate/RKImage.cpp
new file mode 100755
index 0000000000..5522411134
--- /dev/null
+++ b/bootable/recovery/rkupdate/RKImage.cpp
@@ -0,0 +1,344 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "rkupdate/RKImage.h"
+#include "rkupdate/MD5Checksum.h"
+
+DWORD CRKImage::GetVersion()
+{
+	return m_version;
+}
+DWORD CRKImage::GetMergeVersion()
+{
+	return m_mergeVersion;
+}
+STRUCT_RKTIME CRKImage::GetReleaseTime()
+{
+	return m_releaseTime;
+}
+ENUM_RKDEVICE_TYPE CRKImage::GetSupportDevice()
+{
+	return m_supportDevice;
+}
+ENUM_OS_TYPE CRKImage::GetOsType()
+{
+	UINT *pOsType;
+	pOsType = (UINT *)&m_reserved[4];
+	return (ENUM_OS_TYPE)*pOsType;
+}
+USHORT CRKImage::GetBackupSize()
+{
+	USHORT *pBackupSize;
+	pBackupSize = (USHORT *)&m_reserved[12];
+	return *pBackupSize;
+}
+DWORD CRKImage::GetBootOffset()
+{
+	return m_bootOffset;
+}
+DWORD CRKImage::GetBootSize()
+{
+	return m_bootSize;
+}
+DWORD CRKImage::GetFWOffset()
+{
+	return m_fwOffset;
+}
+long long CRKImage::GetFWSize()
+{
+	return m_fwSize;
+}
+bool CRKImage::Md5Check(long long nCheckSize)
+{
+	printf("In Md5Check\n");
+	tstring strNewMd5=_T("");
+	strNewMd5 = CMD5Checksum::GetMD5(m_pFile,nCheckSize);
+	if (strNewMd5.size()==32)
+	{
+		BYTE newMd5[32];
+		memcpy(newMd5,strNewMd5.c_str(),32);
+		int i,j;
+		printf("New Md5:\n");
+		for(i=0;i<2;i++)
+		{
+			for(j=0;j<16;j++)
+				printf("%02X ",newMd5[i*16+j]);
+			printf("\r\n");
+		}
+		printf("Old Md5:\n");
+		for(i=0;i<2;i++)
+		{
+			for(j=0;j<16;j++)
+				printf("%02X ",m_md5[i*16+j]);
+			printf("\r\n");
+		}
+		if ( memcmp(newMd5,m_md5,32)!=0 )
+			return false;
+		else
+			return true;
+	}
+	else
+		return false;
+	
+}
+bool CRKImage::SaveBootFile(tstring filename)
+{
+	FILE *file=NULL;
+	file = fopen(filename.c_str(),_T("wb+"));
+	if ( !file)
+	{
+		return false;
+	}
+	BYTE buffer[1024];
+	DWORD dwBufferSize=1024;
+	DWORD dwBootSize=m_bootSize;
+	DWORD dwReadSize;
+	fseek(m_pFile,m_bootOffset,SEEK_SET);
+	do 
+	{
+		dwReadSize = (dwBootSize>=1024)?dwBufferSize:dwBootSize;
+		fread(buffer,1,dwReadSize,m_pFile);
+		fwrite(buffer,1,dwReadSize,file);
+		dwBootSize -= dwReadSize;
+	} while (dwBootSize>0);
+	fclose(file);
+	return true;
+}
+bool CRKImage::SaveFWFile(tstring filename)
+{
+	FILE *file=NULL;
+	file = fopen(filename.c_str(),_T("wb+"));
+	if ( !file )
+	{
+		return false;
+	}
+	BYTE buffer[1024];
+	DWORD dwBufferSize=1024;
+	long long dwFWSize=m_fwSize;
+	DWORD dwReadSize;
+	fseeko(m_pFile,m_fwOffset,SEEK_SET);
+	do 
+	{
+		dwReadSize = (dwFWSize>=1024)?dwBufferSize:dwFWSize;
+		fread(buffer,1,dwReadSize,m_pFile);
+		fwrite(buffer,1,dwReadSize,file);
+		dwFWSize -= dwReadSize;
+	} while (dwFWSize>0);
+	fclose(file);
+	return true;
+}
+bool CRKImage::GetData(long long dwOffset,DWORD dwSize,PBYTE lpBuffer)
+{
+	
+	if ( dwOffset<0 || dwSize==0 )
+	{
+		return false;
+	}
+	if ( dwOffset+dwSize >m_fileSize)
+	{
+		return false;
+	}
+
+	fseeko(m_pFile,dwOffset,SEEK_SET);
+	UINT uiActualRead;
+	uiActualRead = fread(lpBuffer,1,dwSize,m_pFile);
+	if (dwSize!=uiActualRead)
+	{
+		return false;
+	}
+	return true;
+}
+void CRKImage::GetReservedData(PBYTE &lpData,USHORT &usSize)
+{
+	lpData = m_reserved;
+	usSize = IMAGE_RESERVED_SIZE;
+}
+int CRKImage::GetMd5Data(PBYTE &lpMd5,PBYTE &lpSignMd5)
+{
+	lpMd5 = m_md5;
+	lpSignMd5 = m_signMd5;
+	return m_signMd5Size;
+}
+
+CRKImage::CRKImage(tstring filename,bool &bCheck)
+{
+	Version.setContainer(this);
+	Version.getter(&CRKImage::GetVersion);
+	MergeVersion.setContainer(this);
+	MergeVersion.getter(&CRKImage::GetMergeVersion);
+	ReleaseTime.setContainer(this);
+	ReleaseTime.getter(&CRKImage::GetReleaseTime);
+	SupportDevice.setContainer(this);
+	SupportDevice.getter(&CRKImage::GetSupportDevice);
+	OsType.setContainer(this);
+	OsType.getter(&CRKImage::GetOsType);
+	BackupSize.setContainer(this);
+	BackupSize.getter(&CRKImage::GetBackupSize);
+	BootOffset.setContainer(this);
+	BootOffset.getter(&CRKImage::GetBootOffset);
+	BootSize.setContainer(this);
+	BootSize.getter(&CRKImage::GetBootSize);
+	FWOffset.setContainer(this);
+	FWOffset.getter(&CRKImage::GetFWOffset);
+	FWSize.setContainer(this);
+	FWSize.getter(&CRKImage::GetFWSize);
+	bool bDoMdb5Check=bCheck;
+	struct stat statBuf;  
+	m_bootObject = NULL;
+	m_pFile = NULL;
+
+	m_signMd5Size = 0;
+	memset(m_md5,0,32);
+	memset(m_signMd5,0,256);
+
+	tchar szName[256];
+	_tcscpy(szName,filename.c_str());
+	if(stat(szName, &statBuf) < 0)
+	{
+		bCheck = false;
+		return;
+	}
+	if (S_ISDIR(statBuf.st_mode))
+	{
+		bCheck = false;
+		return;
+	}
+	m_fileSize = statBuf.st_size;
+	
+	bool bOnlyBootFile=false;
+	transform(filename.begin(),filename.end(),filename.begin(),(int(*)(int))tolower);
+	if (filename.find(_T(".bin"))!=tstring::npos)
+	{
+		bOnlyBootFile=true;
+	}
+
+	m_pFile = fopen(szName,"rb");
+	if ( !m_pFile)
+	{
+		bCheck = false;
+		return;
+	}
+//code will be error if firmware is signed.md5 is not last 32 byte.
+//	fseeko(m_pFile,-32,SEEK_END);
+//	fread(m_md5,1,32,m_pFile);
+//	fseeko(m_pFile,0,SEEK_SET);
+// 	if (!Md5Check())
+// 	{
+// 		bCheck = false;
+// 		return;
+// 	}
+
+	int nMd5DataSize;
+	long long ulFwSize;
+	STRUCT_RKIMAGE_HEAD imageHead;
+	if (!bOnlyBootFile)
+	{
+		fseeko(m_pFile,0,SEEK_SET);
+		fread((PBYTE)(&imageHead),1,sizeof(STRUCT_RKIMAGE_HEAD),m_pFile);
+		
+		if ( imageHead.uiTag!=0x57464B52 )
+		{
+			bCheck = false;
+			return;
+		}
+		if ((imageHead.reserved[14]=='H')&&(imageHead.reserved[15]=='I'))
+		{
+			ulFwSize = *((DWORD *)(&imageHead.reserved[16]));
+			ulFwSize <<= 32;
+			ulFwSize += imageHead.dwFWOffset;
+			ulFwSize += imageHead.dwFWSize;
+		}
+		else
+			ulFwSize = imageHead.dwFWOffset+imageHead.dwFWSize;
+		nMd5DataSize = GetImageSize()-ulFwSize;
+		if (nMd5DataSize>=160)
+		{//sign image
+			m_bSignFlag = true;
+			m_signMd5Size = nMd5DataSize-32;
+			fseeko(m_pFile,ulFwSize,SEEK_SET);
+			fread(m_md5,1,32,m_pFile);
+			fread(m_signMd5,1,nMd5DataSize-32,m_pFile);
+		}
+		else
+		{
+			fseeko(m_pFile,-32,SEEK_END);
+			fread(m_md5,1,32,m_pFile);
+		}
+		if (bDoMdb5Check)
+		{
+			if (!Md5Check(ulFwSize))
+			{
+                printf("Md5Check update.img ulFwSize: %lld", ulFwSize);
+				//bCheck = false;
+				//return;
+                bCheck = true;
+			}
+		}
+
+		m_version = imageHead.dwVersion;
+		m_mergeVersion = imageHead.dwMergeVersion;
+		m_releaseTime.usYear = imageHead.stReleaseTime.usYear;
+		m_releaseTime.ucMonth = imageHead.stReleaseTime.ucMonth;
+		m_releaseTime.ucDay = imageHead.stReleaseTime.ucDay;
+		m_releaseTime.ucHour = imageHead.stReleaseTime.ucHour;
+		m_releaseTime.ucMinute = imageHead.stReleaseTime.ucMinute;
+		m_releaseTime.ucSecond = imageHead.stReleaseTime.ucSecond;
+		m_supportDevice = imageHead.emSupportChip;
+		m_bootOffset = imageHead.dwBootOffset;
+		m_bootSize = imageHead.dwBootSize;
+		m_fwOffset = imageHead.dwFWOffset;
+		m_fwSize = ulFwSize - m_fwOffset;
+		
+		memcpy(m_reserved,imageHead.reserved,IMAGE_RESERVED_SIZE);
+	}
+	else
+	{
+		m_bootOffset = 0;
+		m_bootSize = m_fileSize;
+	}
+
+	
+	PBYTE lpBoot;
+	lpBoot = new BYTE[m_bootSize];
+	fseeko(m_pFile,m_bootOffset,SEEK_SET);
+	fread(lpBoot,1,m_bootSize,m_pFile);
+	bool bRet;
+	m_bootObject = new CRKBoot(lpBoot,m_bootSize,bRet);
+	if (!bRet)
+	{
+		bCheck = false;
+		return;
+	}
+	if (bOnlyBootFile)
+	{
+		m_supportDevice = m_bootObject->SupportDevice;
+		UINT *pOsType;
+		pOsType = (UINT *)&m_reserved[4];
+		*pOsType = (UINT)RK_OS;
+		fclose(m_pFile);
+		m_pFile = NULL;
+	}
+	bCheck = true;
+}
+CRKImage::~CRKImage()
+{
+	if (m_pFile)
+	{
+		fclose(m_pFile);
+		m_pFile = NULL;
+	}
+	if (m_bootObject)
+	{
+		delete m_bootObject;
+		m_bootObject = NULL;
+	}
+}
+
+long long CRKImage::GetImageSize()
+{
+	return m_fileSize;
+}
diff --git a/bootable/recovery/rkupdate/RKLog.cpp b/bootable/recovery/rkupdate/RKLog.cpp
new file mode 100755
index 0000000000..d6b416ee8e
--- /dev/null
+++ b/bootable/recovery/rkupdate/RKLog.cpp
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include "rkupdate/RKLog.h"
+
+bool CRKLog::GetEnableLog()
+{
+	return m_enable;
+}
+void CRKLog::SetEnableLog(bool bEnable)
+{
+	m_enable = bEnable;
+}
+
+CRKLog::CRKLog(bool enable)
+{
+ 	
+ 	EnableLog.setContainer(this);
+	EnableLog.getter(&CRKLog::GetEnableLog);
+ 	EnableLog.setter(&CRKLog::SetEnableLog);
+	
+	m_enable = enable;
+}
+CRKLog::~CRKLog()
+{
+}
+void CRKLog::Record(const tchar* lpFmt,...)
+{	
+	/************************* ־ ***********************/
+	va_list ap;
+    va_start(ap, lpFmt);
+	printf("librkupdate_");
+    vfprintf(stdout, lpFmt, ap);
+	printf("\r\n");
+    va_end(ap);
+}
+
+bool CRKLog::SaveBuffer(tstring fileName,PBYTE lpBuffer,DWORD dwSize)
+{
+	FILE *file;
+	file = fopen(fileName.c_str(),_T("wb+"));
+	if (!file)
+	{
+		return false;
+	}
+	fwrite(lpBuffer,1,dwSize,file);
+	fclose(file);
+	return true;
+}
+void CRKLog::PrintBuffer(tstring &strOutput,PBYTE lpBuffer,DWORD dwSize,UINT uiLineCount)
+{
+	UINT i,count;
+	tchar strHex[32];
+	strOutput = _T("");
+	for (i=0,count=0;i<dwSize;i++,count++)
+	{
+		if (count>=uiLineCount)
+		{
+			strOutput += _T("\r\n");
+			count = 0;
+		}
+		sprintf(strHex,_T("%02X"),lpBuffer[i]);
+		strOutput = strOutput + _T(" ") + strHex;
+		
+	}
+}
\ No newline at end of file
diff --git a/bootable/recovery/rkupdate/RKSparse.cpp b/bootable/recovery/rkupdate/RKSparse.cpp
new file mode 100755
index 0000000000..6cedf5d132
--- /dev/null
+++ b/bootable/recovery/rkupdate/RKSparse.cpp
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <iostream>
+#include "rkupdate/RKSparse.h"
+#include "rkupdate/RKDevice.h"
+using namespace std;
+
+RKSparse::RKSparse(const char* filePath){
+    // 1. 打开文件
+    m_pFile = fopen(filePath, "rb");
+    fileName = filePath;
+    // 2. 设置m_header
+    readfile(0, sizeof(m_header), (PBYTE)&m_header);
+    // 3. 设置m_chunk
+    readfile(0 + sizeof(m_header), sizeof(m_chunk), (PBYTE)&m_chunk);
+};
+
+RKSparse::~RKSparse(){
+    if(m_pFile != NULL){
+        fclose(m_pFile);
+    }
+    remove(fileName);
+    sync();
+}
+bool RKSparse::IsSparseImage(){
+    if(m_header.magic != SPARSE_HEADER_MAGIC)
+    {
+        printf("Image isn't Sparse.\n");
+        return false;
+    }else{
+        printf("Image is Sparse.\n");
+        return true;
+    }
+}
+
+long long RKSparse::GetSparseImageSize(){
+    return m_header.blk_sz * m_header.total_blks;
+}
+
+bool RKSparse::SparseFile_Download(DWORD dwPos, CRKComm *pComm){
+    UINT uiLBATransferSize = (LBA_TRANSFER_SIZE) * 1;
+    UINT uiBufferSize = uiLBATransferSize;  // buffer 的长度
+    UINT uiLBASector = uiLBATransferSize/SECTOR_SIZE;
+    UINT uiCurChunk; //当前块的计数
+    UINT uiChunkDataSize, uiWriteByte, uiLen, uiBegin, uiFillByte, uiCrc;
+    int iRet, i;
+    long long uiEntryOffset; //数据的偏移量
+    chunk_header chunk;
+    PBYTE pBuffer = NULL;
+
+    uiEntryOffset = sizeof(m_header);
+    uiCurChunk = 0;
+    uiLen = 0;
+    uiWriteByte = 0;
+    uiBegin = dwPos;
+    
+    //申请buffer，用来放置要写入的数据
+    pBuffer = new BYTE[uiBufferSize];
+    if(pBuffer == NULL){
+        printf("Failed ==== new Buffer %s:%d.\n", __func__, __LINE__);
+        return false;
+    }
+
+    while(uiCurChunk < m_header.total_chunks){
+        bool bRet = false;
+        bRet = readfile(uiEntryOffset, sizeof(chunk), (PBYTE)&chunk); 
+        if(!bRet){
+            printf("Failed ==== readfile %s:%d.\n", __func__, __LINE__);
+            delete []pBuffer;
+            pBuffer = NULL;
+            return false;
+        }
+        uiCurChunk++;
+        uiEntryOffset += sizeof(chunk);
+        switch (chunk.chunk_type)
+        {
+        case CHUNK_TYPE_RAW:
+            uiChunkDataSize = chunk.total_sz - sizeof(chunk_header); //当前chunk 数据长度
+            while (uiChunkDataSize)
+            {
+                memset(pBuffer, 0, uiBufferSize);
+
+                if(uiChunkDataSize < uiBufferSize )
+                {
+                    uiWriteByte = uiChunkDataSize;
+                    uiLen = ( (uiWriteByte%SECTOR_SIZE==0) ? (uiWriteByte/SECTOR_SIZE) : (uiWriteByte/SECTOR_SIZE+1) );
+                }
+                else
+                {
+                    uiWriteByte = uiBufferSize;
+                    uiLen = uiLBASector;
+                }
+
+                if (!readfile(uiEntryOffset, uiWriteByte, pBuffer))
+                {
+                    printf("ERROR:get chunk data failed,chunk=%d, %s:%d",uiCurChunk, __func__, __LINE__);
+                    delete []pBuffer;
+                    pBuffer = NULL;
+                    return false;
+                }
+
+                uiEntryOffset += uiWriteByte;
+                iRet = pComm->RKU_WriteLBA(uiBegin, uiLen, pBuffer, 0);
+                if( iRet!=ERR_SUCCESS )
+                {
+                    printf("ERROR:RKA_SparseFile_Download-->RKU_WriteLBA failed,RetCode(%d),chunk=%d", iRet, uiCurChunk);
+
+                    delete []pBuffer;
+                    pBuffer = NULL;
+                    return false;
+                }
+                uiBegin += uiLen;
+                //currentByte += uiWriteByte;
+                uiChunkDataSize -= uiWriteByte;
+
+            }
+            break;
+        case CHUNK_TYPE_FILL:
+            uiChunkDataSize = chunk.chunk_sz * m_header.blk_sz;
+            if (readfile(uiEntryOffset, 4, (PBYTE)&uiFillByte))
+            {
+                printf("ERROR:RKA_SparseFile_Download-->get fill byte failed,chunk=%d", uiCurChunk);
+                delete []pBuffer;
+                pBuffer = NULL;
+                return false;
+            }
+
+            uiEntryOffset += 4;
+            while(uiChunkDataSize)
+            {
+                memset(pBuffer, 0, uiBufferSize);
+                if (uiChunkDataSize < uiBufferSize )
+                {
+                    uiWriteByte = uiChunkDataSize;
+                    uiLen = ( (uiWriteByte%SECTOR_SIZE==0) ? (uiWriteByte/SECTOR_SIZE) : (uiWriteByte/SECTOR_SIZE+1) );
+                }
+                else
+                {
+                    uiWriteByte = uiBufferSize;
+                    uiLen = uiLBASector;
+                }
+
+                for (i = 0; i < uiWriteByte/4; i++)
+                {
+                    *(UINT *)(pBuffer + i*4) = uiFillByte;
+                }
+
+                uiEntryOffset += uiWriteByte;
+                iRet = pComm->RKU_WriteLBA(uiBegin, uiLen, pBuffer, 0);
+
+                if(iRet != ERR_SUCCESS)
+                {
+                    printf(" ERROR:RKA_SparseFile_Download-->RKU_WriteLBA failed,RetCode(%d),chunk=%d", iRet, uiCurChunk);
+
+                    delete []pBuffer;
+                    pBuffer = NULL;
+                    return false;
+                }
+                uiBegin += uiLen;
+                //currentByte += uiWriteByte;
+                uiChunkDataSize -= uiWriteByte;
+
+            }
+            break;
+            
+        case CHUNK_TYPE_DONT_CARE:
+            uiChunkDataSize = chunk.chunk_sz * m_header.blk_sz;
+            //currentByte += uiChunkDataSize;
+            uiLen = ( (uiChunkDataSize%SECTOR_SIZE==0) ? (uiChunkDataSize/SECTOR_SIZE) : (uiChunkDataSize/SECTOR_SIZE+1) );
+            uiBegin += uiLen;
+            break;
+        case CHUNK_TYPE_CRC32:
+            bRet = readfile(uiEntryOffset, 4, (PBYTE)&uiCrc);
+            uiEntryOffset += 4;
+            break;
+        } 
+    }
+    printf("======%s:%d====== success.\n", __func__, __LINE__);
+    return true;
+}
+
+bool RKSparse::readfile(long long dwOffset, DWORD dwSize, PBYTE lpBuffer){
+
+    if (dwOffset < 0 || dwSize == 0)
+    {
+        return false;
+    }
+    //if ( dwOffset + dwSize > m_fileSize)
+    //{
+    //    return false;
+    //}
+
+    fseeko(m_pFile, dwOffset, SEEK_SET);
+    UINT uiActualRead;
+    uiActualRead = fread(lpBuffer, 1, dwSize, m_pFile);
+
+    if (dwSize!=uiActualRead)
+    {
+        printf("readfile failed.\n");
+        return false;
+    }
+    return true;
+}
+
+void RKSparse::display(){
+    printf("in RKSparse display.\n");
+    printf("m_header->magic is %x.\n",  m_header.magic);
+}
+
diff --git a/bootable/recovery/rkupdate/Upgrade.cpp b/bootable/recovery/rkupdate/Upgrade.cpp
new file mode 100755
index 0000000000..bafcc0bead
--- /dev/null
+++ b/bootable/recovery/rkupdate/Upgrade.cpp
@@ -0,0 +1,1524 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+//#include "RKImage.h"
+//#include "RKLog.h"
+//#include "RKComm.h"
+#include "rkupdate/RKAndroidDevice.h"
+//#include "rkrsa_api.h"
+//#include "uuid/uuid.h"
+#include "rkupdate/RKSparse.h"
+UpgradeCallbackFunc g_callback=NULL;
+UpgradeProgressCallbackFunc g_progress_callback=NULL;
+
+bool CreateUid(PBYTE pUid)
+{
+	if (!pUid)
+	{
+		return false;
+	}
+	memset(pUid,0,RKDEVICE_UID_LEN);
+
+	PBYTE pManufactory,pTime,pGuid,pCrc;
+	pManufactory = pUid;
+	pTime = pManufactory + 8;
+	pGuid = pTime + 4;
+	pCrc = pGuid + 16;
+	memcpy(pManufactory,"ROCKCHIP",8);
+	time_t now;
+	now = time(NULL);
+	memcpy(pTime,(BYTE *)&now,4);
+	#if 0
+	uuid_t guidValue;
+	uuid_generate(guidValue);
+	#else
+	unsigned char raw[16]={0};
+	gen_rand_uuid(raw);
+	#endif
+
+	#if 0
+	memcpy(pGuid,(BYTE *)guidValue,16);
+	#else
+	memcpy(pGuid,(BYTE *)raw,16);
+	#endif
+	
+	USHORT usCrc=0;
+	usCrc = CRC_CCITT(pManufactory,28);
+	memcpy(pCrc,(BYTE *)&usCrc,2);
+	return true;
+	
+}
+
+bool ParsePartitionInfo(string &strPartInfo,string &strName,UINT &uiOffset,UINT &uiLen)
+{
+	string::size_type pos,prevPos;
+	string strOffset,strLen;
+	int iCount;
+	prevPos = pos = 0;
+	if (strPartInfo.size()<=0)
+	{
+		return false;
+	}
+	pos = strPartInfo.find('@');
+	if (pos==string::npos)
+	{
+		return false;
+	}
+	strLen = strPartInfo.substr(prevPos,pos-prevPos);
+	strLen.erase(0,strLen.find_first_not_of(_T(" ")));
+	strLen.erase(strLen.find_last_not_of(_T(" "))+1);
+	if (strchr(strLen.c_str(),'-'))
+	{
+		uiLen = 0xFFFFFFFF;
+	}
+	else
+	{
+		iCount = sscanf(strLen.c_str(),"0x%x",&uiLen);
+		if (iCount!=1)
+		{
+			return false;
+		}
+	}
+
+	prevPos = pos +1;
+	pos = strPartInfo.find('(',prevPos);
+	if (pos==string::npos)
+	{
+		return false;
+	}
+	strOffset = strPartInfo.substr(prevPos,pos-prevPos);
+	strOffset.erase(0,strOffset.find_first_not_of(_T(" ")));
+	strOffset.erase(strOffset.find_last_not_of(_T(" "))+1);
+	iCount = sscanf(strOffset.c_str(),"0x%x",&uiOffset);
+	if (iCount!=1)
+	{
+		return false;
+	}
+	
+	prevPos = pos +1;
+	pos = strPartInfo.find(')',prevPos);
+	if (pos==string::npos)
+	{
+		return false;
+	}
+	strName = strPartInfo.substr(prevPos,pos-prevPos);
+	strName.erase(0,strName.find_first_not_of(_T(" ")));
+	strName.erase(strName.find_last_not_of(_T(" "))+1);
+
+	return true;
+}
+
+bool parse_parameter(char *pParameter,PARAM_ITEM_VECTOR &vecItem)
+{
+	
+	stringstream paramStream(pParameter);
+	bool bRet,bFind=false;
+	string strLine,strPartition,strPartInfo,strPartName;
+	string::size_type line_size,pos,posColon,posComma;
+	UINT uiPartOffset,uiPartSize;
+	STRUCT_PARAM_ITEM item;
+	vecItem.clear();
+        int i=0;
+	while (!paramStream.eof())
+	{
+            i++;
+	    getline(paramStream,strLine);
+            line_size = strLine.size();
+	    if (line_size==0)
+            {
+		continue;
+            }
+	    if(strLine[0]=='#')
+            {
+		continue;
+            }
+	    if (strLine[line_size-1]=='\r')
+	    {
+		strLine = strLine.substr(0,line_size-1);
+	    }
+            pos = strLine.find("mtdparts");
+	    if (pos==string::npos)
+	    {
+		continue;
+	    }
+	    bFind = true;
+	    posColon = strLine.find(':',pos);
+	    if (posColon==string::npos)
+	    {
+		continue;
+	    }
+	    strPartition = strLine.substr(posColon+1);
+	    //ȡϢ
+		pos = 0;
+		posComma = strPartition.find(',',pos);
+		while (posComma!=string::npos)
+		{
+			strPartInfo = strPartition.substr(pos,posComma-pos);
+			bRet = ParsePartitionInfo(strPartInfo,strPartName,uiPartOffset,uiPartSize);
+			if (bRet)
+			{			
+				strcpy(item.szItemName,strPartName.c_str());
+				item.uiItemOffset = uiPartOffset;
+				item.uiItemSize = uiPartSize;
+				vecItem.push_back(item);
+			}
+			pos = posComma+1;
+			posComma = strPartition.find(',',pos);
+		}
+		strPartInfo = strPartition.substr(pos);
+		if (strPartInfo.size()>0)
+		{
+			bRet = ParsePartitionInfo(strPartInfo,strPartName,uiPartOffset,uiPartSize);
+			if (bRet)
+			{
+				strcpy(item.szItemName,strPartName.c_str());
+				item.uiItemOffset = uiPartOffset;
+				item.uiItemSize = uiPartSize;
+				vecItem.push_back(item);
+			}
+		}
+		break;
+	}
+	return bFind;
+	
+}
+
+bool parse_Gptparameter(string str,PARAM_ITEM_VECTOR &vecItem)
+{
+	bool bRet,bFind=false;
+	string strLine,strPartition,strPartInfo,strPartName;
+	string::size_type line_size,pos,posColon,posComma;
+	UINT uiPartOffset,uiPartSize;
+        ifstream  fin(str);
+	STRUCT_PARAM_ITEM item;
+	vecItem.clear();
+        int i=0;
+	while (getline(fin,strLine))
+	{
+        i++;
+        printf("str = %s",strLine.c_str());
+	line_size = strLine.size();
+	if (line_size==0)
+        {
+	    continue;
+        }
+	    if(strLine[0]=='#')
+        {
+	    continue;
+        }
+	if (strLine[line_size-1]=='\r')
+        {
+	    strLine = strLine.substr(0,line_size-1);
+	}
+	pos = strLine.find("mtdparts");
+	if (pos==string::npos)
+	{
+	    continue;
+	}
+	bFind = true;
+	posColon = strLine.find(':',pos);
+	if (posColon==string::npos)
+	{
+	    continue;
+	}
+	strPartition = strLine.substr(posColon+1);
+	//ȡϢ
+	pos = 0;
+	posComma = strPartition.find(',',pos);
+	while (posComma!=string::npos)
+	{
+	    strPartInfo = strPartition.substr(pos,posComma-pos);
+	    bRet = ParsePartitionInfo(strPartInfo,strPartName,uiPartOffset,uiPartSize);
+	    if (bRet)
+	    {
+	        strcpy(item.szItemName,strPartName.c_str());
+		item.uiItemOffset = uiPartOffset;
+		item.uiItemSize = uiPartSize;
+		vecItem.push_back(item);
+	    }
+	    pos = posComma+1;
+	    posComma = strPartition.find(',',pos);
+	}
+	strPartInfo = strPartition.substr(pos);
+	if (strPartInfo.size()>0)
+	{
+	    bRet = ParsePartitionInfo(strPartInfo,strPartName,uiPartOffset,uiPartSize);
+	    if (bRet)
+	    {
+		strcpy(item.szItemName,strPartName.c_str());
+		item.uiItemOffset = uiPartOffset;
+		item.uiItemSize = uiPartSize;
+		vecItem.push_back(item);
+	    }
+	}
+	break;
+	}
+	return bFind;
+}
+
+bool get_parameter_loader( CRKComm *pComm,char *pParameter, int &nParamSize)
+{
+	if ((nParamSize!=-1)&&(!pParameter))
+	{
+		return false;
+	}
+	BYTE paramHead[512];
+	DWORD *pParamTag=(DWORD *)paramHead;
+	DWORD *pParamSize=(DWORD *)(paramHead+4);
+	int iRet;
+
+	iRet = pComm->RKU_ReadLBA(0,1,paramHead);
+	if (iRet!=ERR_SUCCESS)
+	{
+		return false;
+	}
+	if (*pParamTag!=0x4D524150)
+	{
+		return false;
+	}
+	if (nParamSize==-1)
+	{//ȡparameterС
+		nParamSize = *pParamSize;
+		return true;
+	}
+	if (nParamSize<*pParamSize)
+	{
+		return false;
+	}
+
+	nParamSize = *pParamSize;
+	int nParamSec;
+	nParamSec = (nParamSize+12-1)/512+1;
+	PBYTE pBuffer=NULL;
+	pBuffer = new BYTE[nParamSec*512];
+	if (!pBuffer)
+	{
+
+		return false;
+	}
+	iRet = pComm->RKU_ReadLBA(0,nParamSec,pBuffer);
+	if (iRet!=ERR_SUCCESS)
+	{
+		delete []pBuffer;
+		pBuffer = NULL;
+		return false;
+	}
+
+	memcpy(pParameter,pBuffer+8,nParamSize);
+	delete []pBuffer;
+	pBuffer = NULL;
+	return true;
+}
+bool read_bytes_from_partition(DWORD dwPartitionOffset,long long ullstart,DWORD dwCount,PBYTE pOut,CRKComm *pComm)
+{
+	int iRet;
+	UINT uiTransferSize = 16*1024;
+	UINT uiTransferSec = uiTransferSize/SECTOR_SIZE;
+	BYTE *pBuffer = NULL;
+	UINT uiBegin=dwPartitionOffset,uiLen,uiReadBytes=0,uiTmp;
+	DWORD dwWritePos=0;
+	pBuffer = new BYTE[uiTransferSize];
+	if (!pBuffer)
+		return false;
+	uiTmp = ullstart % 2048;
+	if (uiTmp==0)
+	{
+		uiBegin += ullstart / SECTOR_SIZE;
+	}
+	else
+	{
+		uiReadBytes = 2048 - uiTmp;
+		uiBegin += ((ullstart/2048)*4);
+		uiLen = 4;
+		iRet = pComm->RKU_ReadLBA(uiBegin,uiLen,pBuffer);
+		if (iRet!=ERR_SUCCESS)
+		{
+			delete []pBuffer;
+			return false;
+		}
+		if (dwCount>=uiReadBytes)
+		{
+			memcpy(pOut+dwWritePos,pBuffer+uiTmp,uiReadBytes);
+			dwWritePos += uiReadBytes;
+			dwCount -= uiReadBytes;
+		}
+		else
+		{
+			memcpy(pOut+dwWritePos,pBuffer+uiTmp,dwCount);
+			dwWritePos += dwCount;
+			dwCount = 0;
+		}
+		uiBegin += uiLen;
+	}
+	while (dwCount>0)
+	{
+		if (dwCount>=uiTransferSize)
+		{
+			uiReadBytes = uiTransferSize;
+			uiLen = uiTransferSec;
+		}
+		else
+		{
+			uiReadBytes = dwCount;
+			uiLen = BYTE2SECTOR(uiReadBytes);
+		}
+		iRet = pComm->RKU_ReadLBA(uiBegin,uiLen,pBuffer);
+		if (iRet!=ERR_SUCCESS)
+		{
+			delete []pBuffer;
+			return false;
+		}
+		memcpy(pOut+dwWritePos,pBuffer,uiReadBytes);
+		dwWritePos += uiReadBytes;
+		dwCount -= uiReadBytes;
+		uiBegin += uiLen;
+	}
+	delete []pBuffer;
+	return true;
+}
+
+bool check_fw_header(CRKComm *pComm,DWORD dwOffset,PSTRUCT_RKIMAGE_HDR pHeader,CRKLog *pLog=NULL)
+{
+	int nHeaderSec = BYTE2SECTOR(sizeof(STRUCT_RKIMAGE_HDR));
+	char model[256]={0};
+	PBYTE pBuf=NULL;
+	pBuf = new BYTE[nHeaderSec*SECTOR_SIZE];
+	if (!pBuf)
+		return false;
+	int iRet;
+	iRet = pComm->RKU_ReadLBA(dwOffset,nHeaderSec,pBuf);
+	if (iRet!=ERR_SUCCESS)
+	{
+		delete []pBuf;
+		pBuf = NULL;
+		return false;
+	}
+	memcpy(pHeader,pBuf,sizeof(STRUCT_RKIMAGE_HDR));
+	delete []pBuf;
+	pBuf = NULL;
+	if (pHeader->tag!=RKIMAGE_TAG)
+		return false;
+	
+    property_get("ro.product.model", model, "");
+	if (pLog)
+		pLog->Record(_T("model:%s\nbackup firmware model:%s\n"),model,pHeader->machine_model);
+    if(strcmp(model, pHeader->machine_model))
+    {
+        return false;
+    }
+	return true;
+}
+bool check_fw_crc(CRKComm *pComm,DWORD dwOffset,PSTRUCT_RKIMAGE_HDR pHeader,CRKLog *pLog=NULL)
+{
+	int iRet;
+	long long ullRemain,ullCrcOffset;
+	if (pHeader->machine_model[29]=='H')
+	{
+		ullRemain = *((DWORD *)(&pHeader->machine_model[30]));
+		ullRemain <<= 32;
+		ullRemain += pHeader->size;
+	}
+	else
+		ullRemain = pHeader->size;
+	if (ullRemain<=0)
+		return false;
+	ullCrcOffset = ullRemain;
+	UINT uiTransferSize = 16*1024;
+	UINT uiTransferSec = uiTransferSize/SECTOR_SIZE;
+	BYTE *pBuffer = NULL;
+	BYTE oldCrc[4];
+	UINT uiBegin=dwOffset,uiLen,uiCrc=0,uiReadBytes=0;
+	pBuffer = new BYTE[uiTransferSize];
+	if (!pBuffer)
+		return false;
+	while(ullRemain>0)
+	{
+		if (ullRemain>=uiTransferSize)
+		{
+			uiReadBytes = uiTransferSize;
+			uiLen = uiTransferSec;
+		}
+		else
+		{
+			uiReadBytes = ullRemain;
+			uiLen = BYTE2SECTOR(uiReadBytes);
+		}
+		iRet = pComm->RKU_ReadLBA(uiBegin,uiLen,pBuffer);
+		if (iRet!=ERR_SUCCESS)
+		{
+			delete []pBuffer;
+			if (pLog)
+				pLog->Record(_T("ERROR:check_fw_crc-->RKU_ReadLBA failed,err=%d"),iRet);
+			return false;
+		}
+		uiCrc = CRC_32(pBuffer,uiReadBytes,uiCrc);
+		uiBegin += uiLen;
+		ullRemain -= uiReadBytes;
+	}
+	delete []pBuffer;
+	if (!read_bytes_from_partition(dwOffset,ullCrcOffset,4,oldCrc,pComm))
+	{
+		if (pLog)
+			pLog->Record(_T("ERROR:check_fw_crc-->read old crc failed"));
+		return false;
+	}
+	if (uiCrc!=*((UINT *)(oldCrc)))
+		return false;
+	return true;
+	
+}
+
+bool download_backup_image(PARAM_ITEM_VECTOR &vecParam,char *pszItemName,DWORD dwBackupOffset,STRUCT_RKIMAGE_HDR &hdr,CRKComm *pComm,CRKLog *pLog=NULL)
+{
+	DWORD dwToOffset,dwToSize;
+	int i,iRet;
+	if (g_progress_callback)
+		g_progress_callback(0.5,50);
+	for (i=0;i<vecParam.size();i++)
+	{
+		if (strcmp(pszItemName,vecParam[i].szItemName)==0)
+		{
+			dwToOffset = vecParam[i].uiItemOffset;
+			dwToSize = vecParam[i].uiItemSize;
+			break;
+		}
+	}
+	if (i>=vecParam.size())
+	{
+		if (pLog)
+			pLog->Record(_T("ERROR:download_backup_image-->no found dest partition."));
+		return false;
+	}
+	long long ullSrcPos,ullSrcSize;
+	for (i=0;i<hdr.item_count;i++)
+	{
+		if (strcmp(pszItemName,hdr.item[i].name)==0)
+		{
+			if (hdr.item[i].file[50]=='H')
+			{
+				ullSrcPos= *((DWORD *)(&hdr.item[i].file[51]));
+				ullSrcPos <<= 32;
+				ullSrcPos += hdr.item[i].offset;
+			}
+			else
+			{
+				ullSrcPos = hdr.item[i].offset;
+			}
+			if (hdr.item[i].file[55]=='H')
+			{
+				ullSrcSize= *((DWORD *)(&hdr.item[i].file[56]));
+				ullSrcSize <<= 32;
+				ullSrcSize += hdr.item[i].size;
+			}
+			else
+			{
+				ullSrcSize = hdr.item[i].size;
+			}
+			break;
+		}
+	}
+	if (i>=hdr.item_count)
+	{
+		if (pLog)
+			pLog->Record(_T("ERROR:download_backup_image-->no found source in the backup."));
+		return false;
+	}
+	long long ullRemain,ullstart,ullToStart;
+	UINT uiBegin,uiLen,uiTransferByte;
+	UINT uiBufferSize=16*1024;
+	BYTE buffer[16*1024];
+	BYTE readbuffer[16*1024];
+	
+	//write image
+	ullRemain = ullSrcSize;
+	uiBegin = dwToOffset;
+	ullstart = ullSrcPos;
+	while(ullRemain>0)
+	{
+		if (ullRemain>=uiBufferSize)
+		{
+			uiTransferByte = uiBufferSize;
+			uiLen = 32;
+		}
+		else
+		{
+			uiTransferByte = ullRemain;
+			uiLen = BYTE2SECTOR(uiTransferByte);
+		}
+		if (!read_bytes_from_partition(dwBackupOffset,ullstart,uiTransferByte,buffer,pComm))
+		{
+			if (pLog)
+				pLog->Record(_T("ERROR:download_backup_image-->read data from backup failed."));
+			return false;
+		}
+		iRet = pComm->RKU_WriteLBA(uiBegin,uiLen,buffer);
+		if (iRet!=ERR_SUCCESS)
+		{
+			if (pLog)
+				pLog->Record(_T("ERROR:download_backup_image-->write data to partition failed."));
+			return false;
+		}
+		ullRemain -= uiTransferByte;
+		uiBegin += uiLen;
+		ullstart += uiTransferByte;
+		
+	}
+	pComm->RKU_ReopenLBAHandle();
+	if (g_progress_callback)
+		g_progress_callback(1,0);
+	if (g_progress_callback)
+		g_progress_callback(0.4,30);
+//check image
+	if (pLog)
+		pLog->Record(_T("Start to check system..."));
+	ullRemain = ullSrcSize;
+	ullToStart = 0;
+	ullstart = ullSrcPos;
+	while(ullRemain>0)
+	{
+		if (ullRemain>=uiBufferSize)
+		{
+			uiTransferByte = uiBufferSize;
+		}
+		else
+		{
+			uiTransferByte = ullRemain;
+		}
+		if (!read_bytes_from_partition(dwBackupOffset,ullstart,uiTransferByte,buffer,pComm))
+		{
+			if (pLog)
+				pLog->Record(_T("ERROR:download_backup_image-->read data from backup failed."));
+			return false;
+		}
+		if (!read_bytes_from_partition(dwToOffset,ullToStart,uiTransferByte,readbuffer,pComm))
+		{
+			if (pLog)
+				pLog->Record(_T("ERROR:download_backup_image-->read data from partition failed."));
+			return false;
+		}
+		if (memcmp(buffer,readbuffer,uiTransferByte)!=0)
+		{
+			if (pLog)
+				pLog->Record(_T("ERROR:download_backup_image-->compare data failed."));
+			return false;
+		}
+
+		ullRemain -= uiTransferByte;
+		ullToStart += uiTransferByte;
+		ullstart += uiTransferByte;
+		
+	}
+	if (g_progress_callback)
+		g_progress_callback(1,0);
+	return true;
+}
+
+
+
+bool IsDeviceLock(CRKComm *pComm,bool &bLock)
+{
+	bLock = false;(void)pComm;
+	return true;
+#if 0
+	int iRet;
+	BYTE buffer[4];
+	iRet = pComm->RKU_GetLockFlag(buffer);
+	if (iRet!=ERR_SUCCESS)
+		return false;
+	DWORD *pFlag=(DWORD *)buffer;
+	if (*pFlag==1)
+		bLock = true;
+	else
+		bLock = false;
+	return true;
+#endif
+}
+bool GetPubicKeyFromExternal(char *szDev,CRKLog *pLog,unsigned char *pKey,unsigned int &nKeySize)
+{
+	int hDev=-1;
+	int j,ret,nRsaByte;
+	bool bSuccess=false;
+	BYTE bData[SECTOR_SIZE*8];
+	PRKANDROID_IDB_SEC0 pSec0=(PRKANDROID_IDB_SEC0)bData;
+	PRK_SECURE_HEADER pSecureHdr=(PRK_SECURE_HEADER)(bData+SECTOR_SIZE*4);
+	string strOutput;
+	if (!szDev)
+	{
+		printf("In GetPubicKeyFromExternal device=NULL\n");
+		return false;
+	}
+	else
+		printf("In GetPubicKeyFromExternal device=%s\n",szDev);
+	hDev= open(szDev,O_RDONLY,0);
+	if (hDev<0)
+	{
+		if (pLog)
+			pLog->Record(_T("ERROR:GetPubicKeyFromExternal-->open %s failed,err=%d"),szDev,errno);
+		goto Exit_GetPubicKeyFromExternal;
+	}
+	else
+	{
+		if (pLog)
+			pLog->Record(_T("INFO:GetPubicKeyFromExternal-->%s=%d"),szDev,hDev);
+	}
+
+	ret = lseek(hDev,64*512,SEEK_SET);
+	if (ret<0)
+	{
+		if (pLog)
+			pLog->Record(_T("ERROR:GetPubicKeyFromExternal-->seek IDBlock failed,err=%d"),errno);
+		goto Exit_GetPubicKeyFromExternal;
+	}
+	ret = read(hDev,bData,8*512);
+	if (ret!=8*512)
+	{
+		if (pLog)
+			pLog->Record(_T("ERROR:GetPubicKeyFromExternal-->read IDBlock failed,err=%d"),errno);
+		goto Exit_GetPubicKeyFromExternal;
+	}
+//	if (pLog)
+//	{
+//		pLog->PrintBuffer(strOutput,bData,512,16);
+//		pLog->Record("INFO:idb\n%s",strOutput.c_str());
+//	}
+	P_RC4(bData,SECTOR_SIZE);
+//	if (pLog)
+//	{
+//		pLog->PrintBuffer(strOutput,bData,512,16);
+//		pLog->Record("INFO:idb rc4\n%s",strOutput.c_str());
+//	}
+	if (pSec0->dwTag!=0x0FF0AA55)
+	{
+		if (pLog)
+			pLog->Record(_T("ERROR:GetPubicKeyFromExternal-->check IDBlock failed,tag=0x%x"),pSec0->dwTag);
+		goto Exit_GetPubicKeyFromExternal;
+	}
+	if (pSec0->uiRc4Flag==0)
+	{
+		for(j=0;j<4;j++)
+			P_RC4(bData+SECTOR_SIZE*(j+4),SECTOR_SIZE);
+	}
+	if (pSecureHdr->uiTag!=0x4B415352)
+	{
+		if (pLog)
+			pLog->Record(_T("ERROR:GetPubicKeyFromExternal-->check SecureHeader failed,tag=0x%x"),pSecureHdr->uiTag);
+		goto Exit_GetPubicKeyFromExternal;	
+	}
+	nRsaByte = pSecureHdr->usRsaBit/8;
+	*((USHORT *)pKey) = pSecureHdr->usRsaBit;
+	for(j=0;j<nRsaByte;j++)
+		*(pKey+j+2) = pSecureHdr->nFactor[nRsaByte-j-1];
+	for(j=0;j<nRsaByte;j++)
+		*(pKey+j+2+nRsaByte) = pSecureHdr->eFactor[nRsaByte-j-1];
+	nKeySize = nRsaByte*2+2;
+//	if (pLog)
+//	{
+//		pLog->PrintBuffer(strOutput,pKey,nKeySize,16);
+//		pLog->Record("INFO:Key\n%s",strOutput.c_str());
+//	}
+	bSuccess = true;
+Exit_GetPubicKeyFromExternal:
+	if (hDev!=-1)
+		close(hDev);
+	return bSuccess;
+}
+
+bool GetPubicKeyFromDevice(CRKLog *pLog,unsigned char *pKey,unsigned int &nKeySize)
+{
+	bool bSuccess=false,bRet;
+	CRKComm *pComm=NULL;
+	CRKAndroidDevice *pDevice=NULL;
+	STRUCT_RKDEVICE_DESC device;
+	pComm = new CRKUsbComm(pLog);
+	if (!pComm)
+	{
+		pLog->Record("ERROR:GetPubicKeyFromDevice-->new CRKComm failed!");
+		goto EXIT_GetPubicKeyFromDevice;
+	}
+	pDevice = new CRKAndroidDevice(device);
+	if (!pDevice)
+	{
+		pLog->Record("ERROR:GetPubicKeyFromDevice-->new CRKAndroidDevice failed!");
+		goto EXIT_GetPubicKeyFromDevice;
+	}
+	pDevice->SetObject(NULL,pComm,pLog);
+	pDevice->m_pCallback = (UpgradeCallbackFunc)NULL;
+	pDevice->m_pProcessCallback = (UpgradeProgressCallbackFunc)NULL;
+	bRet = pDevice->GetPublicKey(pKey,nKeySize);
+	if (!bRet)
+	{
+		pLog->Record("ERROR:GetPubicKeyFromDevice-->GetPublicKey failed!");
+		goto EXIT_GetPubicKeyFromDevice;
+	}
+	bSuccess = true;
+EXIT_GetPubicKeyFromDevice:
+	if (pDevice)
+	{
+		delete pDevice;
+		pDevice = NULL;
+	}
+	else if (pComm)
+	{
+		delete pComm;
+		pComm = NULL;
+	}
+	return bSuccess;
+}
+bool UnlockDevice(CRKImage *pImage,CRKLog *pLog,unsigned char *pKey,unsigned int nKeySize)
+{
+	PBYTE pMd5,pSignMd5;
+	int nSignSize;
+	unsigned int nOutput = 0;
+	//bool bRet;
+	BYTE output[256];
+	string strOutput;
+	(void)nKeySize;
+	printf("in UnlockDevice\n");
+	if ((!pImage)||(!pKey))
+		return false;
+	nSignSize = pImage->GetMd5Data(pMd5,pSignMd5);
+	if (nSignSize==0)
+	{
+		if (pLog)
+			pLog->Record("Get signed info failed.");
+		return false;
+	}
+	//bRet= DoRsa(output,&nOutput,pSignMd5,nSignSize,pKey,nKeySize);
+	//if (!bRet)
+	//{
+	//	if (pLog)
+	//		pLog->Record("DoRsa failed.");
+	//	return false;
+	//}
+	if(pLog)
+	{
+		pLog->PrintBuffer(strOutput,pMd5,32,16);
+		pLog->Record("INFO:Old Md5\n%s",strOutput.c_str());
+		pLog->PrintBuffer(strOutput,output+nOutput-32,32,16);
+		pLog->Record("INFO:New Md5\n%s",strOutput.c_str());
+	}
+	return true;
+	if (memcmp(pMd5,output+nOutput-32,32)==0)
+		return true;
+	else
+		return false;
+}
+
+bool do_rk_firmware_upgrade(char *szFw,void *pCallback,void *pProgressCallback,char *szBootDev)
+{
+	bool bSuccess=false,bRet=false,bLock;
+	int iRet;
+	CRKImage *pImage=NULL;
+	CRKLog *pLog=NULL;
+	CRKAndroidDevice *pDevice=NULL;
+	CRKComm *pComm=NULL;
+	STRUCT_RKDEVICE_DESC device;
+	//BYTE key[514];
+	//UINT nKeySize=514;
+	BYTE uid[RKDEVICE_UID_LEN];
+	tstring strFw = szFw;
+	tstring strUid;
+	(void)szBootDev;
+	g_callback = (UpgradeCallbackFunc)pCallback;
+	g_progress_callback = (UpgradeProgressCallbackFunc)pProgressCallback;
+	if (g_progress_callback)
+		g_progress_callback(0.1,10);
+
+	pLog = new CRKLog();
+	if (!pLog)
+		goto EXIT_UPGRADE;
+	pLog->Record("Start to upgrade firmware...");
+	if (g_callback)
+		g_callback("Start to upgrade firmware... \n");
+	pImage = new CRKImage(strFw,bRet);
+	if (!bRet)
+	{
+		pLog->Record("ERROR:do_rk_firmware_upgrade-->new CRKImage failed!");
+		if (g_callback)
+			g_callback("ERROR:do_rk_firmware_upgrade-->new CRKImage failed! \n");
+		goto EXIT_UPGRADE;
+	}
+	pComm = new CRKUsbComm(pLog);
+	if (!pComm)
+	{
+		pLog->Record("ERROR:do_rk_firmware_upgrade-->new CRKComm failed!");
+		if (g_callback)
+			g_callback("ERROR:do_rk_firmware_upgrade-->new CRKComm failed! \n");
+		goto EXIT_UPGRADE;
+	}
+	if (IsDeviceLock(pComm,bLock))
+	{
+		if (bLock)
+		{
+			bRet = true;
+			pImage = new CRKImage(strFw,bRet);
+			if (!bRet)
+			{
+				pLog->Record("ERROR:do_rk_firmware_upgrade-->new CRKImage with check failed,%s!",szFw);
+				if (g_callback)
+					g_callback("ERROR:do_rk_firmware_upgrade-->new CRKImage with check failed,%s! \n",szFw);
+				goto EXIT_UPGRADE;
+			}
+
+			//bRet = GetPubicKeyFromExternal(szBootDev,pLog,key,nKeySize);
+			//if (!bRet)
+			//{
+			//	if (szBootDev)
+			//		pLog->Record("ERROR:do_rk_firmware_upgrade-->Get PubicKey failed,dev=%s!",szBootDev);
+			//	else
+			//		pLog->Record("ERROR:do_rk_firmware_upgrade-->Get PubicKey failed,dev=NULL!");
+			//	goto EXIT_UPGRADE;
+			//}
+			//if(access("/res/publicKey.bin",F_OK) == 0){
+			//	int fd = open("/tmp/publicKey.bin", O_RDONLY, 0);
+			//	nKeySize = read(fd, key, 514);
+			//}else{
+			//	printf("access /res/publicKey.bin failed!\n");
+			//	goto EXIT_UPGRADE;
+			//}
+			//if (!UnlockDevice(pImage,pLog,key,nKeySize))
+			//{
+			//	pLog->Record("ERROR:do_rk_firmware_upgrade-->UnlockDevice failed!");
+			//	goto EXIT_UPGRADE;
+			//}
+//			if (pCallback)
+//				((UpgradeCallbackFunc)pCallback)("pause");
+
+		}
+		else
+		{
+			pImage = new CRKImage(strFw,bRet);
+			if (!bRet)
+			{
+				pLog->Record("ERROR:do_rk_firmware_upgrade-->new CRKImage failed,%s!",szFw);
+				if (g_callback)
+					g_callback("ERROR:do_rk_firmware_upgrade-->new CRKImage failed,%s! \n",szFw);
+				goto EXIT_UPGRADE;
+			}
+		}
+	}
+	else
+	{
+		pLog->Record("ERROR:do_rk_firmware_upgrade-->IsDeviceLock failed!");
+		if (g_callback)
+			g_callback("ERROR:do_rk_firmware_upgrade-->IsDeviceLock failed! \n");
+		goto EXIT_UPGRADE;
+	}
+	pDevice = new CRKAndroidDevice(device);
+	if (!pDevice)
+	{
+		pLog->Record("ERROR:do_rk_firmware_upgrade-->new CRKAndroidDevice failed!");
+		if (g_callback)
+			g_callback("ERROR:do_rk_firmware_upgrade-->new CRKAndroidDevice failed! \n");
+		goto EXIT_UPGRADE;
+	}
+	pDevice->SetObject(pImage,pComm,pLog);
+	if (CreateUid(uid))
+	{
+		pDevice->Uid = uid;
+		pLog->PrintBuffer(strUid,uid,RKDEVICE_UID_LEN);
+		pLog->Record("uid:%s",strUid.c_str());
+		if (g_callback)
+			g_callback("uid:%s \n",strUid.c_str());
+	}
+	pDevice->m_pCallback = (UpgradeCallbackFunc)pCallback;
+	pDevice->m_pProcessCallback = (UpgradeProgressCallbackFunc)pProgressCallback;
+	pLog->Record("Get FlashInfo...");
+	if (g_callback)
+		g_callback("Get FlashInfo... \n");
+	bRet = pDevice->GetFlashInfo();
+	if (!bRet)
+	{
+		pLog->Record("ERROR:do_rk_firmware_upgrade-->GetFlashInfo failed!");
+		if (g_callback)
+			g_callback("ERROR:do_rk_firmware_upgrade-->GetFlashInfo failed! \n");
+		goto EXIT_UPGRADE;
+	}
+	pLog->Record("IDBlock Preparing...");
+	if (g_callback)
+		g_callback("IDBlock Preparing... \n");
+	iRet = pDevice->PrepareIDB();
+	if (iRet!=ERR_SUCCESS)
+	{
+		pLog->Record("ERROR:do_rk_firmware_upgrade-->PrepareIDB failed!");
+		if (g_callback)
+			g_callback("ERROR:do_rk_firmware_upgrade-->PrepareIDB failed! \n");
+		goto EXIT_UPGRADE;
+	}
+	pLog->Record("IDBlock Writing...");
+	if (g_callback)
+		g_callback("IDBlock Writing... \n");
+	iRet = pDevice->DownloadIDBlock();
+	if (iRet!=ERR_SUCCESS)
+	{
+		pLog->Record("ERROR:do_rk_firmware_upgrade-->DownloadIDBlock failed!");
+		if (g_callback)
+			g_callback("ERROR:do_rk_firmware_upgrade-->DownloadIDBlock failed! \n");
+		goto EXIT_UPGRADE;
+	}
+
+	if (strFw.find(_T(".bin"))!=tstring::npos)
+	{
+		pLog->Record("INFO:do_rk_firmware_upgrade-->Download loader only success!");
+		if (g_callback)
+			g_callback("INFO:do_rk_firmware_upgrade-->Download loader only success! \n");
+		bSuccess = true;
+		return bSuccess;
+	}
+
+	if (g_callback)
+		g_callback("INFO:do_rk_firmware_upgrade begin DownloadImage... ! \n");
+	iRet = pDevice->DownloadImage();
+	if (iRet!=ERR_SUCCESS)
+	{
+		pLog->Record("ERROR:do_rk_firmware_upgrade-->DownloadImage failed!");
+		if (g_callback)
+			g_callback("ERROR:do_rk_firmware_upgrade-->DownloadImage failed! \n");
+		goto EXIT_UPGRADE;
+	}
+
+	bSuccess = true;
+EXIT_UPGRADE:
+	if (bSuccess)
+	{
+		pLog->Record("Finish to upgrade firmware.");
+		if (g_callback)
+			g_callback("Finish to upgrade firmware. \n");
+	}
+	else
+	{
+		pLog->Record("Fail to upgrade firmware!");
+		if (g_callback)
+			g_callback("Fail to upgrade firmware! \n");
+	}
+	if (pLog)
+	{
+		delete pLog;
+		pLog = NULL;
+	}
+	if (pImage)
+	{
+		delete pImage;
+		pImage = NULL;
+	}
+	if (pDevice)
+	{
+		delete pDevice;
+		pDevice = NULL;
+	}
+	else
+	{
+		if (pComm)
+		{
+			delete pComm;
+			pComm = NULL;
+		}
+	}
+	
+	return bSuccess;
+}
+bool do_rk_partition_upgrade(char *szFw,void *pCallback,void *pProgressCallback,char nBoot,char *szBootDev)
+{
+	bool bSuccess=false,bRet=false,bLock;
+	int iRet;
+	CRKImage *pImage=NULL;
+	CRKLog *pLog=NULL;
+	CRKAndroidDevice *pDevice=NULL;
+	CRKComm *pComm=NULL;
+	STRUCT_RKDEVICE_DESC device;
+	BYTE key[514];
+	UINT nKeySize=514;
+	tstring strFw = szFw;
+	vector<int> vecDownloadEntry;
+	vecDownloadEntry.clear();
+	g_callback = (UpgradeCallbackFunc)pCallback;
+	g_progress_callback = (UpgradeProgressCallbackFunc)pProgressCallback;
+	if (g_progress_callback)
+		g_progress_callback(0.1,5);
+	pLog = new CRKLog();
+	if (!pLog)
+		goto EXIT_DOWNLOAD;
+	pLog->Record("Start to upgrade partition...");
+	
+	pComm = new CRKUsbComm(pLog);
+	if (!pComm)
+	{
+		pLog->Record("ERROR:do_rk_partition_upgrade-->new CRKComm failed!");
+		goto EXIT_DOWNLOAD;
+	}
+	if (IsDeviceLock(pComm,bLock))
+	{
+		if (bLock)
+		{
+			bRet = true;
+			pImage = new CRKImage(strFw,bRet);
+			if (!bRet)
+			{
+				pLog->Record("ERROR:do_rk_partition_upgrade-->new CRKImage with check failed,%s!",szFw);
+				goto EXIT_DOWNLOAD;
+			}
+			if(nBoot==0)//get key from nand or emmc
+				bRet = GetPubicKeyFromDevice(pLog,key,nKeySize);
+			else if((nBoot==1)||(nBoot==2))//get key from sd or usb disk
+				bRet = GetPubicKeyFromExternal(szBootDev,pLog,key,nKeySize);
+			else
+				bRet = false;
+			if (!bRet)
+			{
+				if (szBootDev)
+					pLog->Record("ERROR:do_rk_partition_upgrade-->Get PubicKey failed,boot=%d,dev=%s!",nBoot,szBootDev);
+				else
+					pLog->Record("ERROR:do_rk_partition_upgrade-->Get PubicKey failed,boot=%d,dev=NULL!",nBoot);
+				goto EXIT_DOWNLOAD;
+			}
+				
+			if (!UnlockDevice(pImage,pLog,key,nKeySize))
+			{
+				pLog->Record("ERROR:do_rk_partition_upgrade-->UnlockDevice failed!");
+				goto EXIT_DOWNLOAD;
+			}
+//			if (pCallback)
+//				((UpgradeCallbackFunc)pCallback)("pause");
+
+		}
+		else
+		{
+			pImage = new CRKImage(strFw,bRet);
+			if (!bRet)
+			{
+				pLog->Record("ERROR:do_rk_partition_upgrade-->new CRKImage failed,%s!",szFw);
+				goto EXIT_DOWNLOAD;
+			}
+		}
+			
+	}
+	else
+	{
+		pLog->Record("ERROR:do_rk_partition_upgrade-->IsDeviceLock failed!");
+		goto EXIT_DOWNLOAD;
+	}
+	pDevice = new CRKAndroidDevice(device);
+	if (!pDevice)
+	{
+		pLog->Record("ERROR:do_rk_partition_upgrade-->new CRKAndroidDevice failed!");
+		goto EXIT_DOWNLOAD;
+	}
+	pDevice->SetObject(pImage,pComm,pLog);
+	pDevice->m_pCallback = (UpgradeCallbackFunc)pCallback;
+	pDevice->m_pProcessCallback = (UpgradeProgressCallbackFunc)pProgressCallback;
+	bRet = pDevice->GetFlashInfo();
+	if (!bRet)
+	{
+		pLog->Record("ERROR:do_rk_partition_upgrade-->GetFlashInfo failed!");
+		goto EXIT_DOWNLOAD;
+	}
+	iRet = pComm->RKU_ShowNandLBADevice();
+	pLog->Record("Info:do_rk_partition_upgrade-->RKU_ShowNandLBADevice ret=%d",iRet);
+	iRet = pDevice->UpgradePartition();
+	if (iRet!=ERR_SUCCESS)
+	{
+		pLog->Record("ERROR:do_rk_partition_upgrade-->DownloadImage failed!");
+		goto EXIT_DOWNLOAD;
+	}
+	
+	bSuccess = true;
+EXIT_DOWNLOAD:
+	if (bSuccess)
+	{
+		pLog->Record("Finish to upgrade partition.");
+	}
+	else
+	{
+		pLog->Record("Fail to upgrade partition!");
+	}
+	if (pLog)
+	{
+		delete pLog;
+		pLog = NULL;
+	}
+	if (pImage)
+	{
+		delete pImage;
+		pImage = NULL;
+	}
+	if (pDevice)
+	{
+		delete pDevice;
+		pDevice = NULL;
+	}
+	else
+	{
+		if (pComm)
+		{
+			delete pComm;
+			pComm = NULL;
+		}
+	}
+	
+	return bSuccess;
+}
+
+	
+bool do_rk_backup_recovery(void *pCallback,void *pProgressCallback)
+{
+	bool bSuccess=false,bRet;
+	int i,iRet;
+	CRKLog *pLog=NULL;
+	CRKComm *pComm=NULL;
+	char *pParam=NULL;
+	int nParamSize=-1;
+	DWORD dwBackupOffset=0;
+	PARAM_ITEM_VECTOR vecParam;
+	STRUCT_RKIMAGE_HDR hdr;
+	g_callback = (UpgradeCallbackFunc)pCallback;
+	g_progress_callback = (UpgradeProgressCallbackFunc)pProgressCallback;
+	if (g_progress_callback)
+		g_progress_callback(0.1,10);
+	pLog = new CRKLog();
+	if (!pLog)
+		goto EXIT_RECOVERY;
+	pLog->Record("Start to recovery from backup...");
+	
+	pComm = new CRKUsbComm(pLog);
+	if (!pComm)
+	{
+		pLog->Record("ERROR:do_rk_backup_recovery-->new CRKComm failed!");
+		goto EXIT_RECOVERY;
+	}
+	iRet = pComm->RKU_ShowNandLBADevice();
+	pLog->Record("Info:do_rk_backup_recovery-->RKU_ShowNandLBADevice ret=%d",iRet);
+	pLog->Record("Start to read parameter...");
+	bRet = get_parameter_loader(pComm,pParam,nParamSize);
+	if (bRet)
+	{
+		pParam = new char[nParamSize];
+		if (pParam)
+		{
+			bRet = get_parameter_loader(pComm,pParam,nParamSize);	
+		}	
+	}
+	if (!bRet)
+	{
+		pLog->Record("Read parameter failed!");
+		goto EXIT_RECOVERY;
+	}
+	pLog->Record("Start to parse parameter...");
+	bRet = parse_parameter(pParam,vecParam);
+	if (!bRet)
+	{
+		pLog->Record("Parse parameter failed!");
+		goto EXIT_RECOVERY;
+	}
+	for (i=0;i<vecParam.size();i++)
+	{
+		if (strcmp(vecParam[i].szItemName,PARTNAME_BACKUP)==0)
+		{
+			dwBackupOffset = vecParam[i].uiItemOffset;
+			break;
+		}
+	}
+	if (dwBackupOffset==0)
+	{
+		pLog->Record("Get backup offset failed!");
+		goto EXIT_RECOVERY;
+	}
+	pLog->Record("Start to check firmware...");
+	if (!check_fw_header(pComm,dwBackupOffset,&hdr,pLog))
+	{
+		pLog->Record("Check firmware header failed!");
+		goto EXIT_RECOVERY;
+	}
+
+	if (!check_fw_crc(pComm,dwBackupOffset,&hdr,pLog))
+	{
+		pLog->Record("Check firmware crc failed!");
+		goto EXIT_RECOVERY;
+	}
+
+	pLog->Record("Start to write system...");
+	if(!download_backup_image(vecParam,(char*)PARTNAME_SYSTEM,dwBackupOffset,hdr,pComm,pLog))
+	{
+		pLog->Record("write system failed!");
+		goto EXIT_RECOVERY;
+	}
+
+	bSuccess = true;
+EXIT_RECOVERY:
+	if (bSuccess)
+	{
+		pLog->Record("Finish to recovery from backup.");
+	}
+	else
+	{
+		pLog->Record("Fail to recovery from backup!");
+	}
+	if (pParam)
+	{
+		delete []pParam;
+		pParam = NULL;
+	}
+	
+	if (pLog)
+	{
+		delete pLog;
+		pLog = NULL;
+	}
+
+	if (pComm)
+	{
+		delete pComm;
+		pComm = NULL;
+	}
+	
+	return bSuccess;
+	
+}
+
+
+bool do_rk_sparse_update(const char *partitionName, const char *src_path){
+    bool bSuccess=false, bRet;
+    int i, iRet;
+    CRKComm *pComm = NULL;
+    CRKLog *pLog = NULL;
+    PARAM_ITEM_VECTOR vecParam;
+    int nParamSize = -1;
+    char *pParam = NULL;
+    DWORD dwBackupOffset = 0;
+
+    pLog = new CRKLog();
+    if(!pLog)
+        goto EXIT_RECOVERY;
+    pLog->Record("Start to do_rk_sparse_update ...");
+
+    pComm = new CRKUsbComm(pLog);
+    if(!pComm)
+    {
+        pLog->Record("ERROR:do_rk_sparse_update-->new CRKComm failed!");
+        goto EXIT_RECOVERY;
+    }
+
+    iRet = pComm->RKU_ShowNandLBADevice();
+    pLog->Record("Info:do_rk_sparse_update-->RKU_ShowNandLBADevice ret=%d",iRet);
+    pLog->Record("Start to read parameter...");
+    bRet = get_parameter_loader(pComm, pParam, nParamSize);
+
+
+    if(bRet)
+    {
+        pParam = new char[nParamSize];
+        if (pParam)
+        {
+            bRet = get_parameter_loader(pComm, pParam, nParamSize);
+        }
+    }
+
+    if(!bRet)
+    {
+        pLog->Record("Read parameter failed!");
+        goto EXIT_RECOVERY;
+    }
+
+    pLog->Record("Start to parse parameter...");
+    bRet = parse_parameter(pParam, vecParam);
+    if(!bRet)
+    {
+        pLog->Record("Parse parameter failed!");
+        goto EXIT_RECOVERY;
+    }
+
+
+    for(i = 0;i < vecParam.size();i++)
+    {
+        if (strcmp(vecParam[i].szItemName, partitionName) == 0){
+            dwBackupOffset = vecParam[i].uiItemOffset;
+            break;
+        }
+    }
+
+    if(dwBackupOffset == 0){
+        pLog->Record("Get %s offset failed!", partitionName);
+        goto EXIT_RECOVERY;
+    }else{
+        printf("dwBackupOffset is %d.\n", dwBackupOffset);
+        //dwBackupOffset
+        RKSparse *sparse = new RKSparse(src_path);
+        if(sparse->SparseFile_Download(dwBackupOffset, pComm))
+            bSuccess = true;
+        delete sparse;
+    }
+
+
+EXIT_RECOVERY:
+    if (bSuccess)
+    {
+        pLog->Record("Finish to recovery from backup.");
+    }
+    else
+    {
+        pLog->Record("Fail to recovery from backup!");
+    }
+    if (pParam)
+    {
+        delete []pParam;
+        pParam = NULL;
+    }
+
+    if (pLog)
+    {
+        delete pLog;
+        pLog = NULL;
+    }
+
+    if (pComm)
+    {
+        delete pComm;
+        pComm = NULL;
+    }
+
+    return bSuccess;
+}
+bool do_rk_gpt_update(char *szFw,void *pCallback,void *pProgressCallback,char *szBootDev){
+    bool bSuccess=false, bRet;
+    int iRet,iFileSize;
+    CRKImage *pImage=NULL;
+    CRKLog *pLog=NULL;
+    CRKAndroidDevice *pDevice=NULL;
+    CRKComm *pComm=NULL;
+    PARAM_ITEM_VECTOR vecParam;
+    //int nParamSize = -1;
+    //char *pParam = NULL;
+    //DWORD dwBackupOffset = 0;
+    BYTE *m_paramBuffer;
+    BYTE *m_gptBuffer = nullptr;
+    BYTE *backup_gpt;
+    PARAM_ITEM_VECTOR vecItems;
+    CONFIG_ITEM_VECTOR vecUuids;
+    long long  uiFlashSize;  //bit
+    tstring strFw = szFw;
+   // BYTE uid[RKDEVICE_UID_LEN];
+    tstring strUid;
+    //STRUCT_RKDEVICE_DESC device;
+    FILE *m_pFile;
+    DWORD uiActualRead;
+	(void)pCallback;(void)pProgressCallback;(void)szBootDev;
+    pLog->Record("ERROR:strFw======%s",szFw);
+    pLog = new CRKLog();
+    if (!pLog)
+	goto EXIT_UPGRADE;
+    pLog->Record("Start to do_rk_gpt_update ...");
+    pComm = new CRKUsbComm(pLog);
+	if (!pComm)
+	{
+		pLog->Record("ERROR:do_rk_gpt_update-->new CRKComm failed!");
+		goto EXIT_UPGRADE;
+	}
+    uiFlashSize = pComm->m_FlashSize;
+    pLog->Record("uiFlashSize ------------ %lld...",uiFlashSize);
+    if (!m_gptBuffer)
+	{
+		m_gptBuffer = new BYTE[SECTOR_SIZE*67];
+		if (!m_gptBuffer)
+		{
+			if (pLog)
+			{
+				pLog->Record(_T("ERROR:RKA_Gpt_Download-->new memory failed,err=%d)"),errno);
+			}
+			goto EXIT_UPGRADE;
+		}
+	}
+	memset(m_gptBuffer,0,SECTOR_SIZE*67);
+    //ļ
+    m_pFile = fopen(szFw,"rb");
+    fseek(m_pFile, 0, SEEK_END);
+    iFileSize=ftell(m_pFile);
+    m_paramBuffer = new BYTE[iFileSize];
+    memset(m_paramBuffer,0,iFileSize);
+    pLog->Record(_T("iFileSize is %d"),iFileSize);
+    fseek(m_pFile,0,SEEK_SET);
+	uiActualRead = fread(m_paramBuffer,1,iFileSize,m_pFile);
+    if(uiActualRead != iFileSize)
+    {
+        pLog->Record(_T("ERROR:RKA_Gpt_Download-->read parameter file fail,read is %d,total is %d!"),uiActualRead,iFileSize);
+    }
+    bRet = parse_parameter((char *)(m_paramBuffer+8),vecItems);
+	if (!bRet)
+	{
+		if (pLog)
+		{
+			pLog->Record(_T("ERROR:RKA_Gpt_Download-->parse_parameter failed)"));
+		}
+		goto EXIT_UPGRADE;
+	}
+	bRet = get_uuid_from_parameter((char *)(m_paramBuffer+8),vecUuids);
+	backup_gpt = m_gptBuffer+34*SECTOR_SIZE;
+	create_gpt_buffer(m_gptBuffer,vecItems,vecUuids,uiFlashSize/512);
+	memcpy(backup_gpt, m_gptBuffer + 2* SECTOR_SIZE, 32 * SECTOR_SIZE);
+	memcpy(backup_gpt + 32 * SECTOR_SIZE, m_gptBuffer + SECTOR_SIZE, SECTOR_SIZE);
+	prepare_gpt_backup(m_gptBuffer, backup_gpt, uiFlashSize/512);
+	iRet = pComm->RKU_WriteLBA(0,34,m_gptBuffer);
+	if (iRet!=ERR_SUCCESS)
+	{
+		if (pLog)
+		{
+			pLog->Record(_T("ERROR:RKA_Gpt_Download-->write gpt master failed,RetCode(%d)"),iRet);
+		}
+		goto EXIT_UPGRADE;
+	}
+	if (pLog)
+	{
+		pLog->Record(_T("INFO:RKA_Gpt_Download-->write gpt master successfully!"));
+	}
+	iRet = pComm->RKU_WriteLBA(uiFlashSize/512-33,33,backup_gpt);
+	if (iRet!=ERR_SUCCESS)
+	{
+		if (pLog)
+		{
+			pLog->Record(_T("ERROR:RKA_Gpt_Download-->write gpt backup failed,RetCode(%d)"),iRet);
+		}
+		goto EXIT_UPGRADE;
+	}
+	if (pLog)
+	{
+		pLog->Record(_T("INFO:RKA_Gpt_Download-->write gpt backup also successfully!"));
+	}
+    bSuccess = true;
+
+EXIT_UPGRADE:
+	if (bSuccess)
+	{
+		pLog->Record("Finish to upgrade parameter.");
+	}
+	else
+	{
+		pLog->Record("Fail to upgrade parameter!");
+	}
+	if (pLog)
+	{
+		delete pLog;
+		pLog = NULL;
+	}
+	if (pImage)
+	{
+		delete pImage;
+		pImage = NULL;
+	}
+	if (pDevice)
+	{
+		delete pDevice;
+		pDevice = NULL;
+	}
+	else
+	{
+		if (pComm)
+		{
+			delete pComm;
+			pComm = NULL;
+		}
+	}
+	return bSuccess;
+}
+
diff --git a/bootable/recovery/rkupdate/include/rkupdate/DefineHeader.h b/bootable/recovery/rkupdate/include/rkupdate/DefineHeader.h
new file mode 100755
index 0000000000..9ec131dcde
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/DefineHeader.h
@@ -0,0 +1,392 @@
+#ifndef DEFINE_HEADER
+#define DEFINE_HEADER
+#ifndef _U
+#define _U _CTYPE_U
+#endif
+#ifndef _L
+#define _L _CTYPE_L
+#endif
+#ifndef _N
+#define _N _CTYPE_L
+#endif
+#ifndef _X
+#define _X _CTYPE_X
+#endif
+#ifndef _P
+#define _P _CTYPE_P
+#endif
+#ifndef _B
+#define _B _CTYPE_B
+#endif
+#ifndef _C
+#define _C _CTYPE_C
+#endif
+#ifndef _S
+#define _S _CTYPE_S
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <time.h>
+#include <unistd.h>
+//#include <iconv.h>
+#include <wchar.h>
+#include <errno.h>
+#include <ctype.h>
+#include "cutils/properties.h"
+
+#include "Property.hpp"
+#include <list>
+#include <vector>
+//#include <set>
+#include <string>
+#include <sstream>
+#include <algorithm>
+using namespace std;
+
+typedef unsigned int u_int32;
+typedef unsigned char u_int8;
+typedef unsigned char BYTE;
+typedef signed char CHAR;
+typedef BYTE *PBYTE;
+typedef unsigned char UCHAR;
+typedef unsigned short WCHAR;
+typedef unsigned short USHORT;
+typedef unsigned int	UINT;
+typedef unsigned int	DWORD;
+//#ifdef _UNICODE
+//    typedef wchar_t tchar;
+//    typedef wstring tstring;
+//    #define _T(x) L ## x
+//    #define _tcslen  wcslen
+//    #define _tcscpy wcscpy
+//    #define _tcsicmp wcscmp
+//    #define _tcscmp  wcscmp
+//    #define _stprintf swprintf
+//    #define _istprint iswprint
+//#else
+    typedef char tchar;
+    typedef string tstring;
+    #define _T(x) x
+    #define _tcslen  strlen
+    #define _tcscpy strcpy
+    #define _tcsicmp strcasecmp
+    #define _tcscmp  strcmp
+    #define _stprintf sprintf
+    #define _istprint isprint
+//#endif
+typedef enum
+{
+		RKNONE_DEVICE=0,
+		RK27_DEVICE=0x10,
+		RKCAYMAN_DEVICE,
+		RK28_DEVICE=0x20,
+		RK281X_DEVICE,
+		RKPANDA_DEVICE,
+		RKNANO_DEVICE=0x30,
+		RKSMART_DEVICE,
+		RKCROWN_DEVICE=0x40,
+		RK29_DEVICE=0x50,
+		RK292X_DEVICE,
+		RK30_DEVICE=0x60,
+		RK30B_DEVICE,
+		RK31_DEVICE=0x70,
+		RK32_DEVICE=0x80
+}ENUM_RKDEVICE_TYPE;
+typedef enum
+{
+		RK_OS=0,
+		ANDROID_OS=0x1
+}ENUM_OS_TYPE;
+
+typedef enum
+{
+		RKUSB_NONE=0x0,
+		RKUSB_MASKROM=0x01,
+		RKUSB_LOADER=0x02,
+		RKUSB_MSC=0x04
+}ENUM_RKUSB_TYPE;
+typedef enum
+{
+		ENTRY471=1,
+		ENTRY472=2,
+		ENTRYLOADER=4
+}ENUM_RKBOOTENTRY;
+#define  MSC_ANDROID_OPER 0xFF
+typedef enum
+{
+	MSC_NONE_OPER=0x0,
+	MSC_FORMAT_OPER=0x1,
+	MSC_COPY_OPER=0x2,
+	MSC_FORMAT_DATA_OPER=0x4,
+	MSC_COPY_DATA_OPER=0x8
+}ENUM_MSC_OPER;
+typedef enum
+{
+	MISC_MODIFY_NONE=0,
+	MISC_MODIFY_WIPE_ALL,
+	MISC_MODIFY_WIPE_DATA,
+}ENUM_MISC_MODIFY_FLAG;
+typedef enum
+{
+	WF_UPGRADE=1,
+	WF_RESTORE,
+	WF_GETOLDDISKSIZE,
+	WF_READSN,
+	WF_WRITESN,
+	WF_ERASEFLASH,
+	WF_ERASEIDB,
+	WF_GETBLOCKSTATE,
+	WF_READMAC,
+	WF_WRITEMAC,
+	WF_READBT,
+	WF_WRITEBT,
+	WF_READIMEI,
+	WF_WRITEIMEI,
+	WF_READUID,
+	WF_READCUSTOMDATA,
+	WF_WRITECUSTOMDATA,
+	WF_READALLINFO,
+	WF_WRITEALLINFO,
+	WF_DOWNLOADBOOT
+}ENUM_WORKFLOW;
+#pragma pack(1)
+typedef struct  
+{
+	USHORT	usYear;
+	BYTE	ucMonth;
+	BYTE  	ucDay;
+	BYTE  	ucHour;
+	BYTE  	ucMinute;
+	BYTE  	ucSecond;
+}STRUCT_RKTIME,*PSTRUCT_RKTIME;
+typedef struct sparse_header_t {
+  UINT	magic;		/* 0xed26ff3a */
+  USHORT	major_version;	/* (0x1) - reject images with higher major versions */
+  USHORT	minor_version;	/* (0x0) - allow images with higer minor versions */
+  USHORT	file_hdr_sz;	/* 28 bytes for first revision of the file format */
+  USHORT	chunk_hdr_sz;	/* 12 bytes for first revision of the file format */
+  UINT	blk_sz;		/* block size in bytes, must be a multiple of 4 (4096) */
+  UINT	total_blks;	/* total blocks in the non-sparse output image */
+  UINT	total_chunks;	/* total chunks in the sparse input image */
+  UINT	image_checksum; /* CRC32 checksum of the original data, counting "don't care" */
+				/* as 0. Standard 802.3 polynomial, use a Public Domain */
+				/* table implementation */
+} sparse_header;
+
+typedef struct chunk_header_t {
+  USHORT	chunk_type;	/* 0xCAC1 -> raw; 0xCAC2 -> fill; 0xCAC3 -> don't care */
+  USHORT	reserved1;
+  UINT	chunk_sz;	/* in blocks in output image */
+  UINT	total_sz;	/* in bytes of chunk input file including chunk header and data */
+} chunk_header;
+
+#define SPARSE_HEADER_MAGIC	0xed26ff3a
+#define CHUNK_TYPE_RAW		0xCAC1
+#define CHUNK_TYPE_FILL		0xCAC2
+#define CHUNK_TYPE_DONT_CARE	0xCAC3
+#define CHUNK_TYPE_CRC32    0xCAC4
+typedef struct
+{
+	char szItemName[20];
+	UINT uiItemOffset;
+	UINT uiItemSize;
+}STRUCT_PARAM_ITEM,*PSTRUCT_PARAM_ITEM;
+typedef struct
+{
+	char szItemName[20];
+	char szItemValue[256];
+}STRUCT_CONFIG_ITEM,*PSTRUCT_CONFIG_ITEM;
+typedef struct _STRUCT_RKDEVICE_DESC
+{
+	USHORT usVid;
+	USHORT usPid;
+	USHORT usbcdUsb;
+	UINT     uiLocationID;
+	ENUM_RKUSB_TYPE emUsbType;
+	ENUM_RKDEVICE_TYPE emDeviceType;
+	void*   pUsbHandle;
+}STRUCT_RKDEVICE_DESC,*PSTRUCT_RKDEVICE_DESC;
+#pragma pack()
+typedef list<STRUCT_RKDEVICE_DESC> RKDEVICE_DESC_SET;
+typedef RKDEVICE_DESC_SET::iterator device_list_iter;
+typedef vector<tstring> STRING_VECTOR;
+typedef vector<UINT> UINT_VECTOR;
+typedef vector<STRUCT_PARAM_ITEM> PARAM_ITEM_VECTOR;
+typedef vector<STRUCT_CONFIG_ITEM> CONFIG_ITEM_VECTOR;
+//typedef enum
+//{
+//		DOWNLOADBOOT_START=1,
+//		DOWNLOADBOOT_FAIL=2,
+//		DOWNLOADBOOT_PASS=3,
+//		DOWNLOADIDBLOCK_START=4,
+//		DOWNLOADIDBLOCK_FAIL=5,
+//		DOWNLOADIDBLOCK_PASS=6,
+//		DOWNLOADIMAGE_START=7,
+//		DOWNLOADIMAGE_FAIL=8,
+//		DOWNLOADIMAGE_PASS=9,
+//		TESTDEVICE_START=10,
+//		TESTDEVICE_FAIL=11,
+//		TESTDEVICE_PASS=12,
+//		RESETDEVICE_START=13,
+//		RESETDEVICE_FAIL=14,
+//		RESETDEVICE_PASS=15,
+//		FORMATDISK_START=16,
+//		FORMATDISK_FAIL=17,
+//		FORMATDISK_PASS=18,
+//		COPYDATA_START=19,
+//		COPYDATA_FAIL=20,
+//		COPYDATA_PASS=21,
+//		WAITMSC_START=22,
+//		WAITMSC_FAIL=23,
+//		WAITMSC_PASS=24,
+//		WAITLOADER_START=25,
+//		WAITLOADER_FAIL=26,
+//		WAITLOADER_PASS=27,
+//		WAITMASKROM_START=28,
+//		WAITMASKROM_FAIL=29,
+//		WAITMASKROM_PASS=30,
+//		ERASEIDB_START=31,
+//		ERASEIDB_FAIL=32,
+//		ERASEIDB_PASS=33,
+//		SWITCHMSC_START=34,
+//		SWITCHMSC_FAIL=35,
+//		SWITCHMSC_PASS=36,
+//		CHECKCHIP_START=37,
+//		CHECKCHIP_FAIL=38,
+//		CHECKCHIP_PASS=39,
+//		PREPAREIDB_START=40,
+//		PREPAREIDB_FAIL=41,
+//		PREPAREIDB_PASS=42,
+//		MUTEXRESETDEVICE_START=43,
+//		MUTEXRESETDEVICE_FAIL=44,
+//		MUTEXRESETDEVICE_PASS=45,
+//		GETOLDDISKSIZE_START=46,
+//		GETOLDDISKSIZE_FAIL=47,
+//		GETOLDDISKSIZE_PASS=48,
+//		READSN_START=49,
+//		READSN_FAIL=50,
+//		READSN_PASS=51,
+//		WRITESN_START=52,
+//		WRITESN_FAIL=53,
+//		WRITESN_PASS=54,
+//		ERASEALLBLOCKS_START=55,
+//		ERASEALLBLOCKS_FAIL=56,
+//		ERASEALLBLOCKS_PASS=57,
+//		GETBLOCKSTATE_START=58,
+//		GETBLOCKSTATE_FAIL=59,
+//		GETBLOCKSTATE_PASS=60,
+//		GETFLASHINFO_START=61,
+//		GETFLASHINFO_FAIL=62,
+//		GETFLASHINFO_PASS=63,
+//		WRITEBACK_START=64,
+//		WRITEBACK_FAIL=65,
+//		WRITEBACK_PASS=66,
+//		FINDUSERDISK_START=67,
+//		FINDUSERDISK_FAIL=68,
+//		FINDUSERDISK_PASS=69,
+//		SHOWUSERDISK_START=70,
+//		SHOWUSERDISK_FAIL=71,
+//		SHOWUSERDISK_PASS=72,
+//		READMAC_START=73,
+//		READMAC_FAIL=74,
+//		READMAC_PASS=75,
+//		WRITEMAC_START=76,
+//		WRITEMAC_FAIL=77,
+//		WRITEMAC_PASS=78,
+//		READBT_START=79,
+//		READBT_FAIL=80,
+//		READBT_PASS=81,
+//		WRITEBT_START=82,
+//		WRITEBT_FAIL=83,
+//		WRITEBT_PASS=84,
+//		LOWERFORMAT_START=85,
+//		LOWERFORMAT_FAIL=86,
+//		LOWERFORMAT_PASS=87,
+//		READIMEI_START=88,
+//		READIMEI_FAIL=89,
+//		READIMEI_PASS=90,
+//		WRITEIMEI_START=91,
+//		WRITEIMEI_FAIL=92,
+//		WRITEIMEI_PASS=93,
+//		SHOWDATADISK_START=94,
+//		SHOWDATADISK_FAIL=95,
+//		SHOWDATADISK_PASS=96,
+//		FINDDATADISK_START=97,
+//		FINDDATADISK_FAIL=98,
+//		FINDDATADISK_PASS=99,
+//		FORMATDATADISK_START=100,
+//		FORMATDATADISK_FAIL=101,
+//		FORMATDATADISK_PASS=102,
+//		COPYDATADISK_START=103,
+//		COPYDATADISK_FAIL=104,
+//		COPYDATADISK_PASS=105,
+//		READUID_START=106,
+//		READUID_FAIL=107,
+//		READUID_PASS=108,
+//		READCUSTOMDATA_START=109,
+//		READCUSTOMDATA_FAIL=110,
+//		READCUSTOMDATA_PASS=111,
+//		WRITECUSTOMDATA_START=112,
+//		WRITECUSTOMDATA_FAIL=113,
+//		WRITECUSTOMDATA_PASS=114,
+//		SETRESETFLAG_START=115,
+//		SETRESETFLAG_FAIL=116,
+//		SETRESETFLAG_PASS=117,
+//		POWEROFF_START=118,
+//		POWEROFF_FAIL=119,
+//		POWEROFF_PASS=120,
+//		READALLINFO_START=121,
+//		READALLINFO_FAIL=122,
+//		READALLINFO_PASS=123,
+//		WRITEALLINFO_START=124,
+//		WRITEALLINFO_FAIL=125,
+//		WRITEALLINFO_PASS=126,
+//		RESETMSC_START=127,
+//		RESETMSC_FAIL=128,
+//		RESETMSC_PASS=129
+//}ENUM_UPGRADE_PROMPT;
+//typedef enum
+//{
+//	TESTDEVICE_PROGRESS,
+//	DOWNLOADIMAGE_PROGRESS,
+//	CHECKIMAGE_PROGRESS,
+//	TAGBADBLOCK_PROGRESS,
+//	TESTBLOCK_PROGRESS,
+//	ERASEFLASH_PROGRESS,
+//	ERASESYSTEM_PROGRESS,
+//	LOWERFORMAT_PROGRESS,
+//	ERASEUSERDATA_PROGRESS
+//}ENUM_PROGRESS_PROMPT;
+//#define	MSC_SWITCHROCKUSB	0xFFFFFFFE
+//#define MSC_GETVERSIONINFO	0xFFFFFFFF
+//#define MSC_RESETDEVICE		0xFFFFFFFD
+//#define MSC_GETCHIPINFO		0xFFFFFFFC
+//#define MSC_SHOWUSERDISK	0xFFFFFFFB
+//#define MSC_GETDEVIVEUID	0xFFFFFFF7
+//#define MSC_SHOWDATADISK	0xFFFFFFF6
+//#define MSC_GETPRODUCTMODEL 0xFFFFFFF3
+//#define MSC_GETPARAMETER	0xFFFFFFF2
+//#define MSC_GETIDBSECTOR	0xFFFFFFF1
+//#define MSC_GETPRODUCTSN	0xFFFFFFEF
+//typedef enum
+//{
+//	CALL_FIRST,
+//	CALL_MIDDLE,
+//	CALL_LAST
+//}ENUM_CALL_STEP;
+
+//typedef void (*UpgradeStepPromptCB)(DWORD deviceLayer,ENUM_UPGRADE_PROMPT promptID,DWORD oldDeviceLayer);
+//typedef void (*ProgressPromptCB)(DWORD deviceLayer,ENUM_PROGRESS_PROMPT promptID,long long totalValue,long long currentValue,ENUM_CALL_STEP emCall);
+
+//bool WideStringToString(wchar_t *pszSrc,char *&pszDest);
+//bool StringToWideString(char *pszSrc,wchar_t *&pszDest);
+//bool transform(string &src,bool lowercase);
+typedef void (*UpgradeCallbackFunc)(const char* fmt, ...);
+typedef void (*UpgradeProgressCallbackFunc)(float portion, float seconds);
+#endif
diff --git a/bootable/recovery/rkupdate/include/rkupdate/Endian.h b/bootable/recovery/rkupdate/include/rkupdate/Endian.h
new file mode 100755
index 0000000000..10b08074cd
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/Endian.h
@@ -0,0 +1,21 @@
+#ifndef ENDIAN_HEADER
+#define ENDIAN_HEADER
+
+#define Endian16_Swap(value)	(((((unsigned short)value)<< 8) & 0xFF00)|\
+								((((unsigned short)value) >> 8) & 0x00FF))
+
+#define Endian32_Swap(value)	(((((unsigned int)value)<<24) & 0xFF000000) |\
+								((((unsigned int)value)<< 8) & 0x00FF0000) |\
+								((((unsigned int)value)>> 8) & 0x0000FF00) |\
+								((((unsigned int)value)>>24) & 0x000000FF))
+
+#define EndianS16_LtoB(value)              	 ((short)Endian16_Swap(value))
+#define EndianS16_BtoL(value)                ((short)Endian16_Swap(value))
+#define EndianU16_LtoB(value)                ((unsigned short)Endian16_Swap(value))
+#define EndianU16_BtoL(value)                ((unsigned short)Endian16_Swap(value))
+#define EndianS32_LtoB(value)                ((int)Endian32_Swap(value))
+#define EndianS32_BtoL(value)                ((int)Endian32_Swap(value))
+#define EndianU32_LtoB(value)                ((unsigned int)Endian32_Swap(value))
+#define EndianU32_BtoL(value)                ((unsigned int)Endian32_Swap(value))
+
+#endif
diff --git a/bootable/recovery/rkupdate/include/rkupdate/MD5Checksum.h b/bootable/recovery/rkupdate/include/rkupdate/MD5Checksum.h
new file mode 100755
index 0000000000..bf0828e305
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/MD5Checksum.h
@@ -0,0 +1,338 @@
+// MD5Checksum.h: interface for the MD5Checksum class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#ifndef MD5CHECKSUM_HEADER
+#define MD5CHECKSUM_HEADER
+#include "DefineHeader.h"
+
+/****************************************************************************************
+This software is derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm. 
+Incorporation of this statement is a condition of use; please see the RSA
+Data Security Inc copyright notice below:-
+
+Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
+rights reserved.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+
+Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+rights reserved.
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+*****************************************************************************************/
+
+/****************************************************************************************
+This implementation of the RSA MD5 Algorithm was written by Langfine Ltd.
+
+Langfine Ltd makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+In addition to the above, Langfine make no warrant or assurances regarding the 
+accuracy of this implementation of the MD5 checksum algorithm nor any assurances regarding
+its suitability for any purposes.
+
+This implementation may be used freely provided that Langfine is credited
+in a copyright or similar notices (eg, RSA MD5 Algorithm implemented by Langfine
+Ltd.) and provided that the RSA Data Security notices are complied with.
+
+Langfine may be contacted at mail@langfine.com
+*/
+
+/*****************************************************************************************
+CLASS:			CMD5Checksum
+DESCRIPTION:	Implements the "RSA Data Security, Inc. MD5 Message-Digest Algorithm".
+NOTES:			Calculates the RSA MD5 checksum for a file or congiguous array of data.	
+
+Below are extracts from a memo on The MD5 Message-Digest Algorithm by R. Rivest of MIT 
+Laboratory for Computer Science and RSA Data Security, Inc., April 1992. 
+
+   1. Executive Summary
+   This document describes the MD5 message-digest algorithm. The
+   algorithm takes as input a message of arbitrary length and produces
+   as output a 128-bit "fingerprint" or "message digest" of the input.
+   It is conjectured that it is computationally infeasible to produce
+   two messages having the same message digest, or to produce any
+   message having a given prespecified target message digest. The MD5
+   algorithm is intended for digital signature applications, where a
+   large file must be "compressed" in a secure manner before being
+   encrypted with a private (secret) key under a public-key cryptosystem
+   such as RSA.
+   
+   The MD5 algorithm is designed to be quite fast on 32-bit machines. In
+   addition, the MD5 algorithm does not require any large substitution
+   tables; the algorithm can be coded quite compactly.
+   The MD5 algorithm is an extension of the MD4 message-digest algorithm
+   1,2]. MD5 is slightly slower than MD4, but is more "conservative" in
+   design. MD5 was designed because it was felt that MD4 was perhaps
+   being adopted for use more quickly than justified by the existing
+   critical review; because MD4 was designed to be exceptionally fast,
+   it is "at the edge" in terms of risking successful cryptanalytic
+   attack. MD5 backs off a bit, giving up a little in speed for a much
+   greater likelihood of ultimate security. It incorporates some
+   suggestions made by various reviewers, and contains additional
+   optimizations. The MD5 algorithm is being placed in the public domain
+   for review and possible adoption as a standard.
+
+
+   2. Terminology and Notation
+   In this document a "word" is a 32-bit quantity and a "byte" is an
+   eight-bit quantity. A sequence of bits can be interpreted in a
+   natural manner as a sequence of bytes, where each consecutive group
+   of eight bits is interpreted as a byte with the high-order (most
+   significant) bit of each byte listed first. Similarly, a sequence of
+   bytes can be interpreted as a sequence of 32-bit words, where each
+   consecutive group of four bytes is interpreted as a word with the
+   low-order (least significant) byte given first.
+   Let x_i denote "x sub i". If the subscript is an expression, we
+   surround it in braces, as in x_{i+1}. Similarly, we use ^ for
+   superscripts (exponentiation), so that x^i denotes x to the i-th   power.
+   Let the symbol "+" denote addition of words (i.e., modulo-2^32
+   addition). Let X <<< s denote the 32-bit value obtained by circularly
+   shifting (rotating) X left by s bit positions. Let not(X) denote the
+   bit-wise complement of X, and let X v Y denote the bit-wise OR of X
+   and Y. Let X xor Y denote the bit-wise XOR of X and Y, and let XY
+   denote the bit-wise AND of X and Y.
+
+
+   3. MD5 Algorithm Description
+   We begin by supposing that we have a b-bit message as input, and that
+   we wish to find its message digest. Here b is an arbitrary
+   nonnegative integer; b may be zero, it need not be a multiple of
+   eight, and it may be arbitrarily large. We imagine the bits of the
+   message written down as follows:          m_0 m_1 ... m_{b-1}
+   The following five steps are performed to compute the message digest
+   of the message.
+   
+   3.1 Step 1. Append Padding Bits
+   The message is "padded" (extended) so that its length (in bits) is
+   congruent to 448, modulo 512. That is, the message is extended so
+   that it is just 64 bits shy of being a multiple of 512 bits long.
+   Padding is always performed, even if the length of the message is
+   already congruent to 448, modulo 512.
+   Padding is performed as follows: a single "1" bit is appended to the
+   message, and then "0" bits are appended so that the length in bits of
+   the padded message becomes congruent to 448, modulo 512. In all, at
+   least one bit and at most 512 bits are appended.
+
+   3.2 Step 2. Append Length
+   A 64-bit representation of b (the length of the message before the
+   padding bits were added) is appended to the result of the previous
+   step. In the unlikely event that b is greater than 2^64, then only
+   the low-order 64 bits of b are used. (These bits are appended as two
+   32-bit words and appended low-order word first in accordance with the
+   previous conventions.)
+   At this point the resulting message (after padding with bits and with
+   b) has a length that is an exact multiple of 512 bits. Equivalently,
+   this message has a length that is an exact multiple of 16 (32-bit)
+   words. Let M[0 ... N-1] denote the words of the resulting message,
+   where N is a multiple of 16.
+   
+   3.3 Step 3. Initialize MD Buffer
+   A four-word buffer (A,B,C,D) is used to compute the message digest.
+   Here each of A, B, C, D is a 32-bit register. These registers are
+   initialized to the following values in hexadecimal, low-order bytes   first):
+          word A: 01 23 45 67          word B: 89 ab cd ef
+          word C: fe dc ba 98          word D: 76 54 32 10
+
+   3.4 Step 4. Process Message in 16-Word Blocks
+   We first define four auxiliary functions that each take as input
+   three 32-bit words and produce as output one 32-bit word.
+          F(X,Y,Z) = XY v not(X) Z          G(X,Y,Z) = XZ v Y not(Z)
+          H(X,Y,Z) = X xor Y xor Z          I(X,Y,Z) = Y xor (X v not(Z))
+   In each bit position F acts as a conditional: if X then Y else Z.
+   The function F could have been defined using + instead of v since XY
+   and not(X)Z will never have 1's in the same bit position.) It is
+   interesting to note that if the bits of X, Y, and Z are independent
+   and unbiased, the each bit of F(X,Y,Z) will be independent and   unbiased.
+   The functions G, H, and I are similar to the function F, in that they
+   act in "bitwise parallel" to produce their output from the bits of X,
+   Y, and Z, in such a manner that if the corresponding bits of X, Y,
+   and Z are independent and unbiased, then each bit of G(X,Y,Z),
+   H(X,Y,Z), and I(X,Y,Z) will be independent and unbiased. Note that
+   the function H is the bit-wise "xor" or "parity" function of its   inputs.
+   This step uses a 64-element table T[1 ... 64] constructed from the
+   sine function. Let T[i] denote the i-th element of the table, which
+   is equal to the integer part of 4294967296 times abs(sin(i)), where i
+   is in radians. The elements of the table are given in the appendix.
+   Do the following:   
+   
+	 //Process each 16-word block.
+     For i = 0 to N/16-1 do     // Copy block i into X.      
+		For j = 0 to 15 do
+			Set X[j] to M[i*16+j].     
+        end //of loop on j
+
+		 // Save A as AA, B as BB, C as CC, and D as DD.
+		 AA = A     BB = B
+		 CC = C     DD = D     
+
+		 // Round 1.
+		 // Let [abcd k s i] denote the operation
+		 // a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s).
+		 // Do the following 16 operations.
+		 [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
+		 [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
+		 [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
+		 [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]
+
+		 // Round 2.      
+		 // Let [abcd k s i] denote the operation 
+		 // a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s).
+		 // Do the following 16 operations.
+		 [ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
+		 [ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
+		 [ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
+		 [ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]
+
+		 // Round 3.      
+		 // Let [abcd k s t] denote the operation
+		 // a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s).
+		 // Do the following 16 operations.
+		 [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
+		 [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
+		 [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
+		 [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]
+
+		 // Round 4. 
+		 // Let [abcd k s t] denote the operation
+		 // a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s).
+		 // Do the following 16 operations.
+		 [ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
+		 [ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
+		 [ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
+		 [ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]
+
+		 // Then perform the following additions. (That is increment each
+		 //   of the four registers by the value it had before this block
+		 //   was started.) 
+		A = A + AA     B = B + BB     C = C + CC  D = D + DD   
+
+	end // of loop on i
+
+   3.5 Step 5. Output
+   The message digest produced as output is A, B, C, D. That is, we
+   begin with the low-order byte of A, and end with the high-order byte of D.
+   This completes the description of MD5.
+   
+   Summary
+   The MD5 message-digest algorithm is simple to implement, and provides
+   a "fingerprint" or message digest of a message of arbitrary length.
+   It is conjectured that the difficulty of coming up with two messages
+   having the same message digest is on the order of 2^64 operations,
+   and that the difficulty of coming up with any message having a given
+   message digest is on the order of 2^128 operations. The MD5 algorithm
+   has been carefully scrutinized for weaknesses. It is, however, a
+   relatively new algorithm and further security analysis is of course
+   justified, as is the case with any new proposal of this sort.
+
+
+   5. Differences Between MD4 and MD5
+   The following are the differences between MD4 and MD5:
+       1.   A fourth round has been added.
+       2.   Each step now has a unique additive constant.
+       3.   The function g in round 2 was changed from (XY v XZ v YZ) to
+       (XZ v Y not(Z)) to make g less symmetric.
+       4.   Each step now adds in the result of the previous step.  This
+       promotes a faster "avalanche effect".
+       5.   The order in which input words are accessed in rounds 2 and
+       3 is changed, to make these patterns less like each other.
+       6.   The shift amounts in each round have been approximately
+       optimized, to yield a faster "avalanche effect." The shifts in
+       different rounds are distinct.
+
+   References
+   [1] Rivest, R., "The MD4 Message Digest Algorithm", RFC 1320, MIT and
+       RSA Data Security, Inc., April 1992.
+   [2] Rivest, R., "The MD4 message digest algorithm", in A.J.  Menezes
+       and S.A. Vanstone, editors, Advances in Cryptology - CRYPTO '90
+       Proceedings, pages 303-311, Springer-Verlag, 1991.
+   [3] CCITT Recommendation X.509 (1988), "The Directory -
+       Authentication Framework."APPENDIX A - Reference Implementation
+
+
+   The level of security discussed in this memo is considered to be
+   sufficient for implementing very high security hybrid digital-
+   signature schemes based on MD5 and a public-key cryptosystem.
+   Author's Address
+   Ronald L. Rivest   Massachusetts Institute of Technology
+   Laboratory for Computer Science   NE43-324   545 Technology Square
+   Cambridge, MA  02139-1986   Phone: (617) 253-5880
+   EMail: rivest@theory.lcs.mit.edu
+
+
+*****************************************************************************************/
+class CMD5Checksum  
+{
+public:
+	//interface functions for the RSA MD5 calculation
+	static tstring GetMD5(BYTE* pBuf, UINT nLength);
+	static tstring GetMD5(FILE *File,long long nLength);
+	static tstring GetMD5(const tstring& strFilePath,long long nLength);
+	static unsigned char * _GetMD5(BYTE* pBuf, UINT nLength);
+    static unsigned char * _GetMD5(FILE *File,long long nLength);
+    static unsigned char * _GetMD5(const tstring& strFilePath,long long nLength);
+protected:
+	//constructor/destructor
+	CMD5Checksum();
+	virtual ~CMD5Checksum() 
+	{
+		if (m_pBuffer)
+		{
+			delete []m_pBuffer;
+			m_pBuffer = NULL;
+		}
+	};
+
+	//RSA MD5 implementation
+	void Transform(BYTE Block[64]);
+	void Update(BYTE* Input, UINT nInputLen);
+	tstring Final();
+	unsigned char * FinalChar();
+	inline DWORD RotateLeft(DWORD x, int n);
+	inline void FF( DWORD& A, DWORD B, DWORD C, DWORD D, DWORD X, DWORD S, DWORD T);
+	inline void GG( DWORD& A, DWORD B, DWORD C, DWORD D, DWORD X, DWORD S, DWORD T);
+	inline void HH( DWORD& A, DWORD B, DWORD C, DWORD D, DWORD X, DWORD S, DWORD T);
+	inline void II( DWORD& A, DWORD B, DWORD C, DWORD D, DWORD X, DWORD S, DWORD T);
+
+	//utility functions
+	void DWordToByte(BYTE* Output, DWORD* Input, UINT nLength);
+	void ByteToDWord(DWORD* Output, BYTE* Input, UINT nLength);
+
+private:
+	PBYTE m_pBuffer;
+	BYTE  m_lpszBuffer[64];		//input buffer
+	UINT m_nCount[2];			//number of bits, modulo 2^64 (lsb first)
+	UINT m_lMD5[4];			//MD5 checksum
+};
+
+#endif // !defined(AFX_MD5CHECKSUM_H__2BC7928E_4C15_11D3_B2EE_A4A60E20D2C3__INCLUDED_)
+
+
+
+
+
+
+
+
diff --git a/bootable/recovery/rkupdate/include/rkupdate/MD5ChecksumDefines.h b/bootable/recovery/rkupdate/include/rkupdate/MD5ChecksumDefines.h
new file mode 100755
index 0000000000..81c7bac365
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/MD5ChecksumDefines.h
@@ -0,0 +1,106 @@
+//MD5ChecksumDefines.h : MD5 Checksum constants
+
+//Magic initialization constants
+#define MD5_INIT_STATE_0 0x67452301
+#define MD5_INIT_STATE_1 0xefcdab89
+#define MD5_INIT_STATE_2 0x98badcfe
+#define MD5_INIT_STATE_3 0x10325476
+
+//Constants for Transform routine.
+#define MD5_S11  7
+#define MD5_S12 12
+#define MD5_S13 17
+#define MD5_S14 22
+#define MD5_S21  5
+#define MD5_S22  9
+#define MD5_S23 14
+#define MD5_S24 20
+#define MD5_S31  4
+#define MD5_S32 11
+#define MD5_S33 16
+#define MD5_S34 23
+#define MD5_S41  6
+#define MD5_S42 10
+#define MD5_S43 15
+#define MD5_S44 21
+
+//Transformation Constants - Round 1
+#define MD5_T01  0xd76aa478 //Transformation Constant 1 
+#define MD5_T02  0xe8c7b756 //Transformation Constant 2
+#define MD5_T03  0x242070db //Transformation Constant 3
+#define MD5_T04  0xc1bdceee //Transformation Constant 4
+#define MD5_T05  0xf57c0faf //Transformation Constant 5
+#define MD5_T06  0x4787c62a //Transformation Constant 6
+#define MD5_T07  0xa8304613 //Transformation Constant 7
+#define MD5_T08  0xfd469501 //Transformation Constant 8
+#define MD5_T09  0x698098d8 //Transformation Constant 9
+#define MD5_T10  0x8b44f7af //Transformation Constant 10
+#define MD5_T11  0xffff5bb1 //Transformation Constant 11
+#define MD5_T12  0x895cd7be //Transformation Constant 12
+#define MD5_T13  0x6b901122 //Transformation Constant 13
+#define MD5_T14  0xfd987193 //Transformation Constant 14
+#define MD5_T15  0xa679438e //Transformation Constant 15
+#define MD5_T16  0x49b40821 //Transformation Constant 16
+
+//Transformation Constants - Round 2
+#define MD5_T17  0xf61e2562 //Transformation Constant 17
+#define MD5_T18  0xc040b340 //Transformation Constant 18
+#define MD5_T19  0x265e5a51 //Transformation Constant 19
+#define MD5_T20  0xe9b6c7aa //Transformation Constant 20
+#define MD5_T21  0xd62f105d //Transformation Constant 21
+#define MD5_T22  0x02441453 //Transformation Constant 22
+#define MD5_T23  0xd8a1e681 //Transformation Constant 23
+#define MD5_T24  0xe7d3fbc8 //Transformation Constant 24
+#define MD5_T25  0x21e1cde6 //Transformation Constant 25
+#define MD5_T26  0xc33707d6 //Transformation Constant 26
+#define MD5_T27  0xf4d50d87 //Transformation Constant 27
+#define MD5_T28  0x455a14ed //Transformation Constant 28
+#define MD5_T29  0xa9e3e905 //Transformation Constant 29
+#define MD5_T30  0xfcefa3f8 //Transformation Constant 30
+#define MD5_T31  0x676f02d9 //Transformation Constant 31
+#define MD5_T32  0x8d2a4c8a //Transformation Constant 32
+
+//Transformation Constants - Round 3
+#define MD5_T33  0xfffa3942 //Transformation Constant 33
+#define MD5_T34  0x8771f681 //Transformation Constant 34
+#define MD5_T35  0x6d9d6122 //Transformation Constant 35
+#define MD5_T36  0xfde5380c //Transformation Constant 36
+#define MD5_T37  0xa4beea44 //Transformation Constant 37
+#define MD5_T38  0x4bdecfa9 //Transformation Constant 38
+#define MD5_T39  0xf6bb4b60 //Transformation Constant 39
+#define MD5_T40  0xbebfbc70 //Transformation Constant 40
+#define MD5_T41  0x289b7ec6 //Transformation Constant 41
+#define MD5_T42  0xeaa127fa //Transformation Constant 42
+#define MD5_T43  0xd4ef3085 //Transformation Constant 43
+#define MD5_T44  0x04881d05 //Transformation Constant 44
+#define MD5_T45  0xd9d4d039 //Transformation Constant 45
+#define MD5_T46  0xe6db99e5 //Transformation Constant 46
+#define MD5_T47  0x1fa27cf8 //Transformation Constant 47
+#define MD5_T48  0xc4ac5665 //Transformation Constant 48
+
+//Transformation Constants - Round 4
+#define MD5_T49  0xf4292244 //Transformation Constant 49
+#define MD5_T50  0x432aff97 //Transformation Constant 50
+#define MD5_T51  0xab9423a7 //Transformation Constant 51
+#define MD5_T52  0xfc93a039 //Transformation Constant 52
+#define MD5_T53  0x655b59c3 //Transformation Constant 53
+#define MD5_T54  0x8f0ccc92 //Transformation Constant 54
+#define MD5_T55  0xffeff47d //Transformation Constant 55
+#define MD5_T56  0x85845dd1 //Transformation Constant 56
+#define MD5_T57  0x6fa87e4f //Transformation Constant 57
+#define MD5_T58  0xfe2ce6e0 //Transformation Constant 58
+#define MD5_T59  0xa3014314 //Transformation Constant 59
+#define MD5_T60  0x4e0811a1 //Transformation Constant 60
+#define MD5_T61  0xf7537e82 //Transformation Constant 61
+#define MD5_T62  0xbd3af235 //Transformation Constant 62
+#define MD5_T63  0x2ad7d2bb //Transformation Constant 63
+#define MD5_T64  0xeb86d391 //Transformation Constant 64
+
+
+//Null data (except for first BYTE) used to finalise the checksum calculation
+static unsigned char PADDING[64] = {
+  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
diff --git a/bootable/recovery/rkupdate/include/rkupdate/Property.hpp b/bootable/recovery/rkupdate/include/rkupdate/Property.hpp
new file mode 100755
index 0000000000..668062123d
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/Property.hpp
@@ -0,0 +1,94 @@
+//-- Property.hpp --
+
+/*--------------------------------------------------------------------------
+                         Class Library
+
+     Copyrights Emad Barsoum (ebarsoum@msn.com) 2003. All rights reserved.
+     ________________________________________________________________
+
+
+     PROJECT   : General
+     MODULE    : property
+     FILENAME  : Property.hpp
+	   BUILD     : 1
+
+     History of Modifications:
+
+     Date(dd/mm/yyyy)Person                Description
+     ----            ------                -----------
+     25/03/2003      Emad Barsoum          Initial design and coding
+
+     CLASS NAME: property
+     VERSION: 1.0
+
+     DESCRIPTION:
+        This class try to simulate property for C++, using template technique.
+
+     LICENSE:
+        You are free to change or modify or redistribute the code, just keep the header.
+      And you can use this class in any application you want without any warranty.
+*/
+#include <assert.h>
+#include <stdlib.h>
+#if !defined INC_PROPERTY_HPP
+#define INC_PROPERTY_HPP
+
+#define READ_ONLY 1
+#define WRITE_ONLY 2
+#define READ_WRITE 3
+
+template<typename Container, typename ValueType, int nPropType>
+class property
+{
+public:
+  property()
+  {
+    m_cObject = NULL;
+    Set = NULL;
+    Get = NULL;
+  }
+  //-- This to set a pointer to the class that contain the property --
+  void setContainer(Container* cObject)
+  {
+    m_cObject = cObject;
+  }
+  //-- Set the set member function that will change the value --
+  void setter(void (Container::*pSet)(ValueType value))
+  {
+    if((nPropType == WRITE_ONLY) || (nPropType == READ_WRITE))
+      Set = pSet;
+    else
+      Set = NULL;
+  }
+  //-- Set the get member function that will retrieve the value --
+  void getter(ValueType (Container::*pGet)())
+  {
+    if((nPropType == READ_ONLY) || (nPropType == READ_WRITE))
+     Get = pGet;
+    else
+      Get = NULL;
+  }
+  //-- Overload the '=' sign to set the value using the set member --
+  ValueType operator =(const ValueType& value)
+  {
+    assert(m_cObject != NULL);
+    assert(Set != NULL);
+    (m_cObject->*Set)(value);    
+    return value;
+  }
+
+  //-- To make possible to cast the property class to the internal type --
+  operator ValueType()
+  {
+    assert(m_cObject != NULL);
+    assert(Get != NULL);
+    return (m_cObject->*Get)();
+  }
+
+private:
+  Container* m_cObject;//-- Pointer to the module that contain the property --
+  void (Container::*Set)(ValueType value);//-- Pointer to set member function --
+  ValueType (Container::*Get)();//-- Pointer to get member function --
+};
+
+#endif
\ No newline at end of file
diff --git a/bootable/recovery/rkupdate/include/rkupdate/RKAndroidDevice.h b/bootable/recovery/rkupdate/include/rkupdate/RKAndroidDevice.h
new file mode 100755
index 0000000000..989a891e37
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/RKAndroidDevice.h
@@ -0,0 +1,286 @@
+#ifndef RKANDROIDDEVICE_HEADER
+#define RKANDROIDDEVICE_HEADER
+#include "RKDevice.h"
+//#include <fs_mgr.h>
+//#include "make_ext4fs.h"
+//#include "wipe.h"
+#include "cutils/properties.h"
+#include <selinux/selinux.h>
+#include <selinux/label.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <fstream>
+#include "gpt.h"
+#include "otautil/roots.h"
+#pragma pack(1)
+typedef	struct
+{
+	DWORD	dwTag;
+	BYTE	reserved[4];
+	UINT	uiRc4Flag;
+	USHORT	usBootCode1Offset;
+	USHORT	usBootCode2Offset;
+	BYTE	reserved1[490];
+	USHORT  usBootDataSize;
+	USHORT	usBootCodeSize;
+	USHORT	usCrc;
+}RKANDROID_IDB_SEC0,*PRKANDROID_IDB_SEC0;
+
+typedef struct
+{
+	USHORT  usSysReservedBlock;
+	USHORT  usDisk0Size;
+	USHORT  usDisk1Size;
+	USHORT  usDisk2Size;
+	USHORT  usDisk3Size;
+	UINT	uiChipTag;
+	UINT	uiMachineId;
+	USHORT	usLoaderYear;
+	USHORT	usLoaderDate;
+	USHORT	usLoaderVer;
+	USHORT  usLastLoaderVer;
+	USHORT  usReadWriteTimes;
+	DWORD	dwFwVer;
+	USHORT  usMachineInfoLen;
+	UCHAR	ucMachineInfo[30];
+	USHORT	usManufactoryInfoLen;
+	UCHAR	ucManufactoryInfo[30];
+	USHORT	usFlashInfoOffset;
+	USHORT	usFlashInfoLen;
+	UCHAR	reserved[384];
+	UINT	uiFlashSize;//sectorΪλ
+	BYTE    reserved1;
+	BYTE    bAccessTime;
+	USHORT  usBlockSize;
+	BYTE    bPageSize;
+	BYTE    bECCBits;
+	BYTE    reserved2[8];
+	USHORT  usIdBlock0;
+	USHORT  usIdBlock1;
+	USHORT  usIdBlock2;
+	USHORT  usIdBlock3;
+	USHORT  usIdBlock4;
+}RKANDROID_IDB_SEC1,*PRKANDROID_IDB_SEC1;
+
+typedef struct
+{
+	USHORT  usInfoSize;
+	BYTE    bChipInfo[CHIPINFO_LEN];
+	BYTE    reserved[RKANDROID_SEC2_RESERVED_LEN];
+	char    szVcTag[3];
+	USHORT  usSec0Crc;
+	USHORT  usSec1Crc;
+	UINT	uiBootCodeCrc;
+	USHORT  usSec3CustomDataOffset;
+	USHORT  usSec3CustomDataSize;
+	char    szCrcTag[4];
+	USHORT  usSec3Crc;
+}RKANDROID_IDB_SEC2,*PRKANDROID_IDB_SEC2;
+
+typedef struct
+{
+    	USHORT  usSNSize;
+    	BYTE    sn[RKDEVICE_SN_LEN];
+	BYTE    reserved[RKANDROID_SEC3_RESERVED_LEN];
+	BYTE	imeiSize;
+	BYTE	imei[RKDEVICE_IMEI_LEN];
+	BYTE	uidSize;
+	BYTE	uid[RKDEVICE_UID_LEN];
+	BYTE    blueToothSize;
+	BYTE	blueToothAddr[RKDEVICE_BT_LEN];
+	BYTE	macSize;
+	BYTE	macAddr[RKDEVICE_MAC_LEN];
+}RKANDROID_IDB_SEC3,*PRKANDROID_IDB_SEC3;
+typedef struct
+{
+	DWORD  dwTag;
+	USHORT usSnSize;
+	BYTE   btSnData[RKDEVICE_SN_LEN];
+	BYTE   btReserve[RKANDROID_SEC3_RESERVED_LEN-6];
+	BYTE   btImeiSize;
+	BYTE   btImeiData[RKDEVICE_IMEI_LEN];
+	BYTE   btUidSize;
+	BYTE   btUidData[RKDEVICE_UID_LEN];
+	BYTE   btBlueToothSize;
+	BYTE   btBlueToothData[RKDEVICE_BT_LEN];
+	BYTE   btMacSize;
+	BYTE   btMacData[RKDEVICE_MAC_LEN];
+	USHORT usCrc;
+	BYTE   btSpare[SPARE_SIZE];
+}STRUCT_RKANDROID_WBBUFFER,*PSTRUCT_RKANDROID_WBBUFFER;
+const BYTE Wipe_Data[]={0x72,0x65,0x63,0x6F,0x76,0x65,
+						0x72,0x79,0x0A,0x2D,0x2D,0x77,
+						0x69,0x70,0x65,0x5F,0x64,0x61,0x74,0x61,0x00};
+const BYTE Wipe_All[]={0x72,0x65,0x63,0x6F,0x76,0x65,
+						0x72,0x79,0x0A,0x2D,0x2D,0x77,
+						0x69,0x70,0x65,0x5F,0x61,0x6C,0x6C,0x00};
+#define LBA_TRANSFER_SIZE		16*1024
+#define LBA_LOOP_SIZE	1024*1024
+
+#define MAX_PACKAGE_FILES			16
+#define RKIMAGE_TAG				0x46414B52
+#define PARTNAME_BOOTLOADER		"bootloader"
+#define PARTNAME_PARAMETER		"parameter"
+#define PARTNAME_KERNEL			"kernel"
+#define PARTNAME_BOOT			"boot"
+#define PARTNAME_RECOVERY		"recovery"
+#define PARTNAME_SYSTEM			"system"
+#define PARTNAME_MISC			"misc"
+#define PARTNAME_BACKUP			"backup"
+#define PARTNAME_USERDATA		"userdata"
+#define PARTNAME_USER			"user"
+
+#define MAX_MANUFACTURER		60
+#define MAX_MACHINE_INFO		30
+#define MAX_MACHINE_MODEL		34
+#define RELATIVE_PATH			60
+#define PART_NAME				32
+typedef struct
+{
+	char name[PART_NAME];// 
+	char file[RELATIVE_PATH];// ·ȡļʱõ
+	unsigned int part_size;//ռ
+	unsigned int offset;// ļImageеƫ
+	unsigned int flash_offset;// дFlashеλ(sectorΪλ)
+	unsigned int usespace;// ļռÿռ䣨PAGE)
+	unsigned int size;// ֽʵļС
+}STRUCT_RKIMAGE_ITEM,*PSTRUCT_RKIMAGE_ITEM;
+
+typedef struct tagRKIMAGE_HDR
+{
+	unsigned int tag;
+	unsigned int size;// ļСĩβCRCУ
+	char machine_model[MAX_MACHINE_MODEL];
+	char machine_info[MAX_MACHINE_INFO];
+	char manufacturer[MAX_MANUFACTURER];
+	unsigned int dwFWVer;
+	int item_count;
+	STRUCT_RKIMAGE_ITEM item[MAX_PACKAGE_FILES];
+}STRUCT_RKIMAGE_HDR,*PSTRUCT_RKIMAGE_HDR;
+typedef struct
+{
+	UINT uiTag;
+	UINT uiVer;
+	UINT uiFlag;
+	UINT uiHeadSize;
+	UINT uiReserved[3];
+	USHORT usHashBit;
+	USHORT usRsaBit;
+	BYTE nFactor[256];
+	BYTE eFactor[256];
+	BYTE cFactor[256];
+	BYTE dataHash[32];
+	UINT dataLoadAddr;
+	BYTE codeHash[32];
+	UINT codeLoadAddr;
+	BYTE headSignValue[256];
+}RK_SECURE_HEADER,*PRK_SECURE_HEADER;
+
+#if 0
+static int exec_cmd(const char* path, char* const argv[]) {
+    int status;
+    pid_t child;
+    if ((child = vfork()) == 0) {
+        execv(path, argv);
+        _exit(-1);
+    }
+    waitpid(child, &status, 0);
+    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
+    }
+    return WEXITSTATUS(status);
+}
+#endif
+#pragma pack()
+
+class CRKAndroidDevice :public CRKDevice
+{
+public:
+	static bool bGptFlag;
+	static bool bOnlyLoader;
+	virtual int PrepareIDB();
+	virtual int DownloadIDBlock();
+	virtual int DownloadImage();
+	virtual int EraseIDB();
+	virtual int EraseAllBlocks();
+	virtual bool BufferWriteBack();
+	CRKAndroidDevice(STRUCT_RKDEVICE_DESC &device);
+	virtual ~CRKAndroidDevice();
+	int UpgradePartition();
+	bool GetPublicKey(unsigned char *pKey,unsigned int &nKeySize);
+	UpgradeCallbackFunc m_pCallback;
+	UpgradeProgressCallbackFunc m_pProcessCallback;
+protected:
+private:
+	DWORD  m_dwLoaderSize;
+	DWORD  m_dwLoaderDataSize;
+	DWORD  m_dwBackupOffset;
+	char   m_oldIDBCounts;
+	USHORT m_usFlashDataSec;
+	USHORT m_usFlashBootSec;
+	BYTE   *m_paramBuffer;
+	BYTE *m_gptBuffer;
+	UINT   m_uiParamFileSize;
+	UINT   m_uiResevedBlockSize;
+	RKANDROID_IDB_SEC0 *m_oldSec0;
+	RKANDROID_IDB_SEC1 *m_oldSec1;
+	RKANDROID_IDB_SEC2 *m_oldSec2;
+	RKANDROID_IDB_SEC3 *m_oldSec3;
+	UINT m_uiLBATimes;
+	UINT m_uiUserSectors;
+
+	bool GetLoaderSize();
+	bool GetLoaderDataSize();
+	bool GetOldSectorData();
+	bool CalcIDBCount();
+	bool IsExistSector3Crc(PRKANDROID_IDB_SEC2 pSec);
+
+	virtual bool FindBackupBuffer();
+	virtual CHAR FindIDBlock(char pos,char &IDBlockPos);
+	virtual char FindAllIDB();
+	virtual bool ReserveIDBlock(char iBlockIndex=0,char iIdblockPos=0);
+	virtual bool OffsetIDBlock(char pos);
+	virtual bool MakeSector0(PBYTE pSector);
+	virtual void MakeSector1(PBYTE pSector);
+	virtual bool MakeSector2(PBYTE pSector);
+	virtual bool MakeSector3(PBYTE pSector);
+	virtual int MakeIDBlockData(PBYTE lpIDBlock);
+	virtual bool  MakeSpareData(PBYTE lpIDBlock,DWORD dwSectorNum,PBYTE lpSpareBuffer);
+	virtual int WriteIDBlock(PBYTE lpIDBlock,DWORD dwSectorNum,bool bErase);
+
+	bool RKA_Param_Download(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte);
+	bool RKA_Param_Check(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte);
+	bool RKA_File_Download(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte);
+	bool RKA_File_Check(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte);
+	bool RKA_Gpt_Download(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte);
+	bool RKA_Gpt_Check(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte);
+
+	bool GetParameterPartSize(STRUCT_RKIMAGE_ITEM &paramItem);
+	bool ParsePartitionInfo(string &strPartInfo,string &strName,UINT &uiOffset,UINT &uiLen);
+	bool MakeParamFileBuffer(STRUCT_RKIMAGE_ITEM &entry);
+	bool CheckParamPartSize(STRUCT_RKIMAGE_HDR &rkImageHead,int iParamPos);
+	bool write_partition_upgrade_flag(DWORD dwOffset,BYTE *pMd5,UINT uiFlag);
+	bool read_partition_upgrade_flag(DWORD dwOffset,BYTE *pMd5,UINT *uiFlag);
+	bool RKA_SparseFile_Download(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte);
+	bool RKA_SparseFile_Check(STRUCT_RKIMAGE_ITEM &entry,long long &currentByte,long long totalByte);
+	long long GetSparseImageSize(STRUCT_RKIMAGE_ITEM &entry);
+	bool IsSparseImage(STRUCT_RKIMAGE_ITEM &entry);
+	bool EraseSparseRegion(const char* volume,const char* directory);
+	bool ErasePartition(STRUCT_RKIMAGE_ITEM &entry);
+	bool ErasePartition_discard(STRUCT_RKIMAGE_ITEM &entry);
+	void load_volume();
+	int getEmmc();
+	bool GetParameterGptFlag(STRUCT_RKIMAGE_ITEM &paramItem);
+};
+void create_gpt_buffer(u8 *gpt, PARAM_ITEM_VECTOR &vecParts, CONFIG_ITEM_VECTOR &vecUuid, u64 diskSectors);
+void prepare_gpt_backup(u8 *master, u8 *backup, u64 diskSectors);
+void gen_rand_uuid(unsigned char *uuid_bin);
+unsigned int crc32_le(unsigned int crc, unsigned char *p, unsigned int len);
+bool parse_parameter(char *pParameter,PARAM_ITEM_VECTOR &vecItem);
+bool get_uuid_from_parameter(char *pParameter,CONFIG_ITEM_VECTOR &vecItem);
+bool ParsePartitionInfo(string &strPartInfo,string &strName,UINT &uiOffset,UINT &uiLen);
+bool ParseUuidInfo(string &strUuidInfo, string &strName, string &strUUid);
+void string_to_uuid(string strUUid, char *uuid);
+int find_uuid_item(CONFIG_ITEM_VECTOR &vecItems, char *pszName);
+#endif
diff --git a/bootable/recovery/rkupdate/include/rkupdate/RKBoot.h b/bootable/recovery/rkupdate/include/rkupdate/RKBoot.h
new file mode 100755
index 0000000000..b8442f29a2
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/RKBoot.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+ 
+#ifndef RKBOOT_HEADER
+#define RKBOOT_HEADER
+#include "DefineHeader.h"
+
+
+#define  BOOT_RESERVED_SIZE 57
+#pragma pack(1)
+typedef struct  
+{
+	UINT uiTag;
+	USHORT usSize;
+	DWORD  dwVersion;
+	DWORD  dwMergeVersion;
+	STRUCT_RKTIME stReleaseTime;
+	ENUM_RKDEVICE_TYPE emSupportChip;
+	UCHAR uc471EntryCount;
+	DWORD dw471EntryOffset;
+	UCHAR uc471EntrySize;
+	UCHAR uc472EntryCount;
+	DWORD dw472EntryOffset;
+	UCHAR uc472EntrySize;
+	UCHAR ucLoaderEntryCount;
+	DWORD dwLoaderEntryOffset;
+	UCHAR ucLoaderEntrySize;
+	UCHAR ucSignFlag;
+	UCHAR ucRc4Flag;
+	UCHAR reserved[BOOT_RESERVED_SIZE];
+}STRUCT_RKBOOT_HEAD,*PSTRUCT_RKBOOT_HEAD;
+
+typedef struct  
+{
+	UCHAR ucSize;
+	ENUM_RKBOOTENTRY emType;
+	WCHAR szName[20];
+	DWORD dwDataOffset;
+	DWORD dwDataSize;
+	DWORD dwDataDelay;//Ϊλ
+}STRUCT_RKBOOT_ENTRY,*PSTRUCT_RKBOOT_ENTRY;
+
+
+#pragma pack()
+class CRKBoot
+{
+public:
+	bool GetRc4DisableFlag();
+ 	property<CRKBoot,bool,READ_ONLY> Rc4DisableFlag;
+	bool GetSignFlag();
+ 	property<CRKBoot,bool,READ_ONLY> SignFlag;
+	UINT GetVersion();
+ 	property<CRKBoot,UINT,READ_ONLY> Version;
+	UINT GetMergeVersion();
+ 	property<CRKBoot,UINT,READ_ONLY> MergeVersion;
+	STRUCT_RKTIME GetReleaseTime();
+ 	property<CRKBoot,STRUCT_RKTIME,READ_ONLY> ReleaseTime;
+	ENUM_RKDEVICE_TYPE GetSupportDevice();
+ 	property<CRKBoot,ENUM_RKDEVICE_TYPE,READ_ONLY> SupportDevice;
+	unsigned char GetEntry471Count();
+ 	property<CRKBoot,unsigned char,READ_ONLY> Entry471Count;
+	unsigned char GetEntry472Count();
+ 	property<CRKBoot,unsigned char,READ_ONLY> Entry472Count;
+	unsigned char GetEntryLoaderCount();
+ 	property<CRKBoot,unsigned char,READ_ONLY> EntryLoaderCount;
+	bool CrcCheck();
+	bool SaveEntryFile(ENUM_RKBOOTENTRY type,UCHAR ucIndex,tstring fileName);
+	bool GetEntryProperty(ENUM_RKBOOTENTRY type,UCHAR ucIndex,DWORD &dwSize,DWORD &dwDelay,tchar *pName=NULL);
+	CHAR GetIndexByName(ENUM_RKBOOTENTRY type,tchar *pName);
+	bool GetEntryData(ENUM_RKBOOTENTRY type,UCHAR ucIndex,PBYTE lpData);
+	CRKBoot(PBYTE lpBootData,DWORD dwBootSize,bool &bCheck);
+	~CRKBoot();
+protected:
+private:
+	bool m_bRc4Disable;
+	bool m_bSignFlag;
+	DWORD m_version;
+	DWORD m_mergeVersion;
+	STRUCT_RKTIME m_releaseTime;
+	ENUM_RKDEVICE_TYPE m_supportDevice;
+	DWORD m_471Offset;
+	UCHAR m_471Size;
+	UCHAR m_471Count;
+	DWORD m_472Offset;
+	UCHAR m_472Size;
+	UCHAR m_472Count;
+	DWORD m_loaderOffset;
+	UCHAR m_loaderSize;
+	UCHAR m_loaderCount;
+	BYTE  m_crc[4];
+	PBYTE m_BootData;
+	DWORD m_BootSize;
+	USHORT m_BootHeadSize;
+	void WCHAR_To_char(WCHAR *src,char *dst,int len);
+};
+
+#endif
\ No newline at end of file
diff --git a/bootable/recovery/rkupdate/include/rkupdate/RKComm.h b/bootable/recovery/rkupdate/include/rkupdate/RKComm.h
new file mode 100755
index 0000000000..e43afabfd8
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/RKComm.h
@@ -0,0 +1,236 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef RKCOMM_HEADER
+#define RKCOMM_HEADER
+#include "DefineHeader.h"
+typedef enum{
+		USB_BULK_READ=0,
+		USB_BULK_WRITE,
+		USB_CONTROL,
+}USB_ACCESS_TYPE;
+typedef enum
+{
+	TU_NONE_SUBCODE=0,
+	TU_ERASESYSTEM_SUBCODE=0xFE,
+	TU_LOWERFORMAT_SUBCODE=0xFD,
+	TU_ERASEUSERDATA_SUBCODE=0xFB,
+	TU_GETUSERSECTOR_SUBCODE=0xF9
+}TESTUNIT_SUBCODE;
+typedef enum
+{
+	RST_NONE_SUBCODE=0,
+	RST_RESETMSC_SUBCODE,
+	RST_POWEROFF_SUBCODE,
+	RST_RESETMASKROM_SUBCODE,
+	RST_DISCONNECTRESET_SUBCODE
+}RESET_SUBCODE;
+typedef enum
+{
+	RWMETHOD_IMAGE=0,
+	RWMETHOD_LBA,
+}RW_SUBCODE;
+/*  */
+typedef enum
+{
+		TEST_UNIT_READY=0,
+		READ_FLASH_ID=0x01,
+		TEST_BAD_BLOCK=0x03,
+		READ_SECTOR=0x04,
+		WRITE_SECTOR=0x05,
+		ERASE_NORMAL=0x06,
+		ERASE_FORCE=0x0B,
+		READ_LBA=0x14,
+		WRITE_LBA=0x15,
+		ERASE_SYSTEMDISK=0x16,
+		READ_SDRAM=0x17,
+		WRITE_SDRAM=0x18,
+		EXECUTE_SDRAM=0x19,
+		READ_FLASH_INFO=0x1A,
+		READ_CHIP_INFO=0x1B,
+		SET_RESET_FLAG=0x1E,
+		WRITE_EFUSE=0x1F,
+		READ_EFUSE = 0x20,
+		READ_SPI_FLASH=0x21,
+		WRITE_SPI_FLASH=0x22,
+		WRITE_NEW_EFUSE=0x23,
+		READ_NEW_EFUSE=0x24,
+		ERASE_LBA=0x25,
+		SWITCH_MASKROM=0xFE,
+		DEVICE_RESET=0xFF
+}USB_OPERATION_CODE;
+
+#pragma pack(1)
+
+typedef struct
+{
+	BYTE	ucOperCode;		
+	BYTE	ucReserved;
+	DWORD	dwAddress;		
+	BYTE	ucReserved2;
+	USHORT	usLength;		
+	BYTE	ucReserved3[7];
+}CBWCB, *PCBWCB;
+
+typedef struct
+{
+	DWORD	dwCBWSignature;			
+	DWORD	dwCBWTag;				
+	DWORD	dwCBWTransferLength;		
+	BYTE	ucCBWFlags;				
+	BYTE	ucCBWLUN;			
+	BYTE	ucCBWCBLength;			
+	CBWCB	cbwcb;				
+}CBW, *PCBW;
+
+typedef struct 
+{
+	DWORD	dwCSWSignature;
+	DWORD	dwCSWTag;
+	DWORD	dwCBWDataResidue;
+	BYTE	ucCSWStatus;
+}CSW, *PCSW;
+typedef struct 
+{
+	UINT	uiSize;
+	UINT	uiCrc;
+	UINT	uiBlock[5];
+}STRUCT_END_WRITE_SECTOR, *PSTRUCT_END_WRITE_SECTOR;
+
+#pragma pack()
+#define NAND_DRIVER_DEV "/dev/rknand_sys_storage"
+#define NAND_DRIVER_DEV_VENDOR "/dev/rknand_sys_storage"
+#define NAND_DRIVER_DEV_LBA "/dev/block/rknand0"
+//#define NAND_DRIVER_DEV_LBA "/dev/block/rknand_rknand"
+#define EMMC_DRIVER_DEV "/dev/rknand_sys_storage"
+#define EMMC_DRIVER_DEV_VENDOR "/dev/vendor_storage"
+//#define EMMC_DRIVER_DEV_LBA "/dev/block/mmcblk1"  //for kernel-4.0
+//#define EMMC_DRIVER_DEV_LBA "/dev/block/mmcblk0"
+#define EMMC_DRIVER_DEV_LBA "/dev/mmcblk0"
+#define EMMC_POINT_NAME "emmc_point_name"
+
+#define READ_SECTOR_IO       	_IOW('r', READ_SECTOR, unsigned int)
+#define WRITE_SECTOR_IO       	_IOW('r', WRITE_SECTOR, unsigned int)
+#define READ_LBA_IO       		_IOW('r', READ_LBA, unsigned int)
+#define WRITE_LBA_IO       		_IOW('r', WRITE_LBA, unsigned int)
+#define START_WRITE_SECTOR_IO   _IOW('r', 0x51, unsigned int)
+#define END_WRITE_SECTOR_IO     _IOW('r', 0x52, unsigned int)
+#define GET_FLASH_INFO_IO       _IOW('r', READ_FLASH_INFO, unsigned int)
+#define GET_BAD_BLOCK_IO       	_IOW('r', TEST_BAD_BLOCK, unsigned int)
+#define GET_LOCK_FLAG_IO       	_IOW('r', 0x53, unsigned int)
+#define GET_PUBLIC_KEY_IO       _IOW('r', 0x54, unsigned int)
+
+#define DISABLE_NAND_LBA_WRITE_IO  _IO('V',0)
+#define ENABLE_NAND_LBA_WRITE_IO   _IO('V',1)
+#define DISABLE_NAND_LBA_READ_IO   _IO('V',2)
+#define ENABLE_NAND_LBA_READ_IO    _IO('V',3)
+
+#ifndef BLKDISCARD
+#define BLKDISCARD _IO(0x12,119)
+#endif
+
+#define CMD_TIMEOUT 0
+
+#define CBW_SIGN			0x43425355	/* "USBC" */
+#define CSW_SIGN			0x53425355	/* "USBS" */
+
+
+#define DIRECTION_OUT		0x00	
+#define DIRECTION_IN		0x80	
+#define MAX_TEST_BLOCKS		512		
+#define MAX_ERASE_BLOCKS	128
+#define  MAX_CLEAR_LEN	16*1024
+
+#ifndef ERR_SUCCESS
+#define ERR_SUCCESS		0
+#endif
+#define ERR_DEVICE_READY		0
+#define ERR_DEVICE_OPEN_FAILED	-1
+#define ERR_CSW_OPEN_FAILED		-2
+#define ERR_DEVICE_WRITE_FAILED	-3
+#define ERR_DEVICE_READ_FAILED	-4
+#define ERR_CMD_NOTMATCH		-5
+#define ERR_DEVICE_UNREADY		-6
+#define ERR_FOUND_BAD_BLOCK		-7
+#define ERR_FAILED				-8
+#define ERR_CROSS_BORDER		-9
+#define ERR_DEVICE_NOT_SUPPORT  -10
+#define ERR_REQUEST_NOT_SUPPORT  -11
+#define ERR_REQUEST_FAIL		-12
+#define ERR_BUFFER_NOT_ENOUGH   -13
+
+#define UFI_CHECK_SIGN(cbw, csw) ((CSW_SIGN == (csw).dwCSWSignature) && ((csw).dwCSWTag == (cbw).dwCBWTag))
+
+class CRKLog;
+class CRKComm
+{
+public:
+	virtual int RKU_EraseBlock(BYTE ucFlashCS,DWORD dwPos,DWORD dwCount,BYTE ucEraseType)=0;
+	virtual int RKU_EraseBlock_discard(unsigned int dwPos, unsigned int part_size)=0;
+	virtual int RKU_ReadChipInfo(BYTE* lpBuffer)=0;	
+	virtual int RKU_ReadFlashID(BYTE* lpBuffer)=0;
+	virtual int RKU_ReadFlashInfo(BYTE* lpBuffer,UINT *puiRead=NULL)=0;
+	virtual int RKU_ReadLBA(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer,BYTE bySubCode=RWMETHOD_IMAGE)=0;				
+	virtual int RKU_ReadSector(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer)=0;
+	virtual int RKU_ResetDevice(BYTE bySubCode=RST_NONE_SUBCODE)=0;
+	virtual int RKU_TestBadBlock(BYTE ucFlashCS,DWORD dwPos,DWORD dwCount,BYTE* lpBuffer)=0;
+	virtual int RKU_TestDeviceReady(DWORD *dwTotal=NULL,DWORD *dwCurrent=NULL,BYTE bySubCode=TU_NONE_SUBCODE)=0;
+	virtual int RKU_WriteLBA(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer,BYTE bySubCode=RWMETHOD_IMAGE)=0;
+	virtual int RKU_WriteLBALoader(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer,BYTE bySubCode=RWMETHOD_IMAGE);
+        virtual int RKU_WriteSector(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer)=0;
+	virtual int RKU_EndWriteSector(BYTE* lpBuffer)=0;
+	virtual int RKU_GetLockFlag(BYTE* lpBuffer)=0;
+	virtual int RKU_GetPublicKey(BYTE* lpBuffer)=0;
+	virtual void RKU_ReopenLBAHandle()=0;
+	virtual int RKU_ShowNandLBADevice()=0;
+	virtual long long RKU_GetFlashSize();
+	CRKComm(CRKLog *pLog);
+    long long m_FlashSize;
+	bool m_bEmmc;
+	virtual ~CRKComm();
+protected:
+	CRKLog *m_log;
+	int m_hDev;
+	int m_hLbaDev;
+private:
+	
+};
+class CRKUsbComm: public CRKComm
+{
+public:
+	virtual	int RKU_EraseBlock(BYTE ucFlashCS,DWORD dwPos,DWORD dwCount,BYTE ucEraseType);
+	virtual int RKU_EraseBlock_discard(unsigned int dwPos, unsigned int part_size);
+	virtual int RKU_ReadChipInfo(BYTE* lpBuffer);
+	virtual int RKU_ReadFlashID(BYTE* lpBuffer);
+	virtual int RKU_ReadFlashInfo(BYTE* lpBuffer,UINT *puiRead=NULL);
+	virtual int RKU_ReadLBA(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer,BYTE bySubCode=RWMETHOD_IMAGE);
+	virtual int RKU_ReadSector(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer);
+	virtual int RKU_ResetDevice(BYTE bySubCode=RST_NONE_SUBCODE);
+	virtual int RKU_TestBadBlock(BYTE ucFlashCS,DWORD dwPos,DWORD dwCount,BYTE* lpBuffer);
+	virtual int RKU_TestDeviceReady(DWORD *dwTotal=NULL,DWORD *dwCurrent=NULL,BYTE bySubCode=TU_NONE_SUBCODE);
+	virtual int RKU_WriteLBA(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer,BYTE bySubCode=RWMETHOD_IMAGE);
+	virtual int RKU_WriteLBALoader(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer,BYTE bySubCode=RWMETHOD_IMAGE);
+    virtual int RKU_WriteSector(DWORD dwPos,DWORD dwCount,BYTE* lpBuffer);
+	virtual int RKU_EndWriteSector(BYTE* lpBuffer);
+	virtual int RKU_GetLockFlag(BYTE* lpBuffer);
+	virtual int RKU_GetPublicKey(BYTE* lpBuffer);
+	virtual void RKU_ReopenLBAHandle();
+	virtual int RKU_ShowNandLBADevice();
+	virtual long long RKU_GetFlashSize();
+	CRKUsbComm(CRKLog *pLog);
+	~CRKUsbComm();
+	
+protected:
+	STRUCT_RKDEVICE_DESC m_deviceDesc;
+	CRKLog *m_log;
+private:
+	bool CtrlNandLbaWrite(bool bEnable=true);
+	bool CtrlNandLbaRead(bool bEnable=true);
+ 
+};
+
+#endif
diff --git a/bootable/recovery/rkupdate/include/rkupdate/RKDevice.h b/bootable/recovery/rkupdate/include/rkupdate/RKDevice.h
new file mode 100755
index 0000000000..ad1eb38f29
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/RKDevice.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef RKDEVICE_HEADER
+#define RKDEVICE_HEADER
+#include "RKImage.h"
+#include "RKComm.h"
+#include "RKLog.h"
+#include "DefineHeader.h"
+
+
+
+#define RK28_SEC3_RESERVED_LEN 419
+#define RKANDROID_SEC3_RESERVED_LEN 419
+
+#define RK28_SEC2_RESERVED_LEN 473
+#define RKANDROID_SEC2_RESERVED_LEN 473
+
+
+#define RKDEVICE_CUSTOMDATA_LEN 512
+#define RKDEVICE_SN_LEN 30
+#define RKDEVICE_UID_LEN 30
+#define RKDEVICE_MAC_LEN 6
+#define RKDEVICE_BT_LEN 6
+#define RKDEVICE_IMEI_LEN 15
+
+#define SECTOR_SIZE 512
+#define SPARE_SIZE 16
+#define IDB_BLOCKS 5
+#define CHIPINFO_LEN 16
+#define IDBLOCK_TOP 50
+#define WBBUFFER_BOTTOM 5
+#define WBBUFFER_TOP 10
+#define CALC_UNIT(a, b)		((a>0)?((a-1)/b+1):(a))
+#define BYTE2SECTOR(x)		(CALC_UNIT(x, SECTOR_SIZE))
+#define PAGEALIGN(x)		(CALC_UNIT(x, 4))
+//#define MAX_TEST_BLOCKS		512
+//#define MAX_ERASE_BLOCKS	128
+#define MAX_WRITE_SECTOR	16
+#define IOCTL_TRANSFER_SIZE		4096
+
+#define CRC_TAG "CRC"
+#pragma pack(1)
+typedef struct _STRUCT_FLASH_INFO
+{
+	tchar	szManufacturerName[16];
+	UINT	uiFlashSize;  //MB
+	USHORT	usBlockSize;//KB
+	UINT	uiPageSize;   //KB
+	UINT	uiSectorPerBlock;
+	BYTE	blockState[IDBLOCK_TOP];
+	UINT	uiBlockNum;
+	BYTE	bECCBits;
+	BYTE	bAccessTime;  //ηFlashļʱ
+	BYTE	bFlashCS;  // FlashƬѡ(FlashƬѡ10)
+	USHORT  usValidSecPerBlock;//ÿʹõ=С/ҳС*4
+	USHORT  usPhyBlokcPerIDB;//ÿIDBlockռõ
+	UINT    uiSecNumPerIDB;//ÿIDBlockռõ
+}STRUCT_FLASH_INFO, *PSTRUCT_FLASH_INFO;
+typedef struct _STRUCT_FLASHINFO_CMD
+{
+	UINT	uiFlashSize;	// FlashСSectorΪλ
+	USHORT	usBlockSize;	// BlockСSectorΪλ
+	BYTE	bPageSize;		// PageСSectorΪλ
+	BYTE	bECCBits;		// 8/14
+	BYTE	bAccessTime;	// ηFlashļʱ
+	BYTE	bManufCode;		// ʶ
+	BYTE	bFlashCS;		// FlashƬѡ(FlashƬѡڣӦBit10)
+	BYTE	reserved[501];
+}STRUCT_FLASHINFO_CMD, *PSTRUCT_FLASHINFO_CMD;
+typedef struct  
+{
+	BYTE bFlashCS;
+	UINT uiBlockNum;
+	USHORT usBlockStateSize;
+	PBYTE pBlockStateData;
+}STRUCT_BLOCK_STATE,*PSTRUCT_BLOCK_STATE;
+#pragma pack()
+typedef struct
+{
+	USHORT usVid;
+	USHORT usPid;
+}STRUCT_DEVICE_PROP;
+typedef vector<STRUCT_DEVICE_PROP> DEVICE_PROP_SET;
+
+class CRKDevice
+{
+public:
+	
+	ENUM_OS_TYPE GetOsType();
+	void SetOsType(ENUM_OS_TYPE value);
+ 	property<CRKDevice,ENUM_OS_TYPE,READ_WRITE> OsType;
+
+	void SetUid(PBYTE value);
+ 	property<CRKDevice,PBYTE,WRITE_ONLY> Uid;
+	
+	void SetPrepareEraseFlag(bool value);
+ 	property<CRKDevice,bool,WRITE_ONLY> PrepareEraseFlag;
+
+	void SetWorkFlow(UINT value);
+ 	property<CRKDevice,UINT,WRITE_ONLY> WorkFlow;
+	
+	void SetMiscModifyFlag(ENUM_MISC_MODIFY_FLAG value);
+ 	property<CRKDevice,ENUM_MISC_MODIFY_FLAG,WRITE_ONLY> MiscModifyFlag;
+	
+	CRKLog* GetLogObjectPointer();
+ 	property<CRKDevice,CRKLog*,READ_ONLY> LogObjectPointer;
+	
+	CRKComm* GetCommObjectPointer();
+ 	property<CRKDevice,CRKComm*,READ_ONLY> CommObjectPointer;
+	
+	virtual int DownloadIDBlock()=0;
+	virtual int DownloadImage()=0;
+	virtual int PrepareIDB()=0;
+	virtual bool BufferWriteBack()=0;
+	
+
+	bool CheckChip();
+	bool GetFlashInfo();
+	virtual int EraseIDB()=0;
+	virtual int EraseAllBlocks()=0;
+	bool SetObject(CRKImage *pImage,CRKComm *pComm,CRKLog *pLog);
+	CRKDevice(STRUCT_RKDEVICE_DESC &device);
+	virtual ~CRKDevice();
+protected:
+	STRUCT_FLASH_INFO m_flashInfo;
+	PBYTE	m_pFlashInfoData;
+	USHORT	m_usFlashInfoDataOffset;
+	USHORT  m_usFlashInfoDataLen;
+	DWORD m_idBlockOffset[IDB_BLOCKS];
+	PBYTE  m_chipData;
+	CRKImage *m_pImage;
+	CRKComm  *m_pComm;
+	CRKLog   *m_pLog;
+	PBYTE  m_customData;
+	USHORT m_customDataSize;
+	USHORT m_customDataOffset;
+	PBYTE  m_sn;
+	BYTE   m_snSize;
+	PBYTE  m_mac;
+	PBYTE  m_blueTooth;
+	PBYTE  m_uid;
+	PBYTE  m_imei;
+	USHORT m_sysDiskSize;
+	USHORT m_cfgDiskSize;
+	bool   m_bGetNewDiskSizeFlag;
+	bool   m_bExistSector3Crc;
+	USHORT m_usSector3Crc;
+	USHORT m_usWriteBackCrc;
+	USHORT m_usWriteBackCustomDataOffset;
+	USHORT m_usWriteBackCustomDataSize;
+	PSTRUCT_BLOCK_STATE m_pBlockState;
+	BYTE   m_backupBuffer[SECTOR_SIZE+SPARE_SIZE];
+	bool m_bWriteBack;
+	UINT m_uiWorkFlow;
+	bool m_bEraseInPrepare;
+	bool m_bUidUseFlag;
+	bool m_bUidWriteOK;
+	bool  m_remallocDisk;
+	bool m_bEmmc;
+	bool GptFlag;
+	bool DirectLBA;
+	bool First4Access;
+	ENUM_MISC_MODIFY_FLAG m_emMiscModifyFlag;
+	bool m_bQuickCheckMode;
+	bool BuildBlockStateMap(BYTE bFlashCS);
+	int ReadMutilSector(DWORD dwPos,DWORD dwCount,PBYTE lpBuffer);
+	bool EraseMutilBlock(BYTE bFlashCS,DWORD dwPos,DWORD dwCount,bool bForce);
+	CHAR FindValidBlocks(char bBegin, char bLen);
+	BYTE RandomByte(BYTE bLowLimit,BYTE bHighLimit);
+	bool CheckCrc16(PBYTE pCheckData,USHORT usDataLength,USHORT usOldCrc);
+	bool CheckUid(BYTE uidSize,BYTE *pUid);
+	bool GetWriteBackData(UINT uiIDBCount,PBYTE lpBuf);
+	bool GetIDBData(UINT uiIDBCount,PBYTE lpBuf,UINT uiSecCount);
+	int EraseEmmcBlock(UCHAR ucFlashCS,DWORD dwPos,DWORD dwCount);
+	virtual bool FindBackupBuffer()=0;
+	virtual char FindAllIDB()=0;
+	virtual CHAR FindIDBlock(char pos,char &IDBlockPos)=0;
+	virtual bool ReserveIDBlock(char iBlockIndex=0,char iIdblockPos=0)=0;
+	virtual bool OffsetIDBlock(char pos)=0;		
+	virtual bool MakeSector0(PBYTE pSector)=0;
+	virtual void MakeSector1(PBYTE pSector)=0;
+	virtual bool MakeSector2(PBYTE pSector)=0;
+	virtual bool MakeSector3(PBYTE pSector)=0;
+	virtual int MakeIDBlockData(PBYTE lpIDBlock)=0;
+	virtual bool MakeSpareData(PBYTE lpIDBlock,DWORD dwSectorNum,PBYTE lpSpareBuffer)=0;
+	virtual int WriteIDBlock(PBYTE lpIDBlock,DWORD dwSectorNum,bool bErase)=0;
+	
+private:
+	ENUM_RKDEVICE_TYPE m_device;
+	ENUM_OS_TYPE m_os;
+	ENUM_RKUSB_TYPE m_usb;
+	USHORT m_bcdUsb;
+};
+
+USHORT UshortToBCD(USHORT num);
+BYTE   ByteToBCD(BYTE num);
+extern USHORT CRC_16(BYTE * aData, UINT aSize);
+extern UINT CRC_32(PBYTE pData, UINT ulSize,UINT uiPreviousValue=0);
+extern void P_RC4(BYTE * buf, USHORT len);
+extern void bch_encode(BYTE *encode_in, BYTE *encode_out);
+extern USHORT CRC_CCITT(UCHAR *p, UINT CalculateNumber);
+extern void generate_gf();
+extern void gen_poly();
+#endif
\ No newline at end of file
diff --git a/bootable/recovery/rkupdate/include/rkupdate/RKImage.h b/bootable/recovery/rkupdate/include/rkupdate/RKImage.h
new file mode 100755
index 0000000000..8d0ad71df1
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/RKImage.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef RKIMAGE_HEADER
+#define RKIMAGE_HEADER
+#include "DefineHeader.h"
+#include "RKBoot.h"
+#define  IMAGE_RESERVED_SIZE 61
+#pragma pack(1)
+typedef struct  
+{
+	UINT uiTag;
+	USHORT usSize;
+	DWORD  dwVersion;
+	DWORD  dwMergeVersion;
+	STRUCT_RKTIME stReleaseTime;
+	ENUM_RKDEVICE_TYPE emSupportChip;
+	DWORD  dwBootOffset;
+	DWORD  dwBootSize;
+	DWORD  dwFWOffset;
+	DWORD  dwFWSize;
+	BYTE   reserved[IMAGE_RESERVED_SIZE];
+}STRUCT_RKIMAGE_HEAD,*PSTRUCT_RKIMAGE_HEAD;
+#pragma pack()
+class CRKImage
+{
+public:
+	UINT GetVersion();
+ 	property<CRKImage,UINT,READ_ONLY> Version;
+	UINT GetMergeVersion();
+ 	property<CRKImage,UINT,READ_ONLY> MergeVersion;
+	STRUCT_RKTIME GetReleaseTime();
+ 	property<CRKImage,STRUCT_RKTIME,READ_ONLY> ReleaseTime;
+	ENUM_RKDEVICE_TYPE GetSupportDevice();
+ 	property<CRKImage,ENUM_RKDEVICE_TYPE,READ_ONLY> SupportDevice;
+	ENUM_OS_TYPE GetOsType();
+ 	property<CRKImage,ENUM_OS_TYPE,READ_ONLY> OsType;
+	unsigned short GetBackupSize();
+ 	property<CRKImage,unsigned short,READ_ONLY> BackupSize;
+	UINT GetBootOffset();
+ 	property<CRKImage,UINT,READ_ONLY> BootOffset;
+	UINT GetBootSize();
+ 	property<CRKImage,UINT,READ_ONLY> BootSize;
+	UINT GetFWOffset();
+ 	property<CRKImage,UINT,READ_ONLY> FWOffset;
+	long long GetFWSize();
+ 	property<CRKImage,long long,READ_ONLY> FWSize;
+	CRKBoot *m_bootObject;
+	bool Md5Check(long long nCheckSize);
+	bool SaveBootFile(tstring filename);
+	bool SaveFWFile(tstring filename);
+	bool GetData(long long dwOffset,DWORD dwSize,PBYTE lpBuffer);
+	void GetReservedData(PBYTE &lpData,USHORT &usSize);
+	long long GetImageSize();
+	int GetMd5Data(PBYTE &lpMd5,PBYTE &lpSignMd5);
+	CRKImage(tstring filename,bool &bCheck);
+	~CRKImage();
+protected:
+
+private:
+	DWORD m_version;
+	DWORD m_mergeVersion;
+	STRUCT_RKTIME m_releaseTime;
+	ENUM_RKDEVICE_TYPE m_supportDevice;
+	DWORD m_bootOffset;
+	DWORD m_bootSize;
+	DWORD m_fwOffset;
+	long long m_fwSize;
+	BYTE  m_md5[32];
+	BYTE  m_signMd5[256];
+	BYTE  m_reserved[IMAGE_RESERVED_SIZE];
+	bool  m_bSignFlag;
+	int   m_signMd5Size;
+	FILE *m_pFile;
+	long long m_fileSize;
+};
+#endif
\ No newline at end of file
diff --git a/bootable/recovery/rkupdate/include/rkupdate/RKLog.h b/bootable/recovery/rkupdate/include/rkupdate/RKLog.h
new file mode 100755
index 0000000000..e6eac3206f
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/RKLog.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef RKLOG_HEADER
+#define RKLOG_HEADER
+#include "DefineHeader.h"
+
+class CRKLog
+{
+public:
+ 	bool GetEnableLog();
+ 	void SetEnableLog(bool bEnable);
+ 	property<CRKLog,bool,READ_WRITE> EnableLog;
+	property<CRKLog,tstring,READ_ONLY> LogSavePath;
+	CRKLog(bool enable=true);
+	~CRKLog();
+	bool SaveBuffer(tstring fileName,PBYTE lpBuffer,DWORD dwSize);
+	void PrintBuffer(tstring &strOutput,PBYTE lpBuffer,DWORD dwSize,UINT uiLineCount=16);
+	void Record(const tchar* lpFmt,...);
+	
+protected:
+private:
+	bool    m_enable;
+};
+
+#endif
\ No newline at end of file
diff --git a/bootable/recovery/rkupdate/include/rkupdate/RKSparse.h b/bootable/recovery/rkupdate/include/rkupdate/RKSparse.h
new file mode 100755
index 0000000000..c54d353302
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/RKSparse.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef _RKSPARSE_H
+#define _RKSPARSE_H
+#include "DefineHeader.h"
+#include "RKComm.h"
+#define LBA_TRANSFER_SIZE 16*1024
+class RKSparse{
+public:
+    sparse_header m_header;
+    chunk_header m_chunk;
+    FILE *m_pFile;
+    const char *fileName;
+    RKSparse(const char *filePath);
+    ~RKSparse();
+    bool IsSparseImage();
+    long long GetSparseImageSize();
+    bool SparseFile_Download(DWORD dwPos, CRKComm *pComm);
+    //bool SparseFile_Check();
+    void display();
+private:
+    bool readfile(long long dwOffset, DWORD dwSize, PBYTE lpBuffer);
+    //bool writefile();
+};
+#endif
diff --git a/bootable/recovery/rkupdate/include/rkupdate/Upgrade.h b/bootable/recovery/rkupdate/include/rkupdate/Upgrade.h
new file mode 100755
index 0000000000..068a55c727
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/Upgrade.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _UPGRADEAPI_H_
+#define _UPGRADEAPI_H_
+
+bool do_rk_partition_upgrade(char *szFw,void *pCallback=NULL,void *pProgressCallback=NULL,char nBoot=0,char *szBootDev=NULL);
+bool do_rk_firmware_upgrade(char *szFw,void *pCallback=NULL,void *pProgressCallback=NULL,char *szBootDev=NULL);
+bool do_rk_backup_recovery(void *pCallback=NULL,void *pProgressCallback=NULL);
+bool do_rk_sparse_update(const char *partitionName, const char *src_path);
+bool do_rk_gpt_update(char *szFw,void *pCallback,void *pProgressCallback,char *szBootDev);
+#endif
+
diff --git a/bootable/recovery/rkupdate/include/rkupdate/gpt.h b/bootable/recovery/rkupdate/include/rkupdate/gpt.h
new file mode 100755
index 0000000000..f8f6c21e81
--- /dev/null
+++ b/bootable/recovery/rkupdate/include/rkupdate/gpt.h
@@ -0,0 +1,167 @@
+#ifndef _GPT_H
+#define _GPT_H
+
+#define MSDOS_MBR_SIGNATURE 0xAA55
+#define EFI_PMBR_OSTYPE_EFI 0xEF
+#define EFI_PMBR_OSTYPE_EFI_GPT 0xEE
+
+#define GPT_HEADER_SIGNATURE 0x5452415020494645ULL
+#define GPT_HEADER_REVISION_V1 0x00010000
+#define GPT_PRIMARY_PARTITION_TABLE_LBA 1ULL
+#define GPT_ENTRY_NAME "gpt"
+#define GPT_ENTRY_NUMBERS		128
+#define GPT_ENTRY_SIZE			128
+#define PART_PROPERTY_BOOTABLE (1 << 2)
+
+#define EFI_GUID(a,b,c,d0,d1,d2,d3,d4,d5,d6,d7) \
+	((efi_guid_t) \
+	{{ (a) & 0xff, ((a) >> 8) & 0xff, ((a) >> 16) & 0xff, ((a) >> 24) & 0xff, \
+		(b) & 0xff, ((b) >> 8) & 0xff, \
+		(c) & 0xff, ((c) >> 8) & 0xff, \
+		(d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) }})
+
+#define PARTITION_IDBLOCK_GUID \
+	EFI_GUID(0xDA2BB095, 0x390E, 0x48ca, \
+		0x90, 0x47, 0x05, 0xE8, 0x18, 0xB2, 0x97, 0xCE)
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int  u32;
+#ifdef __LP64__
+typedef unsigned long u64;
+#else
+typedef unsigned long long u64;
+#endif
+
+#define uswap_16(x) \
+	((((x) & 0xff00) >> 8) | \
+	 (((x) & 0x00ff) << 8))
+#define uswap_32(x) \
+	((((x) & 0xff000000) >> 24) | \
+	 (((x) & 0x00ff0000) >>  8) | \
+	 (((x) & 0x0000ff00) <<  8) | \
+	 (((x) & 0x000000ff) << 24))
+#define _uswap_64(x, sfx) \
+	((((x) & 0xff00000000000000##sfx) >> 56) | \
+	 (((x) & 0x00ff000000000000##sfx) >> 40) | \
+	 (((x) & 0x0000ff0000000000##sfx) >> 24) | \
+	 (((x) & 0x000000ff00000000##sfx) >>  8) | \
+	 (((x) & 0x00000000ff000000##sfx) <<  8) | \
+	 (((x) & 0x0000000000ff0000##sfx) << 24) | \
+	 (((x) & 0x000000000000ff00##sfx) << 40) | \
+	 (((x) & 0x00000000000000ff##sfx) << 56))
+#if defined(__GNUC__)
+# define uswap_64(x) _uswap_64(x, ull)
+#else
+# define uswap_64(x) _uswap_64(x, )
+#endif
+#define __LITTLE_ENDIAN__ 1
+#ifdef __LITTLE_ENDIAN__
+# define cpu_to_le16(x)		(x)
+# define cpu_to_le32(x)		(x)
+# define cpu_to_le64(x)		(x)
+# define le16_to_cpu(x)		(x)
+# define le32_to_cpu(x)		(x)
+# define le64_to_cpu(x)		(x)
+# define cpu_to_be16(x)		uswap_16(x)
+# define cpu_to_be32(x)		uswap_32(x)
+# define cpu_to_be64(x)		uswap_64(x)
+# define be16_to_cpu(x)		uswap_16(x)
+# define be32_to_cpu(x)		uswap_32(x)
+# define be64_to_cpu(x)		uswap_64(x)
+#else
+# define cpu_to_le16(x)		uswap_16(x)
+# define cpu_to_le32(x)		uswap_32(x)
+# define cpu_to_le64(x)		uswap_64(x)
+# define le16_to_cpu(x)		uswap_16(x)
+# define le32_to_cpu(x)		uswap_32(x)
+# define le64_to_cpu(x)		uswap_64(x)
+# define cpu_to_be16(x)		(x)
+# define cpu_to_be32(x)		(x)
+# define cpu_to_be64(x)		(x)
+# define be16_to_cpu(x)		(x)
+# define be32_to_cpu(x)		(x)
+# define be64_to_cpu(x)		(x)
+#endif
+
+
+typedef union {
+	struct {
+	unsigned int time_low;
+	unsigned short time_mid;
+	unsigned short time_hi_and_version;
+	unsigned char clock_seq_hi_and_reserved;
+	unsigned char clock_seq_low;
+	unsigned char node[6];
+	} uuid;
+	u8 raw[16];
+} efi_guid_t;
+#pragma pack(1)
+typedef struct {
+	u16 usTag;/*0xEEEE*/
+	u16 usBackupGpt;/*0:no backup,1:has backup*/
+	u16 usEntryCount;
+	u64 entryDataSize[32];
+} gpt_compact_info;
+/* based on linux/include/genhd.h */
+typedef struct {
+	u8 boot_ind;		/* 0x80 - active */
+	u8 head;		/* starting head */
+	u8 sector;		/* starting sector */
+	u8 cyl;			/* starting cylinder */
+	u8 sys_ind;		/* What partition type */
+	u8 end_head;		/* end head */
+	u8 end_sector;		/* end sector */
+	u8 end_cyl;		/* end cylinder */
+	u32 start_sect;	/* starting sector counting from 0 */
+	u32 nr_sects;	/* nr of sectors in partition */
+} mbr_partition ;
+
+/* based on linux/fs/partitions/efi.h */
+typedef struct _gpt_header {
+	u64 signature;
+	u32 revision;
+	u32 header_size;
+	u32 header_crc32;
+	u32 reserved1;
+	u64 my_lba;
+	u64 alternate_lba;
+	u64 first_usable_lba;
+	u64 last_usable_lba;
+	efi_guid_t disk_guid;
+	u64 partition_entry_lba;
+	u32 num_partition_entries;
+	u32 sizeof_partition_entry;
+	u32 partition_entry_array_crc32;
+} gpt_header;
+
+typedef union _gpt_entry_attributes {
+	struct {
+		u64 required_to_function:1;
+		u64 no_block_io_protocol:1;
+		u64 legacy_bios_bootable:1;
+		u64 reserved:45;
+		u64 type_guid_specific:16;
+	} fields;
+	unsigned long long raw;
+} gpt_entry_attributes;
+
+#define PARTNAME_SZ	72
+typedef struct _gpt_entry {
+	efi_guid_t partition_type_guid;
+	efi_guid_t unique_partition_guid;
+	u64 starting_lba;
+	u64 ending_lba;
+	gpt_entry_attributes attributes;
+	u16 partition_name[PARTNAME_SZ / sizeof(u16)];
+} gpt_entry;
+
+typedef struct _legacy_mbr {
+	u8 boot_code[440];
+	u32 unique_mbr_signature;
+	u16 unknown;
+	mbr_partition partition_record[4];
+	u16 signature;
+} legacy_mbr;
+#pragma pack()
+#endif	/* _GPT_H */
diff --git a/bootable/recovery/rkupdate/test_sparse.cpp b/bootable/recovery/rkupdate/test_sparse.cpp
new file mode 100755
index 0000000000..ba649d870f
--- /dev/null
+++ b/bootable/recovery/rkupdate/test_sparse.cpp
@@ -0,0 +1,18 @@
+/*************************************************************************
+	> File Name: test_sparse.cpp
+	> Author: jkand.huang
+	> Mail: jkand.huang@rock-chips.com
+	> Created Time: Mon 21 Aug 2017 10:50:50 AM CST
+ ************************************************************************/
+
+#include <iostream>
+#include "RKSparse.h"
+#include "Upgrade.h"
+using namespace std;
+int main(int argc, char *argv[]){
+    printf("======= start test RKSparse. ======\n");
+    do_rk_sparse_update("system", "/data/media/0/system.img");
+    printf("======= end test RKSparse. ======\n");
+
+    return 0;
+}
diff --git a/bootable/recovery/rkutility/Android.bp b/bootable/recovery/rkutility/Android.bp
new file mode 100644
index 0000000000..dceba377e4
--- /dev/null
+++ b/bootable/recovery/rkutility/Android.bp
@@ -0,0 +1,38 @@
+//
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+cc_library_static {
+    name: "librkutility",
+
+    defaults: [
+        "recovery_defaults",
+    ],
+
+    srcs: [
+        "rktools.cpp",
+        "sdboot.cpp",
+    ],
+
+    static_libs: [
+        "libfstab",
+    ],
+
+    export_include_dirs: [
+        "include",
+    ],
+
+    recovery_available: true,
+}
diff --git a/bootable/recovery/rkutility/include/rkutility/rktools.h b/bootable/recovery/rkutility/include/rkutility/rktools.h
new file mode 100644
index 0000000000..13e4ade15b
--- /dev/null
+++ b/bootable/recovery/rkutility/include/rkutility/rktools.h
@@ -0,0 +1,61 @@
+/*************************************************************************
+	> File Name: rktools.h
+	> Author: jkand.huang
+	> Mail: jkand.huang@rock-chips.com
+	> Created Time: Mon 23 Jan 2017 03:05:58 PM CST
+ ************************************************************************/
+
+#ifndef _RKTOOLS_H
+#define _RKTOOLS_H
+
+#define PATH_LEN 50
+#define usb_path "/mnt/usb_storage/"
+#define sd_path "/mnt/external_sd/"
+
+#define NET_FILE_PATH          "./sys/class/net_cmcc_gpio/net_cmcc_led"
+#define NET_FILE_PATH_NEW      "/sys/class/leds/net-green/brightness"
+#define KETGRUND_FILE_PATH     "./sys/class/ir_cmcc_gpio/ir_cmcc_led"
+#define POWER_FILE_PATH        "./sys/class/suspend_cmcc_gpio/suspend_cmcc_led"
+
+#define OFF_VALUE 0
+#define ON_VALUE 1
+
+#define EMMC_POINT_NAME "emmc_point_name"
+#define SD_POINT_NAME "sd_point_name"
+#define SD_POINT_NAME_2 "sd_point_name_2"
+
+#define SD_BLOCK_DEVICE_NODE	("/dev/block/mmcblk0p1")
+
+
+static const char *point_items[] = {
+    "/dev/block/mmcblk0",
+    "/dev/block/mmcblk1",
+    "/dev/block/mmcblk2",
+    "/dev/block/mmcblk3",
+};
+
+enum type{
+    MMC,
+    SD,
+    SDIO,
+    SDcombo,
+};
+
+static const char *typeName[] = {
+    "MMC",
+    "SD",
+    "SDIO",
+    "SDcombo",
+};
+
+//char* check_media_package(const char *path);
+char* getSerial();
+//int erase_baseparameter();
+void startLed();
+void stopLed(int state);
+void setFlashPoint();
+void dumpCmdArgs(int argc, char** argv);
+void SplitString(const std::string& s, std::string& result, const std::string& c);
+int getEmmcState();
+bool IsSpecialName(const char *str);
+#endif
diff --git a/bootable/recovery/rkutility/include/rkutility/sdboot.h b/bootable/recovery/rkutility/include/rkutility/sdboot.h
new file mode 100755
index 0000000000..0b14a6cfd8
--- /dev/null
+++ b/bootable/recovery/rkutility/include/rkutility/sdboot.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SDBOOT_H
+#define _SDBOOT_H
+#include <vector>
+#include <string>
+#include <sstream>
+
+#define EX_SDCARD_ROOT "/mnt/external_sd"
+#define USB_ROOT "/mnt/usb_storage"
+#define MAX_ARGS 100
+#define SD_POINT_NAME "sd_point_name"
+
+#define SD_BLOCK_DEVICE_NODE	("/dev/block/mmcblk0p1")
+
+
+typedef struct {
+    char* name;
+    char* value;
+}RKSdBootCfgItem;
+
+typedef struct{
+    std::string strKey;
+    std::string strValue;
+}STRUCT_SD_CONFIG_ITEM,*PSTRUCT_SD_CONFIG_ITEM;
+
+typedef std::vector<STRUCT_SD_CONFIG_ITEM> VEC_SD_CONFIG;
+
+class SDBoot{
+public:
+    SDBoot();
+    bool isSDboot();
+    bool isUSBboot();
+    std::vector<std::string> get_args(int argc, char **argv);
+    void ensure_usb_mounted();
+    //void ensure_sd_mounted();
+   // int do_rk_mode_update(const char *pFile);
+   // void check_device_remove();
+    int do_rk_factory_mode();
+	//int do_rk_direct_sd_update(const char *pFile);
+	bool do_direct_parse_config_file(const char *pConfigFile,VEC_SD_CONFIG &vecItem);
+	void sdboot_set_status(int stat);
+	int sdboot_get_status(void);
+	bool sdboot_get_bSDBoot(void);
+	void sdboot_set_bSDBoot(bool is_sdboot);
+	bool sdboot_get_bUsbBoot(void);
+	void sdboot_set_bUsbBoot(bool is_usbboot);
+	void sdboot_set_bUpdateModel(bool bUpdate);
+	bool sdboot_get_bUpdateModel(void);
+	std::string sdboot_get_usb_device_path(void);
+	void sdboot_set_bSDMounted(bool bMounted);
+	bool sdboot_get_bSDMounted(void);
+	bool sdboot_get_bUsbMounted(void);
+	std::vector<std::string> get_args_from_usb(int argc, char **argv);
+    std::vector<std::string> get_sd_config(char *path, int argc, char **argv);
+private:
+    int status;
+    bool bSDBoot;
+    bool bUsbBoot;
+    bool bUpdateModel;
+    bool bSDMounted;
+    bool bUsbMounted;
+    std::string IN_SDCARD_ROOT;
+    std::string USB_DEVICE_PATH;
+    void bootwhere();
+    //std::vector<std::string> get_args_from_sd(int argc, char **argv);
+    bool parse_config(char *pConfig,VEC_SD_CONFIG &vecItem);
+    bool parse_config_file(const char *pConfigFile,VEC_SD_CONFIG &vecItem);
+    int mount_usb_device();
+    //void checkSDRemoved(); 
+    //void checkUSBRemoved(); 
+    //int do_sd_mode_update(const char *pFile);
+    //int do_usb_mode_update(const char *pFile);
+};
+#endif
diff --git a/bootable/recovery/rkutility/rktools.cpp b/bootable/recovery/rkutility/rktools.cpp
new file mode 100644
index 0000000000..5a5d5a16a0
--- /dev/null
+++ b/bootable/recovery/rkutility/rktools.cpp
@@ -0,0 +1,290 @@
+/*************************************************************************
+	> File Name: rktools.cpp
+	> Author: jkand.huang
+	> Mail: jkand.huang@rock-chips.com
+	> Created Time: Mon 23 Jan 2017 02:36:42 PM CST
+ ************************************************************************/
+
+#include <iostream>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <pthread.h>
+//#include <fs_mgr.h>
+//#include "common.h"
+#include <cutils/properties.h>
+#include <pthread.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <assert.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string>
+
+
+#include "rkutility/rktools.h"
+#include "rkutility/sdboot.h"
+
+
+
+//static bool isLedFlash = false;
+//static pthread_t tid;
+//static int last_state = 0;
+
+using namespace std;
+
+/**
+ * 从/proc/cmdline 获取串口的节点
+ *
+*/
+char *getSerial(){
+    char *ans = (char*)malloc(20);
+    char param[1024];
+    int fd, ret;
+    char *s = NULL;
+    fd = open("/proc/cmdline", O_RDONLY);
+    ret = read(fd, (char*)param, 1024);
+    printf("cmdline=%s\n",param);
+    s = strstr(param,"console");
+    if(s == NULL){
+        printf("no found console in cmdline\n");
+        free(ans);
+        ans = NULL;
+        return ans;
+    }else{
+        s = strstr(s, "=");
+        if(s == NULL){
+            free(ans);
+            ans = NULL;
+            return ans;
+        }
+
+        strcpy(ans, "/dev/");
+        char *str = ans + 5;
+        s++;
+        while(*s != ' '){
+            *str = *s;
+            str++;
+            s++;
+        }
+        *str = '\0';
+        printf("read console from cmdline is %s\n", ans);
+    }
+
+    return ans;
+}
+
+
+#if 0
+void *thrd_led_func(void *arg) {
+    FILE * ledFd = NULL;
+    bool onoff = false;
+    char real_net_file_path[128] = "\0";
+    if((ledFd = fopen(NET_FILE_PATH, "w")) != NULL){
+        strcpy(real_net_file_path, NET_FILE_PATH);
+        fclose(ledFd);
+    }else if((ledFd = fopen(NET_FILE_PATH_NEW, "w")) != NULL){
+        strcpy(real_net_file_path, NET_FILE_PATH_NEW);
+        fclose(ledFd);
+    }
+
+    while(isLedFlash) {
+        ledFd = fopen(real_net_file_path, "w");
+        if(ledFd == NULL)
+        {
+            usleep(500 * 1000);
+            continue;
+        }
+        if(onoff) {
+            fprintf(ledFd, "%d", OFF_VALUE);
+            onoff = false;
+        }else {
+            fprintf(ledFd, "%d", ON_VALUE);
+            onoff = true;
+        }
+
+        fclose(ledFd);
+        usleep(500 * 1000);
+    }
+
+    printf("stopping led thread, close led and exit\n");
+
+    ledFd = fopen(real_net_file_path, "w");
+    if(ledFd != NULL){
+        fprintf(ledFd, "%d", last_state);
+        fclose(ledFd);
+    }
+    pthread_exit(NULL);
+    return NULL;
+}
+
+void startLed() {
+    isLedFlash = true;
+    if (pthread_create(&tid,NULL,thrd_led_func,NULL)!=0) {
+        printf("Create led thread error!\n");
+    }
+
+    printf("tid in led pthread: %ld.\n",tid);
+}
+
+void stopLed(int state) {
+    last_state = state;
+    void *tret;
+    isLedFlash = false;
+
+    if (pthread_join(tid, &tret)!=0){
+        printf("Join led thread error!\n");
+    }else {
+        printf("join led thread success!\n");
+    }
+}
+#endif
+
+/**
+ *  设置flash 节点
+ */
+static char result_point[4][20]; //0-->emmc, 1-->sdcard, 2-->SDIO, 3-->SDcombo
+int readFile(DIR* dir, char* filename){
+    char name[30] = {'\0'};
+    strcpy(name, filename);
+    strcat(name, "/type");
+    int fd = openat(dirfd(dir), name, O_RDONLY);
+    if(fd == -1){
+        printf("Error: openat %s error %s.\n", name, strerror(errno));
+        return -1;
+    }
+    char resultBuf[10] = {'\0'};
+    read(fd, resultBuf, sizeof(resultBuf));
+    for(int i = 0; i < (int)strlen(resultBuf); i++){
+        if(resultBuf[i] == '\n'){
+            resultBuf[i] = '\0';
+            break;
+        }
+    }
+    for(int i = 0; i < 4; i++){
+        if(strcmp(typeName[i], resultBuf) == 0){
+            //printf("type is %s.\n", typeName[i]);
+            return i;
+        }
+    }
+
+    printf("Error:no found type!\n");
+    return -1;
+}
+
+void init_sd_emmc_point(){
+    DIR* dir = opendir("/sys/bus/mmc/devices/");
+    if(dir != NULL){
+		printf("exit=================\n");
+        memset(result_point, 0, 4*20);
+        dirent* de;
+        while((de = readdir(dir))){
+            if(strncmp(de->d_name, "mmc", 3) == 0){
+                //printf("find mmc is %s.\n", de->d_name);
+                char flag = de->d_name[3];
+                int ret = -1;
+                ret = readFile(dir, de->d_name);
+                if(ret != -1){
+                    strcpy(result_point[ret], point_items[flag - '0']);
+                }else{
+                    strcpy(result_point[ret], "");
+                }
+                printf("result_point[%d] is ----%s\n",ret,result_point[ret]);
+            }
+        }
+
+    }
+    closedir(dir);
+}
+
+void setFlashPoint(){
+    init_sd_emmc_point();
+    setenv(EMMC_POINT_NAME, result_point[MMC], 1);
+    //SDcard 有两个挂载点
+	printf("111\n");
+    if(access(result_point[SD], F_OK) == 0)
+        setenv(SD_POINT_NAME_2, result_point[SD], 1);
+    char name_t[22];
+    if(strlen(result_point[SD]) > 0){
+        strcpy(name_t, result_point[SD]);
+        strcat(name_t, "p1");
+    }
+    if(access(name_t, F_OK) == 0)
+        setenv(SD_POINT_NAME, name_t, 1);
+
+    printf("emmc_point is %s\n", getenv(EMMC_POINT_NAME));
+    printf("sd_point is %s\n", getenv(SD_POINT_NAME));
+    printf("sd_point_2 is %s\n", getenv(SD_POINT_NAME_2));
+}
+
+void dumpCmdArgs(int argc, char** argv) {
+    fprintf(stdout, "=== start %s:%d ===\n", __func__, __LINE__);
+    for(int i = 0; i < argc; i++)
+    {
+        fprintf(stdout, "argv[%d] =  %s.\n", i, argv[i]);
+    }
+}
+
+int getEmmcState() {
+    char bootmode[256];
+    int result = 0;
+
+    property_get("ro.boot.mode", bootmode, "unknown");
+    printf("ro.boot.mode = %s \n", bootmode);
+
+    if(!strcmp(bootmode, "nvme")) {
+        result = 2;
+    } else if(!strcmp(bootmode, "emmc")) {
+        result = 1;
+    }else {
+        result = 0;
+    }
+
+    return result;
+}
+
+/**
+ * 分割字符串
+ */
+void SplitString(const std::string& s, std::string& result, const std::string& c){
+#if 0
+    if(getEmmcState() != 0){
+        result = s;
+        return ;
+    }
+    std::string::size_type pos1, pos2;
+    pos2 = s.find(c);
+    pos1 = 0;
+    while(std::string::npos != pos2){
+        result = s.substr(pos1, pos2-pos1);
+        pos1 = pos2 + c.size();
+        pos2 = s.find(c, pos1);
+    }
+    if(pos1 != s.length())
+        result = s.substr(pos1);
+    result = "/dev/block/rknand_" + result;
+#else
+	result = s;
+	(void)c;
+#endif
+    printf("SplitString :: result is %s.\n", result.c_str());
+}
+
+bool IsSpecialName(const char *str){
+    if(getEmmcState() != 0){
+        return false;
+    }
+    string fileName[5] = {"uboot.img", "trust.img", "resource.img", "recovery.img", "boot.img"};
+    for(int i = 0; i < 5; i++){
+        if(fileName[i].compare(str) == 0){
+            printf("func is %s.\n", fileName[i].c_str());
+            return true;
+        }
+    }
+    return false;
+}
diff --git a/bootable/recovery/rkutility/sdboot.cpp b/bootable/recovery/rkutility/sdboot.cpp
new file mode 100755
index 0000000000..4a364429d6
--- /dev/null
+++ b/bootable/recovery/rkutility/sdboot.cpp
@@ -0,0 +1,395 @@
+/*
+ * Copyright 2019 Rockchip Electronics Co., Ltd
+ * Dayao Ji <jdy@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <iostream>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/mount.h> 
+#include <cutils/properties.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include "cutils/android_reboot.h"
+//#include "common.h"
+#include "rkutility/sdboot.h"
+
+//#include "otautil/roots.h"
+//#include "otautil/sysutil.h"
+
+//#include "install.h"
+//#include "recovery_ui/ui.h"
+//#include "recovery_ui/screen_ui.h"
+//#include "rkupdate/Upgrade.h"
+
+//#include <fs_mgr.h>
+enum InstallResult {
+  INSTALL_SUCCESS,
+  INSTALL_ERROR,
+  INSTALL_CORRUPT,
+  INSTALL_NONE,
+  INSTALL_SKIPPED,
+  INSTALL_RETRY,
+  INSTALL_KEY_INTERRUPTED,
+  INSTALL_REBOOT,
+};
+
+using namespace std;
+//extern RecoveryUI* ui;
+SDBoot::SDBoot(){
+    status = INSTALL_ERROR;
+    bootwhere();
+    bUpdateModel = false;
+}
+bool SDBoot::isSDboot(){
+    return bSDBoot;
+}
+bool SDBoot::isUSBboot(){
+    return bUsbBoot;
+}
+bool SDBoot::parse_config(char *pConfig,VEC_SD_CONFIG &vecItem)
+{     
+    printf("in parse_config\n");
+    std::stringstream configStream(pConfig);
+    std::string strLine,strItemName,strItemValue;
+    std::string::size_type line_size,pos;
+    vecItem.clear();
+    STRUCT_SD_CONFIG_ITEM item;
+    while (!configStream.eof())
+    { 
+        getline(configStream,strLine);
+        line_size = strLine.size();
+        if (line_size==0)
+        continue;
+        if (strLine[line_size-1]=='\r')
+        {
+            strLine = strLine.substr(0,line_size-1);
+        }
+        printf("%s\n",strLine.c_str());
+        pos = strLine.find("=");
+        if (pos==std::string::npos)
+        {
+            continue;
+        }
+        if (strLine[0]=='#')
+        {
+            continue;
+        }
+        strItemName = strLine.substr(0,pos);
+        strItemValue = strLine.substr(pos+1);
+        strItemName.erase(0,strItemName.find_first_not_of(" "));
+        strItemName.erase(strItemName.find_last_not_of(" ")+1);
+        strItemValue.erase(0,strItemValue.find_first_not_of(" "));
+        strItemValue.erase(strItemValue.find_last_not_of(" ")+1);
+        if ((strItemName.size()>0)&&(strItemValue.size()>0))
+        {
+            item.strKey = strItemName;
+            item.strValue = strItemValue;
+            vecItem.push_back(item);
+        }
+    } 
+    printf("out parse_config\n");
+    return true;
+
+}  
+bool SDBoot::parse_config_file(const char *pConfigFile,VEC_SD_CONFIG &vecItem)
+{         
+    FILE *file=NULL;
+    file = fopen(pConfigFile,"rb");
+    if( !file ){
+        return false;
+    }    
+    int iFileSize;
+    fseek(file,0,SEEK_END);
+    iFileSize = ftell(file);
+    fseek(file,0,SEEK_SET);
+    char *pConfigBuf=NULL;
+    pConfigBuf = new char[iFileSize+1];
+    if (!pConfigBuf)
+    {    
+        fclose(file);
+        return false;
+    }    
+    memset(pConfigBuf,0,iFileSize+1);
+    int iRead;
+    iRead = fread(pConfigBuf,1,iFileSize,file);
+    if (iRead!=iFileSize)
+    {    
+        fclose(file);
+        delete []pConfigBuf;
+        return false;
+    }    
+    fclose(file);
+    bool bRet;
+    bRet = parse_config(pConfigBuf,vecItem);
+    delete []pConfigBuf;
+    printf("out parse_config_file\n");
+    return bRet;
+}      
+std::vector<std::string> SDBoot::get_sd_config(char *configFile, int argc, char **argv){
+    std::vector<std::string> args(argv, argv + argc);
+    char arg[64];
+    VEC_SD_CONFIG vecItem;
+    unsigned long i;
+    if (!parse_config_file(configFile,vecItem))
+    {
+        printf("out get_args_from_sd:parse_config_file\n");
+        return args;
+    }
+
+    for (i=0;i<vecItem.size();i++)
+    {
+        if ((strcmp(vecItem[i].strKey.c_str(),"pcba_test")==0)||
+            (strcmp(vecItem[i].strKey.c_str(),"fw_update")==0)||
+            (strcmp(vecItem[i].strKey.c_str(),"demo_copy")==0)||
+            (strcmp(vecItem[i].strKey.c_str(),"volume_label")==0))
+        {
+            if (strcmp(vecItem[i].strValue.c_str(),"0")!=0)
+            {
+                sprintf(arg,"--%s=%s",vecItem[i].strKey.c_str(),vecItem[i].strValue.c_str());
+                printf("%s\n",arg);
+                args.push_back(arg);
+            }
+        }
+    }
+    printf("out get_args_from_sd\n");
+    return args;
+}
+
+std::vector<std::string> SDBoot::get_args_from_usb(int argc, char **argv){
+    printf("in get_args_from_usb\n");
+    std::vector<std::string> args;
+    ensure_usb_mounted(); 
+    if (!bUsbMounted) 
+    {
+        printf("out get_args_from_usb:bUsbMounted=false\n");
+        return args;
+    }
+
+    char configFile[64];
+    strcpy(configFile, USB_ROOT);
+    strcat(configFile, "/sd_boot_config.config");  
+    args =  get_sd_config(configFile, argc, argv);
+
+    return args;
+}
+
+
+void SDBoot::bootwhere(){
+    bSDBoot = false;
+    char param[1024];
+    int fd, ret; 
+    char *s=NULL;
+    printf("read cmdline\n");
+    memset(param,0,1024);
+    fd= open("/proc/cmdline", O_RDONLY);
+    ret = read(fd, (char*)param, 1024);
+
+    s = strstr(param,"sdfwupdate");
+    if(s != NULL){
+        bSDBoot = true;
+    }else{ 
+        bSDBoot = false;
+    }
+
+    s = strstr(param, "usbfwupdate");
+    if(s != NULL){
+        bUsbBoot = true;
+    }else{
+        bUsbBoot = false;
+    }
+
+    close(fd);
+}
+
+
+void SDBoot::ensure_usb_mounted(){
+    int i;
+    for(i = 0; i < 10; i++) {
+        if(0 == mount_usb_device()){
+            bUsbMounted = true;
+            break;
+        }else {
+            printf("delay 1sec\n");
+            sleep(1);
+        }
+    } 
+}
+
+
+int SDBoot::mount_usb_device()
+{
+    char configFile[64];
+    char usbDevice[64];
+    int result;
+    DIR* d=NULL;
+    struct dirent* de;
+    d = opendir(USB_ROOT);
+    if (d)
+    {//check whether usb_root has  mounted
+     strcpy(configFile, USB_ROOT);
+     strcat(configFile, "/sd_boot_config.config");
+     if (access(configFile,F_OK)==0)
+     {
+         closedir(d);
+         return 0;
+     }
+     closedir(d);
+    }  
+    else
+    {  
+        if (errno==ENOENT)
+        {
+            if (mkdir(USB_ROOT,0755)!=0)
+            {
+                printf("failed to create %s dir,err=%s!\n",USB_ROOT,strerror(errno));
+                return -1;
+            }
+        }
+        else
+        {   
+            printf("failed to open %s dir,err=%s\n!",USB_ROOT,strerror(errno));
+            return -1;
+        }   
+    }       
+
+    d = opendir("/dev/block");
+    if(d != NULL) {
+        while((de = readdir(d))) {
+            printf("/dev/block/%s\n", de->d_name);
+            if((strncmp(de->d_name, "sd", 2) == 0) &&(isxdigit(de->d_name[strlen(de->d_name)-1])!=0)){
+                memset(usbDevice, 0, sizeof(usbDevice));
+                sprintf(usbDevice, "/dev/block/%s", de->d_name);
+                printf("try to mount usb device %s by vfat", usbDevice);
+                result = mount(usbDevice, USB_ROOT, "vfat",
+                               MS_NOATIME | MS_NODEV | MS_NODIRATIME, "shortname=mixed,utf8");
+                if(result != 0) {
+                    printf("try to mount usb device %s by ntfs\n", usbDevice);
+                    result = mount(usbDevice, USB_ROOT, "ntfs",
+                                   MS_NOATIME | MS_NODEV | MS_NODIRATIME, "");
+                }
+
+                if(result == 0) {
+                    //strcpy(USB_DEVICE_PATH,usbDevice);
+                    USB_DEVICE_PATH = usbDevice;
+                    closedir(d);
+                    return 0;
+                }
+            }
+        }
+        closedir(d); 
+    } 
+
+             return -2;
+}
+
+bool SDBoot::do_direct_parse_config_file(const char * pConfigFile,VEC_SD_CONFIG & vecItem){
+	printf("enter do_direct_parse_config_file!\n");
+	return parse_config_file(pConfigFile, vecItem);
+}
+
+int SDBoot::do_rk_factory_mode(){
+    //pcba_test
+    printf("enter pcba test!\n");
+
+    status = INSTALL_SUCCESS;
+    const char *args[2];
+    args[0] = "/sbin/pcba_core";
+    args[1] = NULL;
+
+    pid_t child = fork();
+    if (child == 0) {
+        execv(args[0], (char* const*)args);
+        fprintf(stderr, "run_program: execv failed: %s\n", strerror(errno));
+        status = INSTALL_ERROR;
+        //pcbaTestPass = false;
+    }
+    int child_status;
+    waitpid(child, &child_status, 0);
+    if (WIFEXITED(child_status)) {
+        if (WEXITSTATUS(child_status) != 0) {
+            printf("pcba test error coder is %d \n", WEXITSTATUS(child_status));
+            status = INSTALL_ERROR;
+            //pcbaTestPass = false;
+        }
+    } else if (WIFSIGNALED(child_status)) {
+        printf("run_program: child terminated by signal %d\n", WTERMSIG(child_status));
+        status = INSTALL_ERROR;
+        //pcbaTestPass = false;
+    }
+    return status;
+}
+
+
+void SDBoot::sdboot_set_status(int stat){
+	printf("enter sdboot_set_status !\n");
+	status = stat;
+}
+
+int SDBoot::sdboot_get_status(void){
+	printf("enter sdboot_get_status !\n");
+	return status;
+}
+
+bool SDBoot::sdboot_get_bSDBoot(void){
+	printf("enter sdboot_get_bSDBoot !\n");
+	return bSDBoot;
+}
+
+void SDBoot::sdboot_set_bSDBoot(bool is_sdboot){
+	printf("enter sdboot_set_bSDBoot !\n");
+	bSDBoot = is_sdboot;
+}
+
+
+bool SDBoot::sdboot_get_bUsbBoot(void){
+	printf("enter sdboot_get_bUsbBoot !\n");
+	return bUsbBoot;
+}
+
+void SDBoot::sdboot_set_bUsbBoot(bool is_usbboot){
+	printf("enter sdboot_set_bUsbBoot !\n");
+	bUsbBoot = is_usbboot;
+}
+
+
+void SDBoot::sdboot_set_bUpdateModel(bool bUpdate){
+	printf("enter sdboot_set_bUpdateModel !\n");
+	bUpdateModel = bUpdate;
+}
+
+bool SDBoot::sdboot_get_bUpdateModel(void){
+	printf("enter sdboot_get_bUpdateModel !\n");
+	return bUpdateModel;
+}
+
+std::string SDBoot::sdboot_get_usb_device_path(void){
+	printf("enter sdboot_get_usb_device_path !\n");
+	return USB_DEVICE_PATH;
+}
+
+void SDBoot::sdboot_set_bSDMounted(bool bMounted){
+	printf("enter sdboot_set_bUpdateModel !\n");
+	bSDMounted = bMounted;
+}
+
+bool SDBoot::sdboot_get_bSDMounted(void){
+	printf("enter sdboot_get_bUpdateModel !\n");
+	return bSDMounted;
+}
+
+bool SDBoot::sdboot_get_bUsbMounted(void){
+	printf("enter sdboot_get_bUpdateModel !\n");
+	return bUsbMounted;
+}
+
+
+
diff --git a/external/e2fsprogs/debugfs/debug_cmds.c b/external/e2fsprogs/debugfs/debug_cmds.c
new file mode 100644
index 0000000000..e1d85f8eea
--- /dev/null
+++ b/external/e2fsprogs/debugfs/debug_cmds.c
@@ -0,0 +1,724 @@
+/* debugfs/debug_cmds.c - automatically generated from debugfs/debug_cmds.ct */
+#include <ss/ss.h>
+
+static char const * const ssu00001[] = {
+"show_debugfs_params",
+    "params",
+    (char const *)0
+};
+extern void do_show_debugfs_params __SS_PROTO;
+static char const * const ssu00002[] = {
+"open_filesys",
+    "open",
+    (char const *)0
+};
+extern void do_open_filesys __SS_PROTO;
+static char const * const ssu00003[] = {
+"close_filesys",
+    "close",
+    (char const *)0
+};
+extern void do_close_filesys __SS_PROTO;
+static char const * const ssu00004[] = {
+"freefrag",
+    "e2freefrag",
+    (char const *)0
+};
+extern void do_freefrag __SS_PROTO;
+static char const * const ssu00005[] = {
+"feature",
+    "features",
+    (char const *)0
+};
+extern void do_features __SS_PROTO;
+static char const * const ssu00006[] = {
+"dirty_filesys",
+    "dirty",
+    (char const *)0
+};
+extern void do_dirty_filesys __SS_PROTO;
+static char const * const ssu00007[] = {
+"init_filesys",
+    (char const *)0
+};
+extern void do_init_filesys __SS_PROTO;
+static char const * const ssu00008[] = {
+"show_super_stats",
+    "stats",
+    (char const *)0
+};
+extern void do_show_super_stats __SS_PROTO;
+static char const * const ssu00009[] = {
+"ncheck",
+    (char const *)0
+};
+extern void do_ncheck __SS_PROTO;
+static char const * const ssu00010[] = {
+"icheck",
+    (char const *)0
+};
+extern void do_icheck __SS_PROTO;
+static char const * const ssu00011[] = {
+"change_root_directory",
+    "chroot",
+    (char const *)0
+};
+extern void do_chroot __SS_PROTO;
+static char const * const ssu00012[] = {
+"change_working_directory",
+    "cd",
+    (char const *)0
+};
+extern void do_change_working_dir __SS_PROTO;
+static char const * const ssu00013[] = {
+"list_directory",
+    "ls",
+    (char const *)0
+};
+extern void do_list_dir __SS_PROTO;
+static char const * const ssu00014[] = {
+"show_inode_info",
+    "stat",
+    (char const *)0
+};
+extern void do_stat __SS_PROTO;
+static char const * const ssu00015[] = {
+"dump_extents",
+    "extents",
+    "ex",
+    (char const *)0
+};
+extern void do_dump_extents __SS_PROTO;
+static char const * const ssu00016[] = {
+"blocks",
+    (char const *)0
+};
+extern void do_blocks __SS_PROTO;
+static char const * const ssu00017[] = {
+"filefrag",
+    (char const *)0
+};
+extern void do_filefrag __SS_PROTO;
+static char const * const ssu00018[] = {
+"link",
+    "ln",
+    (char const *)0
+};
+extern void do_link __SS_PROTO;
+static char const * const ssu00019[] = {
+"unlink",
+    (char const *)0
+};
+extern void do_unlink __SS_PROTO;
+static char const * const ssu00020[] = {
+"mkdir",
+    (char const *)0
+};
+extern void do_mkdir __SS_PROTO;
+static char const * const ssu00021[] = {
+"rmdir",
+    (char const *)0
+};
+extern void do_rmdir __SS_PROTO;
+static char const * const ssu00022[] = {
+"rm",
+    (char const *)0
+};
+extern void do_rm __SS_PROTO;
+static char const * const ssu00023[] = {
+"kill_file",
+    (char const *)0
+};
+extern void do_kill_file __SS_PROTO;
+static char const * const ssu00024[] = {
+"copy_inode",
+    (char const *)0
+};
+extern void do_copy_inode __SS_PROTO;
+static char const * const ssu00025[] = {
+"clri",
+    (char const *)0
+};
+extern void do_clri __SS_PROTO;
+static char const * const ssu00026[] = {
+"freei",
+    (char const *)0
+};
+extern void do_freei __SS_PROTO;
+static char const * const ssu00027[] = {
+"seti",
+    (char const *)0
+};
+extern void do_seti __SS_PROTO;
+static char const * const ssu00028[] = {
+"testi",
+    (char const *)0
+};
+extern void do_testi __SS_PROTO;
+static char const * const ssu00029[] = {
+"freeb",
+    (char const *)0
+};
+extern void do_freeb __SS_PROTO;
+static char const * const ssu00030[] = {
+"setb",
+    (char const *)0
+};
+extern void do_setb __SS_PROTO;
+static char const * const ssu00031[] = {
+"testb",
+    (char const *)0
+};
+extern void do_testb __SS_PROTO;
+static char const * const ssu00032[] = {
+"modify_inode",
+    "mi",
+    (char const *)0
+};
+extern void do_modify_inode __SS_PROTO;
+static char const * const ssu00033[] = {
+"find_free_block",
+    "ffb",
+    (char const *)0
+};
+extern void do_find_free_block __SS_PROTO;
+static char const * const ssu00034[] = {
+"find_free_inode",
+    "ffi",
+    (char const *)0
+};
+extern void do_find_free_inode __SS_PROTO;
+static char const * const ssu00035[] = {
+"print_working_directory",
+    "pwd",
+    (char const *)0
+};
+extern void do_print_working_directory __SS_PROTO;
+static char const * const ssu00036[] = {
+"expand_dir",
+    "expand",
+    (char const *)0
+};
+extern void do_expand_dir __SS_PROTO;
+static char const * const ssu00037[] = {
+"mknod",
+    (char const *)0
+};
+extern void do_mknod __SS_PROTO;
+static char const * const ssu00038[] = {
+"list_deleted_inodes",
+    "lsdel",
+    (char const *)0
+};
+extern void do_lsdel __SS_PROTO;
+static char const * const ssu00039[] = {
+"undelete",
+    "undel",
+    (char const *)0
+};
+extern void do_undel __SS_PROTO;
+static char const * const ssu00040[] = {
+"write",
+    (char const *)0
+};
+extern void do_write __SS_PROTO;
+static char const * const ssu00041[] = {
+"dump_inode",
+    "dump",
+    (char const *)0
+};
+extern void do_dump __SS_PROTO;
+static char const * const ssu00042[] = {
+"cat",
+    (char const *)0
+};
+extern void do_cat __SS_PROTO;
+static char const * const ssu00043[] = {
+"lcd",
+    (char const *)0
+};
+extern void do_lcd __SS_PROTO;
+static char const * const ssu00044[] = {
+"rdump",
+    (char const *)0
+};
+extern void do_rdump __SS_PROTO;
+static char const * const ssu00045[] = {
+"set_super_value",
+    "ssv",
+    (char const *)0
+};
+extern void do_set_super __SS_PROTO;
+static char const * const ssu00046[] = {
+"set_inode_field",
+    "sif",
+    (char const *)0
+};
+extern void do_set_inode __SS_PROTO;
+static char const * const ssu00047[] = {
+"set_block_group",
+    "set_bg",
+    (char const *)0
+};
+extern void do_set_block_group_descriptor __SS_PROTO;
+static char const * const ssu00048[] = {
+"logdump",
+    (char const *)0
+};
+extern void do_logdump __SS_PROTO;
+static char const * const ssu00049[] = {
+"htree_dump",
+    "htree",
+    (char const *)0
+};
+extern void do_htree_dump __SS_PROTO;
+static char const * const ssu00050[] = {
+"dx_hash",
+    "hash",
+    (char const *)0
+};
+extern void do_dx_hash __SS_PROTO;
+static char const * const ssu00051[] = {
+"dirsearch",
+    (char const *)0
+};
+extern void do_dirsearch __SS_PROTO;
+static char const * const ssu00052[] = {
+"bmap",
+    (char const *)0
+};
+extern void do_bmap __SS_PROTO;
+static char const * const ssu00053[] = {
+"fallocate",
+    (char const *)0
+};
+extern void do_fallocate __SS_PROTO;
+static char const * const ssu00054[] = {
+"punch",
+    "truncate",
+    (char const *)0
+};
+extern void do_punch __SS_PROTO;
+static char const * const ssu00055[] = {
+"symlink",
+    (char const *)0
+};
+extern void do_symlink __SS_PROTO;
+static char const * const ssu00056[] = {
+"imap",
+    (char const *)0
+};
+extern void do_imap __SS_PROTO;
+static char const * const ssu00057[] = {
+"dump_unused",
+    (char const *)0
+};
+extern void do_dump_unused __SS_PROTO;
+static char const * const ssu00058[] = {
+"set_current_time",
+    (char const *)0
+};
+extern void do_set_current_time __SS_PROTO;
+static char const * const ssu00059[] = {
+"supported_features",
+    (char const *)0
+};
+extern void do_supported_features __SS_PROTO;
+static char const * const ssu00060[] = {
+"dump_mmp",
+    (char const *)0
+};
+extern void do_dump_mmp __SS_PROTO;
+static char const * const ssu00061[] = {
+"set_mmp_value",
+    "smmp",
+    (char const *)0
+};
+extern void do_set_mmp_value __SS_PROTO;
+static char const * const ssu00062[] = {
+"extent_open",
+    "eo",
+    (char const *)0
+};
+extern void do_extent_open __SS_PROTO;
+static char const * const ssu00063[] = {
+"zap_block",
+    "zap",
+    (char const *)0
+};
+extern void do_zap_block __SS_PROTO;
+static char const * const ssu00064[] = {
+"block_dump",
+    "bdump",
+    "bd",
+    (char const *)0
+};
+extern void do_block_dump __SS_PROTO;
+static char const * const ssu00065[] = {
+"ea_list",
+    (char const *)0
+};
+extern void do_list_xattr __SS_PROTO;
+static char const * const ssu00066[] = {
+"ea_get",
+    (char const *)0
+};
+extern void do_get_xattr __SS_PROTO;
+static char const * const ssu00067[] = {
+"ea_set",
+    (char const *)0
+};
+extern void do_set_xattr __SS_PROTO;
+static char const * const ssu00068[] = {
+"ea_rm",
+    (char const *)0
+};
+extern void do_rm_xattr __SS_PROTO;
+static char const * const ssu00069[] = {
+"list_quota",
+    "lq",
+    (char const *)0
+};
+extern void do_list_quota __SS_PROTO;
+static char const * const ssu00070[] = {
+"get_quota",
+    "gq",
+    (char const *)0
+};
+extern void do_get_quota __SS_PROTO;
+static char const * const ssu00071[] = {
+"inode_dump",
+    "idump",
+    "id",
+    (char const *)0
+};
+extern void do_idump __SS_PROTO;
+static char const * const ssu00072[] = {
+"journal_open",
+    "jo",
+    (char const *)0
+};
+extern void do_journal_open __SS_PROTO;
+static char const * const ssu00073[] = {
+"journal_close",
+    "jc",
+    (char const *)0
+};
+extern void do_journal_close __SS_PROTO;
+static char const * const ssu00074[] = {
+"journal_write",
+    "jw",
+    (char const *)0
+};
+extern void do_journal_write __SS_PROTO;
+static char const * const ssu00075[] = {
+"journal_run",
+    "jr",
+    (char const *)0
+};
+extern void do_journal_run __SS_PROTO;
+static ss_request_entry ssu00076[] = {
+    { ssu00001,
+      do_show_debugfs_params,
+      "Show debugfs parameters",
+      0 },
+    { ssu00002,
+      do_open_filesys,
+      "Open a filesystem",
+      0 },
+    { ssu00003,
+      do_close_filesys,
+      "Close the filesystem",
+      0 },
+    { ssu00004,
+      do_freefrag,
+      "Report free space fragmentation",
+      0 },
+    { ssu00005,
+      do_features,
+      "Set/print superblock features",
+      0 },
+    { ssu00006,
+      do_dirty_filesys,
+      "Mark the filesystem as dirty",
+      0 },
+    { ssu00007,
+      do_init_filesys,
+      "Initialize a filesystem (DESTROYS DATA)",
+      0 },
+    { ssu00008,
+      do_show_super_stats,
+      "Show superblock statistics",
+      0 },
+    { ssu00009,
+      do_ncheck,
+      "Do inode->name translation",
+      0 },
+    { ssu00010,
+      do_icheck,
+      "Do block->inode translation",
+      0 },
+    { ssu00011,
+      do_chroot,
+      "Change root directory",
+      0 },
+    { ssu00012,
+      do_change_working_dir,
+      "Change working directory",
+      0 },
+    { ssu00013,
+      do_list_dir,
+      "List directory",
+      0 },
+    { ssu00014,
+      do_stat,
+      "Show inode information ",
+      0 },
+    { ssu00015,
+      do_dump_extents,
+      "Dump extents information ",
+      0 },
+    { ssu00016,
+      do_blocks,
+      "Dump blocks used by an inode ",
+      0 },
+    { ssu00017,
+      do_filefrag,
+      "Report fragmentation information for an inode",
+      0 },
+    { ssu00018,
+      do_link,
+      "Create directory link",
+      0 },
+    { ssu00019,
+      do_unlink,
+      "Delete a directory link",
+      0 },
+    { ssu00020,
+      do_mkdir,
+      "Create a directory",
+      0 },
+    { ssu00021,
+      do_rmdir,
+      "Remove a directory",
+      0 },
+    { ssu00022,
+      do_rm,
+      "Remove a file (unlink and kill_file, if appropriate)",
+      0 },
+    { ssu00023,
+      do_kill_file,
+      "Deallocate an inode and its blocks",
+      0 },
+    { ssu00024,
+      do_copy_inode,
+      "Copy the inode structure",
+      0 },
+    { ssu00025,
+      do_clri,
+      "Clear an inode's contents",
+      0 },
+    { ssu00026,
+      do_freei,
+      "Clear an inode's in-use flag",
+      0 },
+    { ssu00027,
+      do_seti,
+      "Set an inode's in-use flag",
+      0 },
+    { ssu00028,
+      do_testi,
+      "Test an inode's in-use flag",
+      0 },
+    { ssu00029,
+      do_freeb,
+      "Clear a block's in-use flag",
+      0 },
+    { ssu00030,
+      do_setb,
+      "Set a block's in-use flag",
+      0 },
+    { ssu00031,
+      do_testb,
+      "Test a block's in-use flag",
+      0 },
+    { ssu00032,
+      do_modify_inode,
+      "Modify an inode by structure",
+      0 },
+    { ssu00033,
+      do_find_free_block,
+      "Find free block(s)",
+      0 },
+    { ssu00034,
+      do_find_free_inode,
+      "Find free inode(s)",
+      0 },
+    { ssu00035,
+      do_print_working_directory,
+      "Print current working directory",
+      0 },
+    { ssu00036,
+      do_expand_dir,
+      "Expand directory",
+      0 },
+    { ssu00037,
+      do_mknod,
+      "Create a special file",
+      0 },
+    { ssu00038,
+      do_lsdel,
+      "List deleted inodes",
+      0 },
+    { ssu00039,
+      do_undel,
+      "Undelete file",
+      0 },
+    { ssu00040,
+      do_write,
+      "Copy a file from your native filesystem",
+      0 },
+    { ssu00041,
+      do_dump,
+      "Dump an inode out to a file",
+      0 },
+    { ssu00042,
+      do_cat,
+      "Dump an inode out to stdout",
+      0 },
+    { ssu00043,
+      do_lcd,
+      "Change the current directory on your native filesystem",
+      0 },
+    { ssu00044,
+      do_rdump,
+      "Recursively dump a directory to the native filesystem",
+      0 },
+    { ssu00045,
+      do_set_super,
+      "Set superblock value",
+      0 },
+    { ssu00046,
+      do_set_inode,
+      "Set inode field",
+      0 },
+    { ssu00047,
+      do_set_block_group_descriptor,
+      "Set block group descriptor field",
+      0 },
+    { ssu00048,
+      do_logdump,
+      "Dump the contents of the journal",
+      0 },
+    { ssu00049,
+      do_htree_dump,
+      "Dump a hash-indexed directory",
+      0 },
+    { ssu00050,
+      do_dx_hash,
+      "Calculate the directory hash of a filename",
+      0 },
+    { ssu00051,
+      do_dirsearch,
+      "Search a directory for a particular filename",
+      0 },
+    { ssu00052,
+      do_bmap,
+      "Calculate the logical->physical block mapping for an inode",
+      0 },
+    { ssu00053,
+      do_fallocate,
+      "Allocate uninitialized blocks to an inode",
+      0 },
+    { ssu00054,
+      do_punch,
+      "Punch (or truncate) blocks from an inode by deallocating them",
+      0 },
+    { ssu00055,
+      do_symlink,
+      "Create a symbolic link",
+      0 },
+    { ssu00056,
+      do_imap,
+      "Calculate the location of an inode",
+      0 },
+    { ssu00057,
+      do_dump_unused,
+      "Dump unused blocks",
+      0 },
+    { ssu00058,
+      do_set_current_time,
+      "Set current time to use when setting filesystem fields",
+      0 },
+    { ssu00059,
+      do_supported_features,
+      "Print features supported by this version of e2fsprogs",
+      0 },
+    { ssu00060,
+      do_dump_mmp,
+      "Dump MMP information",
+      0 },
+    { ssu00061,
+      do_set_mmp_value,
+      "Set MMP value",
+      0 },
+    { ssu00062,
+      do_extent_open,
+      "Open inode for extent manipulation",
+      0 },
+    { ssu00063,
+      do_zap_block,
+      "Zap block: fill with 0, pattern, flip bits etc.",
+      0 },
+    { ssu00064,
+      do_block_dump,
+      "Dump contents of a block",
+      0 },
+    { ssu00065,
+      do_list_xattr,
+      "List extended attributes of an inode",
+      0 },
+    { ssu00066,
+      do_get_xattr,
+      "Get an extended attribute of an inode",
+      0 },
+    { ssu00067,
+      do_set_xattr,
+      "Set an extended attribute of an inode",
+      0 },
+    { ssu00068,
+      do_rm_xattr,
+      "Remove an extended attribute of an inode",
+      0 },
+    { ssu00069,
+      do_list_quota,
+      "List quota",
+      0 },
+    { ssu00070,
+      do_get_quota,
+      "Get quota",
+      0 },
+    { ssu00071,
+      do_idump,
+      "Dump the inode structure in hex",
+      0 },
+    { ssu00072,
+      do_journal_open,
+      "Open the journal",
+      0 },
+    { ssu00073,
+      do_journal_close,
+      "Close the journal",
+      0 },
+    { ssu00074,
+      do_journal_write,
+      "Write a transaction to the journal",
+      0 },
+    { ssu00075,
+      do_journal_run,
+      "Recover the journal",
+      0 },
+    { 0, 0, 0, 0 }
+};
+
+ss_request_table debug_cmds = { 2, ssu00076 };
diff --git a/external/e2fsprogs/debugfs/extent_cmds.c b/external/e2fsprogs/debugfs/extent_cmds.c
new file mode 100644
index 0000000000..902dcad3d5
--- /dev/null
+++ b/external/e2fsprogs/debugfs/extent_cmds.c
@@ -0,0 +1,240 @@
+/* debugfs/extent_cmds.c - automatically generated from debugfs/extent_cmds.ct */
+#include <ss/ss.h>
+
+static char const * const ssu00001[] = {
+"current_node",
+    "current",
+    (char const *)0
+};
+extern void do_current_node __SS_PROTO;
+static char const * const ssu00002[] = {
+"root_node",
+    "root",
+    (char const *)0
+};
+extern void do_root_node __SS_PROTO;
+static char const * const ssu00003[] = {
+"last_leaf",
+    (char const *)0
+};
+extern void do_last_leaf __SS_PROTO;
+static char const * const ssu00004[] = {
+"first_sibling",
+    "first_sib",
+    (char const *)0
+};
+extern void do_first_sib __SS_PROTO;
+static char const * const ssu00005[] = {
+"last_sibling",
+    "last_sib",
+    (char const *)0
+};
+extern void do_last_sib __SS_PROTO;
+static char const * const ssu00006[] = {
+"next_sibling",
+    "next_sib",
+    "ns",
+    (char const *)0
+};
+extern void do_next_sib __SS_PROTO;
+static char const * const ssu00007[] = {
+"prev_sibling",
+    "prev_sib",
+    "ps",
+    (char const *)0
+};
+extern void do_prev_sib __SS_PROTO;
+static char const * const ssu00008[] = {
+"next_leaf",
+    "nl",
+    (char const *)0
+};
+extern void do_next_leaf __SS_PROTO;
+static char const * const ssu00009[] = {
+"prev_leaf",
+    "pl",
+    (char const *)0
+};
+extern void do_prev_leaf __SS_PROTO;
+static char const * const ssu00010[] = {
+"next",
+    "n",
+    (char const *)0
+};
+extern void do_next __SS_PROTO;
+static char const * const ssu00011[] = {
+"previous",
+    "prev",
+    "p",
+    (char const *)0
+};
+extern void do_prev __SS_PROTO;
+static char const * const ssu00012[] = {
+"up_node",
+    "up",
+    "u",
+    (char const *)0
+};
+extern void do_up __SS_PROTO;
+static char const * const ssu00013[] = {
+"down_node",
+    "down",
+    "d",
+    (char const *)0
+};
+extern void do_down __SS_PROTO;
+static char const * const ssu00014[] = {
+"delete_node",
+    "delete",
+    (char const *)0
+};
+extern void do_delete_node __SS_PROTO;
+static char const * const ssu00015[] = {
+"insert_node",
+    "insert",
+    (char const *)0
+};
+extern void do_insert_node __SS_PROTO;
+static char const * const ssu00016[] = {
+"split_node",
+    "split",
+    (char const *)0
+};
+extern void do_split_node __SS_PROTO;
+static char const * const ssu00017[] = {
+"fix_parents",
+    "fixp",
+    (char const *)0
+};
+extern void do_fix_parents __SS_PROTO;
+static char const * const ssu00018[] = {
+"set_bmap",
+    (char const *)0
+};
+extern void do_set_bmap __SS_PROTO;
+static char const * const ssu00019[] = {
+"replace_node",
+    "replace",
+    (char const *)0
+};
+extern void do_replace_node __SS_PROTO;
+static char const * const ssu00020[] = {
+"print_all",
+    "all",
+    (char const *)0
+};
+extern void do_print_all __SS_PROTO;
+static char const * const ssu00021[] = {
+"goto_block",
+    "goto",
+    (char const *)0
+};
+extern void do_goto_block __SS_PROTO;
+static char const * const ssu00022[] = {
+"info",
+    (char const *)0
+};
+extern void do_info __SS_PROTO;
+static char const * const ssu00023[] = {
+"extent_close",
+    "ec",
+    (char const *)0
+};
+extern void do_extent_close __SS_PROTO;
+static ss_request_entry ssu00024[] = {
+    { ssu00001,
+      do_current_node,
+      "Current extent node",
+      0 },
+    { ssu00002,
+      do_root_node,
+      "Goto root extent",
+      0 },
+    { ssu00003,
+      do_last_leaf,
+      "Goto last leaf",
+      0 },
+    { ssu00004,
+      do_first_sib,
+      "Goto first sibling",
+      0 },
+    { ssu00005,
+      do_last_sib,
+      "Goto last sibling",
+      0 },
+    { ssu00006,
+      do_next_sib,
+      "Goto next sibling",
+      0 },
+    { ssu00007,
+      do_prev_sib,
+      "Goto previous sibling",
+      0 },
+    { ssu00008,
+      do_next_leaf,
+      "Goto next leaf",
+      0 },
+    { ssu00009,
+      do_prev_leaf,
+      "Goto previous leaf",
+      0 },
+    { ssu00010,
+      do_next,
+      "Goto next node",
+      0 },
+    { ssu00011,
+      do_prev,
+      "Goto previous node",
+      0 },
+    { ssu00012,
+      do_up,
+      "Up node",
+      0 },
+    { ssu00013,
+      do_down,
+      "Down node",
+      0 },
+    { ssu00014,
+      do_delete_node,
+      "Delete node",
+      0 },
+    { ssu00015,
+      do_insert_node,
+      "Insert node",
+      0 },
+    { ssu00016,
+      do_split_node,
+      "Split node",
+      0 },
+    { ssu00017,
+      do_fix_parents,
+      "Fix parents",
+      0 },
+    { ssu00018,
+      do_set_bmap,
+      "Set block mapping",
+      0 },
+    { ssu00019,
+      do_replace_node,
+      "Insert node",
+      0 },
+    { ssu00020,
+      do_print_all,
+      "Iterate over all nodes and print them",
+      0 },
+    { ssu00021,
+      do_goto_block,
+      "Goto extent containing specified block",
+      0 },
+    { ssu00022,
+      do_info,
+      "Print extent info",
+      0 },
+    { ssu00023,
+      do_extent_close,
+      "Close extent handle",
+      0 },
+    { 0, 0, 0, 0 }
+};
+
+ss_request_table extent_cmds = { 2, ssu00024 };
diff --git a/external/e2fsprogs/lib/blkid/blkid.h b/external/e2fsprogs/lib/blkid/blkid.h
new file mode 100644
index 0000000000..81f3098c1b
--- /dev/null
+++ b/external/e2fsprogs/lib/blkid/blkid.h
@@ -0,0 +1,110 @@
+/*
+ * blkid.h - Interface for libblkid, a library to identify block devices
+ *
+ * Copyright (C) 2001 Andreas Dilger
+ * Copyright (C) 2003 Theodore Ts'o
+ *
+ * %Begin-Header%
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ * %End-Header%
+ */
+
+#ifndef _BLKID_BLKID_H
+#define _BLKID_BLKID_H
+
+#include <sys/types.h>
+#include <blkid/blkid_types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define BLKID_VERSION	"1.0.0"
+#define BLKID_DATE	"12-Feb-2003"
+
+typedef struct blkid_struct_dev *blkid_dev;
+typedef struct blkid_struct_cache *blkid_cache;
+typedef __s64 blkid_loff_t;
+
+typedef struct blkid_struct_tag_iterate *blkid_tag_iterate;
+typedef struct blkid_struct_dev_iterate *blkid_dev_iterate;
+
+/*
+ * Flags for blkid_get_dev
+ *
+ * BLKID_DEV_CREATE	Create an empty device structure if not found
+ * 			in the cache.
+ * BLKID_DEV_VERIFY	Make sure the device structure corresponds
+ * 			with reality.
+ * BLKID_DEV_FIND	Just look up a device entry, and return NULL
+ * 			if it is not found.
+ * BLKID_DEV_NORMAL	Get a valid device structure, either from the
+ * 			cache or by probing the device.
+ */
+#define BLKID_DEV_FIND		0x0000
+#define BLKID_DEV_CREATE	0x0001
+#define BLKID_DEV_VERIFY	0x0002
+#define BLKID_DEV_NORMAL	(BLKID_DEV_CREATE | BLKID_DEV_VERIFY)
+
+/* cache.c */
+extern void blkid_put_cache(blkid_cache cache);
+extern int blkid_get_cache(blkid_cache *cache, const char *filename);
+extern void blkid_gc_cache(blkid_cache cache);
+
+/* dev.c */
+extern const char *blkid_dev_devname(blkid_dev dev);
+
+extern blkid_dev_iterate blkid_dev_iterate_begin(blkid_cache cache);
+extern int blkid_dev_set_search(blkid_dev_iterate iter,
+				char *search_type, char *search_value);
+extern int blkid_dev_next(blkid_dev_iterate iterate, blkid_dev *dev);
+extern void blkid_dev_iterate_end(blkid_dev_iterate iterate);
+
+/* devno.c */
+extern char *blkid_devno_to_devname(dev_t devno);
+
+/* devname.c */
+extern int blkid_probe_all(blkid_cache cache);
+extern int blkid_probe_all_new(blkid_cache cache);
+extern blkid_dev blkid_get_dev(blkid_cache cache, const char *devname,
+			       int flags);
+
+/* getsize.c */
+extern blkid_loff_t blkid_get_dev_size(int fd);
+
+/* probe.c */
+int blkid_known_fstype(const char *fstype);
+extern blkid_dev blkid_verify(blkid_cache cache, blkid_dev dev);
+
+/* read.c */
+
+/* resolve.c */
+extern char *blkid_get_tag_value(blkid_cache cache, const char *tagname,
+				       const char *devname);
+extern char *blkid_get_devname(blkid_cache cache, const char *token,
+			       const char *value);
+
+/* tag.c */
+extern blkid_tag_iterate blkid_tag_iterate_begin(blkid_dev dev);
+extern int blkid_tag_next(blkid_tag_iterate iterate,
+			      const char **type, const char **value);
+extern void blkid_tag_iterate_end(blkid_tag_iterate iterate);
+extern int blkid_dev_has_tag(blkid_dev dev, const char *type,
+			     const char *value);
+extern blkid_dev blkid_find_dev_with_tag(blkid_cache cache,
+					 const char *type,
+					 const char *value);
+extern int blkid_parse_tag_string(const char *token, char **ret_type,
+				  char **ret_val);
+
+/* version.c */
+extern int blkid_parse_version_string(const char *ver_string);
+extern int blkid_get_library_version(const char **ver_string,
+				     const char **date_string);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _BLKID_BLKID_H */
diff --git a/external/e2fsprogs/lib/blkid/blkid_types.h b/external/e2fsprogs/lib/blkid/blkid_types.h
new file mode 100644
index 0000000000..a8d7cff1fa
--- /dev/null
+++ b/external/e2fsprogs/lib/blkid/blkid_types.h
@@ -0,0 +1,45 @@
+/* 
+ * If linux/types.h is already been included, assume it has defined
+ * everything we need.  (cross fingers)  Other header files may have
+ * also defined the types that we need.
+ */
+#if (!defined(_LINUX_TYPES_H) && !defined(_BLKID_TYPES_H) && \
+	!defined(_EXT2_TYPES_H))
+#define _EXT2_TYPES_H
+
+typedef unsigned char __u8;
+typedef __signed__ char __s8;
+typedef unsigned short __u16;
+typedef __signed__ short __s16;
+typedef unsigned int __u32;
+typedef __signed__ int __s32;
+typedef unsigned long long __u64;
+typedef __signed__ long long __s64;
+#endif
+
+#include <stdint.h> //uintptr_t
+
+/* endian checking stuff */
+#ifndef EXT2_ENDIAN_H_
+#define EXT2_ENDIAN_H_
+
+#ifdef __CHECKER__
+#ifndef __bitwise
+#define __bitwise		__attribute__((bitwise))
+#endif
+#define __force			__attribute__((force))
+#else
+#ifndef __bitwise
+#define __bitwise
+#endif
+#define __force
+#endif
+
+typedef __u16	__bitwise	__le16;
+typedef __u32	__bitwise	__le32;
+typedef __u64	__bitwise	__le64;
+typedef __u16	__bitwise	__be16;
+typedef __u32	__bitwise	__be32;
+typedef __u64	__bitwise	__be64;
+
+#endif /* EXT2_ENDIAN_H_ */
diff --git a/external/e2fsprogs/lib/config.h b/external/e2fsprogs/lib/config.h
new file mode 100644
index 0000000000..6ac16fec15
--- /dev/null
+++ b/external/e2fsprogs/lib/config.h
@@ -0,0 +1,70 @@
+#ifndef __APPLE__
+#define HAVE_MALLOC_H 1
+#endif
+
+#define ROOT_SYSCONFDIR "/etc"
+
+#define ENABLE_LIBSPARSE 1
+
+#define DISABLE_BACKTRACE 1
+#define HAVE_DIRENT_H 1
+#define HAVE_ERRNO_H 1
+#define HAVE_GETOPT_H 1
+#define HAVE_GETPWUID_R 1
+#define HAVE_INTPTR_T 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_MMAP 1
+#define HAVE_SETJMP_H 1
+#define HAVE_SNPRINTF 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRCASECMP 1
+#define HAVE_STRDUP 1
+#define HAVE_STRINGS_H 1
+#define HAVE_STRNLEN 1
+#define HAVE_STRPTIME 1
+#define HAVE_SYSCONF 1
+#define HAVE_TYPE_SSIZE_T 1
+#define HAVE_UNISTD_H 1
+#define HAVE_UTIME_H 1
+
+#define HAVE_SYS_STAT_H 1
+#if !defined(__APPLE__)
+# define HAVE_SYS_SYSMACROS_H 1
+#endif
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_TYPES_H 1
+
+#if defined(_WIN32)
+# define HAVE_LINUX_TYPES_H 1
+# define HAVE_WINSOCK_H 1
+#endif
+#if defined(__APPLE__) || defined(__linux__)
+# define HAVE_FCNTL 1
+# define HAVE_FSYNC 1
+# define HAVE_GETPAGESIZE 1
+# define HAVE_NET_IF_H 1
+# define HAVE_NETINET_IN_H 1
+# define HAVE_PREAD 1
+# define HAVE_PWRITE 1
+# define HAVE_POSIX_MEMALIGN 1
+# define HAVE_SYS_IOCTL_H 1
+# define HAVE_SYS_MMAN_H 1
+# define HAVE_SYS_MOUNT_H 1
+# define HAVE_SYS_PARAM_H 1
+# define HAVE_SYS_RESOURCE_H 1
+# define HAVE_SYS_SELECT_H 1
+# define HAVE_SYS_WAIT_H 1
+#endif
+#if defined(__linux__)
+# define HAVE_EXT2_IOCTLS 1
+# define HAVE_FALLOCATE 1
+# define HAVE_LINUX_FD_H 1
+# define HAVE_LINUX_TYPES_H 1
+# define HAVE_LSEEK64 1
+# define HAVE_LSEEK64_PROTOTYPE 1
+# define HAVE_MNTENT_H 1
+# define HAVE_PREAD64 1
+# define HAVE_PWRITE64 1
+# define HAVE_SETMNTENT 1
+# define HAVE_SYS_PRCTL_H 1
+#endif
diff --git a/external/e2fsprogs/lib/ext2fs/crc32c_table.h b/external/e2fsprogs/lib/ext2fs/crc32c_table.h
new file mode 100644
index 0000000000..07b56d4db7
--- /dev/null
+++ b/external/e2fsprogs/lib/ext2fs/crc32c_table.h
@@ -0,0 +1,1044 @@
+/* this file is generated - do not edit */
+
+static const uint32_t crc32table_be[8][256] = {{
+tobe(0x00000000L), tobe(0x04c11db7L), tobe(0x09823b6eL), tobe(0x0d4326d9L), 
+tobe(0x130476dcL), tobe(0x17c56b6bL), tobe(0x1a864db2L), tobe(0x1e475005L), 
+tobe(0x2608edb8L), tobe(0x22c9f00fL), tobe(0x2f8ad6d6L), tobe(0x2b4bcb61L), 
+tobe(0x350c9b64L), tobe(0x31cd86d3L), tobe(0x3c8ea00aL), tobe(0x384fbdbdL), 
+tobe(0x4c11db70L), tobe(0x48d0c6c7L), tobe(0x4593e01eL), tobe(0x4152fda9L), 
+tobe(0x5f15adacL), tobe(0x5bd4b01bL), tobe(0x569796c2L), tobe(0x52568b75L), 
+tobe(0x6a1936c8L), tobe(0x6ed82b7fL), tobe(0x639b0da6L), tobe(0x675a1011L), 
+tobe(0x791d4014L), tobe(0x7ddc5da3L), tobe(0x709f7b7aL), tobe(0x745e66cdL), 
+tobe(0x9823b6e0L), tobe(0x9ce2ab57L), tobe(0x91a18d8eL), tobe(0x95609039L), 
+tobe(0x8b27c03cL), tobe(0x8fe6dd8bL), tobe(0x82a5fb52L), tobe(0x8664e6e5L), 
+tobe(0xbe2b5b58L), tobe(0xbaea46efL), tobe(0xb7a96036L), tobe(0xb3687d81L), 
+tobe(0xad2f2d84L), tobe(0xa9ee3033L), tobe(0xa4ad16eaL), tobe(0xa06c0b5dL), 
+tobe(0xd4326d90L), tobe(0xd0f37027L), tobe(0xddb056feL), tobe(0xd9714b49L), 
+tobe(0xc7361b4cL), tobe(0xc3f706fbL), tobe(0xceb42022L), tobe(0xca753d95L), 
+tobe(0xf23a8028L), tobe(0xf6fb9d9fL), tobe(0xfbb8bb46L), tobe(0xff79a6f1L), 
+tobe(0xe13ef6f4L), tobe(0xe5ffeb43L), tobe(0xe8bccd9aL), tobe(0xec7dd02dL), 
+tobe(0x34867077L), tobe(0x30476dc0L), tobe(0x3d044b19L), tobe(0x39c556aeL), 
+tobe(0x278206abL), tobe(0x23431b1cL), tobe(0x2e003dc5L), tobe(0x2ac12072L), 
+tobe(0x128e9dcfL), tobe(0x164f8078L), tobe(0x1b0ca6a1L), tobe(0x1fcdbb16L), 
+tobe(0x018aeb13L), tobe(0x054bf6a4L), tobe(0x0808d07dL), tobe(0x0cc9cdcaL), 
+tobe(0x7897ab07L), tobe(0x7c56b6b0L), tobe(0x71159069L), tobe(0x75d48ddeL), 
+tobe(0x6b93dddbL), tobe(0x6f52c06cL), tobe(0x6211e6b5L), tobe(0x66d0fb02L), 
+tobe(0x5e9f46bfL), tobe(0x5a5e5b08L), tobe(0x571d7dd1L), tobe(0x53dc6066L), 
+tobe(0x4d9b3063L), tobe(0x495a2dd4L), tobe(0x44190b0dL), tobe(0x40d816baL), 
+tobe(0xaca5c697L), tobe(0xa864db20L), tobe(0xa527fdf9L), tobe(0xa1e6e04eL), 
+tobe(0xbfa1b04bL), tobe(0xbb60adfcL), tobe(0xb6238b25L), tobe(0xb2e29692L), 
+tobe(0x8aad2b2fL), tobe(0x8e6c3698L), tobe(0x832f1041L), tobe(0x87ee0df6L), 
+tobe(0x99a95df3L), tobe(0x9d684044L), tobe(0x902b669dL), tobe(0x94ea7b2aL), 
+tobe(0xe0b41de7L), tobe(0xe4750050L), tobe(0xe9362689L), tobe(0xedf73b3eL), 
+tobe(0xf3b06b3bL), tobe(0xf771768cL), tobe(0xfa325055L), tobe(0xfef34de2L), 
+tobe(0xc6bcf05fL), tobe(0xc27dede8L), tobe(0xcf3ecb31L), tobe(0xcbffd686L), 
+tobe(0xd5b88683L), tobe(0xd1799b34L), tobe(0xdc3abdedL), tobe(0xd8fba05aL), 
+tobe(0x690ce0eeL), tobe(0x6dcdfd59L), tobe(0x608edb80L), tobe(0x644fc637L), 
+tobe(0x7a089632L), tobe(0x7ec98b85L), tobe(0x738aad5cL), tobe(0x774bb0ebL), 
+tobe(0x4f040d56L), tobe(0x4bc510e1L), tobe(0x46863638L), tobe(0x42472b8fL), 
+tobe(0x5c007b8aL), tobe(0x58c1663dL), tobe(0x558240e4L), tobe(0x51435d53L), 
+tobe(0x251d3b9eL), tobe(0x21dc2629L), tobe(0x2c9f00f0L), tobe(0x285e1d47L), 
+tobe(0x36194d42L), tobe(0x32d850f5L), tobe(0x3f9b762cL), tobe(0x3b5a6b9bL), 
+tobe(0x0315d626L), tobe(0x07d4cb91L), tobe(0x0a97ed48L), tobe(0x0e56f0ffL), 
+tobe(0x1011a0faL), tobe(0x14d0bd4dL), tobe(0x19939b94L), tobe(0x1d528623L), 
+tobe(0xf12f560eL), tobe(0xf5ee4bb9L), tobe(0xf8ad6d60L), tobe(0xfc6c70d7L), 
+tobe(0xe22b20d2L), tobe(0xe6ea3d65L), tobe(0xeba91bbcL), tobe(0xef68060bL), 
+tobe(0xd727bbb6L), tobe(0xd3e6a601L), tobe(0xdea580d8L), tobe(0xda649d6fL), 
+tobe(0xc423cd6aL), tobe(0xc0e2d0ddL), tobe(0xcda1f604L), tobe(0xc960ebb3L), 
+tobe(0xbd3e8d7eL), tobe(0xb9ff90c9L), tobe(0xb4bcb610L), tobe(0xb07daba7L), 
+tobe(0xae3afba2L), tobe(0xaafbe615L), tobe(0xa7b8c0ccL), tobe(0xa379dd7bL), 
+tobe(0x9b3660c6L), tobe(0x9ff77d71L), tobe(0x92b45ba8L), tobe(0x9675461fL), 
+tobe(0x8832161aL), tobe(0x8cf30badL), tobe(0x81b02d74L), tobe(0x857130c3L), 
+tobe(0x5d8a9099L), tobe(0x594b8d2eL), tobe(0x5408abf7L), tobe(0x50c9b640L), 
+tobe(0x4e8ee645L), tobe(0x4a4ffbf2L), tobe(0x470cdd2bL), tobe(0x43cdc09cL), 
+tobe(0x7b827d21L), tobe(0x7f436096L), tobe(0x7200464fL), tobe(0x76c15bf8L), 
+tobe(0x68860bfdL), tobe(0x6c47164aL), tobe(0x61043093L), tobe(0x65c52d24L), 
+tobe(0x119b4be9L), tobe(0x155a565eL), tobe(0x18197087L), tobe(0x1cd86d30L), 
+tobe(0x029f3d35L), tobe(0x065e2082L), tobe(0x0b1d065bL), tobe(0x0fdc1becL), 
+tobe(0x3793a651L), tobe(0x3352bbe6L), tobe(0x3e119d3fL), tobe(0x3ad08088L), 
+tobe(0x2497d08dL), tobe(0x2056cd3aL), tobe(0x2d15ebe3L), tobe(0x29d4f654L), 
+tobe(0xc5a92679L), tobe(0xc1683bceL), tobe(0xcc2b1d17L), tobe(0xc8ea00a0L), 
+tobe(0xd6ad50a5L), tobe(0xd26c4d12L), tobe(0xdf2f6bcbL), tobe(0xdbee767cL), 
+tobe(0xe3a1cbc1L), tobe(0xe760d676L), tobe(0xea23f0afL), tobe(0xeee2ed18L), 
+tobe(0xf0a5bd1dL), tobe(0xf464a0aaL), tobe(0xf9278673L), tobe(0xfde69bc4L), 
+tobe(0x89b8fd09L), tobe(0x8d79e0beL), tobe(0x803ac667L), tobe(0x84fbdbd0L), 
+tobe(0x9abc8bd5L), tobe(0x9e7d9662L), tobe(0x933eb0bbL), tobe(0x97ffad0cL), 
+tobe(0xafb010b1L), tobe(0xab710d06L), tobe(0xa6322bdfL), tobe(0xa2f33668L), 
+tobe(0xbcb4666dL), tobe(0xb8757bdaL), tobe(0xb5365d03L), tobe(0xb1f740b4L)},
+{
+tobe(0x00000000L), tobe(0xd219c1dcL), tobe(0xa0f29e0fL), tobe(0x72eb5fd3L), 
+tobe(0x452421a9L), tobe(0x973de075L), tobe(0xe5d6bfa6L), tobe(0x37cf7e7aL), 
+tobe(0x8a484352L), tobe(0x5851828eL), tobe(0x2abadd5dL), tobe(0xf8a31c81L), 
+tobe(0xcf6c62fbL), tobe(0x1d75a327L), tobe(0x6f9efcf4L), tobe(0xbd873d28L), 
+tobe(0x10519b13L), tobe(0xc2485acfL), tobe(0xb0a3051cL), tobe(0x62bac4c0L), 
+tobe(0x5575babaL), tobe(0x876c7b66L), tobe(0xf58724b5L), tobe(0x279ee569L), 
+tobe(0x9a19d841L), tobe(0x4800199dL), tobe(0x3aeb464eL), tobe(0xe8f28792L), 
+tobe(0xdf3df9e8L), tobe(0x0d243834L), tobe(0x7fcf67e7L), tobe(0xadd6a63bL), 
+tobe(0x20a33626L), tobe(0xf2baf7faL), tobe(0x8051a829L), tobe(0x524869f5L), 
+tobe(0x6587178fL), tobe(0xb79ed653L), tobe(0xc5758980L), tobe(0x176c485cL), 
+tobe(0xaaeb7574L), tobe(0x78f2b4a8L), tobe(0x0a19eb7bL), tobe(0xd8002aa7L), 
+tobe(0xefcf54ddL), tobe(0x3dd69501L), tobe(0x4f3dcad2L), tobe(0x9d240b0eL), 
+tobe(0x30f2ad35L), tobe(0xe2eb6ce9L), tobe(0x9000333aL), tobe(0x4219f2e6L), 
+tobe(0x75d68c9cL), tobe(0xa7cf4d40L), tobe(0xd5241293L), tobe(0x073dd34fL), 
+tobe(0xbabaee67L), tobe(0x68a32fbbL), tobe(0x1a487068L), tobe(0xc851b1b4L), 
+tobe(0xff9ecfceL), tobe(0x2d870e12L), tobe(0x5f6c51c1L), tobe(0x8d75901dL), 
+tobe(0x41466c4cL), tobe(0x935fad90L), tobe(0xe1b4f243L), tobe(0x33ad339fL), 
+tobe(0x04624de5L), tobe(0xd67b8c39L), tobe(0xa490d3eaL), tobe(0x76891236L), 
+tobe(0xcb0e2f1eL), tobe(0x1917eec2L), tobe(0x6bfcb111L), tobe(0xb9e570cdL), 
+tobe(0x8e2a0eb7L), tobe(0x5c33cf6bL), tobe(0x2ed890b8L), tobe(0xfcc15164L), 
+tobe(0x5117f75fL), tobe(0x830e3683L), tobe(0xf1e56950L), tobe(0x23fca88cL), 
+tobe(0x1433d6f6L), tobe(0xc62a172aL), tobe(0xb4c148f9L), tobe(0x66d88925L), 
+tobe(0xdb5fb40dL), tobe(0x094675d1L), tobe(0x7bad2a02L), tobe(0xa9b4ebdeL), 
+tobe(0x9e7b95a4L), tobe(0x4c625478L), tobe(0x3e890babL), tobe(0xec90ca77L), 
+tobe(0x61e55a6aL), tobe(0xb3fc9bb6L), tobe(0xc117c465L), tobe(0x130e05b9L), 
+tobe(0x24c17bc3L), tobe(0xf6d8ba1fL), tobe(0x8433e5ccL), tobe(0x562a2410L), 
+tobe(0xebad1938L), tobe(0x39b4d8e4L), tobe(0x4b5f8737L), tobe(0x994646ebL), 
+tobe(0xae893891L), tobe(0x7c90f94dL), tobe(0x0e7ba69eL), tobe(0xdc626742L), 
+tobe(0x71b4c179L), tobe(0xa3ad00a5L), tobe(0xd1465f76L), tobe(0x035f9eaaL), 
+tobe(0x3490e0d0L), tobe(0xe689210cL), tobe(0x94627edfL), tobe(0x467bbf03L), 
+tobe(0xfbfc822bL), tobe(0x29e543f7L), tobe(0x5b0e1c24L), tobe(0x8917ddf8L), 
+tobe(0xbed8a382L), tobe(0x6cc1625eL), tobe(0x1e2a3d8dL), tobe(0xcc33fc51L), 
+tobe(0x828cd898L), tobe(0x50951944L), tobe(0x227e4697L), tobe(0xf067874bL), 
+tobe(0xc7a8f931L), tobe(0x15b138edL), tobe(0x675a673eL), tobe(0xb543a6e2L), 
+tobe(0x08c49bcaL), tobe(0xdadd5a16L), tobe(0xa83605c5L), tobe(0x7a2fc419L), 
+tobe(0x4de0ba63L), tobe(0x9ff97bbfL), tobe(0xed12246cL), tobe(0x3f0be5b0L), 
+tobe(0x92dd438bL), tobe(0x40c48257L), tobe(0x322fdd84L), tobe(0xe0361c58L), 
+tobe(0xd7f96222L), tobe(0x05e0a3feL), tobe(0x770bfc2dL), tobe(0xa5123df1L), 
+tobe(0x189500d9L), tobe(0xca8cc105L), tobe(0xb8679ed6L), tobe(0x6a7e5f0aL), 
+tobe(0x5db12170L), tobe(0x8fa8e0acL), tobe(0xfd43bf7fL), tobe(0x2f5a7ea3L), 
+tobe(0xa22feebeL), tobe(0x70362f62L), tobe(0x02dd70b1L), tobe(0xd0c4b16dL), 
+tobe(0xe70bcf17L), tobe(0x35120ecbL), tobe(0x47f95118L), tobe(0x95e090c4L), 
+tobe(0x2867adecL), tobe(0xfa7e6c30L), tobe(0x889533e3L), tobe(0x5a8cf23fL), 
+tobe(0x6d438c45L), tobe(0xbf5a4d99L), tobe(0xcdb1124aL), tobe(0x1fa8d396L), 
+tobe(0xb27e75adL), tobe(0x6067b471L), tobe(0x128ceba2L), tobe(0xc0952a7eL), 
+tobe(0xf75a5404L), tobe(0x254395d8L), tobe(0x57a8ca0bL), tobe(0x85b10bd7L), 
+tobe(0x383636ffL), tobe(0xea2ff723L), tobe(0x98c4a8f0L), tobe(0x4add692cL), 
+tobe(0x7d121756L), tobe(0xaf0bd68aL), tobe(0xdde08959L), tobe(0x0ff94885L), 
+tobe(0xc3cab4d4L), tobe(0x11d37508L), tobe(0x63382adbL), tobe(0xb121eb07L), 
+tobe(0x86ee957dL), tobe(0x54f754a1L), tobe(0x261c0b72L), tobe(0xf405caaeL), 
+tobe(0x4982f786L), tobe(0x9b9b365aL), tobe(0xe9706989L), tobe(0x3b69a855L), 
+tobe(0x0ca6d62fL), tobe(0xdebf17f3L), tobe(0xac544820L), tobe(0x7e4d89fcL), 
+tobe(0xd39b2fc7L), tobe(0x0182ee1bL), tobe(0x7369b1c8L), tobe(0xa1707014L), 
+tobe(0x96bf0e6eL), tobe(0x44a6cfb2L), tobe(0x364d9061L), tobe(0xe45451bdL), 
+tobe(0x59d36c95L), tobe(0x8bcaad49L), tobe(0xf921f29aL), tobe(0x2b383346L), 
+tobe(0x1cf74d3cL), tobe(0xceee8ce0L), tobe(0xbc05d333L), tobe(0x6e1c12efL), 
+tobe(0xe36982f2L), tobe(0x3170432eL), tobe(0x439b1cfdL), tobe(0x9182dd21L), 
+tobe(0xa64da35bL), tobe(0x74546287L), tobe(0x06bf3d54L), tobe(0xd4a6fc88L), 
+tobe(0x6921c1a0L), tobe(0xbb38007cL), tobe(0xc9d35fafL), tobe(0x1bca9e73L), 
+tobe(0x2c05e009L), tobe(0xfe1c21d5L), tobe(0x8cf77e06L), tobe(0x5eeebfdaL), 
+tobe(0xf33819e1L), tobe(0x2121d83dL), tobe(0x53ca87eeL), tobe(0x81d34632L), 
+tobe(0xb61c3848L), tobe(0x6405f994L), tobe(0x16eea647L), tobe(0xc4f7679bL), 
+tobe(0x79705ab3L), tobe(0xab699b6fL), tobe(0xd982c4bcL), tobe(0x0b9b0560L), 
+tobe(0x3c547b1aL), tobe(0xee4dbac6L), tobe(0x9ca6e515L), tobe(0x4ebf24c9L)},
+{
+tobe(0x00000000L), tobe(0x01d8ac87L), tobe(0x03b1590eL), tobe(0x0269f589L), 
+tobe(0x0762b21cL), tobe(0x06ba1e9bL), tobe(0x04d3eb12L), tobe(0x050b4795L), 
+tobe(0x0ec56438L), tobe(0x0f1dc8bfL), tobe(0x0d743d36L), tobe(0x0cac91b1L), 
+tobe(0x09a7d624L), tobe(0x087f7aa3L), tobe(0x0a168f2aL), tobe(0x0bce23adL), 
+tobe(0x1d8ac870L), tobe(0x1c5264f7L), tobe(0x1e3b917eL), tobe(0x1fe33df9L), 
+tobe(0x1ae87a6cL), tobe(0x1b30d6ebL), tobe(0x19592362L), tobe(0x18818fe5L), 
+tobe(0x134fac48L), tobe(0x129700cfL), tobe(0x10fef546L), tobe(0x112659c1L), 
+tobe(0x142d1e54L), tobe(0x15f5b2d3L), tobe(0x179c475aL), tobe(0x1644ebddL), 
+tobe(0x3b1590e0L), tobe(0x3acd3c67L), tobe(0x38a4c9eeL), tobe(0x397c6569L), 
+tobe(0x3c7722fcL), tobe(0x3daf8e7bL), tobe(0x3fc67bf2L), tobe(0x3e1ed775L), 
+tobe(0x35d0f4d8L), tobe(0x3408585fL), tobe(0x3661add6L), tobe(0x37b90151L), 
+tobe(0x32b246c4L), tobe(0x336aea43L), tobe(0x31031fcaL), tobe(0x30dbb34dL), 
+tobe(0x269f5890L), tobe(0x2747f417L), tobe(0x252e019eL), tobe(0x24f6ad19L), 
+tobe(0x21fdea8cL), tobe(0x2025460bL), tobe(0x224cb382L), tobe(0x23941f05L), 
+tobe(0x285a3ca8L), tobe(0x2982902fL), tobe(0x2beb65a6L), tobe(0x2a33c921L), 
+tobe(0x2f388eb4L), tobe(0x2ee02233L), tobe(0x2c89d7baL), tobe(0x2d517b3dL), 
+tobe(0x762b21c0L), tobe(0x77f38d47L), tobe(0x759a78ceL), tobe(0x7442d449L), 
+tobe(0x714993dcL), tobe(0x70913f5bL), tobe(0x72f8cad2L), tobe(0x73206655L), 
+tobe(0x78ee45f8L), tobe(0x7936e97fL), tobe(0x7b5f1cf6L), tobe(0x7a87b071L), 
+tobe(0x7f8cf7e4L), tobe(0x7e545b63L), tobe(0x7c3daeeaL), tobe(0x7de5026dL), 
+tobe(0x6ba1e9b0L), tobe(0x6a794537L), tobe(0x6810b0beL), tobe(0x69c81c39L), 
+tobe(0x6cc35bacL), tobe(0x6d1bf72bL), tobe(0x6f7202a2L), tobe(0x6eaaae25L), 
+tobe(0x65648d88L), tobe(0x64bc210fL), tobe(0x66d5d486L), tobe(0x670d7801L), 
+tobe(0x62063f94L), tobe(0x63de9313L), tobe(0x61b7669aL), tobe(0x606fca1dL), 
+tobe(0x4d3eb120L), tobe(0x4ce61da7L), tobe(0x4e8fe82eL), tobe(0x4f5744a9L), 
+tobe(0x4a5c033cL), tobe(0x4b84afbbL), tobe(0x49ed5a32L), tobe(0x4835f6b5L), 
+tobe(0x43fbd518L), tobe(0x4223799fL), tobe(0x404a8c16L), tobe(0x41922091L), 
+tobe(0x44996704L), tobe(0x4541cb83L), tobe(0x47283e0aL), tobe(0x46f0928dL), 
+tobe(0x50b47950L), tobe(0x516cd5d7L), tobe(0x5305205eL), tobe(0x52dd8cd9L), 
+tobe(0x57d6cb4cL), tobe(0x560e67cbL), tobe(0x54679242L), tobe(0x55bf3ec5L), 
+tobe(0x5e711d68L), tobe(0x5fa9b1efL), tobe(0x5dc04466L), tobe(0x5c18e8e1L), 
+tobe(0x5913af74L), tobe(0x58cb03f3L), tobe(0x5aa2f67aL), tobe(0x5b7a5afdL), 
+tobe(0xec564380L), tobe(0xed8eef07L), tobe(0xefe71a8eL), tobe(0xee3fb609L), 
+tobe(0xeb34f19cL), tobe(0xeaec5d1bL), tobe(0xe885a892L), tobe(0xe95d0415L), 
+tobe(0xe29327b8L), tobe(0xe34b8b3fL), tobe(0xe1227eb6L), tobe(0xe0fad231L), 
+tobe(0xe5f195a4L), tobe(0xe4293923L), tobe(0xe640ccaaL), tobe(0xe798602dL), 
+tobe(0xf1dc8bf0L), tobe(0xf0042777L), tobe(0xf26dd2feL), tobe(0xf3b57e79L), 
+tobe(0xf6be39ecL), tobe(0xf766956bL), tobe(0xf50f60e2L), tobe(0xf4d7cc65L), 
+tobe(0xff19efc8L), tobe(0xfec1434fL), tobe(0xfca8b6c6L), tobe(0xfd701a41L), 
+tobe(0xf87b5dd4L), tobe(0xf9a3f153L), tobe(0xfbca04daL), tobe(0xfa12a85dL), 
+tobe(0xd743d360L), tobe(0xd69b7fe7L), tobe(0xd4f28a6eL), tobe(0xd52a26e9L), 
+tobe(0xd021617cL), tobe(0xd1f9cdfbL), tobe(0xd3903872L), tobe(0xd24894f5L), 
+tobe(0xd986b758L), tobe(0xd85e1bdfL), tobe(0xda37ee56L), tobe(0xdbef42d1L), 
+tobe(0xdee40544L), tobe(0xdf3ca9c3L), tobe(0xdd555c4aL), tobe(0xdc8df0cdL), 
+tobe(0xcac91b10L), tobe(0xcb11b797L), tobe(0xc978421eL), tobe(0xc8a0ee99L), 
+tobe(0xcdaba90cL), tobe(0xcc73058bL), tobe(0xce1af002L), tobe(0xcfc25c85L), 
+tobe(0xc40c7f28L), tobe(0xc5d4d3afL), tobe(0xc7bd2626L), tobe(0xc6658aa1L), 
+tobe(0xc36ecd34L), tobe(0xc2b661b3L), tobe(0xc0df943aL), tobe(0xc10738bdL), 
+tobe(0x9a7d6240L), tobe(0x9ba5cec7L), tobe(0x99cc3b4eL), tobe(0x981497c9L), 
+tobe(0x9d1fd05cL), tobe(0x9cc77cdbL), tobe(0x9eae8952L), tobe(0x9f7625d5L), 
+tobe(0x94b80678L), tobe(0x9560aaffL), tobe(0x97095f76L), tobe(0x96d1f3f1L), 
+tobe(0x93dab464L), tobe(0x920218e3L), tobe(0x906bed6aL), tobe(0x91b341edL), 
+tobe(0x87f7aa30L), tobe(0x862f06b7L), tobe(0x8446f33eL), tobe(0x859e5fb9L), 
+tobe(0x8095182cL), tobe(0x814db4abL), tobe(0x83244122L), tobe(0x82fceda5L), 
+tobe(0x8932ce08L), tobe(0x88ea628fL), tobe(0x8a839706L), tobe(0x8b5b3b81L), 
+tobe(0x8e507c14L), tobe(0x8f88d093L), tobe(0x8de1251aL), tobe(0x8c39899dL), 
+tobe(0xa168f2a0L), tobe(0xa0b05e27L), tobe(0xa2d9abaeL), tobe(0xa3010729L), 
+tobe(0xa60a40bcL), tobe(0xa7d2ec3bL), tobe(0xa5bb19b2L), tobe(0xa463b535L), 
+tobe(0xafad9698L), tobe(0xae753a1fL), tobe(0xac1ccf96L), tobe(0xadc46311L), 
+tobe(0xa8cf2484L), tobe(0xa9178803L), tobe(0xab7e7d8aL), tobe(0xaaa6d10dL), 
+tobe(0xbce23ad0L), tobe(0xbd3a9657L), tobe(0xbf5363deL), tobe(0xbe8bcf59L), 
+tobe(0xbb8088ccL), tobe(0xba58244bL), tobe(0xb831d1c2L), tobe(0xb9e97d45L), 
+tobe(0xb2275ee8L), tobe(0xb3fff26fL), tobe(0xb19607e6L), tobe(0xb04eab61L), 
+tobe(0xb545ecf4L), tobe(0xb49d4073L), tobe(0xb6f4b5faL), tobe(0xb72c197dL)},
+{
+tobe(0x00000000L), tobe(0xdc6d9ab7L), tobe(0xbc1a28d9L), tobe(0x6077b26eL), 
+tobe(0x7cf54c05L), tobe(0xa098d6b2L), tobe(0xc0ef64dcL), tobe(0x1c82fe6bL), 
+tobe(0xf9ea980aL), tobe(0x258702bdL), tobe(0x45f0b0d3L), tobe(0x999d2a64L), 
+tobe(0x851fd40fL), tobe(0x59724eb8L), tobe(0x3905fcd6L), tobe(0xe5686661L), 
+tobe(0xf7142da3L), tobe(0x2b79b714L), tobe(0x4b0e057aL), tobe(0x97639fcdL), 
+tobe(0x8be161a6L), tobe(0x578cfb11L), tobe(0x37fb497fL), tobe(0xeb96d3c8L), 
+tobe(0x0efeb5a9L), tobe(0xd2932f1eL), tobe(0xb2e49d70L), tobe(0x6e8907c7L), 
+tobe(0x720bf9acL), tobe(0xae66631bL), tobe(0xce11d175L), tobe(0x127c4bc2L), 
+tobe(0xeae946f1L), tobe(0x3684dc46L), tobe(0x56f36e28L), tobe(0x8a9ef49fL), 
+tobe(0x961c0af4L), tobe(0x4a719043L), tobe(0x2a06222dL), tobe(0xf66bb89aL), 
+tobe(0x1303defbL), tobe(0xcf6e444cL), tobe(0xaf19f622L), tobe(0x73746c95L), 
+tobe(0x6ff692feL), tobe(0xb39b0849L), tobe(0xd3ecba27L), tobe(0x0f812090L), 
+tobe(0x1dfd6b52L), tobe(0xc190f1e5L), tobe(0xa1e7438bL), tobe(0x7d8ad93cL), 
+tobe(0x61082757L), tobe(0xbd65bde0L), tobe(0xdd120f8eL), tobe(0x017f9539L), 
+tobe(0xe417f358L), tobe(0x387a69efL), tobe(0x580ddb81L), tobe(0x84604136L), 
+tobe(0x98e2bf5dL), tobe(0x448f25eaL), tobe(0x24f89784L), tobe(0xf8950d33L), 
+tobe(0xd1139055L), tobe(0x0d7e0ae2L), tobe(0x6d09b88cL), tobe(0xb164223bL), 
+tobe(0xade6dc50L), tobe(0x718b46e7L), tobe(0x11fcf489L), tobe(0xcd916e3eL), 
+tobe(0x28f9085fL), tobe(0xf49492e8L), tobe(0x94e32086L), tobe(0x488eba31L), 
+tobe(0x540c445aL), tobe(0x8861deedL), tobe(0xe8166c83L), tobe(0x347bf634L), 
+tobe(0x2607bdf6L), tobe(0xfa6a2741L), tobe(0x9a1d952fL), tobe(0x46700f98L), 
+tobe(0x5af2f1f3L), tobe(0x869f6b44L), tobe(0xe6e8d92aL), tobe(0x3a85439dL), 
+tobe(0xdfed25fcL), tobe(0x0380bf4bL), tobe(0x63f70d25L), tobe(0xbf9a9792L), 
+tobe(0xa31869f9L), tobe(0x7f75f34eL), tobe(0x1f024120L), tobe(0xc36fdb97L), 
+tobe(0x3bfad6a4L), tobe(0xe7974c13L), tobe(0x87e0fe7dL), tobe(0x5b8d64caL), 
+tobe(0x470f9aa1L), tobe(0x9b620016L), tobe(0xfb15b278L), tobe(0x277828cfL), 
+tobe(0xc2104eaeL), tobe(0x1e7dd419L), tobe(0x7e0a6677L), tobe(0xa267fcc0L), 
+tobe(0xbee502abL), tobe(0x6288981cL), tobe(0x02ff2a72L), tobe(0xde92b0c5L), 
+tobe(0xcceefb07L), tobe(0x108361b0L), tobe(0x70f4d3deL), tobe(0xac994969L), 
+tobe(0xb01bb702L), tobe(0x6c762db5L), tobe(0x0c019fdbL), tobe(0xd06c056cL), 
+tobe(0x3504630dL), tobe(0xe969f9baL), tobe(0x891e4bd4L), tobe(0x5573d163L), 
+tobe(0x49f12f08L), tobe(0x959cb5bfL), tobe(0xf5eb07d1L), tobe(0x29869d66L), 
+tobe(0xa6e63d1dL), tobe(0x7a8ba7aaL), tobe(0x1afc15c4L), tobe(0xc6918f73L), 
+tobe(0xda137118L), tobe(0x067eebafL), tobe(0x660959c1L), tobe(0xba64c376L), 
+tobe(0x5f0ca517L), tobe(0x83613fa0L), tobe(0xe3168dceL), tobe(0x3f7b1779L), 
+tobe(0x23f9e912L), tobe(0xff9473a5L), tobe(0x9fe3c1cbL), tobe(0x438e5b7cL), 
+tobe(0x51f210beL), tobe(0x8d9f8a09L), tobe(0xede83867L), tobe(0x3185a2d0L), 
+tobe(0x2d075cbbL), tobe(0xf16ac60cL), tobe(0x911d7462L), tobe(0x4d70eed5L), 
+tobe(0xa81888b4L), tobe(0x74751203L), tobe(0x1402a06dL), tobe(0xc86f3adaL), 
+tobe(0xd4edc4b1L), tobe(0x08805e06L), tobe(0x68f7ec68L), tobe(0xb49a76dfL), 
+tobe(0x4c0f7becL), tobe(0x9062e15bL), tobe(0xf0155335L), tobe(0x2c78c982L), 
+tobe(0x30fa37e9L), tobe(0xec97ad5eL), tobe(0x8ce01f30L), tobe(0x508d8587L), 
+tobe(0xb5e5e3e6L), tobe(0x69887951L), tobe(0x09ffcb3fL), tobe(0xd5925188L), 
+tobe(0xc910afe3L), tobe(0x157d3554L), tobe(0x750a873aL), tobe(0xa9671d8dL), 
+tobe(0xbb1b564fL), tobe(0x6776ccf8L), tobe(0x07017e96L), tobe(0xdb6ce421L), 
+tobe(0xc7ee1a4aL), tobe(0x1b8380fdL), tobe(0x7bf43293L), tobe(0xa799a824L), 
+tobe(0x42f1ce45L), tobe(0x9e9c54f2L), tobe(0xfeebe69cL), tobe(0x22867c2bL), 
+tobe(0x3e048240L), tobe(0xe26918f7L), tobe(0x821eaa99L), tobe(0x5e73302eL), 
+tobe(0x77f5ad48L), tobe(0xab9837ffL), tobe(0xcbef8591L), tobe(0x17821f26L), 
+tobe(0x0b00e14dL), tobe(0xd76d7bfaL), tobe(0xb71ac994L), tobe(0x6b775323L), 
+tobe(0x8e1f3542L), tobe(0x5272aff5L), tobe(0x32051d9bL), tobe(0xee68872cL), 
+tobe(0xf2ea7947L), tobe(0x2e87e3f0L), tobe(0x4ef0519eL), tobe(0x929dcb29L), 
+tobe(0x80e180ebL), tobe(0x5c8c1a5cL), tobe(0x3cfba832L), tobe(0xe0963285L), 
+tobe(0xfc14cceeL), tobe(0x20795659L), tobe(0x400ee437L), tobe(0x9c637e80L), 
+tobe(0x790b18e1L), tobe(0xa5668256L), tobe(0xc5113038L), tobe(0x197caa8fL), 
+tobe(0x05fe54e4L), tobe(0xd993ce53L), tobe(0xb9e47c3dL), tobe(0x6589e68aL), 
+tobe(0x9d1cebb9L), tobe(0x4171710eL), tobe(0x2106c360L), tobe(0xfd6b59d7L), 
+tobe(0xe1e9a7bcL), tobe(0x3d843d0bL), tobe(0x5df38f65L), tobe(0x819e15d2L), 
+tobe(0x64f673b3L), tobe(0xb89be904L), tobe(0xd8ec5b6aL), tobe(0x0481c1ddL), 
+tobe(0x18033fb6L), tobe(0xc46ea501L), tobe(0xa419176fL), tobe(0x78748dd8L), 
+tobe(0x6a08c61aL), tobe(0xb6655cadL), tobe(0xd612eec3L), tobe(0x0a7f7474L), 
+tobe(0x16fd8a1fL), tobe(0xca9010a8L), tobe(0xaae7a2c6L), tobe(0x768a3871L), 
+tobe(0x93e25e10L), tobe(0x4f8fc4a7L), tobe(0x2ff876c9L), tobe(0xf395ec7eL), 
+tobe(0xef171215L), tobe(0x337a88a2L), tobe(0x530d3accL), tobe(0x8f60a07bL)},
+{
+tobe(0x00000000L), tobe(0x490d678dL), tobe(0x921acf1aL), tobe(0xdb17a897L), 
+tobe(0x20f48383L), tobe(0x69f9e40eL), tobe(0xb2ee4c99L), tobe(0xfbe32b14L), 
+tobe(0x41e90706L), tobe(0x08e4608bL), tobe(0xd3f3c81cL), tobe(0x9afeaf91L), 
+tobe(0x611d8485L), tobe(0x2810e308L), tobe(0xf3074b9fL), tobe(0xba0a2c12L), 
+tobe(0x83d20e0cL), tobe(0xcadf6981L), tobe(0x11c8c116L), tobe(0x58c5a69bL), 
+tobe(0xa3268d8fL), tobe(0xea2bea02L), tobe(0x313c4295L), tobe(0x78312518L), 
+tobe(0xc23b090aL), tobe(0x8b366e87L), tobe(0x5021c610L), tobe(0x192ca19dL), 
+tobe(0xe2cf8a89L), tobe(0xabc2ed04L), tobe(0x70d54593L), tobe(0x39d8221eL), 
+tobe(0x036501afL), tobe(0x4a686622L), tobe(0x917fceb5L), tobe(0xd872a938L), 
+tobe(0x2391822cL), tobe(0x6a9ce5a1L), tobe(0xb18b4d36L), tobe(0xf8862abbL), 
+tobe(0x428c06a9L), tobe(0x0b816124L), tobe(0xd096c9b3L), tobe(0x999bae3eL), 
+tobe(0x6278852aL), tobe(0x2b75e2a7L), tobe(0xf0624a30L), tobe(0xb96f2dbdL), 
+tobe(0x80b70fa3L), tobe(0xc9ba682eL), tobe(0x12adc0b9L), tobe(0x5ba0a734L), 
+tobe(0xa0438c20L), tobe(0xe94eebadL), tobe(0x3259433aL), tobe(0x7b5424b7L), 
+tobe(0xc15e08a5L), tobe(0x88536f28L), tobe(0x5344c7bfL), tobe(0x1a49a032L), 
+tobe(0xe1aa8b26L), tobe(0xa8a7ecabL), tobe(0x73b0443cL), tobe(0x3abd23b1L), 
+tobe(0x06ca035eL), tobe(0x4fc764d3L), tobe(0x94d0cc44L), tobe(0xddddabc9L), 
+tobe(0x263e80ddL), tobe(0x6f33e750L), tobe(0xb4244fc7L), tobe(0xfd29284aL), 
+tobe(0x47230458L), tobe(0x0e2e63d5L), tobe(0xd539cb42L), tobe(0x9c34accfL), 
+tobe(0x67d787dbL), tobe(0x2edae056L), tobe(0xf5cd48c1L), tobe(0xbcc02f4cL), 
+tobe(0x85180d52L), tobe(0xcc156adfL), tobe(0x1702c248L), tobe(0x5e0fa5c5L), 
+tobe(0xa5ec8ed1L), tobe(0xece1e95cL), tobe(0x37f641cbL), tobe(0x7efb2646L), 
+tobe(0xc4f10a54L), tobe(0x8dfc6dd9L), tobe(0x56ebc54eL), tobe(0x1fe6a2c3L), 
+tobe(0xe40589d7L), tobe(0xad08ee5aL), tobe(0x761f46cdL), tobe(0x3f122140L), 
+tobe(0x05af02f1L), tobe(0x4ca2657cL), tobe(0x97b5cdebL), tobe(0xdeb8aa66L), 
+tobe(0x255b8172L), tobe(0x6c56e6ffL), tobe(0xb7414e68L), tobe(0xfe4c29e5L), 
+tobe(0x444605f7L), tobe(0x0d4b627aL), tobe(0xd65ccaedL), tobe(0x9f51ad60L), 
+tobe(0x64b28674L), tobe(0x2dbfe1f9L), tobe(0xf6a8496eL), tobe(0xbfa52ee3L), 
+tobe(0x867d0cfdL), tobe(0xcf706b70L), tobe(0x1467c3e7L), tobe(0x5d6aa46aL), 
+tobe(0xa6898f7eL), tobe(0xef84e8f3L), tobe(0x34934064L), tobe(0x7d9e27e9L), 
+tobe(0xc7940bfbL), tobe(0x8e996c76L), tobe(0x558ec4e1L), tobe(0x1c83a36cL), 
+tobe(0xe7608878L), tobe(0xae6deff5L), tobe(0x757a4762L), tobe(0x3c7720efL), 
+tobe(0x0d9406bcL), tobe(0x44996131L), tobe(0x9f8ec9a6L), tobe(0xd683ae2bL), 
+tobe(0x2d60853fL), tobe(0x646de2b2L), tobe(0xbf7a4a25L), tobe(0xf6772da8L), 
+tobe(0x4c7d01baL), tobe(0x05706637L), tobe(0xde67cea0L), tobe(0x976aa92dL), 
+tobe(0x6c898239L), tobe(0x2584e5b4L), tobe(0xfe934d23L), tobe(0xb79e2aaeL), 
+tobe(0x8e4608b0L), tobe(0xc74b6f3dL), tobe(0x1c5cc7aaL), tobe(0x5551a027L), 
+tobe(0xaeb28b33L), tobe(0xe7bfecbeL), tobe(0x3ca84429L), tobe(0x75a523a4L), 
+tobe(0xcfaf0fb6L), tobe(0x86a2683bL), tobe(0x5db5c0acL), tobe(0x14b8a721L), 
+tobe(0xef5b8c35L), tobe(0xa656ebb8L), tobe(0x7d41432fL), tobe(0x344c24a2L), 
+tobe(0x0ef10713L), tobe(0x47fc609eL), tobe(0x9cebc809L), tobe(0xd5e6af84L), 
+tobe(0x2e058490L), tobe(0x6708e31dL), tobe(0xbc1f4b8aL), tobe(0xf5122c07L), 
+tobe(0x4f180015L), tobe(0x06156798L), tobe(0xdd02cf0fL), tobe(0x940fa882L), 
+tobe(0x6fec8396L), tobe(0x26e1e41bL), tobe(0xfdf64c8cL), tobe(0xb4fb2b01L), 
+tobe(0x8d23091fL), tobe(0xc42e6e92L), tobe(0x1f39c605L), tobe(0x5634a188L), 
+tobe(0xadd78a9cL), tobe(0xe4daed11L), tobe(0x3fcd4586L), tobe(0x76c0220bL), 
+tobe(0xccca0e19L), tobe(0x85c76994L), tobe(0x5ed0c103L), tobe(0x17dda68eL), 
+tobe(0xec3e8d9aL), tobe(0xa533ea17L), tobe(0x7e244280L), tobe(0x3729250dL), 
+tobe(0x0b5e05e2L), tobe(0x4253626fL), tobe(0x9944caf8L), tobe(0xd049ad75L), 
+tobe(0x2baa8661L), tobe(0x62a7e1ecL), tobe(0xb9b0497bL), tobe(0xf0bd2ef6L), 
+tobe(0x4ab702e4L), tobe(0x03ba6569L), tobe(0xd8adcdfeL), tobe(0x91a0aa73L), 
+tobe(0x6a438167L), tobe(0x234ee6eaL), tobe(0xf8594e7dL), tobe(0xb15429f0L), 
+tobe(0x888c0beeL), tobe(0xc1816c63L), tobe(0x1a96c4f4L), tobe(0x539ba379L), 
+tobe(0xa878886dL), tobe(0xe175efe0L), tobe(0x3a624777L), tobe(0x736f20faL), 
+tobe(0xc9650ce8L), tobe(0x80686b65L), tobe(0x5b7fc3f2L), tobe(0x1272a47fL), 
+tobe(0xe9918f6bL), tobe(0xa09ce8e6L), tobe(0x7b8b4071L), tobe(0x328627fcL), 
+tobe(0x083b044dL), tobe(0x413663c0L), tobe(0x9a21cb57L), tobe(0xd32cacdaL), 
+tobe(0x28cf87ceL), tobe(0x61c2e043L), tobe(0xbad548d4L), tobe(0xf3d82f59L), 
+tobe(0x49d2034bL), tobe(0x00df64c6L), tobe(0xdbc8cc51L), tobe(0x92c5abdcL), 
+tobe(0x692680c8L), tobe(0x202be745L), tobe(0xfb3c4fd2L), tobe(0xb231285fL), 
+tobe(0x8be90a41L), tobe(0xc2e46dccL), tobe(0x19f3c55bL), tobe(0x50fea2d6L), 
+tobe(0xab1d89c2L), tobe(0xe210ee4fL), tobe(0x390746d8L), tobe(0x700a2155L), 
+tobe(0xca000d47L), tobe(0x830d6acaL), tobe(0x581ac25dL), tobe(0x1117a5d0L), 
+tobe(0xeaf48ec4L), tobe(0xa3f9e949L), tobe(0x78ee41deL), tobe(0x31e32653L)},
+{
+tobe(0x00000000L), tobe(0x1b280d78L), tobe(0x36501af0L), tobe(0x2d781788L), 
+tobe(0x6ca035e0L), tobe(0x77883898L), tobe(0x5af02f10L), tobe(0x41d82268L), 
+tobe(0xd9406bc0L), tobe(0xc26866b8L), tobe(0xef107130L), tobe(0xf4387c48L), 
+tobe(0xb5e05e20L), tobe(0xaec85358L), tobe(0x83b044d0L), tobe(0x989849a8L), 
+tobe(0xb641ca37L), tobe(0xad69c74fL), tobe(0x8011d0c7L), tobe(0x9b39ddbfL), 
+tobe(0xdae1ffd7L), tobe(0xc1c9f2afL), tobe(0xecb1e527L), tobe(0xf799e85fL), 
+tobe(0x6f01a1f7L), tobe(0x7429ac8fL), tobe(0x5951bb07L), tobe(0x4279b67fL), 
+tobe(0x03a19417L), tobe(0x1889996fL), tobe(0x35f18ee7L), tobe(0x2ed9839fL), 
+tobe(0x684289d9L), tobe(0x736a84a1L), tobe(0x5e129329L), tobe(0x453a9e51L), 
+tobe(0x04e2bc39L), tobe(0x1fcab141L), tobe(0x32b2a6c9L), tobe(0x299aabb1L), 
+tobe(0xb102e219L), tobe(0xaa2aef61L), tobe(0x8752f8e9L), tobe(0x9c7af591L), 
+tobe(0xdda2d7f9L), tobe(0xc68ada81L), tobe(0xebf2cd09L), tobe(0xf0dac071L), 
+tobe(0xde0343eeL), tobe(0xc52b4e96L), tobe(0xe853591eL), tobe(0xf37b5466L), 
+tobe(0xb2a3760eL), tobe(0xa98b7b76L), tobe(0x84f36cfeL), tobe(0x9fdb6186L), 
+tobe(0x0743282eL), tobe(0x1c6b2556L), tobe(0x311332deL), tobe(0x2a3b3fa6L), 
+tobe(0x6be31dceL), tobe(0x70cb10b6L), tobe(0x5db3073eL), tobe(0x469b0a46L), 
+tobe(0xd08513b2L), tobe(0xcbad1ecaL), tobe(0xe6d50942L), tobe(0xfdfd043aL), 
+tobe(0xbc252652L), tobe(0xa70d2b2aL), tobe(0x8a753ca2L), tobe(0x915d31daL), 
+tobe(0x09c57872L), tobe(0x12ed750aL), tobe(0x3f956282L), tobe(0x24bd6ffaL), 
+tobe(0x65654d92L), tobe(0x7e4d40eaL), tobe(0x53355762L), tobe(0x481d5a1aL), 
+tobe(0x66c4d985L), tobe(0x7decd4fdL), tobe(0x5094c375L), tobe(0x4bbcce0dL), 
+tobe(0x0a64ec65L), tobe(0x114ce11dL), tobe(0x3c34f695L), tobe(0x271cfbedL), 
+tobe(0xbf84b245L), tobe(0xa4acbf3dL), tobe(0x89d4a8b5L), tobe(0x92fca5cdL), 
+tobe(0xd32487a5L), tobe(0xc80c8addL), tobe(0xe5749d55L), tobe(0xfe5c902dL), 
+tobe(0xb8c79a6bL), tobe(0xa3ef9713L), tobe(0x8e97809bL), tobe(0x95bf8de3L), 
+tobe(0xd467af8bL), tobe(0xcf4fa2f3L), tobe(0xe237b57bL), tobe(0xf91fb803L), 
+tobe(0x6187f1abL), tobe(0x7aaffcd3L), tobe(0x57d7eb5bL), tobe(0x4cffe623L), 
+tobe(0x0d27c44bL), tobe(0x160fc933L), tobe(0x3b77debbL), tobe(0x205fd3c3L), 
+tobe(0x0e86505cL), tobe(0x15ae5d24L), tobe(0x38d64aacL), tobe(0x23fe47d4L), 
+tobe(0x622665bcL), tobe(0x790e68c4L), tobe(0x54767f4cL), tobe(0x4f5e7234L), 
+tobe(0xd7c63b9cL), tobe(0xccee36e4L), tobe(0xe196216cL), tobe(0xfabe2c14L), 
+tobe(0xbb660e7cL), tobe(0xa04e0304L), tobe(0x8d36148cL), tobe(0x961e19f4L), 
+tobe(0xa5cb3ad3L), tobe(0xbee337abL), tobe(0x939b2023L), tobe(0x88b32d5bL), 
+tobe(0xc96b0f33L), tobe(0xd243024bL), tobe(0xff3b15c3L), tobe(0xe41318bbL), 
+tobe(0x7c8b5113L), tobe(0x67a35c6bL), tobe(0x4adb4be3L), tobe(0x51f3469bL), 
+tobe(0x102b64f3L), tobe(0x0b03698bL), tobe(0x267b7e03L), tobe(0x3d53737bL), 
+tobe(0x138af0e4L), tobe(0x08a2fd9cL), tobe(0x25daea14L), tobe(0x3ef2e76cL), 
+tobe(0x7f2ac504L), tobe(0x6402c87cL), tobe(0x497adff4L), tobe(0x5252d28cL), 
+tobe(0xcaca9b24L), tobe(0xd1e2965cL), tobe(0xfc9a81d4L), tobe(0xe7b28cacL), 
+tobe(0xa66aaec4L), tobe(0xbd42a3bcL), tobe(0x903ab434L), tobe(0x8b12b94cL), 
+tobe(0xcd89b30aL), tobe(0xd6a1be72L), tobe(0xfbd9a9faL), tobe(0xe0f1a482L), 
+tobe(0xa12986eaL), tobe(0xba018b92L), tobe(0x97799c1aL), tobe(0x8c519162L), 
+tobe(0x14c9d8caL), tobe(0x0fe1d5b2L), tobe(0x2299c23aL), tobe(0x39b1cf42L), 
+tobe(0x7869ed2aL), tobe(0x6341e052L), tobe(0x4e39f7daL), tobe(0x5511faa2L), 
+tobe(0x7bc8793dL), tobe(0x60e07445L), tobe(0x4d9863cdL), tobe(0x56b06eb5L), 
+tobe(0x17684cddL), tobe(0x0c4041a5L), tobe(0x2138562dL), tobe(0x3a105b55L), 
+tobe(0xa28812fdL), tobe(0xb9a01f85L), tobe(0x94d8080dL), tobe(0x8ff00575L), 
+tobe(0xce28271dL), tobe(0xd5002a65L), tobe(0xf8783dedL), tobe(0xe3503095L), 
+tobe(0x754e2961L), tobe(0x6e662419L), tobe(0x431e3391L), tobe(0x58363ee9L), 
+tobe(0x19ee1c81L), tobe(0x02c611f9L), tobe(0x2fbe0671L), tobe(0x34960b09L), 
+tobe(0xac0e42a1L), tobe(0xb7264fd9L), tobe(0x9a5e5851L), tobe(0x81765529L), 
+tobe(0xc0ae7741L), tobe(0xdb867a39L), tobe(0xf6fe6db1L), tobe(0xedd660c9L), 
+tobe(0xc30fe356L), tobe(0xd827ee2eL), tobe(0xf55ff9a6L), tobe(0xee77f4deL), 
+tobe(0xafafd6b6L), tobe(0xb487dbceL), tobe(0x99ffcc46L), tobe(0x82d7c13eL), 
+tobe(0x1a4f8896L), tobe(0x016785eeL), tobe(0x2c1f9266L), tobe(0x37379f1eL), 
+tobe(0x76efbd76L), tobe(0x6dc7b00eL), tobe(0x40bfa786L), tobe(0x5b97aafeL), 
+tobe(0x1d0ca0b8L), tobe(0x0624adc0L), tobe(0x2b5cba48L), tobe(0x3074b730L), 
+tobe(0x71ac9558L), tobe(0x6a849820L), tobe(0x47fc8fa8L), tobe(0x5cd482d0L), 
+tobe(0xc44ccb78L), tobe(0xdf64c600L), tobe(0xf21cd188L), tobe(0xe934dcf0L), 
+tobe(0xa8ecfe98L), tobe(0xb3c4f3e0L), tobe(0x9ebce468L), tobe(0x8594e910L), 
+tobe(0xab4d6a8fL), tobe(0xb06567f7L), tobe(0x9d1d707fL), tobe(0x86357d07L), 
+tobe(0xc7ed5f6fL), tobe(0xdcc55217L), tobe(0xf1bd459fL), tobe(0xea9548e7L), 
+tobe(0x720d014fL), tobe(0x69250c37L), tobe(0x445d1bbfL), tobe(0x5f7516c7L), 
+tobe(0x1ead34afL), tobe(0x058539d7L), tobe(0x28fd2e5fL), tobe(0x33d52327L)},
+{
+tobe(0x00000000L), tobe(0x4f576811L), tobe(0x9eaed022L), tobe(0xd1f9b833L), 
+tobe(0x399cbdf3L), tobe(0x76cbd5e2L), tobe(0xa7326dd1L), tobe(0xe86505c0L), 
+tobe(0x73397be6L), tobe(0x3c6e13f7L), tobe(0xed97abc4L), tobe(0xa2c0c3d5L), 
+tobe(0x4aa5c615L), tobe(0x05f2ae04L), tobe(0xd40b1637L), tobe(0x9b5c7e26L), 
+tobe(0xe672f7ccL), tobe(0xa9259fddL), tobe(0x78dc27eeL), tobe(0x378b4fffL), 
+tobe(0xdfee4a3fL), tobe(0x90b9222eL), tobe(0x41409a1dL), tobe(0x0e17f20cL), 
+tobe(0x954b8c2aL), tobe(0xda1ce43bL), tobe(0x0be55c08L), tobe(0x44b23419L), 
+tobe(0xacd731d9L), tobe(0xe38059c8L), tobe(0x3279e1fbL), tobe(0x7d2e89eaL), 
+tobe(0xc824f22fL), tobe(0x87739a3eL), tobe(0x568a220dL), tobe(0x19dd4a1cL), 
+tobe(0xf1b84fdcL), tobe(0xbeef27cdL), tobe(0x6f169ffeL), tobe(0x2041f7efL), 
+tobe(0xbb1d89c9L), tobe(0xf44ae1d8L), tobe(0x25b359ebL), tobe(0x6ae431faL), 
+tobe(0x8281343aL), tobe(0xcdd65c2bL), tobe(0x1c2fe418L), tobe(0x53788c09L), 
+tobe(0x2e5605e3L), tobe(0x61016df2L), tobe(0xb0f8d5c1L), tobe(0xffafbdd0L), 
+tobe(0x17cab810L), tobe(0x589dd001L), tobe(0x89646832L), tobe(0xc6330023L), 
+tobe(0x5d6f7e05L), tobe(0x12381614L), tobe(0xc3c1ae27L), tobe(0x8c96c636L), 
+tobe(0x64f3c3f6L), tobe(0x2ba4abe7L), tobe(0xfa5d13d4L), tobe(0xb50a7bc5L), 
+tobe(0x9488f9e9L), tobe(0xdbdf91f8L), tobe(0x0a2629cbL), tobe(0x457141daL), 
+tobe(0xad14441aL), tobe(0xe2432c0bL), tobe(0x33ba9438L), tobe(0x7cedfc29L), 
+tobe(0xe7b1820fL), tobe(0xa8e6ea1eL), tobe(0x791f522dL), tobe(0x36483a3cL), 
+tobe(0xde2d3ffcL), tobe(0x917a57edL), tobe(0x4083efdeL), tobe(0x0fd487cfL), 
+tobe(0x72fa0e25L), tobe(0x3dad6634L), tobe(0xec54de07L), tobe(0xa303b616L), 
+tobe(0x4b66b3d6L), tobe(0x0431dbc7L), tobe(0xd5c863f4L), tobe(0x9a9f0be5L), 
+tobe(0x01c375c3L), tobe(0x4e941dd2L), tobe(0x9f6da5e1L), tobe(0xd03acdf0L), 
+tobe(0x385fc830L), tobe(0x7708a021L), tobe(0xa6f11812L), tobe(0xe9a67003L), 
+tobe(0x5cac0bc6L), tobe(0x13fb63d7L), tobe(0xc202dbe4L), tobe(0x8d55b3f5L), 
+tobe(0x6530b635L), tobe(0x2a67de24L), tobe(0xfb9e6617L), tobe(0xb4c90e06L), 
+tobe(0x2f957020L), tobe(0x60c21831L), tobe(0xb13ba002L), tobe(0xfe6cc813L), 
+tobe(0x1609cdd3L), tobe(0x595ea5c2L), tobe(0x88a71df1L), tobe(0xc7f075e0L), 
+tobe(0xbadefc0aL), tobe(0xf589941bL), tobe(0x24702c28L), tobe(0x6b274439L), 
+tobe(0x834241f9L), tobe(0xcc1529e8L), tobe(0x1dec91dbL), tobe(0x52bbf9caL), 
+tobe(0xc9e787ecL), tobe(0x86b0effdL), tobe(0x574957ceL), tobe(0x181e3fdfL), 
+tobe(0xf07b3a1fL), tobe(0xbf2c520eL), tobe(0x6ed5ea3dL), tobe(0x2182822cL), 
+tobe(0x2dd0ee65L), tobe(0x62878674L), tobe(0xb37e3e47L), tobe(0xfc295656L), 
+tobe(0x144c5396L), tobe(0x5b1b3b87L), tobe(0x8ae283b4L), tobe(0xc5b5eba5L), 
+tobe(0x5ee99583L), tobe(0x11befd92L), tobe(0xc04745a1L), tobe(0x8f102db0L), 
+tobe(0x67752870L), tobe(0x28224061L), tobe(0xf9dbf852L), tobe(0xb68c9043L), 
+tobe(0xcba219a9L), tobe(0x84f571b8L), tobe(0x550cc98bL), tobe(0x1a5ba19aL), 
+tobe(0xf23ea45aL), tobe(0xbd69cc4bL), tobe(0x6c907478L), tobe(0x23c71c69L), 
+tobe(0xb89b624fL), tobe(0xf7cc0a5eL), tobe(0x2635b26dL), tobe(0x6962da7cL), 
+tobe(0x8107dfbcL), tobe(0xce50b7adL), tobe(0x1fa90f9eL), tobe(0x50fe678fL), 
+tobe(0xe5f41c4aL), tobe(0xaaa3745bL), tobe(0x7b5acc68L), tobe(0x340da479L), 
+tobe(0xdc68a1b9L), tobe(0x933fc9a8L), tobe(0x42c6719bL), tobe(0x0d91198aL), 
+tobe(0x96cd67acL), tobe(0xd99a0fbdL), tobe(0x0863b78eL), tobe(0x4734df9fL), 
+tobe(0xaf51da5fL), tobe(0xe006b24eL), tobe(0x31ff0a7dL), tobe(0x7ea8626cL), 
+tobe(0x0386eb86L), tobe(0x4cd18397L), tobe(0x9d283ba4L), tobe(0xd27f53b5L), 
+tobe(0x3a1a5675L), tobe(0x754d3e64L), tobe(0xa4b48657L), tobe(0xebe3ee46L), 
+tobe(0x70bf9060L), tobe(0x3fe8f871L), tobe(0xee114042L), tobe(0xa1462853L), 
+tobe(0x49232d93L), tobe(0x06744582L), tobe(0xd78dfdb1L), tobe(0x98da95a0L), 
+tobe(0xb958178cL), tobe(0xf60f7f9dL), tobe(0x27f6c7aeL), tobe(0x68a1afbfL), 
+tobe(0x80c4aa7fL), tobe(0xcf93c26eL), tobe(0x1e6a7a5dL), tobe(0x513d124cL), 
+tobe(0xca616c6aL), tobe(0x8536047bL), tobe(0x54cfbc48L), tobe(0x1b98d459L), 
+tobe(0xf3fdd199L), tobe(0xbcaab988L), tobe(0x6d5301bbL), tobe(0x220469aaL), 
+tobe(0x5f2ae040L), tobe(0x107d8851L), tobe(0xc1843062L), tobe(0x8ed35873L), 
+tobe(0x66b65db3L), tobe(0x29e135a2L), tobe(0xf8188d91L), tobe(0xb74fe580L), 
+tobe(0x2c139ba6L), tobe(0x6344f3b7L), tobe(0xb2bd4b84L), tobe(0xfdea2395L), 
+tobe(0x158f2655L), tobe(0x5ad84e44L), tobe(0x8b21f677L), tobe(0xc4769e66L), 
+tobe(0x717ce5a3L), tobe(0x3e2b8db2L), tobe(0xefd23581L), tobe(0xa0855d90L), 
+tobe(0x48e05850L), tobe(0x07b73041L), tobe(0xd64e8872L), tobe(0x9919e063L), 
+tobe(0x02459e45L), tobe(0x4d12f654L), tobe(0x9ceb4e67L), tobe(0xd3bc2676L), 
+tobe(0x3bd923b6L), tobe(0x748e4ba7L), tobe(0xa577f394L), tobe(0xea209b85L), 
+tobe(0x970e126fL), tobe(0xd8597a7eL), tobe(0x09a0c24dL), tobe(0x46f7aa5cL), 
+tobe(0xae92af9cL), tobe(0xe1c5c78dL), tobe(0x303c7fbeL), tobe(0x7f6b17afL), 
+tobe(0xe4376989L), tobe(0xab600198L), tobe(0x7a99b9abL), tobe(0x35ced1baL), 
+tobe(0xddabd47aL), tobe(0x92fcbc6bL), tobe(0x43050458L), tobe(0x0c526c49L)},
+{
+tobe(0x00000000L), tobe(0x5ba1dccaL), tobe(0xb743b994L), tobe(0xece2655eL), 
+tobe(0x6a466e9fL), tobe(0x31e7b255L), tobe(0xdd05d70bL), tobe(0x86a40bc1L), 
+tobe(0xd48cdd3eL), tobe(0x8f2d01f4L), tobe(0x63cf64aaL), tobe(0x386eb860L), 
+tobe(0xbecab3a1L), tobe(0xe56b6f6bL), tobe(0x09890a35L), tobe(0x5228d6ffL), 
+tobe(0xadd8a7cbL), tobe(0xf6797b01L), tobe(0x1a9b1e5fL), tobe(0x413ac295L), 
+tobe(0xc79ec954L), tobe(0x9c3f159eL), tobe(0x70dd70c0L), tobe(0x2b7cac0aL), 
+tobe(0x79547af5L), tobe(0x22f5a63fL), tobe(0xce17c361L), tobe(0x95b61fabL), 
+tobe(0x1312146aL), tobe(0x48b3c8a0L), tobe(0xa451adfeL), tobe(0xfff07134L), 
+tobe(0x5f705221L), tobe(0x04d18eebL), tobe(0xe833ebb5L), tobe(0xb392377fL), 
+tobe(0x35363cbeL), tobe(0x6e97e074L), tobe(0x8275852aL), tobe(0xd9d459e0L), 
+tobe(0x8bfc8f1fL), tobe(0xd05d53d5L), tobe(0x3cbf368bL), tobe(0x671eea41L), 
+tobe(0xe1bae180L), tobe(0xba1b3d4aL), tobe(0x56f95814L), tobe(0x0d5884deL), 
+tobe(0xf2a8f5eaL), tobe(0xa9092920L), tobe(0x45eb4c7eL), tobe(0x1e4a90b4L), 
+tobe(0x98ee9b75L), tobe(0xc34f47bfL), tobe(0x2fad22e1L), tobe(0x740cfe2bL), 
+tobe(0x262428d4L), tobe(0x7d85f41eL), tobe(0x91679140L), tobe(0xcac64d8aL), 
+tobe(0x4c62464bL), tobe(0x17c39a81L), tobe(0xfb21ffdfL), tobe(0xa0802315L), 
+tobe(0xbee0a442L), tobe(0xe5417888L), tobe(0x09a31dd6L), tobe(0x5202c11cL), 
+tobe(0xd4a6caddL), tobe(0x8f071617L), tobe(0x63e57349L), tobe(0x3844af83L), 
+tobe(0x6a6c797cL), tobe(0x31cda5b6L), tobe(0xdd2fc0e8L), tobe(0x868e1c22L), 
+tobe(0x002a17e3L), tobe(0x5b8bcb29L), tobe(0xb769ae77L), tobe(0xecc872bdL), 
+tobe(0x13380389L), tobe(0x4899df43L), tobe(0xa47bba1dL), tobe(0xffda66d7L), 
+tobe(0x797e6d16L), tobe(0x22dfb1dcL), tobe(0xce3dd482L), tobe(0x959c0848L), 
+tobe(0xc7b4deb7L), tobe(0x9c15027dL), tobe(0x70f76723L), tobe(0x2b56bbe9L), 
+tobe(0xadf2b028L), tobe(0xf6536ce2L), tobe(0x1ab109bcL), tobe(0x4110d576L), 
+tobe(0xe190f663L), tobe(0xba312aa9L), tobe(0x56d34ff7L), tobe(0x0d72933dL), 
+tobe(0x8bd698fcL), tobe(0xd0774436L), tobe(0x3c952168L), tobe(0x6734fda2L), 
+tobe(0x351c2b5dL), tobe(0x6ebdf797L), tobe(0x825f92c9L), tobe(0xd9fe4e03L), 
+tobe(0x5f5a45c2L), tobe(0x04fb9908L), tobe(0xe819fc56L), tobe(0xb3b8209cL), 
+tobe(0x4c4851a8L), tobe(0x17e98d62L), tobe(0xfb0be83cL), tobe(0xa0aa34f6L), 
+tobe(0x260e3f37L), tobe(0x7dafe3fdL), tobe(0x914d86a3L), tobe(0xcaec5a69L), 
+tobe(0x98c48c96L), tobe(0xc365505cL), tobe(0x2f873502L), tobe(0x7426e9c8L), 
+tobe(0xf282e209L), tobe(0xa9233ec3L), tobe(0x45c15b9dL), tobe(0x1e608757L), 
+tobe(0x79005533L), tobe(0x22a189f9L), tobe(0xce43eca7L), tobe(0x95e2306dL), 
+tobe(0x13463bacL), tobe(0x48e7e766L), tobe(0xa4058238L), tobe(0xffa45ef2L), 
+tobe(0xad8c880dL), tobe(0xf62d54c7L), tobe(0x1acf3199L), tobe(0x416eed53L), 
+tobe(0xc7cae692L), tobe(0x9c6b3a58L), tobe(0x70895f06L), tobe(0x2b2883ccL), 
+tobe(0xd4d8f2f8L), tobe(0x8f792e32L), tobe(0x639b4b6cL), tobe(0x383a97a6L), 
+tobe(0xbe9e9c67L), tobe(0xe53f40adL), tobe(0x09dd25f3L), tobe(0x527cf939L), 
+tobe(0x00542fc6L), tobe(0x5bf5f30cL), tobe(0xb7179652L), tobe(0xecb64a98L), 
+tobe(0x6a124159L), tobe(0x31b39d93L), tobe(0xdd51f8cdL), tobe(0x86f02407L), 
+tobe(0x26700712L), tobe(0x7dd1dbd8L), tobe(0x9133be86L), tobe(0xca92624cL), 
+tobe(0x4c36698dL), tobe(0x1797b547L), tobe(0xfb75d019L), tobe(0xa0d40cd3L), 
+tobe(0xf2fcda2cL), tobe(0xa95d06e6L), tobe(0x45bf63b8L), tobe(0x1e1ebf72L), 
+tobe(0x98bab4b3L), tobe(0xc31b6879L), tobe(0x2ff90d27L), tobe(0x7458d1edL), 
+tobe(0x8ba8a0d9L), tobe(0xd0097c13L), tobe(0x3ceb194dL), tobe(0x674ac587L), 
+tobe(0xe1eece46L), tobe(0xba4f128cL), tobe(0x56ad77d2L), tobe(0x0d0cab18L), 
+tobe(0x5f247de7L), tobe(0x0485a12dL), tobe(0xe867c473L), tobe(0xb3c618b9L), 
+tobe(0x35621378L), tobe(0x6ec3cfb2L), tobe(0x8221aaecL), tobe(0xd9807626L), 
+tobe(0xc7e0f171L), tobe(0x9c412dbbL), tobe(0x70a348e5L), tobe(0x2b02942fL), 
+tobe(0xada69feeL), tobe(0xf6074324L), tobe(0x1ae5267aL), tobe(0x4144fab0L), 
+tobe(0x136c2c4fL), tobe(0x48cdf085L), tobe(0xa42f95dbL), tobe(0xff8e4911L), 
+tobe(0x792a42d0L), tobe(0x228b9e1aL), tobe(0xce69fb44L), tobe(0x95c8278eL), 
+tobe(0x6a3856baL), tobe(0x31998a70L), tobe(0xdd7bef2eL), tobe(0x86da33e4L), 
+tobe(0x007e3825L), tobe(0x5bdfe4efL), tobe(0xb73d81b1L), tobe(0xec9c5d7bL), 
+tobe(0xbeb48b84L), tobe(0xe515574eL), tobe(0x09f73210L), tobe(0x5256eedaL), 
+tobe(0xd4f2e51bL), tobe(0x8f5339d1L), tobe(0x63b15c8fL), tobe(0x38108045L), 
+tobe(0x9890a350L), tobe(0xc3317f9aL), tobe(0x2fd31ac4L), tobe(0x7472c60eL), 
+tobe(0xf2d6cdcfL), tobe(0xa9771105L), tobe(0x4595745bL), tobe(0x1e34a891L), 
+tobe(0x4c1c7e6eL), tobe(0x17bda2a4L), tobe(0xfb5fc7faL), tobe(0xa0fe1b30L), 
+tobe(0x265a10f1L), tobe(0x7dfbcc3bL), tobe(0x9119a965L), tobe(0xcab875afL), 
+tobe(0x3548049bL), tobe(0x6ee9d851L), tobe(0x820bbd0fL), tobe(0xd9aa61c5L), 
+tobe(0x5f0e6a04L), tobe(0x04afb6ceL), tobe(0xe84dd390L), tobe(0xb3ec0f5aL), 
+tobe(0xe1c4d9a5L), tobe(0xba65056fL), tobe(0x56876031L), tobe(0x0d26bcfbL), 
+tobe(0x8b82b73aL), tobe(0xd0236bf0L), tobe(0x3cc10eaeL), tobe(0x6760d264L)},
+};
+static const uint32_t crc32ctable_le[8][256] = {{
+tole(0x00000000L), tole(0xf26b8303L), tole(0xe13b70f7L), tole(0x1350f3f4L), 
+tole(0xc79a971fL), tole(0x35f1141cL), tole(0x26a1e7e8L), tole(0xd4ca64ebL), 
+tole(0x8ad958cfL), tole(0x78b2dbccL), tole(0x6be22838L), tole(0x9989ab3bL), 
+tole(0x4d43cfd0L), tole(0xbf284cd3L), tole(0xac78bf27L), tole(0x5e133c24L), 
+tole(0x105ec76fL), tole(0xe235446cL), tole(0xf165b798L), tole(0x030e349bL), 
+tole(0xd7c45070L), tole(0x25afd373L), tole(0x36ff2087L), tole(0xc494a384L), 
+tole(0x9a879fa0L), tole(0x68ec1ca3L), tole(0x7bbcef57L), tole(0x89d76c54L), 
+tole(0x5d1d08bfL), tole(0xaf768bbcL), tole(0xbc267848L), tole(0x4e4dfb4bL), 
+tole(0x20bd8edeL), tole(0xd2d60dddL), tole(0xc186fe29L), tole(0x33ed7d2aL), 
+tole(0xe72719c1L), tole(0x154c9ac2L), tole(0x061c6936L), tole(0xf477ea35L), 
+tole(0xaa64d611L), tole(0x580f5512L), tole(0x4b5fa6e6L), tole(0xb93425e5L), 
+tole(0x6dfe410eL), tole(0x9f95c20dL), tole(0x8cc531f9L), tole(0x7eaeb2faL), 
+tole(0x30e349b1L), tole(0xc288cab2L), tole(0xd1d83946L), tole(0x23b3ba45L), 
+tole(0xf779deaeL), tole(0x05125dadL), tole(0x1642ae59L), tole(0xe4292d5aL), 
+tole(0xba3a117eL), tole(0x4851927dL), tole(0x5b016189L), tole(0xa96ae28aL), 
+tole(0x7da08661L), tole(0x8fcb0562L), tole(0x9c9bf696L), tole(0x6ef07595L), 
+tole(0x417b1dbcL), tole(0xb3109ebfL), tole(0xa0406d4bL), tole(0x522bee48L), 
+tole(0x86e18aa3L), tole(0x748a09a0L), tole(0x67dafa54L), tole(0x95b17957L), 
+tole(0xcba24573L), tole(0x39c9c670L), tole(0x2a993584L), tole(0xd8f2b687L), 
+tole(0x0c38d26cL), tole(0xfe53516fL), tole(0xed03a29bL), tole(0x1f682198L), 
+tole(0x5125dad3L), tole(0xa34e59d0L), tole(0xb01eaa24L), tole(0x42752927L), 
+tole(0x96bf4dccL), tole(0x64d4cecfL), tole(0x77843d3bL), tole(0x85efbe38L), 
+tole(0xdbfc821cL), tole(0x2997011fL), tole(0x3ac7f2ebL), tole(0xc8ac71e8L), 
+tole(0x1c661503L), tole(0xee0d9600L), tole(0xfd5d65f4L), tole(0x0f36e6f7L), 
+tole(0x61c69362L), tole(0x93ad1061L), tole(0x80fde395L), tole(0x72966096L), 
+tole(0xa65c047dL), tole(0x5437877eL), tole(0x4767748aL), tole(0xb50cf789L), 
+tole(0xeb1fcbadL), tole(0x197448aeL), tole(0x0a24bb5aL), tole(0xf84f3859L), 
+tole(0x2c855cb2L), tole(0xdeeedfb1L), tole(0xcdbe2c45L), tole(0x3fd5af46L), 
+tole(0x7198540dL), tole(0x83f3d70eL), tole(0x90a324faL), tole(0x62c8a7f9L), 
+tole(0xb602c312L), tole(0x44694011L), tole(0x5739b3e5L), tole(0xa55230e6L), 
+tole(0xfb410cc2L), tole(0x092a8fc1L), tole(0x1a7a7c35L), tole(0xe811ff36L), 
+tole(0x3cdb9bddL), tole(0xceb018deL), tole(0xdde0eb2aL), tole(0x2f8b6829L), 
+tole(0x82f63b78L), tole(0x709db87bL), tole(0x63cd4b8fL), tole(0x91a6c88cL), 
+tole(0x456cac67L), tole(0xb7072f64L), tole(0xa457dc90L), tole(0x563c5f93L), 
+tole(0x082f63b7L), tole(0xfa44e0b4L), tole(0xe9141340L), tole(0x1b7f9043L), 
+tole(0xcfb5f4a8L), tole(0x3dde77abL), tole(0x2e8e845fL), tole(0xdce5075cL), 
+tole(0x92a8fc17L), tole(0x60c37f14L), tole(0x73938ce0L), tole(0x81f80fe3L), 
+tole(0x55326b08L), tole(0xa759e80bL), tole(0xb4091bffL), tole(0x466298fcL), 
+tole(0x1871a4d8L), tole(0xea1a27dbL), tole(0xf94ad42fL), tole(0x0b21572cL), 
+tole(0xdfeb33c7L), tole(0x2d80b0c4L), tole(0x3ed04330L), tole(0xccbbc033L), 
+tole(0xa24bb5a6L), tole(0x502036a5L), tole(0x4370c551L), tole(0xb11b4652L), 
+tole(0x65d122b9L), tole(0x97baa1baL), tole(0x84ea524eL), tole(0x7681d14dL), 
+tole(0x2892ed69L), tole(0xdaf96e6aL), tole(0xc9a99d9eL), tole(0x3bc21e9dL), 
+tole(0xef087a76L), tole(0x1d63f975L), tole(0x0e330a81L), tole(0xfc588982L), 
+tole(0xb21572c9L), tole(0x407ef1caL), tole(0x532e023eL), tole(0xa145813dL), 
+tole(0x758fe5d6L), tole(0x87e466d5L), tole(0x94b49521L), tole(0x66df1622L), 
+tole(0x38cc2a06L), tole(0xcaa7a905L), tole(0xd9f75af1L), tole(0x2b9cd9f2L), 
+tole(0xff56bd19L), tole(0x0d3d3e1aL), tole(0x1e6dcdeeL), tole(0xec064eedL), 
+tole(0xc38d26c4L), tole(0x31e6a5c7L), tole(0x22b65633L), tole(0xd0ddd530L), 
+tole(0x0417b1dbL), tole(0xf67c32d8L), tole(0xe52cc12cL), tole(0x1747422fL), 
+tole(0x49547e0bL), tole(0xbb3ffd08L), tole(0xa86f0efcL), tole(0x5a048dffL), 
+tole(0x8ecee914L), tole(0x7ca56a17L), tole(0x6ff599e3L), tole(0x9d9e1ae0L), 
+tole(0xd3d3e1abL), tole(0x21b862a8L), tole(0x32e8915cL), tole(0xc083125fL), 
+tole(0x144976b4L), tole(0xe622f5b7L), tole(0xf5720643L), tole(0x07198540L), 
+tole(0x590ab964L), tole(0xab613a67L), tole(0xb831c993L), tole(0x4a5a4a90L), 
+tole(0x9e902e7bL), tole(0x6cfbad78L), tole(0x7fab5e8cL), tole(0x8dc0dd8fL), 
+tole(0xe330a81aL), tole(0x115b2b19L), tole(0x020bd8edL), tole(0xf0605beeL), 
+tole(0x24aa3f05L), tole(0xd6c1bc06L), tole(0xc5914ff2L), tole(0x37faccf1L), 
+tole(0x69e9f0d5L), tole(0x9b8273d6L), tole(0x88d28022L), tole(0x7ab90321L), 
+tole(0xae7367caL), tole(0x5c18e4c9L), tole(0x4f48173dL), tole(0xbd23943eL), 
+tole(0xf36e6f75L), tole(0x0105ec76L), tole(0x12551f82L), tole(0xe03e9c81L), 
+tole(0x34f4f86aL), tole(0xc69f7b69L), tole(0xd5cf889dL), tole(0x27a40b9eL), 
+tole(0x79b737baL), tole(0x8bdcb4b9L), tole(0x988c474dL), tole(0x6ae7c44eL), 
+tole(0xbe2da0a5L), tole(0x4c4623a6L), tole(0x5f16d052L), tole(0xad7d5351L)},
+{
+tole(0x00000000L), tole(0x13a29877L), tole(0x274530eeL), tole(0x34e7a899L), 
+tole(0x4e8a61dcL), tole(0x5d28f9abL), tole(0x69cf5132L), tole(0x7a6dc945L), 
+tole(0x9d14c3b8L), tole(0x8eb65bcfL), tole(0xba51f356L), tole(0xa9f36b21L), 
+tole(0xd39ea264L), tole(0xc03c3a13L), tole(0xf4db928aL), tole(0xe7790afdL), 
+tole(0x3fc5f181L), tole(0x2c6769f6L), tole(0x1880c16fL), tole(0x0b225918L), 
+tole(0x714f905dL), tole(0x62ed082aL), tole(0x560aa0b3L), tole(0x45a838c4L), 
+tole(0xa2d13239L), tole(0xb173aa4eL), tole(0x859402d7L), tole(0x96369aa0L), 
+tole(0xec5b53e5L), tole(0xfff9cb92L), tole(0xcb1e630bL), tole(0xd8bcfb7cL), 
+tole(0x7f8be302L), tole(0x6c297b75L), tole(0x58ced3ecL), tole(0x4b6c4b9bL), 
+tole(0x310182deL), tole(0x22a31aa9L), tole(0x1644b230L), tole(0x05e62a47L), 
+tole(0xe29f20baL), tole(0xf13db8cdL), tole(0xc5da1054L), tole(0xd6788823L), 
+tole(0xac154166L), tole(0xbfb7d911L), tole(0x8b507188L), tole(0x98f2e9ffL), 
+tole(0x404e1283L), tole(0x53ec8af4L), tole(0x670b226dL), tole(0x74a9ba1aL), 
+tole(0x0ec4735fL), tole(0x1d66eb28L), tole(0x298143b1L), tole(0x3a23dbc6L), 
+tole(0xdd5ad13bL), tole(0xcef8494cL), tole(0xfa1fe1d5L), tole(0xe9bd79a2L), 
+tole(0x93d0b0e7L), tole(0x80722890L), tole(0xb4958009L), tole(0xa737187eL), 
+tole(0xff17c604L), tole(0xecb55e73L), tole(0xd852f6eaL), tole(0xcbf06e9dL), 
+tole(0xb19da7d8L), tole(0xa23f3fafL), tole(0x96d89736L), tole(0x857a0f41L), 
+tole(0x620305bcL), tole(0x71a19dcbL), tole(0x45463552L), tole(0x56e4ad25L), 
+tole(0x2c896460L), tole(0x3f2bfc17L), tole(0x0bcc548eL), tole(0x186eccf9L), 
+tole(0xc0d23785L), tole(0xd370aff2L), tole(0xe797076bL), tole(0xf4359f1cL), 
+tole(0x8e585659L), tole(0x9dface2eL), tole(0xa91d66b7L), tole(0xbabffec0L), 
+tole(0x5dc6f43dL), tole(0x4e646c4aL), tole(0x7a83c4d3L), tole(0x69215ca4L), 
+tole(0x134c95e1L), tole(0x00ee0d96L), tole(0x3409a50fL), tole(0x27ab3d78L), 
+tole(0x809c2506L), tole(0x933ebd71L), tole(0xa7d915e8L), tole(0xb47b8d9fL), 
+tole(0xce1644daL), tole(0xddb4dcadL), tole(0xe9537434L), tole(0xfaf1ec43L), 
+tole(0x1d88e6beL), tole(0x0e2a7ec9L), tole(0x3acdd650L), tole(0x296f4e27L), 
+tole(0x53028762L), tole(0x40a01f15L), tole(0x7447b78cL), tole(0x67e52ffbL), 
+tole(0xbf59d487L), tole(0xacfb4cf0L), tole(0x981ce469L), tole(0x8bbe7c1eL), 
+tole(0xf1d3b55bL), tole(0xe2712d2cL), tole(0xd69685b5L), tole(0xc5341dc2L), 
+tole(0x224d173fL), tole(0x31ef8f48L), tole(0x050827d1L), tole(0x16aabfa6L), 
+tole(0x6cc776e3L), tole(0x7f65ee94L), tole(0x4b82460dL), tole(0x5820de7aL), 
+tole(0xfbc3faf9L), tole(0xe861628eL), tole(0xdc86ca17L), tole(0xcf245260L), 
+tole(0xb5499b25L), tole(0xa6eb0352L), tole(0x920cabcbL), tole(0x81ae33bcL), 
+tole(0x66d73941L), tole(0x7575a136L), tole(0x419209afL), tole(0x523091d8L), 
+tole(0x285d589dL), tole(0x3bffc0eaL), tole(0x0f186873L), tole(0x1cbaf004L), 
+tole(0xc4060b78L), tole(0xd7a4930fL), tole(0xe3433b96L), tole(0xf0e1a3e1L), 
+tole(0x8a8c6aa4L), tole(0x992ef2d3L), tole(0xadc95a4aL), tole(0xbe6bc23dL), 
+tole(0x5912c8c0L), tole(0x4ab050b7L), tole(0x7e57f82eL), tole(0x6df56059L), 
+tole(0x1798a91cL), tole(0x043a316bL), tole(0x30dd99f2L), tole(0x237f0185L), 
+tole(0x844819fbL), tole(0x97ea818cL), tole(0xa30d2915L), tole(0xb0afb162L), 
+tole(0xcac27827L), tole(0xd960e050L), tole(0xed8748c9L), tole(0xfe25d0beL), 
+tole(0x195cda43L), tole(0x0afe4234L), tole(0x3e19eaadL), tole(0x2dbb72daL), 
+tole(0x57d6bb9fL), tole(0x447423e8L), tole(0x70938b71L), tole(0x63311306L), 
+tole(0xbb8de87aL), tole(0xa82f700dL), tole(0x9cc8d894L), tole(0x8f6a40e3L), 
+tole(0xf50789a6L), tole(0xe6a511d1L), tole(0xd242b948L), tole(0xc1e0213fL), 
+tole(0x26992bc2L), tole(0x353bb3b5L), tole(0x01dc1b2cL), tole(0x127e835bL), 
+tole(0x68134a1eL), tole(0x7bb1d269L), tole(0x4f567af0L), tole(0x5cf4e287L), 
+tole(0x04d43cfdL), tole(0x1776a48aL), tole(0x23910c13L), tole(0x30339464L), 
+tole(0x4a5e5d21L), tole(0x59fcc556L), tole(0x6d1b6dcfL), tole(0x7eb9f5b8L), 
+tole(0x99c0ff45L), tole(0x8a626732L), tole(0xbe85cfabL), tole(0xad2757dcL), 
+tole(0xd74a9e99L), tole(0xc4e806eeL), tole(0xf00fae77L), tole(0xe3ad3600L), 
+tole(0x3b11cd7cL), tole(0x28b3550bL), tole(0x1c54fd92L), tole(0x0ff665e5L), 
+tole(0x759baca0L), tole(0x663934d7L), tole(0x52de9c4eL), tole(0x417c0439L), 
+tole(0xa6050ec4L), tole(0xb5a796b3L), tole(0x81403e2aL), tole(0x92e2a65dL), 
+tole(0xe88f6f18L), tole(0xfb2df76fL), tole(0xcfca5ff6L), tole(0xdc68c781L), 
+tole(0x7b5fdfffL), tole(0x68fd4788L), tole(0x5c1aef11L), tole(0x4fb87766L), 
+tole(0x35d5be23L), tole(0x26772654L), tole(0x12908ecdL), tole(0x013216baL), 
+tole(0xe64b1c47L), tole(0xf5e98430L), tole(0xc10e2ca9L), tole(0xd2acb4deL), 
+tole(0xa8c17d9bL), tole(0xbb63e5ecL), tole(0x8f844d75L), tole(0x9c26d502L), 
+tole(0x449a2e7eL), tole(0x5738b609L), tole(0x63df1e90L), tole(0x707d86e7L), 
+tole(0x0a104fa2L), tole(0x19b2d7d5L), tole(0x2d557f4cL), tole(0x3ef7e73bL), 
+tole(0xd98eedc6L), tole(0xca2c75b1L), tole(0xfecbdd28L), tole(0xed69455fL), 
+tole(0x97048c1aL), tole(0x84a6146dL), tole(0xb041bcf4L), tole(0xa3e32483L)},
+{
+tole(0x00000000L), tole(0xa541927eL), tole(0x4f6f520dL), tole(0xea2ec073L), 
+tole(0x9edea41aL), tole(0x3b9f3664L), tole(0xd1b1f617L), tole(0x74f06469L), 
+tole(0x38513ec5L), tole(0x9d10acbbL), tole(0x773e6cc8L), tole(0xd27ffeb6L), 
+tole(0xa68f9adfL), tole(0x03ce08a1L), tole(0xe9e0c8d2L), tole(0x4ca15aacL), 
+tole(0x70a27d8aL), tole(0xd5e3eff4L), tole(0x3fcd2f87L), tole(0x9a8cbdf9L), 
+tole(0xee7cd990L), tole(0x4b3d4beeL), tole(0xa1138b9dL), tole(0x045219e3L), 
+tole(0x48f3434fL), tole(0xedb2d131L), tole(0x079c1142L), tole(0xa2dd833cL), 
+tole(0xd62de755L), tole(0x736c752bL), tole(0x9942b558L), tole(0x3c032726L), 
+tole(0xe144fb14L), tole(0x4405696aL), tole(0xae2ba919L), tole(0x0b6a3b67L), 
+tole(0x7f9a5f0eL), tole(0xdadbcd70L), tole(0x30f50d03L), tole(0x95b49f7dL), 
+tole(0xd915c5d1L), tole(0x7c5457afL), tole(0x967a97dcL), tole(0x333b05a2L), 
+tole(0x47cb61cbL), tole(0xe28af3b5L), tole(0x08a433c6L), tole(0xade5a1b8L), 
+tole(0x91e6869eL), tole(0x34a714e0L), tole(0xde89d493L), tole(0x7bc846edL), 
+tole(0x0f382284L), tole(0xaa79b0faL), tole(0x40577089L), tole(0xe516e2f7L), 
+tole(0xa9b7b85bL), tole(0x0cf62a25L), tole(0xe6d8ea56L), tole(0x43997828L), 
+tole(0x37691c41L), tole(0x92288e3fL), tole(0x78064e4cL), tole(0xdd47dc32L), 
+tole(0xc76580d9L), tole(0x622412a7L), tole(0x880ad2d4L), tole(0x2d4b40aaL), 
+tole(0x59bb24c3L), tole(0xfcfab6bdL), tole(0x16d476ceL), tole(0xb395e4b0L), 
+tole(0xff34be1cL), tole(0x5a752c62L), tole(0xb05bec11L), tole(0x151a7e6fL), 
+tole(0x61ea1a06L), tole(0xc4ab8878L), tole(0x2e85480bL), tole(0x8bc4da75L), 
+tole(0xb7c7fd53L), tole(0x12866f2dL), tole(0xf8a8af5eL), tole(0x5de93d20L), 
+tole(0x29195949L), tole(0x8c58cb37L), tole(0x66760b44L), tole(0xc337993aL), 
+tole(0x8f96c396L), tole(0x2ad751e8L), tole(0xc0f9919bL), tole(0x65b803e5L), 
+tole(0x1148678cL), tole(0xb409f5f2L), tole(0x5e273581L), tole(0xfb66a7ffL), 
+tole(0x26217bcdL), tole(0x8360e9b3L), tole(0x694e29c0L), tole(0xcc0fbbbeL), 
+tole(0xb8ffdfd7L), tole(0x1dbe4da9L), tole(0xf7908ddaL), tole(0x52d11fa4L), 
+tole(0x1e704508L), tole(0xbb31d776L), tole(0x511f1705L), tole(0xf45e857bL), 
+tole(0x80aee112L), tole(0x25ef736cL), tole(0xcfc1b31fL), tole(0x6a802161L), 
+tole(0x56830647L), tole(0xf3c29439L), tole(0x19ec544aL), tole(0xbcadc634L), 
+tole(0xc85da25dL), tole(0x6d1c3023L), tole(0x8732f050L), tole(0x2273622eL), 
+tole(0x6ed23882L), tole(0xcb93aafcL), tole(0x21bd6a8fL), tole(0x84fcf8f1L), 
+tole(0xf00c9c98L), tole(0x554d0ee6L), tole(0xbf63ce95L), tole(0x1a225cebL), 
+tole(0x8b277743L), tole(0x2e66e53dL), tole(0xc448254eL), tole(0x6109b730L), 
+tole(0x15f9d359L), tole(0xb0b84127L), tole(0x5a968154L), tole(0xffd7132aL), 
+tole(0xb3764986L), tole(0x1637dbf8L), tole(0xfc191b8bL), tole(0x595889f5L), 
+tole(0x2da8ed9cL), tole(0x88e97fe2L), tole(0x62c7bf91L), tole(0xc7862defL), 
+tole(0xfb850ac9L), tole(0x5ec498b7L), tole(0xb4ea58c4L), tole(0x11abcabaL), 
+tole(0x655baed3L), tole(0xc01a3cadL), tole(0x2a34fcdeL), tole(0x8f756ea0L), 
+tole(0xc3d4340cL), tole(0x6695a672L), tole(0x8cbb6601L), tole(0x29faf47fL), 
+tole(0x5d0a9016L), tole(0xf84b0268L), tole(0x1265c21bL), tole(0xb7245065L), 
+tole(0x6a638c57L), tole(0xcf221e29L), tole(0x250cde5aL), tole(0x804d4c24L), 
+tole(0xf4bd284dL), tole(0x51fcba33L), tole(0xbbd27a40L), tole(0x1e93e83eL), 
+tole(0x5232b292L), tole(0xf77320ecL), tole(0x1d5de09fL), tole(0xb81c72e1L), 
+tole(0xccec1688L), tole(0x69ad84f6L), tole(0x83834485L), tole(0x26c2d6fbL), 
+tole(0x1ac1f1ddL), tole(0xbf8063a3L), tole(0x55aea3d0L), tole(0xf0ef31aeL), 
+tole(0x841f55c7L), tole(0x215ec7b9L), tole(0xcb7007caL), tole(0x6e3195b4L), 
+tole(0x2290cf18L), tole(0x87d15d66L), tole(0x6dff9d15L), tole(0xc8be0f6bL), 
+tole(0xbc4e6b02L), tole(0x190ff97cL), tole(0xf321390fL), tole(0x5660ab71L), 
+tole(0x4c42f79aL), tole(0xe90365e4L), tole(0x032da597L), tole(0xa66c37e9L), 
+tole(0xd29c5380L), tole(0x77ddc1feL), tole(0x9df3018dL), tole(0x38b293f3L), 
+tole(0x7413c95fL), tole(0xd1525b21L), tole(0x3b7c9b52L), tole(0x9e3d092cL), 
+tole(0xeacd6d45L), tole(0x4f8cff3bL), tole(0xa5a23f48L), tole(0x00e3ad36L), 
+tole(0x3ce08a10L), tole(0x99a1186eL), tole(0x738fd81dL), tole(0xd6ce4a63L), 
+tole(0xa23e2e0aL), tole(0x077fbc74L), tole(0xed517c07L), tole(0x4810ee79L), 
+tole(0x04b1b4d5L), tole(0xa1f026abL), tole(0x4bdee6d8L), tole(0xee9f74a6L), 
+tole(0x9a6f10cfL), tole(0x3f2e82b1L), tole(0xd50042c2L), tole(0x7041d0bcL), 
+tole(0xad060c8eL), tole(0x08479ef0L), tole(0xe2695e83L), tole(0x4728ccfdL), 
+tole(0x33d8a894L), tole(0x96993aeaL), tole(0x7cb7fa99L), tole(0xd9f668e7L), 
+tole(0x9557324bL), tole(0x3016a035L), tole(0xda386046L), tole(0x7f79f238L), 
+tole(0x0b899651L), tole(0xaec8042fL), tole(0x44e6c45cL), tole(0xe1a75622L), 
+tole(0xdda47104L), tole(0x78e5e37aL), tole(0x92cb2309L), tole(0x378ab177L), 
+tole(0x437ad51eL), tole(0xe63b4760L), tole(0x0c158713L), tole(0xa954156dL), 
+tole(0xe5f54fc1L), tole(0x40b4ddbfL), tole(0xaa9a1dccL), tole(0x0fdb8fb2L), 
+tole(0x7b2bebdbL), tole(0xde6a79a5L), tole(0x3444b9d6L), tole(0x91052ba8L)},
+{
+tole(0x00000000L), tole(0xdd45aab8L), tole(0xbf672381L), tole(0x62228939L), 
+tole(0x7b2231f3L), tole(0xa6679b4bL), tole(0xc4451272L), tole(0x1900b8caL), 
+tole(0xf64463e6L), tole(0x2b01c95eL), tole(0x49234067L), tole(0x9466eadfL), 
+tole(0x8d665215L), tole(0x5023f8adL), tole(0x32017194L), tole(0xef44db2cL), 
+tole(0xe964b13dL), tole(0x34211b85L), tole(0x560392bcL), tole(0x8b463804L), 
+tole(0x924680ceL), tole(0x4f032a76L), tole(0x2d21a34fL), tole(0xf06409f7L), 
+tole(0x1f20d2dbL), tole(0xc2657863L), tole(0xa047f15aL), tole(0x7d025be2L), 
+tole(0x6402e328L), tole(0xb9474990L), tole(0xdb65c0a9L), tole(0x06206a11L), 
+tole(0xd725148bL), tole(0x0a60be33L), tole(0x6842370aL), tole(0xb5079db2L), 
+tole(0xac072578L), tole(0x71428fc0L), tole(0x136006f9L), tole(0xce25ac41L), 
+tole(0x2161776dL), tole(0xfc24ddd5L), tole(0x9e0654ecL), tole(0x4343fe54L), 
+tole(0x5a43469eL), tole(0x8706ec26L), tole(0xe524651fL), tole(0x3861cfa7L), 
+tole(0x3e41a5b6L), tole(0xe3040f0eL), tole(0x81268637L), tole(0x5c632c8fL), 
+tole(0x45639445L), tole(0x98263efdL), tole(0xfa04b7c4L), tole(0x27411d7cL), 
+tole(0xc805c650L), tole(0x15406ce8L), tole(0x7762e5d1L), tole(0xaa274f69L), 
+tole(0xb327f7a3L), tole(0x6e625d1bL), tole(0x0c40d422L), tole(0xd1057e9aL), 
+tole(0xaba65fe7L), tole(0x76e3f55fL), tole(0x14c17c66L), tole(0xc984d6deL), 
+tole(0xd0846e14L), tole(0x0dc1c4acL), tole(0x6fe34d95L), tole(0xb2a6e72dL), 
+tole(0x5de23c01L), tole(0x80a796b9L), tole(0xe2851f80L), tole(0x3fc0b538L), 
+tole(0x26c00df2L), tole(0xfb85a74aL), tole(0x99a72e73L), tole(0x44e284cbL), 
+tole(0x42c2eedaL), tole(0x9f874462L), tole(0xfda5cd5bL), tole(0x20e067e3L), 
+tole(0x39e0df29L), tole(0xe4a57591L), tole(0x8687fca8L), tole(0x5bc25610L), 
+tole(0xb4868d3cL), tole(0x69c32784L), tole(0x0be1aebdL), tole(0xd6a40405L), 
+tole(0xcfa4bccfL), tole(0x12e11677L), tole(0x70c39f4eL), tole(0xad8635f6L), 
+tole(0x7c834b6cL), tole(0xa1c6e1d4L), tole(0xc3e468edL), tole(0x1ea1c255L), 
+tole(0x07a17a9fL), tole(0xdae4d027L), tole(0xb8c6591eL), tole(0x6583f3a6L), 
+tole(0x8ac7288aL), tole(0x57828232L), tole(0x35a00b0bL), tole(0xe8e5a1b3L), 
+tole(0xf1e51979L), tole(0x2ca0b3c1L), tole(0x4e823af8L), tole(0x93c79040L), 
+tole(0x95e7fa51L), tole(0x48a250e9L), tole(0x2a80d9d0L), tole(0xf7c57368L), 
+tole(0xeec5cba2L), tole(0x3380611aL), tole(0x51a2e823L), tole(0x8ce7429bL), 
+tole(0x63a399b7L), tole(0xbee6330fL), tole(0xdcc4ba36L), tole(0x0181108eL), 
+tole(0x1881a844L), tole(0xc5c402fcL), tole(0xa7e68bc5L), tole(0x7aa3217dL), 
+tole(0x52a0c93fL), tole(0x8fe56387L), tole(0xedc7eabeL), tole(0x30824006L), 
+tole(0x2982f8ccL), tole(0xf4c75274L), tole(0x96e5db4dL), tole(0x4ba071f5L), 
+tole(0xa4e4aad9L), tole(0x79a10061L), tole(0x1b838958L), tole(0xc6c623e0L), 
+tole(0xdfc69b2aL), tole(0x02833192L), tole(0x60a1b8abL), tole(0xbde41213L), 
+tole(0xbbc47802L), tole(0x6681d2baL), tole(0x04a35b83L), tole(0xd9e6f13bL), 
+tole(0xc0e649f1L), tole(0x1da3e349L), tole(0x7f816a70L), tole(0xa2c4c0c8L), 
+tole(0x4d801be4L), tole(0x90c5b15cL), tole(0xf2e73865L), tole(0x2fa292ddL), 
+tole(0x36a22a17L), tole(0xebe780afL), tole(0x89c50996L), tole(0x5480a32eL), 
+tole(0x8585ddb4L), tole(0x58c0770cL), tole(0x3ae2fe35L), tole(0xe7a7548dL), 
+tole(0xfea7ec47L), tole(0x23e246ffL), tole(0x41c0cfc6L), tole(0x9c85657eL), 
+tole(0x73c1be52L), tole(0xae8414eaL), tole(0xcca69dd3L), tole(0x11e3376bL), 
+tole(0x08e38fa1L), tole(0xd5a62519L), tole(0xb784ac20L), tole(0x6ac10698L), 
+tole(0x6ce16c89L), tole(0xb1a4c631L), tole(0xd3864f08L), tole(0x0ec3e5b0L), 
+tole(0x17c35d7aL), tole(0xca86f7c2L), tole(0xa8a47efbL), tole(0x75e1d443L), 
+tole(0x9aa50f6fL), tole(0x47e0a5d7L), tole(0x25c22ceeL), tole(0xf8878656L), 
+tole(0xe1873e9cL), tole(0x3cc29424L), tole(0x5ee01d1dL), tole(0x83a5b7a5L), 
+tole(0xf90696d8L), tole(0x24433c60L), tole(0x4661b559L), tole(0x9b241fe1L), 
+tole(0x8224a72bL), tole(0x5f610d93L), tole(0x3d4384aaL), tole(0xe0062e12L), 
+tole(0x0f42f53eL), tole(0xd2075f86L), tole(0xb025d6bfL), tole(0x6d607c07L), 
+tole(0x7460c4cdL), tole(0xa9256e75L), tole(0xcb07e74cL), tole(0x16424df4L), 
+tole(0x106227e5L), tole(0xcd278d5dL), tole(0xaf050464L), tole(0x7240aedcL), 
+tole(0x6b401616L), tole(0xb605bcaeL), tole(0xd4273597L), tole(0x09629f2fL), 
+tole(0xe6264403L), tole(0x3b63eebbL), tole(0x59416782L), tole(0x8404cd3aL), 
+tole(0x9d0475f0L), tole(0x4041df48L), tole(0x22635671L), tole(0xff26fcc9L), 
+tole(0x2e238253L), tole(0xf36628ebL), tole(0x9144a1d2L), tole(0x4c010b6aL), 
+tole(0x5501b3a0L), tole(0x88441918L), tole(0xea669021L), tole(0x37233a99L), 
+tole(0xd867e1b5L), tole(0x05224b0dL), tole(0x6700c234L), tole(0xba45688cL), 
+tole(0xa345d046L), tole(0x7e007afeL), tole(0x1c22f3c7L), tole(0xc167597fL), 
+tole(0xc747336eL), tole(0x1a0299d6L), tole(0x782010efL), tole(0xa565ba57L), 
+tole(0xbc65029dL), tole(0x6120a825L), tole(0x0302211cL), tole(0xde478ba4L), 
+tole(0x31035088L), tole(0xec46fa30L), tole(0x8e647309L), tole(0x5321d9b1L), 
+tole(0x4a21617bL), tole(0x9764cbc3L), tole(0xf54642faL), tole(0x2803e842L)},
+{
+tole(0x00000000L), tole(0x38116facL), tole(0x7022df58L), tole(0x4833b0f4L), 
+tole(0xe045beb0L), tole(0xd854d11cL), tole(0x906761e8L), tole(0xa8760e44L), 
+tole(0xc5670b91L), tole(0xfd76643dL), tole(0xb545d4c9L), tole(0x8d54bb65L), 
+tole(0x2522b521L), tole(0x1d33da8dL), tole(0x55006a79L), tole(0x6d1105d5L), 
+tole(0x8f2261d3L), tole(0xb7330e7fL), tole(0xff00be8bL), tole(0xc711d127L), 
+tole(0x6f67df63L), tole(0x5776b0cfL), tole(0x1f45003bL), tole(0x27546f97L), 
+tole(0x4a456a42L), tole(0x725405eeL), tole(0x3a67b51aL), tole(0x0276dab6L), 
+tole(0xaa00d4f2L), tole(0x9211bb5eL), tole(0xda220baaL), tole(0xe2336406L), 
+tole(0x1ba8b557L), tole(0x23b9dafbL), tole(0x6b8a6a0fL), tole(0x539b05a3L), 
+tole(0xfbed0be7L), tole(0xc3fc644bL), tole(0x8bcfd4bfL), tole(0xb3debb13L), 
+tole(0xdecfbec6L), tole(0xe6ded16aL), tole(0xaeed619eL), tole(0x96fc0e32L), 
+tole(0x3e8a0076L), tole(0x069b6fdaL), tole(0x4ea8df2eL), tole(0x76b9b082L), 
+tole(0x948ad484L), tole(0xac9bbb28L), tole(0xe4a80bdcL), tole(0xdcb96470L), 
+tole(0x74cf6a34L), tole(0x4cde0598L), tole(0x04edb56cL), tole(0x3cfcdac0L), 
+tole(0x51eddf15L), tole(0x69fcb0b9L), tole(0x21cf004dL), tole(0x19de6fe1L), 
+tole(0xb1a861a5L), tole(0x89b90e09L), tole(0xc18abefdL), tole(0xf99bd151L), 
+tole(0x37516aaeL), tole(0x0f400502L), tole(0x4773b5f6L), tole(0x7f62da5aL), 
+tole(0xd714d41eL), tole(0xef05bbb2L), tole(0xa7360b46L), tole(0x9f2764eaL), 
+tole(0xf236613fL), tole(0xca270e93L), tole(0x8214be67L), tole(0xba05d1cbL), 
+tole(0x1273df8fL), tole(0x2a62b023L), tole(0x625100d7L), tole(0x5a406f7bL), 
+tole(0xb8730b7dL), tole(0x806264d1L), tole(0xc851d425L), tole(0xf040bb89L), 
+tole(0x5836b5cdL), tole(0x6027da61L), tole(0x28146a95L), tole(0x10050539L), 
+tole(0x7d1400ecL), tole(0x45056f40L), tole(0x0d36dfb4L), tole(0x3527b018L), 
+tole(0x9d51be5cL), tole(0xa540d1f0L), tole(0xed736104L), tole(0xd5620ea8L), 
+tole(0x2cf9dff9L), tole(0x14e8b055L), tole(0x5cdb00a1L), tole(0x64ca6f0dL), 
+tole(0xccbc6149L), tole(0xf4ad0ee5L), tole(0xbc9ebe11L), tole(0x848fd1bdL), 
+tole(0xe99ed468L), tole(0xd18fbbc4L), tole(0x99bc0b30L), tole(0xa1ad649cL), 
+tole(0x09db6ad8L), tole(0x31ca0574L), tole(0x79f9b580L), tole(0x41e8da2cL), 
+tole(0xa3dbbe2aL), tole(0x9bcad186L), tole(0xd3f96172L), tole(0xebe80edeL), 
+tole(0x439e009aL), tole(0x7b8f6f36L), tole(0x33bcdfc2L), tole(0x0badb06eL), 
+tole(0x66bcb5bbL), tole(0x5eadda17L), tole(0x169e6ae3L), tole(0x2e8f054fL), 
+tole(0x86f90b0bL), tole(0xbee864a7L), tole(0xf6dbd453L), tole(0xcecabbffL), 
+tole(0x6ea2d55cL), tole(0x56b3baf0L), tole(0x1e800a04L), tole(0x269165a8L), 
+tole(0x8ee76becL), tole(0xb6f60440L), tole(0xfec5b4b4L), tole(0xc6d4db18L), 
+tole(0xabc5decdL), tole(0x93d4b161L), tole(0xdbe70195L), tole(0xe3f66e39L), 
+tole(0x4b80607dL), tole(0x73910fd1L), tole(0x3ba2bf25L), tole(0x03b3d089L), 
+tole(0xe180b48fL), tole(0xd991db23L), tole(0x91a26bd7L), tole(0xa9b3047bL), 
+tole(0x01c50a3fL), tole(0x39d46593L), tole(0x71e7d567L), tole(0x49f6bacbL), 
+tole(0x24e7bf1eL), tole(0x1cf6d0b2L), tole(0x54c56046L), tole(0x6cd40feaL), 
+tole(0xc4a201aeL), tole(0xfcb36e02L), tole(0xb480def6L), tole(0x8c91b15aL), 
+tole(0x750a600bL), tole(0x4d1b0fa7L), tole(0x0528bf53L), tole(0x3d39d0ffL), 
+tole(0x954fdebbL), tole(0xad5eb117L), tole(0xe56d01e3L), tole(0xdd7c6e4fL), 
+tole(0xb06d6b9aL), tole(0x887c0436L), tole(0xc04fb4c2L), tole(0xf85edb6eL), 
+tole(0x5028d52aL), tole(0x6839ba86L), tole(0x200a0a72L), tole(0x181b65deL), 
+tole(0xfa2801d8L), tole(0xc2396e74L), tole(0x8a0ade80L), tole(0xb21bb12cL), 
+tole(0x1a6dbf68L), tole(0x227cd0c4L), tole(0x6a4f6030L), tole(0x525e0f9cL), 
+tole(0x3f4f0a49L), tole(0x075e65e5L), tole(0x4f6dd511L), tole(0x777cbabdL), 
+tole(0xdf0ab4f9L), tole(0xe71bdb55L), tole(0xaf286ba1L), tole(0x9739040dL), 
+tole(0x59f3bff2L), tole(0x61e2d05eL), tole(0x29d160aaL), tole(0x11c00f06L), 
+tole(0xb9b60142L), tole(0x81a76eeeL), tole(0xc994de1aL), tole(0xf185b1b6L), 
+tole(0x9c94b463L), tole(0xa485dbcfL), tole(0xecb66b3bL), tole(0xd4a70497L), 
+tole(0x7cd10ad3L), tole(0x44c0657fL), tole(0x0cf3d58bL), tole(0x34e2ba27L), 
+tole(0xd6d1de21L), tole(0xeec0b18dL), tole(0xa6f30179L), tole(0x9ee26ed5L), 
+tole(0x36946091L), tole(0x0e850f3dL), tole(0x46b6bfc9L), tole(0x7ea7d065L), 
+tole(0x13b6d5b0L), tole(0x2ba7ba1cL), tole(0x63940ae8L), tole(0x5b856544L), 
+tole(0xf3f36b00L), tole(0xcbe204acL), tole(0x83d1b458L), tole(0xbbc0dbf4L), 
+tole(0x425b0aa5L), tole(0x7a4a6509L), tole(0x3279d5fdL), tole(0x0a68ba51L), 
+tole(0xa21eb415L), tole(0x9a0fdbb9L), tole(0xd23c6b4dL), tole(0xea2d04e1L), 
+tole(0x873c0134L), tole(0xbf2d6e98L), tole(0xf71ede6cL), tole(0xcf0fb1c0L), 
+tole(0x6779bf84L), tole(0x5f68d028L), tole(0x175b60dcL), tole(0x2f4a0f70L), 
+tole(0xcd796b76L), tole(0xf56804daL), tole(0xbd5bb42eL), tole(0x854adb82L), 
+tole(0x2d3cd5c6L), tole(0x152dba6aL), tole(0x5d1e0a9eL), tole(0x650f6532L), 
+tole(0x081e60e7L), tole(0x300f0f4bL), tole(0x783cbfbfL), tole(0x402dd013L), 
+tole(0xe85bde57L), tole(0xd04ab1fbL), tole(0x9879010fL), tole(0xa0686ea3L)},
+{
+tole(0x00000000L), tole(0xef306b19L), tole(0xdb8ca0c3L), tole(0x34bccbdaL), 
+tole(0xb2f53777L), tole(0x5dc55c6eL), tole(0x697997b4L), tole(0x8649fcadL), 
+tole(0x6006181fL), tole(0x8f367306L), tole(0xbb8ab8dcL), tole(0x54bad3c5L), 
+tole(0xd2f32f68L), tole(0x3dc34471L), tole(0x097f8fabL), tole(0xe64fe4b2L), 
+tole(0xc00c303eL), tole(0x2f3c5b27L), tole(0x1b8090fdL), tole(0xf4b0fbe4L), 
+tole(0x72f90749L), tole(0x9dc96c50L), tole(0xa975a78aL), tole(0x4645cc93L), 
+tole(0xa00a2821L), tole(0x4f3a4338L), tole(0x7b8688e2L), tole(0x94b6e3fbL), 
+tole(0x12ff1f56L), tole(0xfdcf744fL), tole(0xc973bf95L), tole(0x2643d48cL), 
+tole(0x85f4168dL), tole(0x6ac47d94L), tole(0x5e78b64eL), tole(0xb148dd57L), 
+tole(0x370121faL), tole(0xd8314ae3L), tole(0xec8d8139L), tole(0x03bdea20L), 
+tole(0xe5f20e92L), tole(0x0ac2658bL), tole(0x3e7eae51L), tole(0xd14ec548L), 
+tole(0x570739e5L), tole(0xb83752fcL), tole(0x8c8b9926L), tole(0x63bbf23fL), 
+tole(0x45f826b3L), tole(0xaac84daaL), tole(0x9e748670L), tole(0x7144ed69L), 
+tole(0xf70d11c4L), tole(0x183d7addL), tole(0x2c81b107L), tole(0xc3b1da1eL), 
+tole(0x25fe3eacL), tole(0xcace55b5L), tole(0xfe729e6fL), tole(0x1142f576L), 
+tole(0x970b09dbL), tole(0x783b62c2L), tole(0x4c87a918L), tole(0xa3b7c201L), 
+tole(0x0e045bebL), tole(0xe13430f2L), tole(0xd588fb28L), tole(0x3ab89031L), 
+tole(0xbcf16c9cL), tole(0x53c10785L), tole(0x677dcc5fL), tole(0x884da746L), 
+tole(0x6e0243f4L), tole(0x813228edL), tole(0xb58ee337L), tole(0x5abe882eL), 
+tole(0xdcf77483L), tole(0x33c71f9aL), tole(0x077bd440L), tole(0xe84bbf59L), 
+tole(0xce086bd5L), tole(0x213800ccL), tole(0x1584cb16L), tole(0xfab4a00fL), 
+tole(0x7cfd5ca2L), tole(0x93cd37bbL), tole(0xa771fc61L), tole(0x48419778L), 
+tole(0xae0e73caL), tole(0x413e18d3L), tole(0x7582d309L), tole(0x9ab2b810L), 
+tole(0x1cfb44bdL), tole(0xf3cb2fa4L), tole(0xc777e47eL), tole(0x28478f67L), 
+tole(0x8bf04d66L), tole(0x64c0267fL), tole(0x507ceda5L), tole(0xbf4c86bcL), 
+tole(0x39057a11L), tole(0xd6351108L), tole(0xe289dad2L), tole(0x0db9b1cbL), 
+tole(0xebf65579L), tole(0x04c63e60L), tole(0x307af5baL), tole(0xdf4a9ea3L), 
+tole(0x5903620eL), tole(0xb6330917L), tole(0x828fc2cdL), tole(0x6dbfa9d4L), 
+tole(0x4bfc7d58L), tole(0xa4cc1641L), tole(0x9070dd9bL), tole(0x7f40b682L), 
+tole(0xf9094a2fL), tole(0x16392136L), tole(0x2285eaecL), tole(0xcdb581f5L), 
+tole(0x2bfa6547L), tole(0xc4ca0e5eL), tole(0xf076c584L), tole(0x1f46ae9dL), 
+tole(0x990f5230L), tole(0x763f3929L), tole(0x4283f2f3L), tole(0xadb399eaL), 
+tole(0x1c08b7d6L), tole(0xf338dccfL), tole(0xc7841715L), tole(0x28b47c0cL), 
+tole(0xaefd80a1L), tole(0x41cdebb8L), tole(0x75712062L), tole(0x9a414b7bL), 
+tole(0x7c0eafc9L), tole(0x933ec4d0L), tole(0xa7820f0aL), tole(0x48b26413L), 
+tole(0xcefb98beL), tole(0x21cbf3a7L), tole(0x1577387dL), tole(0xfa475364L), 
+tole(0xdc0487e8L), tole(0x3334ecf1L), tole(0x0788272bL), tole(0xe8b84c32L), 
+tole(0x6ef1b09fL), tole(0x81c1db86L), tole(0xb57d105cL), tole(0x5a4d7b45L), 
+tole(0xbc029ff7L), tole(0x5332f4eeL), tole(0x678e3f34L), tole(0x88be542dL), 
+tole(0x0ef7a880L), tole(0xe1c7c399L), tole(0xd57b0843L), tole(0x3a4b635aL), 
+tole(0x99fca15bL), tole(0x76ccca42L), tole(0x42700198L), tole(0xad406a81L), 
+tole(0x2b09962cL), tole(0xc439fd35L), tole(0xf08536efL), tole(0x1fb55df6L), 
+tole(0xf9fab944L), tole(0x16cad25dL), tole(0x22761987L), tole(0xcd46729eL), 
+tole(0x4b0f8e33L), tole(0xa43fe52aL), tole(0x90832ef0L), tole(0x7fb345e9L), 
+tole(0x59f09165L), tole(0xb6c0fa7cL), tole(0x827c31a6L), tole(0x6d4c5abfL), 
+tole(0xeb05a612L), tole(0x0435cd0bL), tole(0x308906d1L), tole(0xdfb96dc8L), 
+tole(0x39f6897aL), tole(0xd6c6e263L), tole(0xe27a29b9L), tole(0x0d4a42a0L), 
+tole(0x8b03be0dL), tole(0x6433d514L), tole(0x508f1eceL), tole(0xbfbf75d7L), 
+tole(0x120cec3dL), tole(0xfd3c8724L), tole(0xc9804cfeL), tole(0x26b027e7L), 
+tole(0xa0f9db4aL), tole(0x4fc9b053L), tole(0x7b757b89L), tole(0x94451090L), 
+tole(0x720af422L), tole(0x9d3a9f3bL), tole(0xa98654e1L), tole(0x46b63ff8L), 
+tole(0xc0ffc355L), tole(0x2fcfa84cL), tole(0x1b736396L), tole(0xf443088fL), 
+tole(0xd200dc03L), tole(0x3d30b71aL), tole(0x098c7cc0L), tole(0xe6bc17d9L), 
+tole(0x60f5eb74L), tole(0x8fc5806dL), tole(0xbb794bb7L), tole(0x544920aeL), 
+tole(0xb206c41cL), tole(0x5d36af05L), tole(0x698a64dfL), tole(0x86ba0fc6L), 
+tole(0x00f3f36bL), tole(0xefc39872L), tole(0xdb7f53a8L), tole(0x344f38b1L), 
+tole(0x97f8fab0L), tole(0x78c891a9L), tole(0x4c745a73L), tole(0xa344316aL), 
+tole(0x250dcdc7L), tole(0xca3da6deL), tole(0xfe816d04L), tole(0x11b1061dL), 
+tole(0xf7fee2afL), tole(0x18ce89b6L), tole(0x2c72426cL), tole(0xc3422975L), 
+tole(0x450bd5d8L), tole(0xaa3bbec1L), tole(0x9e87751bL), tole(0x71b71e02L), 
+tole(0x57f4ca8eL), tole(0xb8c4a197L), tole(0x8c786a4dL), tole(0x63480154L), 
+tole(0xe501fdf9L), tole(0x0a3196e0L), tole(0x3e8d5d3aL), tole(0xd1bd3623L), 
+tole(0x37f2d291L), tole(0xd8c2b988L), tole(0xec7e7252L), tole(0x034e194bL), 
+tole(0x8507e5e6L), tole(0x6a378effL), tole(0x5e8b4525L), tole(0xb1bb2e3cL)},
+{
+tole(0x00000000L), tole(0x68032cc8L), tole(0xd0065990L), tole(0xb8057558L), 
+tole(0xa5e0c5d1L), tole(0xcde3e919L), tole(0x75e69c41L), tole(0x1de5b089L), 
+tole(0x4e2dfd53L), tole(0x262ed19bL), tole(0x9e2ba4c3L), tole(0xf628880bL), 
+tole(0xebcd3882L), tole(0x83ce144aL), tole(0x3bcb6112L), tole(0x53c84ddaL), 
+tole(0x9c5bfaa6L), tole(0xf458d66eL), tole(0x4c5da336L), tole(0x245e8ffeL), 
+tole(0x39bb3f77L), tole(0x51b813bfL), tole(0xe9bd66e7L), tole(0x81be4a2fL), 
+tole(0xd27607f5L), tole(0xba752b3dL), tole(0x02705e65L), tole(0x6a7372adL), 
+tole(0x7796c224L), tole(0x1f95eeecL), tole(0xa7909bb4L), tole(0xcf93b77cL), 
+tole(0x3d5b83bdL), tole(0x5558af75L), tole(0xed5dda2dL), tole(0x855ef6e5L), 
+tole(0x98bb466cL), tole(0xf0b86aa4L), tole(0x48bd1ffcL), tole(0x20be3334L), 
+tole(0x73767eeeL), tole(0x1b755226L), tole(0xa370277eL), tole(0xcb730bb6L), 
+tole(0xd696bb3fL), tole(0xbe9597f7L), tole(0x0690e2afL), tole(0x6e93ce67L), 
+tole(0xa100791bL), tole(0xc90355d3L), tole(0x7106208bL), tole(0x19050c43L), 
+tole(0x04e0bccaL), tole(0x6ce39002L), tole(0xd4e6e55aL), tole(0xbce5c992L), 
+tole(0xef2d8448L), tole(0x872ea880L), tole(0x3f2bddd8L), tole(0x5728f110L), 
+tole(0x4acd4199L), tole(0x22ce6d51L), tole(0x9acb1809L), tole(0xf2c834c1L), 
+tole(0x7ab7077aL), tole(0x12b42bb2L), tole(0xaab15eeaL), tole(0xc2b27222L), 
+tole(0xdf57c2abL), tole(0xb754ee63L), tole(0x0f519b3bL), tole(0x6752b7f3L), 
+tole(0x349afa29L), tole(0x5c99d6e1L), tole(0xe49ca3b9L), tole(0x8c9f8f71L), 
+tole(0x917a3ff8L), tole(0xf9791330L), tole(0x417c6668L), tole(0x297f4aa0L), 
+tole(0xe6ecfddcL), tole(0x8eefd114L), tole(0x36eaa44cL), tole(0x5ee98884L), 
+tole(0x430c380dL), tole(0x2b0f14c5L), tole(0x930a619dL), tole(0xfb094d55L), 
+tole(0xa8c1008fL), tole(0xc0c22c47L), tole(0x78c7591fL), tole(0x10c475d7L), 
+tole(0x0d21c55eL), tole(0x6522e996L), tole(0xdd279cceL), tole(0xb524b006L), 
+tole(0x47ec84c7L), tole(0x2fefa80fL), tole(0x97eadd57L), tole(0xffe9f19fL), 
+tole(0xe20c4116L), tole(0x8a0f6ddeL), tole(0x320a1886L), tole(0x5a09344eL), 
+tole(0x09c17994L), tole(0x61c2555cL), tole(0xd9c72004L), tole(0xb1c40cccL), 
+tole(0xac21bc45L), tole(0xc422908dL), tole(0x7c27e5d5L), tole(0x1424c91dL), 
+tole(0xdbb77e61L), tole(0xb3b452a9L), tole(0x0bb127f1L), tole(0x63b20b39L), 
+tole(0x7e57bbb0L), tole(0x16549778L), tole(0xae51e220L), tole(0xc652cee8L), 
+tole(0x959a8332L), tole(0xfd99affaL), tole(0x459cdaa2L), tole(0x2d9ff66aL), 
+tole(0x307a46e3L), tole(0x58796a2bL), tole(0xe07c1f73L), tole(0x887f33bbL), 
+tole(0xf56e0ef4L), tole(0x9d6d223cL), tole(0x25685764L), tole(0x4d6b7bacL), 
+tole(0x508ecb25L), tole(0x388de7edL), tole(0x808892b5L), tole(0xe88bbe7dL), 
+tole(0xbb43f3a7L), tole(0xd340df6fL), tole(0x6b45aa37L), tole(0x034686ffL), 
+tole(0x1ea33676L), tole(0x76a01abeL), tole(0xcea56fe6L), tole(0xa6a6432eL), 
+tole(0x6935f452L), tole(0x0136d89aL), tole(0xb933adc2L), tole(0xd130810aL), 
+tole(0xccd53183L), tole(0xa4d61d4bL), tole(0x1cd36813L), tole(0x74d044dbL), 
+tole(0x27180901L), tole(0x4f1b25c9L), tole(0xf71e5091L), tole(0x9f1d7c59L), 
+tole(0x82f8ccd0L), tole(0xeafbe018L), tole(0x52fe9540L), tole(0x3afdb988L), 
+tole(0xc8358d49L), tole(0xa036a181L), tole(0x1833d4d9L), tole(0x7030f811L), 
+tole(0x6dd54898L), tole(0x05d66450L), tole(0xbdd31108L), tole(0xd5d03dc0L), 
+tole(0x8618701aL), tole(0xee1b5cd2L), tole(0x561e298aL), tole(0x3e1d0542L), 
+tole(0x23f8b5cbL), tole(0x4bfb9903L), tole(0xf3feec5bL), tole(0x9bfdc093L), 
+tole(0x546e77efL), tole(0x3c6d5b27L), tole(0x84682e7fL), tole(0xec6b02b7L), 
+tole(0xf18eb23eL), tole(0x998d9ef6L), tole(0x2188ebaeL), tole(0x498bc766L), 
+tole(0x1a438abcL), tole(0x7240a674L), tole(0xca45d32cL), tole(0xa246ffe4L), 
+tole(0xbfa34f6dL), tole(0xd7a063a5L), tole(0x6fa516fdL), tole(0x07a63a35L), 
+tole(0x8fd9098eL), tole(0xe7da2546L), tole(0x5fdf501eL), tole(0x37dc7cd6L), 
+tole(0x2a39cc5fL), tole(0x423ae097L), tole(0xfa3f95cfL), tole(0x923cb907L), 
+tole(0xc1f4f4ddL), tole(0xa9f7d815L), tole(0x11f2ad4dL), tole(0x79f18185L), 
+tole(0x6414310cL), tole(0x0c171dc4L), tole(0xb412689cL), tole(0xdc114454L), 
+tole(0x1382f328L), tole(0x7b81dfe0L), tole(0xc384aab8L), tole(0xab878670L), 
+tole(0xb66236f9L), tole(0xde611a31L), tole(0x66646f69L), tole(0x0e6743a1L), 
+tole(0x5daf0e7bL), tole(0x35ac22b3L), tole(0x8da957ebL), tole(0xe5aa7b23L), 
+tole(0xf84fcbaaL), tole(0x904ce762L), tole(0x2849923aL), tole(0x404abef2L), 
+tole(0xb2828a33L), tole(0xda81a6fbL), tole(0x6284d3a3L), tole(0x0a87ff6bL), 
+tole(0x17624fe2L), tole(0x7f61632aL), tole(0xc7641672L), tole(0xaf673abaL), 
+tole(0xfcaf7760L), tole(0x94ac5ba8L), tole(0x2ca92ef0L), tole(0x44aa0238L), 
+tole(0x594fb2b1L), tole(0x314c9e79L), tole(0x8949eb21L), tole(0xe14ac7e9L), 
+tole(0x2ed97095L), tole(0x46da5c5dL), tole(0xfedf2905L), tole(0x96dc05cdL), 
+tole(0x8b39b544L), tole(0xe33a998cL), tole(0x5b3fecd4L), tole(0x333cc01cL), 
+tole(0x60f48dc6L), tole(0x08f7a10eL), tole(0xb0f2d456L), tole(0xd8f1f89eL), 
+tole(0xc5144817L), tole(0xad1764dfL), tole(0x15121187L), tole(0x7d113d4fL)},
+{
+tole(0x00000000L), tole(0x493c7d27L), tole(0x9278fa4eL), tole(0xdb448769L), 
+tole(0x211d826dL), tole(0x6821ff4aL), tole(0xb3657823L), tole(0xfa590504L), 
+tole(0x423b04daL), tole(0x0b0779fdL), tole(0xd043fe94L), tole(0x997f83b3L), 
+tole(0x632686b7L), tole(0x2a1afb90L), tole(0xf15e7cf9L), tole(0xb86201deL), 
+tole(0x847609b4L), tole(0xcd4a7493L), tole(0x160ef3faL), tole(0x5f328eddL), 
+tole(0xa56b8bd9L), tole(0xec57f6feL), tole(0x37137197L), tole(0x7e2f0cb0L), 
+tole(0xc64d0d6eL), tole(0x8f717049L), tole(0x5435f720L), tole(0x1d098a07L), 
+tole(0xe7508f03L), tole(0xae6cf224L), tole(0x7528754dL), tole(0x3c14086aL), 
+tole(0x0d006599L), tole(0x443c18beL), tole(0x9f789fd7L), tole(0xd644e2f0L), 
+tole(0x2c1de7f4L), tole(0x65219ad3L), tole(0xbe651dbaL), tole(0xf759609dL), 
+tole(0x4f3b6143L), tole(0x06071c64L), tole(0xdd439b0dL), tole(0x947fe62aL), 
+tole(0x6e26e32eL), tole(0x271a9e09L), tole(0xfc5e1960L), tole(0xb5626447L), 
+tole(0x89766c2dL), tole(0xc04a110aL), tole(0x1b0e9663L), tole(0x5232eb44L), 
+tole(0xa86bee40L), tole(0xe1579367L), tole(0x3a13140eL), tole(0x732f6929L), 
+tole(0xcb4d68f7L), tole(0x827115d0L), tole(0x593592b9L), tole(0x1009ef9eL), 
+tole(0xea50ea9aL), tole(0xa36c97bdL), tole(0x782810d4L), tole(0x31146df3L), 
+tole(0x1a00cb32L), tole(0x533cb615L), tole(0x8878317cL), tole(0xc1444c5bL), 
+tole(0x3b1d495fL), tole(0x72213478L), tole(0xa965b311L), tole(0xe059ce36L), 
+tole(0x583bcfe8L), tole(0x1107b2cfL), tole(0xca4335a6L), tole(0x837f4881L), 
+tole(0x79264d85L), tole(0x301a30a2L), tole(0xeb5eb7cbL), tole(0xa262caecL), 
+tole(0x9e76c286L), tole(0xd74abfa1L), tole(0x0c0e38c8L), tole(0x453245efL), 
+tole(0xbf6b40ebL), tole(0xf6573dccL), tole(0x2d13baa5L), tole(0x642fc782L), 
+tole(0xdc4dc65cL), tole(0x9571bb7bL), tole(0x4e353c12L), tole(0x07094135L), 
+tole(0xfd504431L), tole(0xb46c3916L), tole(0x6f28be7fL), tole(0x2614c358L), 
+tole(0x1700aeabL), tole(0x5e3cd38cL), tole(0x857854e5L), tole(0xcc4429c2L), 
+tole(0x361d2cc6L), tole(0x7f2151e1L), tole(0xa465d688L), tole(0xed59abafL), 
+tole(0x553baa71L), tole(0x1c07d756L), tole(0xc743503fL), tole(0x8e7f2d18L), 
+tole(0x7426281cL), tole(0x3d1a553bL), tole(0xe65ed252L), tole(0xaf62af75L), 
+tole(0x9376a71fL), tole(0xda4ada38L), tole(0x010e5d51L), tole(0x48322076L), 
+tole(0xb26b2572L), tole(0xfb575855L), tole(0x2013df3cL), tole(0x692fa21bL), 
+tole(0xd14da3c5L), tole(0x9871dee2L), tole(0x4335598bL), tole(0x0a0924acL), 
+tole(0xf05021a8L), tole(0xb96c5c8fL), tole(0x6228dbe6L), tole(0x2b14a6c1L), 
+tole(0x34019664L), tole(0x7d3deb43L), tole(0xa6796c2aL), tole(0xef45110dL), 
+tole(0x151c1409L), tole(0x5c20692eL), tole(0x8764ee47L), tole(0xce589360L), 
+tole(0x763a92beL), tole(0x3f06ef99L), tole(0xe44268f0L), tole(0xad7e15d7L), 
+tole(0x572710d3L), tole(0x1e1b6df4L), tole(0xc55fea9dL), tole(0x8c6397baL), 
+tole(0xb0779fd0L), tole(0xf94be2f7L), tole(0x220f659eL), tole(0x6b3318b9L), 
+tole(0x916a1dbdL), tole(0xd856609aL), tole(0x0312e7f3L), tole(0x4a2e9ad4L), 
+tole(0xf24c9b0aL), tole(0xbb70e62dL), tole(0x60346144L), tole(0x29081c63L), 
+tole(0xd3511967L), tole(0x9a6d6440L), tole(0x4129e329L), tole(0x08159e0eL), 
+tole(0x3901f3fdL), tole(0x703d8edaL), tole(0xab7909b3L), tole(0xe2457494L), 
+tole(0x181c7190L), tole(0x51200cb7L), tole(0x8a648bdeL), tole(0xc358f6f9L), 
+tole(0x7b3af727L), tole(0x32068a00L), tole(0xe9420d69L), tole(0xa07e704eL), 
+tole(0x5a27754aL), tole(0x131b086dL), tole(0xc85f8f04L), tole(0x8163f223L), 
+tole(0xbd77fa49L), tole(0xf44b876eL), tole(0x2f0f0007L), tole(0x66337d20L), 
+tole(0x9c6a7824L), tole(0xd5560503L), tole(0x0e12826aL), tole(0x472eff4dL), 
+tole(0xff4cfe93L), tole(0xb67083b4L), tole(0x6d3404ddL), tole(0x240879faL), 
+tole(0xde517cfeL), tole(0x976d01d9L), tole(0x4c2986b0L), tole(0x0515fb97L), 
+tole(0x2e015d56L), tole(0x673d2071L), tole(0xbc79a718L), tole(0xf545da3fL), 
+tole(0x0f1cdf3bL), tole(0x4620a21cL), tole(0x9d642575L), tole(0xd4585852L), 
+tole(0x6c3a598cL), tole(0x250624abL), tole(0xfe42a3c2L), tole(0xb77edee5L), 
+tole(0x4d27dbe1L), tole(0x041ba6c6L), tole(0xdf5f21afL), tole(0x96635c88L), 
+tole(0xaa7754e2L), tole(0xe34b29c5L), tole(0x380faeacL), tole(0x7133d38bL), 
+tole(0x8b6ad68fL), tole(0xc256aba8L), tole(0x19122cc1L), tole(0x502e51e6L), 
+tole(0xe84c5038L), tole(0xa1702d1fL), tole(0x7a34aa76L), tole(0x3308d751L), 
+tole(0xc951d255L), tole(0x806daf72L), tole(0x5b29281bL), tole(0x1215553cL), 
+tole(0x230138cfL), tole(0x6a3d45e8L), tole(0xb179c281L), tole(0xf845bfa6L), 
+tole(0x021cbaa2L), tole(0x4b20c785L), tole(0x906440ecL), tole(0xd9583dcbL), 
+tole(0x613a3c15L), tole(0x28064132L), tole(0xf342c65bL), tole(0xba7ebb7cL), 
+tole(0x4027be78L), tole(0x091bc35fL), tole(0xd25f4436L), tole(0x9b633911L), 
+tole(0xa777317bL), tole(0xee4b4c5cL), tole(0x350fcb35L), tole(0x7c33b612L), 
+tole(0x866ab316L), tole(0xcf56ce31L), tole(0x14124958L), tole(0x5d2e347fL), 
+tole(0xe54c35a1L), tole(0xac704886L), tole(0x7734cfefL), tole(0x3e08b2c8L), 
+tole(0xc451b7ccL), tole(0x8d6dcaebL), tole(0x56294d82L), tole(0x1f1530a5L)},
+};
diff --git a/external/e2fsprogs/lib/ext2fs/ext2_err.c b/external/e2fsprogs/lib/ext2fs/ext2_err.c
new file mode 100644
index 0000000000..d3937010ef
--- /dev/null
+++ b/external/e2fsprogs/lib/ext2fs/ext2_err.c
@@ -0,0 +1,233 @@
+/*
+ * ext2_err.c:
+ * This file is automatically generated; please do not edit it.
+ */
+
+#include <stdlib.h>
+
+#define N_(a) a
+
+static const char * const text[] = {
+	N_(	"EXT2FS Library version v1.44.3-rc1-845-g7e9e2ca4"),
+	N_(	"Wrong magic number for ext2_filsys structure"),
+	N_(	"Wrong magic number for badblocks_list structure"),
+	N_(	"Wrong magic number for badblocks_iterate structure"),
+	N_(	"Wrong magic number for inode_scan structure"),
+	N_(	"Wrong magic number for io_channel structure"),
+	N_(	"Wrong magic number for unix io_channel structure"),
+	N_(	"Wrong magic number for io_manager structure"),
+	N_(	"Wrong magic number for block_bitmap structure"),
+	N_(	"Wrong magic number for inode_bitmap structure"),
+	N_(	"Wrong magic number for generic_bitmap structure"),
+	N_(	"Wrong magic number for test io_channel structure"),
+	N_(	"Wrong magic number for directory block list structure"),
+	N_(	"Wrong magic number for icount structure"),
+	N_(	"Wrong magic number for Powerquest io_channel structure"),
+	N_(	"Wrong magic number for ext2 file structure"),
+	N_(	"Wrong magic number for Ext2 Image Header"),
+	N_(	"Wrong magic number for inode io_channel structure"),
+	N_(	"Wrong magic number for ext4 extent handle"),
+	N_(	"Bad magic number in super-block"),
+	N_(	"Filesystem revision too high"),
+	N_(	"Attempt to write to filesystem opened read-only"),
+	N_(	"Can't read group descriptors"),
+	N_(	"Can't write group descriptors"),
+	N_(	"Corrupt group descriptor: bad block for block bitmap"),
+	N_(	"Corrupt group descriptor: bad block for inode bitmap"),
+	N_(	"Corrupt group descriptor: bad block for inode table"),
+	N_(	"Can't write an inode bitmap"),
+	N_(	"Can't read an inode bitmap"),
+	N_(	"Can't write a block bitmap"),
+	N_(	"Can't read a block bitmap"),
+	N_(	"Can't write an inode table"),
+	N_(	"Can't read an inode table"),
+	N_(	"Can't read next inode"),
+	N_(	"Filesystem has unexpected block size"),
+	N_(	"EXT2 directory corrupted"),
+	N_(	"Attempt to read block from filesystem resulted in short read"),
+	N_(	"Attempt to write block to filesystem resulted in short write"),
+	N_(	"No free space in the directory"),
+	N_(	"Inode bitmap not loaded"),
+	N_(	"Block bitmap not loaded"),
+	N_(	"Illegal inode number"),
+	N_(	"Illegal block number"),
+	N_(	"Internal error in ext2fs_expand_dir"),
+	N_(	"Not enough space to build proposed filesystem"),
+	N_(	"Illegal block number passed to ext2fs_mark_block_bitmap"),
+	N_(	"Illegal block number passed to ext2fs_unmark_block_bitmap"),
+	N_(	"Illegal block number passed to ext2fs_test_block_bitmap"),
+	N_(	"Illegal inode number passed to ext2fs_mark_inode_bitmap"),
+	N_(	"Illegal inode number passed to ext2fs_unmark_inode_bitmap"),
+	N_(	"Illegal inode number passed to ext2fs_test_inode_bitmap"),
+	N_(	"Attempt to fudge end of block bitmap past the real end"),
+	N_(	"Attempt to fudge end of inode bitmap past the real end"),
+	N_(	"Illegal indirect block found" ),
+	N_(	"Illegal doubly indirect block found" ),
+	N_(	"Illegal triply indirect block found" ),
+	N_(	"Block bitmaps are not the same"),
+	N_(	"Inode bitmaps are not the same"),
+	N_(	"Illegal or malformed device name"),
+	N_(	"A block group is missing an inode table"),
+	N_(	"The ext2 superblock is corrupt"),
+	N_(	"Illegal generic bit number passed to ext2fs_mark_generic_bitmap"),
+	N_(	"Illegal generic bit number passed to ext2fs_unmark_generic_bitmap"),
+	N_(	"Illegal generic bit number passed to ext2fs_test_generic_bitmap"),
+	N_(	"Too many symbolic links encountered."),
+	N_(	"The callback function will not handle this case"),
+	N_(	"The inode is from a bad block in the inode table"),
+	N_(	"Filesystem has unsupported feature(s)"),
+	N_(	"Filesystem has unsupported read-only feature(s)"),
+	N_(	"IO Channel failed to seek on read or write"),
+	N_(	"Memory allocation failed"),
+	N_(	"Invalid argument passed to ext2 library"),
+	N_(	"Could not allocate block in ext2 filesystem"),
+	N_(	"Could not allocate inode in ext2 filesystem"),
+	N_(	"Ext2 inode is not a directory"),
+	N_(	"Too many references in table"),
+	N_(	"File not found by ext2_lookup"),
+	N_(	"File open read-only"),
+	N_(	"Ext2 directory block not found"),
+	N_(	"Ext2 directory already exists"),
+	N_(	"Unimplemented ext2 library function"),
+	N_(	"User cancel requested"),
+	N_(	"Ext2 file too big"),
+	N_(	"Supplied journal device not a block device"),
+	N_(	"Journal superblock not found"),
+	N_(	"Journal must be at least 1024 blocks"),
+	N_(	"Unsupported journal version"),
+	N_(	"Error loading external journal"),
+	N_(	"Journal not found"),
+	N_(	"Directory hash unsupported"),
+	N_(	"Illegal extended attribute block number"),
+	N_(	"Cannot create filesystem with requested number of inodes"),
+	N_(	"E2image snapshot not in use"),
+	N_(	"Too many reserved group descriptor blocks"),
+	N_(	"Resize inode is corrupt"),
+	N_(	"Tried to set block bmap with missing indirect block"),
+	N_(	"TDB: Success"),
+	N_(	"TDB: Corrupt database"),
+	N_(	"TDB: IO Error"),
+	N_(	"TDB: Locking error"),
+	N_(	"TDB: Out of memory"),
+	N_(	"TDB: Record exists"),
+	N_(	"TDB: Lock exists on other keys"),
+	N_(	"TDB: Invalid parameter"),
+	N_(	"TDB: Record does not exist"),
+	N_(	"TDB: Write not permitted"),
+	N_(	"Ext2fs directory block list is empty"),
+	N_(	"Attempt to modify a block mapping via a read-only block iterator"),
+	N_(	"Wrong magic number for ext4 extent saved path"),
+	N_(	"Wrong magic number for 64-bit generic bitmap"),
+	N_(	"Wrong magic number for 64-bit block bitmap"),
+	N_(	"Wrong magic number for 64-bit inode bitmap"),
+	N_(	"Wrong magic number --- RESERVED_13"),
+	N_(	"Wrong magic number --- RESERVED_14"),
+	N_(	"Wrong magic number --- RESERVED_15"),
+	N_(	"Wrong magic number --- RESERVED_16"),
+	N_(	"Wrong magic number --- RESERVED_17"),
+	N_(	"Wrong magic number --- RESERVED_18"),
+	N_(	"Wrong magic number --- RESERVED_19"),
+	N_(	"Corrupt extent header"),
+	N_(	"Corrupt extent index"),
+	N_(	"Corrupt extent"),
+	N_(	"No free space in extent map"),
+	N_(	"Inode does not use extents"),
+	N_(	"No 'next' extent"),
+	N_(	"No 'previous' extent"),
+	N_(	"No 'up' extent"),
+	N_(	"No 'down' extent"),
+	N_(	"No current node"),
+	N_(	"Ext2fs operation not supported"),
+	N_(	"No room to insert extent in node"),
+	N_(	"Splitting would result in empty node"),
+	N_(	"Extent not found"),
+	N_(	"Operation not supported for inodes containing extents"),
+	N_(	"Extent length is invalid"),
+	N_(	"I/O Channel does not support 64-bit block numbers"),
+	N_(	"Can't check if filesystem is mounted due to missing mtab file"),
+	N_(	"Filesystem too large to use legacy bitmaps"),
+	N_(	"MMP: invalid magic number"),
+	N_(	"MMP: device currently active"),
+	N_(	"MMP: e2fsck being run"),
+	N_(	"MMP: block number beyond filesystem range"),
+	N_(	"MMP: undergoing an unknown operation"),
+	N_(	"MMP: filesystem still in use"),
+	N_(	"MMP: open with O_DIRECT failed"),
+	N_(	"Block group descriptor size incorrect"),
+	N_(	"Inode checksum does not match inode"),
+	N_(	"Inode bitmap checksum does not match bitmap"),
+	N_(	"Extent block checksum does not match extent block"),
+	N_(	"Directory block does not have space for checksum"),
+	N_(	"Directory block checksum does not match directory block"),
+	N_(	"Extended attribute block checksum does not match block"),
+	N_(	"Superblock checksum does not match superblock"),
+	N_(	"Unknown checksum algorithm"),
+	N_(	"MMP block checksum does not match"),
+	N_(	"Ext2 file already exists"),
+	N_(	"Block bitmap checksum does not match bitmap"),
+	N_(	"Cannot iterate data blocks of an inode containing inline data"),
+	N_(	"Extended attribute has an invalid name length"),
+	N_(	"Extended attribute has an invalid value length"),
+	N_(	"Extended attribute has an incorrect hash"),
+	N_(	"Extended attribute block has a bad header"),
+	N_(	"Extended attribute key not found"),
+	N_(	"Insufficient space to store extended attribute data"),
+	N_(	"Filesystem is missing ext_attr or inline_data feature"),
+	N_(	"Inode doesn't have inline data"),
+	N_(	"No block for an inode with inline data"),
+	N_(	"No free space in inline data"),
+	N_(	"Wrong magic number for extended attribute structure"),
+	N_(	"Inode seems to contain garbage"),
+	N_(	"Extended attribute has an invalid value offset"),
+	N_(	"Journal flags inconsistent"),
+	N_(	"Undo file corrupt"),
+	N_(	"Wrong undo file for this filesystem"),
+	N_(	"File system is corrupted"),
+	N_(	"Bad CRC detected in file system"),
+	N_(	"The journal superblock is corrupt"),
+	N_(	"Inode is corrupted"),
+	N_(	"Inode containing extended attribute value is corrupted"),
+    0
+};
+
+struct error_table {
+    char const * const * msgs;
+    long base;
+    int n_msgs;
+};
+struct et_list {
+    struct et_list *next;
+    const struct error_table * table;
+};
+extern struct et_list *_et_list;
+
+const struct error_table et_ext2_error_table = { text, 2133571328L, 179 };
+
+static struct et_list link = { 0, 0 };
+
+void initialize_ext2_error_table_r(struct et_list **list);
+void initialize_ext2_error_table(void);
+
+void initialize_ext2_error_table(void) {
+    initialize_ext2_error_table_r(&_et_list);
+}
+
+/* For Heimdal compatibility */
+void initialize_ext2_error_table_r(struct et_list **list)
+{
+    struct et_list *et, **end;
+
+    for (end = list, et = *list; et; end = &et->next, et = et->next)
+        if (et->table->msgs == text)
+            return;
+    et = malloc(sizeof(struct et_list));
+    if (et == 0) {
+        if (!link.table)
+            et = &link;
+        else
+            return;
+    }
+    et->table = &et_ext2_error_table;
+    et->next = 0;
+    *end = et;
+}
diff --git a/external/e2fsprogs/lib/ext2fs/ext2_err.h b/external/e2fsprogs/lib/ext2fs/ext2_err.h
new file mode 100644
index 0000000000..b1c83e18af
--- /dev/null
+++ b/external/e2fsprogs/lib/ext2fs/ext2_err.h
@@ -0,0 +1,197 @@
+/*
+ * ext2_err.h:
+ * This file is automatically generated; please do not edit it.
+ */
+
+#include <et/com_err.h>
+
+#define EXT2_ET_BASE                             (2133571328L)
+#define EXT2_ET_MAGIC_EXT2FS_FILSYS              (2133571329L)
+#define EXT2_ET_MAGIC_BADBLOCKS_LIST             (2133571330L)
+#define EXT2_ET_MAGIC_BADBLOCKS_ITERATE          (2133571331L)
+#define EXT2_ET_MAGIC_INODE_SCAN                 (2133571332L)
+#define EXT2_ET_MAGIC_IO_CHANNEL                 (2133571333L)
+#define EXT2_ET_MAGIC_UNIX_IO_CHANNEL            (2133571334L)
+#define EXT2_ET_MAGIC_IO_MANAGER                 (2133571335L)
+#define EXT2_ET_MAGIC_BLOCK_BITMAP               (2133571336L)
+#define EXT2_ET_MAGIC_INODE_BITMAP               (2133571337L)
+#define EXT2_ET_MAGIC_GENERIC_BITMAP             (2133571338L)
+#define EXT2_ET_MAGIC_TEST_IO_CHANNEL            (2133571339L)
+#define EXT2_ET_MAGIC_DBLIST                     (2133571340L)
+#define EXT2_ET_MAGIC_ICOUNT                     (2133571341L)
+#define EXT2_ET_MAGIC_PQ_IO_CHANNEL              (2133571342L)
+#define EXT2_ET_MAGIC_EXT2_FILE                  (2133571343L)
+#define EXT2_ET_MAGIC_E2IMAGE                    (2133571344L)
+#define EXT2_ET_MAGIC_INODE_IO_CHANNEL           (2133571345L)
+#define EXT2_ET_MAGIC_EXTENT_HANDLE              (2133571346L)
+#define EXT2_ET_BAD_MAGIC                        (2133571347L)
+#define EXT2_ET_REV_TOO_HIGH                     (2133571348L)
+#define EXT2_ET_RO_FILSYS                        (2133571349L)
+#define EXT2_ET_GDESC_READ                       (2133571350L)
+#define EXT2_ET_GDESC_WRITE                      (2133571351L)
+#define EXT2_ET_GDESC_BAD_BLOCK_MAP              (2133571352L)
+#define EXT2_ET_GDESC_BAD_INODE_MAP              (2133571353L)
+#define EXT2_ET_GDESC_BAD_INODE_TABLE            (2133571354L)
+#define EXT2_ET_INODE_BITMAP_WRITE               (2133571355L)
+#define EXT2_ET_INODE_BITMAP_READ                (2133571356L)
+#define EXT2_ET_BLOCK_BITMAP_WRITE               (2133571357L)
+#define EXT2_ET_BLOCK_BITMAP_READ                (2133571358L)
+#define EXT2_ET_INODE_TABLE_WRITE                (2133571359L)
+#define EXT2_ET_INODE_TABLE_READ                 (2133571360L)
+#define EXT2_ET_NEXT_INODE_READ                  (2133571361L)
+#define EXT2_ET_UNEXPECTED_BLOCK_SIZE            (2133571362L)
+#define EXT2_ET_DIR_CORRUPTED                    (2133571363L)
+#define EXT2_ET_SHORT_READ                       (2133571364L)
+#define EXT2_ET_SHORT_WRITE                      (2133571365L)
+#define EXT2_ET_DIR_NO_SPACE                     (2133571366L)
+#define EXT2_ET_NO_INODE_BITMAP                  (2133571367L)
+#define EXT2_ET_NO_BLOCK_BITMAP                  (2133571368L)
+#define EXT2_ET_BAD_INODE_NUM                    (2133571369L)
+#define EXT2_ET_BAD_BLOCK_NUM                    (2133571370L)
+#define EXT2_ET_EXPAND_DIR_ERR                   (2133571371L)
+#define EXT2_ET_TOOSMALL                         (2133571372L)
+#define EXT2_ET_BAD_BLOCK_MARK                   (2133571373L)
+#define EXT2_ET_BAD_BLOCK_UNMARK                 (2133571374L)
+#define EXT2_ET_BAD_BLOCK_TEST                   (2133571375L)
+#define EXT2_ET_BAD_INODE_MARK                   (2133571376L)
+#define EXT2_ET_BAD_INODE_UNMARK                 (2133571377L)
+#define EXT2_ET_BAD_INODE_TEST                   (2133571378L)
+#define EXT2_ET_FUDGE_BLOCK_BITMAP_END           (2133571379L)
+#define EXT2_ET_FUDGE_INODE_BITMAP_END           (2133571380L)
+#define EXT2_ET_BAD_IND_BLOCK                    (2133571381L)
+#define EXT2_ET_BAD_DIND_BLOCK                   (2133571382L)
+#define EXT2_ET_BAD_TIND_BLOCK                   (2133571383L)
+#define EXT2_ET_NEQ_BLOCK_BITMAP                 (2133571384L)
+#define EXT2_ET_NEQ_INODE_BITMAP                 (2133571385L)
+#define EXT2_ET_BAD_DEVICE_NAME                  (2133571386L)
+#define EXT2_ET_MISSING_INODE_TABLE              (2133571387L)
+#define EXT2_ET_CORRUPT_SUPERBLOCK               (2133571388L)
+#define EXT2_ET_BAD_GENERIC_MARK                 (2133571389L)
+#define EXT2_ET_BAD_GENERIC_UNMARK               (2133571390L)
+#define EXT2_ET_BAD_GENERIC_TEST                 (2133571391L)
+#define EXT2_ET_SYMLINK_LOOP                     (2133571392L)
+#define EXT2_ET_CALLBACK_NOTHANDLED              (2133571393L)
+#define EXT2_ET_BAD_BLOCK_IN_INODE_TABLE         (2133571394L)
+#define EXT2_ET_UNSUPP_FEATURE                   (2133571395L)
+#define EXT2_ET_RO_UNSUPP_FEATURE                (2133571396L)
+#define EXT2_ET_LLSEEK_FAILED                    (2133571397L)
+#define EXT2_ET_NO_MEMORY                        (2133571398L)
+#define EXT2_ET_INVALID_ARGUMENT                 (2133571399L)
+#define EXT2_ET_BLOCK_ALLOC_FAIL                 (2133571400L)
+#define EXT2_ET_INODE_ALLOC_FAIL                 (2133571401L)
+#define EXT2_ET_NO_DIRECTORY                     (2133571402L)
+#define EXT2_ET_TOO_MANY_REFS                    (2133571403L)
+#define EXT2_ET_FILE_NOT_FOUND                   (2133571404L)
+#define EXT2_ET_FILE_RO                          (2133571405L)
+#define EXT2_ET_DB_NOT_FOUND                     (2133571406L)
+#define EXT2_ET_DIR_EXISTS                       (2133571407L)
+#define EXT2_ET_UNIMPLEMENTED                    (2133571408L)
+#define EXT2_ET_CANCEL_REQUESTED                 (2133571409L)
+#define EXT2_ET_FILE_TOO_BIG                     (2133571410L)
+#define EXT2_ET_JOURNAL_NOT_BLOCK                (2133571411L)
+#define EXT2_ET_NO_JOURNAL_SB                    (2133571412L)
+#define EXT2_ET_JOURNAL_TOO_SMALL                (2133571413L)
+#define EXT2_ET_JOURNAL_UNSUPP_VERSION           (2133571414L)
+#define EXT2_ET_LOAD_EXT_JOURNAL                 (2133571415L)
+#define EXT2_ET_NO_JOURNAL                       (2133571416L)
+#define EXT2_ET_DIRHASH_UNSUPP                   (2133571417L)
+#define EXT2_ET_BAD_EA_BLOCK_NUM                 (2133571418L)
+#define EXT2_ET_TOO_MANY_INODES                  (2133571419L)
+#define EXT2_ET_NOT_IMAGE_FILE                   (2133571420L)
+#define EXT2_ET_RES_GDT_BLOCKS                   (2133571421L)
+#define EXT2_ET_RESIZE_INODE_CORRUPT             (2133571422L)
+#define EXT2_ET_SET_BMAP_NO_IND                  (2133571423L)
+#define EXT2_ET_TDB_SUCCESS                      (2133571424L)
+#define EXT2_ET_TDB_ERR_CORRUPT                  (2133571425L)
+#define EXT2_ET_TDB_ERR_IO                       (2133571426L)
+#define EXT2_ET_TDB_ERR_LOCK                     (2133571427L)
+#define EXT2_ET_TDB_ERR_OOM                      (2133571428L)
+#define EXT2_ET_TDB_ERR_EXISTS                   (2133571429L)
+#define EXT2_ET_TDB_ERR_NOLOCK                   (2133571430L)
+#define EXT2_ET_TDB_ERR_EINVAL                   (2133571431L)
+#define EXT2_ET_TDB_ERR_NOEXIST                  (2133571432L)
+#define EXT2_ET_TDB_ERR_RDONLY                   (2133571433L)
+#define EXT2_ET_DBLIST_EMPTY                     (2133571434L)
+#define EXT2_ET_RO_BLOCK_ITERATE                 (2133571435L)
+#define EXT2_ET_MAGIC_EXTENT_PATH                (2133571436L)
+#define EXT2_ET_MAGIC_GENERIC_BITMAP64           (2133571437L)
+#define EXT2_ET_MAGIC_BLOCK_BITMAP64             (2133571438L)
+#define EXT2_ET_MAGIC_INODE_BITMAP64             (2133571439L)
+#define EXT2_ET_MAGIC_RESERVED_13                (2133571440L)
+#define EXT2_ET_MAGIC_RESERVED_14                (2133571441L)
+#define EXT2_ET_MAGIC_RESERVED_15                (2133571442L)
+#define EXT2_ET_MAGIC_RESERVED_16                (2133571443L)
+#define EXT2_ET_MAGIC_RESERVED_17                (2133571444L)
+#define EXT2_ET_MAGIC_RESERVED_18                (2133571445L)
+#define EXT2_ET_MAGIC_RESERVED_19                (2133571446L)
+#define EXT2_ET_EXTENT_HEADER_BAD                (2133571447L)
+#define EXT2_ET_EXTENT_INDEX_BAD                 (2133571448L)
+#define EXT2_ET_EXTENT_LEAF_BAD                  (2133571449L)
+#define EXT2_ET_EXTENT_NO_SPACE                  (2133571450L)
+#define EXT2_ET_INODE_NOT_EXTENT                 (2133571451L)
+#define EXT2_ET_EXTENT_NO_NEXT                   (2133571452L)
+#define EXT2_ET_EXTENT_NO_PREV                   (2133571453L)
+#define EXT2_ET_EXTENT_NO_UP                     (2133571454L)
+#define EXT2_ET_EXTENT_NO_DOWN                   (2133571455L)
+#define EXT2_ET_NO_CURRENT_NODE                  (2133571456L)
+#define EXT2_ET_OP_NOT_SUPPORTED                 (2133571457L)
+#define EXT2_ET_CANT_INSERT_EXTENT               (2133571458L)
+#define EXT2_ET_CANT_SPLIT_EXTENT                (2133571459L)
+#define EXT2_ET_EXTENT_NOT_FOUND                 (2133571460L)
+#define EXT2_ET_EXTENT_NOT_SUPPORTED             (2133571461L)
+#define EXT2_ET_EXTENT_INVALID_LENGTH            (2133571462L)
+#define EXT2_ET_IO_CHANNEL_NO_SUPPORT_64         (2133571463L)
+#define EXT2_ET_NO_MTAB_FILE                     (2133571464L)
+#define EXT2_ET_CANT_USE_LEGACY_BITMAPS          (2133571465L)
+#define EXT2_ET_MMP_MAGIC_INVALID                (2133571466L)
+#define EXT2_ET_MMP_FAILED                       (2133571467L)
+#define EXT2_ET_MMP_FSCK_ON                      (2133571468L)
+#define EXT2_ET_MMP_BAD_BLOCK                    (2133571469L)
+#define EXT2_ET_MMP_UNKNOWN_SEQ                  (2133571470L)
+#define EXT2_ET_MMP_CHANGE_ABORT                 (2133571471L)
+#define EXT2_ET_MMP_OPEN_DIRECT                  (2133571472L)
+#define EXT2_ET_BAD_DESC_SIZE                    (2133571473L)
+#define EXT2_ET_INODE_CSUM_INVALID               (2133571474L)
+#define EXT2_ET_INODE_BITMAP_CSUM_INVALID        (2133571475L)
+#define EXT2_ET_EXTENT_CSUM_INVALID              (2133571476L)
+#define EXT2_ET_DIR_NO_SPACE_FOR_CSUM            (2133571477L)
+#define EXT2_ET_DIR_CSUM_INVALID                 (2133571478L)
+#define EXT2_ET_EXT_ATTR_CSUM_INVALID            (2133571479L)
+#define EXT2_ET_SB_CSUM_INVALID                  (2133571480L)
+#define EXT2_ET_UNKNOWN_CSUM                     (2133571481L)
+#define EXT2_ET_MMP_CSUM_INVALID                 (2133571482L)
+#define EXT2_ET_FILE_EXISTS                      (2133571483L)
+#define EXT2_ET_BLOCK_BITMAP_CSUM_INVALID        (2133571484L)
+#define EXT2_ET_INLINE_DATA_CANT_ITERATE         (2133571485L)
+#define EXT2_ET_EA_BAD_NAME_LEN                  (2133571486L)
+#define EXT2_ET_EA_BAD_VALUE_SIZE                (2133571487L)
+#define EXT2_ET_BAD_EA_HASH                      (2133571488L)
+#define EXT2_ET_BAD_EA_HEADER                    (2133571489L)
+#define EXT2_ET_EA_KEY_NOT_FOUND                 (2133571490L)
+#define EXT2_ET_EA_NO_SPACE                      (2133571491L)
+#define EXT2_ET_MISSING_EA_FEATURE               (2133571492L)
+#define EXT2_ET_NO_INLINE_DATA                   (2133571493L)
+#define EXT2_ET_INLINE_DATA_NO_BLOCK             (2133571494L)
+#define EXT2_ET_INLINE_DATA_NO_SPACE             (2133571495L)
+#define EXT2_ET_MAGIC_EA_HANDLE                  (2133571496L)
+#define EXT2_ET_INODE_IS_GARBAGE                 (2133571497L)
+#define EXT2_ET_EA_BAD_VALUE_OFFSET              (2133571498L)
+#define EXT2_ET_JOURNAL_FLAGS_WRONG              (2133571499L)
+#define EXT2_ET_UNDO_FILE_CORRUPT                (2133571500L)
+#define EXT2_ET_UNDO_FILE_WRONG                  (2133571501L)
+#define EXT2_ET_FILESYSTEM_CORRUPTED             (2133571502L)
+#define EXT2_ET_BAD_CRC                          (2133571503L)
+#define EXT2_ET_CORRUPT_JOURNAL_SB               (2133571504L)
+#define EXT2_ET_INODE_CORRUPTED                  (2133571505L)
+#define EXT2_ET_EA_INODE_CORRUPTED               (2133571506L)
+extern const struct error_table et_ext2_error_table;
+extern void initialize_ext2_error_table(void);
+
+/* For compatibility with Heimdal */
+extern void initialize_ext2_error_table_r(struct et_list **list);
+
+#define ERROR_TABLE_BASE_ext2 (2133571328L)
+
+/* for compatibility with older versions... */
+#define init_ext2_err_tbl initialize_ext2_error_table
+#define ext2_err_base ERROR_TABLE_BASE_ext2
diff --git a/external/e2fsprogs/lib/ext2fs/ext2_types.h b/external/e2fsprogs/lib/ext2fs/ext2_types.h
new file mode 100644
index 0000000000..a8d7cff1fa
--- /dev/null
+++ b/external/e2fsprogs/lib/ext2fs/ext2_types.h
@@ -0,0 +1,45 @@
+/* 
+ * If linux/types.h is already been included, assume it has defined
+ * everything we need.  (cross fingers)  Other header files may have
+ * also defined the types that we need.
+ */
+#if (!defined(_LINUX_TYPES_H) && !defined(_BLKID_TYPES_H) && \
+	!defined(_EXT2_TYPES_H))
+#define _EXT2_TYPES_H
+
+typedef unsigned char __u8;
+typedef __signed__ char __s8;
+typedef unsigned short __u16;
+typedef __signed__ short __s16;
+typedef unsigned int __u32;
+typedef __signed__ int __s32;
+typedef unsigned long long __u64;
+typedef __signed__ long long __s64;
+#endif
+
+#include <stdint.h> //uintptr_t
+
+/* endian checking stuff */
+#ifndef EXT2_ENDIAN_H_
+#define EXT2_ENDIAN_H_
+
+#ifdef __CHECKER__
+#ifndef __bitwise
+#define __bitwise		__attribute__((bitwise))
+#endif
+#define __force			__attribute__((force))
+#else
+#ifndef __bitwise
+#define __bitwise
+#endif
+#define __force
+#endif
+
+typedef __u16	__bitwise	__le16;
+typedef __u32	__bitwise	__le32;
+typedef __u64	__bitwise	__le64;
+typedef __u16	__bitwise	__be16;
+typedef __u32	__bitwise	__be32;
+typedef __u64	__bitwise	__be64;
+
+#endif /* EXT2_ENDIAN_H_ */
diff --git a/external/e2fsprogs/lib/ss/ss_err.c b/external/e2fsprogs/lib/ss/ss_err.c
new file mode 100644
index 0000000000..2beeaad947
--- /dev/null
+++ b/external/e2fsprogs/lib/ss/ss_err.c
@@ -0,0 +1,66 @@
+/*
+ * ss_err.c:
+ * This file is automatically generated; please do not edit it.
+ */
+
+#include <stdlib.h>
+
+#define N_(a) a
+
+static const char * const text[] = {
+	N_(	"Subsystem aborted"),
+	N_(	"Version mismatch"),
+	N_(	"No current invocation"),
+	N_(	"No info directory"),
+	N_(	"Command not found"),
+	N_(	"Command line aborted"),
+	N_(	"End-of-file reached"),
+	N_(	"Permission denied"),
+	N_(	"Request table not found"),
+	N_(	"No info available"),
+	N_(	"Shell escapes are disabled"),
+	N_(	"Sorry, this request is not yet implemented"),
+    0
+};
+
+struct error_table {
+    char const * const * msgs;
+    long base;
+    int n_msgs;
+};
+struct et_list {
+    struct et_list *next;
+    const struct error_table * table;
+};
+extern struct et_list *_et_list;
+
+const struct error_table et_ss_error_table = { text, 748800L, 12 };
+
+static struct et_list link = { 0, 0 };
+
+void initialize_ss_error_table_r(struct et_list **list);
+void initialize_ss_error_table(void);
+
+void initialize_ss_error_table(void) {
+    initialize_ss_error_table_r(&_et_list);
+}
+
+/* For Heimdal compatibility */
+void initialize_ss_error_table_r(struct et_list **list)
+{
+    struct et_list *et, **end;
+
+    for (end = list, et = *list; et; end = &et->next, et = et->next)
+        if (et->table->msgs == text)
+            return;
+    et = malloc(sizeof(struct et_list));
+    if (et == 0) {
+        if (!link.table)
+            et = &link;
+        else
+            return;
+    }
+    et->table = &et_ss_error_table;
+    et->next = 0;
+    *end = et;
+}
diff --git a/external/e2fsprogs/lib/ss/ss_err.h b/external/e2fsprogs/lib/ss/ss_err.h
new file mode 100644
index 0000000000..930776aeeb
--- /dev/null
+++ b/external/e2fsprogs/lib/ss/ss_err.h
@@ -0,0 +1,30 @@
+/*
+ * ss_err.h:
+ * This file is automatically generated; please do not edit it.
+ */
+
+#include <et/com_err.h>
+
+#define SS_ET_SUBSYSTEM_ABORTED                  (748800L)
+#define SS_ET_VERSION_MISMATCH                   (748801L)
+#define SS_ET_NULL_INV                           (748802L)
+#define SS_ET_NO_INFO_DIR                        (748803L)
+#define SS_ET_COMMAND_NOT_FOUND                  (748804L)
+#define SS_ET_LINE_ABORTED                       (748805L)
+#define SS_ET_EOF                                (748806L)
+#define SS_ET_PERMISSION_DENIED                  (748807L)
+#define SS_ET_TABLE_NOT_FOUND                    (748808L)
+#define SS_ET_NO_HELP_FILE                       (748809L)
+#define SS_ET_ESCAPE_DISABLED                    (748810L)
+#define SS_ET_UNIMPLEMENTED                      (748811L)
+extern const struct error_table et_ss_error_table;
+extern void initialize_ss_error_table(void);
+
+/* For compatibility with Heimdal */
+extern void initialize_ss_error_table_r(struct et_list **list);
+
+#define ERROR_TABLE_BASE_ss (748800L)
+
+/* for compatibility with older versions... */
+#define init_ss_err_tbl initialize_ss_error_table
+#define ss_err_base ERROR_TABLE_BASE_ss
diff --git a/external/e2fsprogs/lib/ss/std_rqs.c b/external/e2fsprogs/lib/ss/std_rqs.c
new file mode 100644
index 0000000000..72a0c05893
--- /dev/null
+++ b/external/e2fsprogs/lib/ss/std_rqs.c
@@ -0,0 +1,104 @@
+/* lib/ss/std_rqs.c - automatically generated from lib/ss/std_rqs.ct */
+#include <ss/ss.h>
+
+static char const * const ssu00001[] = {
+".",
+    (char const *)0
+};
+extern void ss_self_identify __SS_PROTO;
+static char const * const ssu00002[] = {
+"help",
+    (char const *)0
+};
+extern void ss_help __SS_PROTO;
+static char const * const ssu00003[] = {
+"list_help",
+    "lh",
+    (char const *)0
+};
+extern void ss_unimplemented __SS_PROTO;
+static char const * const ssu00004[] = {
+"list_requests",
+    "lr",
+    "?",
+    (char const *)0
+};
+extern void ss_list_requests __SS_PROTO;
+static char const * const ssu00005[] = {
+"quit",
+    "q",
+    (char const *)0
+};
+extern void ss_quit __SS_PROTO;
+static char const * const ssu00006[] = {
+"abbrev",
+    "ab",
+    (char const *)0
+};
+extern void ss_unimplemented __SS_PROTO;
+static char const * const ssu00007[] = {
+"execute",
+    "e",
+    (char const *)0
+};
+extern void ss_unimplemented __SS_PROTO;
+static char const * const ssu00008[] = {
+"?",
+    (char const *)0
+};
+extern void ss_unimplemented __SS_PROTO;
+static char const * const ssu00009[] = {
+"subsystem_name",
+    (char const *)0
+};
+extern void ss_subsystem_name __SS_PROTO;
+static char const * const ssu00010[] = {
+"subsystem_version",
+    (char const *)0
+};
+extern void ss_subsystem_version __SS_PROTO;
+static ss_request_entry ssu00011[] = {
+    { ssu00001,
+      ss_self_identify,
+      "Identify the subsystem.",
+      3 },
+    { ssu00002,
+      ss_help,
+      "Display info on command or topic.",
+      0 },
+    { ssu00003,
+      ss_unimplemented,
+      "List topics for which help is available.",
+      3 },
+    { ssu00004,
+      ss_list_requests,
+      "List available commands.",
+      0 },
+    { ssu00005,
+      ss_quit,
+      "Leave the subsystem.",
+      0 },
+    { ssu00006,
+      ss_unimplemented,
+      "Enable/disable abbreviation processing of request lines.",
+      3 },
+    { ssu00007,
+      ss_unimplemented,
+      "Execute a UNIX command line.",
+      3 },
+    { ssu00008,
+      ss_unimplemented,
+      "Produce a list of the most commonly used requests.",
+      3 },
+    { ssu00009,
+      ss_subsystem_name,
+      "Return the name of this subsystem.",
+      1 },
+    { ssu00010,
+      ss_subsystem_version,
+      "Return the version of this subsystem.",
+      1 },
+    { 0, 0, 0, 0 }
+};
+
+ss_request_table ss_std_requests = { 2, ssu00011 };
diff --git a/external/e2fsprogs/lib/support/prof_err.c b/external/e2fsprogs/lib/support/prof_err.c
new file mode 100644
index 0000000000..2c8d43bfd0
--- /dev/null
+++ b/external/e2fsprogs/lib/support/prof_err.c
@@ -0,0 +1,85 @@
+/*
+ * prof_err.c:
+ * This file is automatically generated; please do not edit it.
+ */
+
+#include <stdlib.h>
+
+#define N_(a) a
+
+static const char * const text[] = {
+	N_("Profile version 0.0"),
+	N_("Bad magic value in profile_node"),
+	N_("Profile section not found"),
+	N_("Profile relation not found"),
+	N_(	"Attempt to add a relation to node which is not a section"),
+	N_(	"A profile section header has a non-zero value"),
+	N_("Bad linked list in profile structures"),
+	N_("Bad group level in profile structures"),
+	N_(	"Bad parent pointer in profile structures"),
+	N_("Bad magic value in profile iterator"),
+	N_("Can't set value on section node"),
+	N_("Invalid argument passed to profile library"),
+	N_("Attempt to modify read-only profile"),
+	N_("Profile section header not at top level"),
+	N_("Syntax error in profile section header"),
+	N_("Syntax error in profile relation"),
+	N_("Extra closing brace in profile"),
+	N_("Missing open brace in profile"),
+	N_("Bad magic value in profile_t"),
+	N_("Bad magic value in profile_section_t"),
+	N_(	"Iteration through all top level section not supported"),
+	N_("Invalid profile_section object"),
+	N_("No more sections"),
+	N_("Bad nameset passed to query routine"),
+	N_("No profile file open"),
+	N_("Bad magic value in profile_file_t"),
+	N_("Couldn't open profile file"),
+	N_("Section already exists"),
+	N_("Invalid boolean value"),
+	N_("Invalid integer value"),
+	N_("Bad magic value in profile_file_data_t"),
+    0
+};
+
+struct error_table {
+    char const * const * msgs;
+    long base;
+    int n_msgs;
+};
+struct et_list {
+    struct et_list *next;
+    const struct error_table * table;
+};
+extern struct et_list *_et_list;
+
+const struct error_table et_prof_error_table = { text, -1429577728L, 31 };
+
+static struct et_list link = { 0, 0 };
+
+void initialize_prof_error_table_r(struct et_list **list);
+void initialize_prof_error_table(void);
+
+void initialize_prof_error_table(void) {
+    initialize_prof_error_table_r(&_et_list);
+}
+
+/* For Heimdal compatibility */
+void initialize_prof_error_table_r(struct et_list **list)
+{
+    struct et_list *et, **end;
+
+    for (end = list, et = *list; et; end = &et->next, et = et->next)
+        if (et->table->msgs == text)
+            return;
+    et = malloc(sizeof(struct et_list));
+    if (et == 0) {
+        if (!link.table)
+            et = &link;
+        else
+            return;
+    }
+    et->table = &et_prof_error_table;
+    et->next = 0;
+    *end = et;
+}
diff --git a/external/e2fsprogs/lib/support/prof_err.h b/external/e2fsprogs/lib/support/prof_err.h
new file mode 100644
index 0000000000..e8066ddcff
--- /dev/null
+++ b/external/e2fsprogs/lib/support/prof_err.h
@@ -0,0 +1,49 @@
+/*
+ * prof_err.h:
+ * This file is automatically generated; please do not edit it.
+ */
+
+#include <et/com_err.h>
+
+#define PROF_VERSION                             (-1429577728L)
+#define PROF_MAGIC_NODE                          (-1429577727L)
+#define PROF_NO_SECTION                          (-1429577726L)
+#define PROF_NO_RELATION                         (-1429577725L)
+#define PROF_ADD_NOT_SECTION                     (-1429577724L)
+#define PROF_SECTION_WITH_VALUE                  (-1429577723L)
+#define PROF_BAD_LINK_LIST                       (-1429577722L)
+#define PROF_BAD_GROUP_LVL                       (-1429577721L)
+#define PROF_BAD_PARENT_PTR                      (-1429577720L)
+#define PROF_MAGIC_ITERATOR                      (-1429577719L)
+#define PROF_SET_SECTION_VALUE                   (-1429577718L)
+#define PROF_EINVAL                              (-1429577717L)
+#define PROF_READ_ONLY                           (-1429577716L)
+#define PROF_SECTION_NOTOP                       (-1429577715L)
+#define PROF_SECTION_SYNTAX                      (-1429577714L)
+#define PROF_RELATION_SYNTAX                     (-1429577713L)
+#define PROF_EXTRA_CBRACE                        (-1429577712L)
+#define PROF_MISSING_OBRACE                      (-1429577711L)
+#define PROF_MAGIC_PROFILE                       (-1429577710L)
+#define PROF_MAGIC_SECTION                       (-1429577709L)
+#define PROF_TOPSECTION_ITER_NOSUPP              (-1429577708L)
+#define PROF_INVALID_SECTION                     (-1429577707L)
+#define PROF_END_OF_SECTIONS                     (-1429577706L)
+#define PROF_BAD_NAMESET                         (-1429577705L)
+#define PROF_NO_PROFILE                          (-1429577704L)
+#define PROF_MAGIC_FILE                          (-1429577703L)
+#define PROF_FAIL_OPEN                           (-1429577702L)
+#define PROF_EXISTS                              (-1429577701L)
+#define PROF_BAD_BOOLEAN                         (-1429577700L)
+#define PROF_BAD_INTEGER                         (-1429577699L)
+#define PROF_MAGIC_FILE_DATA                     (-1429577698L)
+extern const struct error_table et_prof_error_table;
+extern void initialize_prof_error_table(void);
+
+/* For compatibility with Heimdal */
+extern void initialize_prof_error_table_r(struct et_list **list);
+
+#define ERROR_TABLE_BASE_prof (-1429577728L)
+
+/* for compatibility with older versions... */
+#define init_prof_err_tbl initialize_prof_error_table
+#define prof_err_base ERROR_TABLE_BASE_prof
diff --git a/external/e2fsprogs/lib/uuid/uuid.h b/external/e2fsprogs/lib/uuid/uuid.h
new file mode 100644
index 0000000000..ca846da0f0
--- /dev/null
+++ b/external/e2fsprogs/lib/uuid/uuid.h
@@ -0,0 +1,103 @@
+/*
+ * Public include file for the UUID library
+ *
+ * Copyright (C) 1996, 1997, 1998 Theodore Ts'o.
+ *
+ * %Begin-Header%
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * %End-Header%
+ */
+
+#ifndef _UUID_UUID_H
+#define _UUID_UUID_H
+
+#include <sys/types.h>
+#ifndef _WIN32
+#include <sys/time.h>
+#endif
+#include <time.h>
+
+typedef unsigned char uuid_t[16];
+
+/* UUID Variant definitions */
+#define UUID_VARIANT_NCS 	0
+#define UUID_VARIANT_DCE 	1
+#define UUID_VARIANT_MICROSOFT	2
+#define UUID_VARIANT_OTHER	3
+
+/* UUID Type definitions */
+#define UUID_TYPE_DCE_TIME   1
+#define UUID_TYPE_DCE_RANDOM 4
+
+/* Allow UUID constants to be defined */
+#ifdef __GNUC__
+#define UUID_DEFINE(name,u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15) \
+	static const uuid_t name __attribute__ ((unused)) = {u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15}
+#else
+#define UUID_DEFINE(name,u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15) \
+	static const uuid_t name = {u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15}
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* clear.c */
+void uuid_clear(uuid_t uu);
+
+/* compare.c */
+int uuid_compare(const uuid_t uu1, const uuid_t uu2);
+
+/* copy.c */
+void uuid_copy(uuid_t dst, const uuid_t src);
+
+/* gen_uuid.c */
+void uuid_generate(uuid_t out);
+void uuid_generate_random(uuid_t out);
+void uuid_generate_time(uuid_t out);
+
+/* isnull.c */
+int uuid_is_null(const uuid_t uu);
+
+/* parse.c */
+int uuid_parse(const char *in, uuid_t uu);
+
+/* unparse.c */
+void uuid_unparse(const uuid_t uu, char *out);
+void uuid_unparse_lower(const uuid_t uu, char *out);
+void uuid_unparse_upper(const uuid_t uu, char *out);
+
+/* uuid_time.c */
+time_t uuid_time(const uuid_t uu, struct timeval *ret_tv);
+int uuid_type(const uuid_t uu);
+int uuid_variant(const uuid_t uu);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UUID_UUID_H */
diff --git a/external/e2fsprogs/misc/default_profile.c b/external/e2fsprogs/misc/default_profile.c
new file mode 100644
index 0000000000..585a34d349
--- /dev/null
+++ b/external/e2fsprogs/misc/default_profile.c
@@ -0,0 +1,49 @@
+const char *mke2fs_default_profile = 
+  "[defaults]\n"
+  "	base_features = sparse_super,large_file,filetype,resize_inode,dir_index,ext_attr\n"
+  "	default_mntopts = acl,user_xattr\n"
+  "	enable_periodic_fsck = 0\n"
+  "	blocksize = 4096\n"
+  "	inode_size = 256\n"
+  "	inode_ratio = 16384\n"
+  "\n"
+  "[fs_types]\n"
+  "	ext3 = {\n"
+  "		features = has_journal\n"
+  "	}\n"
+  "	ext4 = {\n"
+  "		features = has_journal,extent,huge_file,flex_bg,metadata_csum,64bit,dir_nlink,extra_isize\n"
+  "		inode_size = 256\n"
+  "	}\n"
+  "	small = {\n"
+  "		blocksize = 1024\n"
+  "		inode_size = 128\n"
+  "		inode_ratio = 4096\n"
+  "	}\n"
+  "	floppy = {\n"
+  "		blocksize = 1024\n"
+  "		inode_size = 128\n"
+  "		inode_ratio = 8192\n"
+  "	}\n"
+  "	big = {\n"
+  "		inode_ratio = 32768\n"
+  "	}\n"
+  "	huge = {\n"
+  "		inode_ratio = 65536\n"
+  "	}\n"
+  "	news = {\n"
+  "		inode_ratio = 4096\n"
+  "	}\n"
+  "	largefile = {\n"
+  "		inode_ratio = 1048576\n"
+  "		blocksize = -1\n"
+  "	}\n"
+  "	largefile4 = {\n"
+  "		inode_ratio = 4194304\n"
+  "		blocksize = -1\n"
+  "	}\n"
+  "	hurd = {\n"
+  "	     blocksize = 4096\n"
+  "	     inode_size = 128\n"
+  "	}\n"
+;
diff --git a/external/iptables/config.h b/external/iptables/config.h
new file mode 100644
index 0000000000..7bff59c20b
--- /dev/null
+++ b/external/iptables/config.h
@@ -0,0 +1,90 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `pcap' library (-lpcap). */
+/* #undef HAVE_LIBPCAP */
+
+/* Define to 1 if you have the <linux/dccp.h> header file. */
+#define HAVE_LINUX_DCCP_H 1
+
+/* Define to 1 if you have the <linux/ip_vs.h> header file. */
+#define HAVE_LINUX_IP_VS_H 1
+
+/* Define to 1 if you have the <linux/magic.h> header file. */
+#define HAVE_LINUX_MAGIC_H 1
+
+/* Define to 1 if you have the <linux/proc_fs.h> header file. */
+#define HAVE_LINUX_PROC_FS_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* Name of package */
+#define PACKAGE "iptables"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "iptables"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "iptables 1.6.1"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "iptables"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.6.1"
+
+/* The size of `struct ip6_hdr', as computed by sizeof. */
+#define SIZEOF_STRUCT_IP6_HDR 40
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "1.6.1"
+
+/* Location of the iptables lock file */
+#define XT_LOCK_NAME "/system/etc/xtables.lock"
+
+/* Define to 1 if you have the <linux/bpf.h> header file. */
+#define HAVE_LINUX_BPF_H 1
diff --git a/external/jemalloc_new/test/integration/cpp/basic.cpp b/external/jemalloc_new/test/integration/cpp/basic.cpp
new file mode 100644
index 0000000000..65890ecd55
--- /dev/null
+++ b/external/jemalloc_new/test/integration/cpp/basic.cpp
@@ -0,0 +1,25 @@
+#include <memory>
+#include "test/jemalloc_test.h"
+
+TEST_BEGIN(test_basic) {
+	auto foo = new long(4);
+	assert_ptr_not_null(foo, "Unexpected new[] failure");
+	delete foo;
+	// Test nullptr handling.
+	foo = nullptr;
+	delete foo;
+
+	auto bar = new long;
+	assert_ptr_not_null(bar, "Unexpected new failure");
+	delete bar;
+	// Test nullptr handling.
+	bar = nullptr;
+	delete bar;
+}
+TEST_END
+
+int
+main() {
+	return test(
+	    test_basic);
+}
diff --git a/external/libcap/libcap/cap_names.h b/external/libcap/libcap/cap_names.h
new file mode 100644
index 0000000000..83186e5852
--- /dev/null
+++ b/external/libcap/libcap/cap_names.h
@@ -0,0 +1,50 @@
+/*
+ * DO NOT EDIT: this file is generated automatically from
+ *
+ *     <linux/capability.h>
+ */
+#define __CAP_BITS   37
+
+#ifdef LIBCAP_PLEASE_INCLUDE_ARRAY
+  char const *_cap_names[__CAP_BITS] = {
+      /* 0 */	"cap_chown",
+      /* 1 */	"cap_dac_override",
+      /* 2 */	"cap_dac_read_search",
+      /* 3 */	"cap_fowner",
+      /* 4 */	"cap_fsetid",
+      /* 5 */	"cap_kill",
+      /* 6 */	"cap_setgid",
+      /* 7 */	"cap_setuid",
+      /* 8 */	"cap_setpcap",
+      /* 9 */	"cap_linux_immutable",
+      /* 10 */	"cap_net_bind_service",
+      /* 11 */	"cap_net_broadcast",
+      /* 12 */	"cap_net_admin",
+      /* 13 */	"cap_net_raw",
+      /* 14 */	"cap_ipc_lock",
+      /* 15 */	"cap_ipc_owner",
+      /* 16 */	"cap_sys_module",
+      /* 17 */	"cap_sys_rawio",
+      /* 18 */	"cap_sys_chroot",
+      /* 19 */	"cap_sys_ptrace",
+      /* 20 */	"cap_sys_pacct",
+      /* 21 */	"cap_sys_admin",
+      /* 22 */	"cap_sys_boot",
+      /* 23 */	"cap_sys_nice",
+      /* 24 */	"cap_sys_resource",
+      /* 25 */	"cap_sys_time",
+      /* 26 */	"cap_sys_tty_config",
+      /* 27 */	"cap_mknod",
+      /* 28 */	"cap_lease",
+      /* 29 */	"cap_audit_write",
+      /* 30 */	"cap_audit_control",
+      /* 31 */	"cap_setfcap",
+      /* 32 */	"cap_mac_override",
+      /* 33 */	"cap_mac_admin",
+      /* 34 */	"cap_syslog",
+      /* 35 */	"cap_wake_alarm",
+      /* 36 */	"cap_block_suspend",
+  };
+#endif /* LIBCAP_PLEASE_INCLUDE_ARRAY */
+
+/* END OF FILE */
diff --git a/external/libnl/include/netlink/version.h b/external/libnl/include/netlink/version.h
new file mode 100644
index 0000000000..a809442079
--- /dev/null
+++ b/external/libnl/include/netlink/version.h
@@ -0,0 +1,37 @@
+/*
+ * netlink/version.h	Versioning Information
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2011 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef NETLINK_VERSION_H_
+#define NETLINK_VERSION_H_
+
+/* Compile Time Versioning Information */
+
+#define LIBNL_STRING "libnl 3.2.25"
+#define LIBNL_VERSION "3.2.25"
+
+#define LIBNL_VER_MAJ		3
+#define LIBNL_VER_MIN		2
+#define LIBNL_VER_MIC		25
+#define LIBNL_VER(maj,min)	((maj) << 8 | (min))
+#define LIBNL_VER_NUM		LIBNL_VER(LIBNL_VER_MAJ, LIBNL_VER_MIN)
+
+#define LIBNL_CURRENT		220
+#define LIBNL_REVISION		0
+#define LIBNL_AGE		20
+
+/* Run-time version information */
+
+extern const int        nl_ver_num;
+extern const int        nl_ver_maj;
+extern const int        nl_ver_min;
+extern const int        nl_ver_mic;
+
+#endif
diff --git a/external/libunwind/include/config.h b/external/libunwind/include/config.h
new file mode 100644
index 0000000000..bcef953a2a
--- /dev/null
+++ b/external/libunwind/include/config.h
@@ -0,0 +1,255 @@
+/* include/config.h.  Generated from config.h.in by configure.  */
+/* include/config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Block signals before mutex operations */
+/* #undef CONFIG_BLOCK_SIGNALS */
+
+/* Enable Debug Frame */
+#define CONFIG_DEBUG_FRAME 1
+
+/* Support for Microsoft ABI extensions */
+/* This is required to understand floating point registers on x86-64 */
+#define CONFIG_MSABI_SUPPORT 1
+
+/* Define to 1 if you want every memory access validated */
+#define CONSERVATIVE_CHECKS 1
+
+/* Allocate large structures rather than place them on the stack. */
+#define CONSERVE_STACK /**/
+
+/* Define to 1 if you have the <asm/ptrace_offsets.h> header file. */
+/* #undef HAVE_ASM_PTRACE_OFFSETS_H */
+
+/* Define to 1 if you have the <atomic_ops.h> header file. */
+/* #undef HAVE_ATOMIC_OPS_H */
+
+/* Define to 1 if you have the <byteswap.h> header file. */
+#define HAVE_BYTESWAP_H 1
+
+/* Define to 1 if you have the declaration of `PTRACE_CONT', and to 0 if you
+   don't. */
+#define HAVE_DECL_PTRACE_CONT 1
+
+/* Define to 1 if you have the declaration of `PTRACE_POKEDATA', and to 0 if
+   you don't. */
+#define HAVE_DECL_PTRACE_POKEDATA 1
+
+/* Define to 1 if you have the declaration of `PTRACE_POKEUSER', and to 0 if
+   you don't. */
+#if defined(__aarch64__) || defined(__mips__)
+#define HAVE_DECL_PTRACE_POKEUSER 0
+#else
+#define HAVE_DECL_PTRACE_POKEUSER 1
+#endif
+
+/* Define to 1 if you have the declaration of `PTRACE_SINGLESTEP', and to 0 if
+   you don't. */
+#define HAVE_DECL_PTRACE_SINGLESTEP 1
+
+/* Define to 1 if you have the declaration of `PTRACE_SYSCALL', and to 0 if
+   you don't. */
+#define HAVE_DECL_PTRACE_SYSCALL 1
+
+/* Define to 1 if you have the declaration of `PTRACE_TRACEME', and to 0 if
+   you don't. */
+#define HAVE_DECL_PTRACE_TRACEME 1
+
+/* Define to 1 if you have the declaration of `PT_CONTINUE', and to 0 if you
+   don't. */
+#define HAVE_DECL_PT_CONTINUE 0
+
+/* Define to 1 if you have the declaration of `PT_GETFPREGS', and to 0 if you
+   don't. */
+#define HAVE_DECL_PT_GETFPREGS 0
+
+/* Define to 1 if you have the declaration of `PT_GETREGS', and to 0 if you
+   don't. */
+#if defined(__mips__)
+#define HAVE_DECL_PT_GETREGS 1
+#else
+#define HAVE_DECL_PT_GETREGS 0
+#endif
+
+/* Define to 1 if you have the declaration of `PT_GETREGSET', and to 0 if you
+   don't. */
+#if defined(__aarch64__)
+#define HAVE_DECL_PT_GETREGSET 1
+#else
+#define HAVE_DECL_PT_GETREGSET 0
+#endif
+
+/* Define to 1 if you have the declaration of `PT_IO', and to 0 if you don't.
+   */
+#define HAVE_DECL_PT_IO 0
+
+/* Define to 1 if you have the declaration of `PT_STEP', and to 0 if you
+   don't. */
+#define HAVE_DECL_PT_STEP 0
+
+/* Define to 1 if you have the declaration of `PT_SYSCALL', and to 0 if you
+   don't. */
+#define HAVE_DECL_PT_SYSCALL 0
+
+/* Define to 1 if you have the declaration of `PT_TRACE_ME', and to 0 if you
+   don't. */
+#define HAVE_DECL_PT_TRACE_ME 0
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `dlmodinfo' function. */
+#define HAVE_DLMODINFO 1
+
+/* Define to 1 if you have the `dl_iterate_phdr' function. */
+#define HAVE_DL_ITERATE_PHDR 1
+
+/* Define to 1 if you have the `dl_phdr_removals_counter' function. */
+#define HAVE_DL_PHDR_REMOVALS_COUNTER 1
+
+/* Define to 1 if you have the <elf.h> header file. */
+#define HAVE_ELF_H 1
+
+/* Define to 1 if you have the <endian.h> header file. */
+#define HAVE_ENDIAN_H 1
+
+/* Define to 1 if you have the <execinfo.h> header file. */
+/* #undef HAVE_EXECINFO_H */
+
+/* Define to 1 if you have the `getunwind' function. */
+#define HAVE_GETUNWIND 1
+
+/* Define to 1 if you have the <ia64intrin.h> header file. */
+/* #undef HAVE_IA64INTRIN_H */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `uca' library (-luca). */
+/* #undef HAVE_LIBUCA */
+
+/* Define to 1 if you have the <link.h> header file. */
+#define HAVE_LINK_H 1
+
+/* Define if you have liblzma */
+/* #undef HAVE_LZMA */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mincore' function. */
+#define HAVE_MINCORE 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if `dlpi_subs' is a member of `struct dl_phdr_info'. */
+/* #undef HAVE_STRUCT_DL_PHDR_INFO_DLPI_SUBS */
+
+/* Define to 1 if the system has the type `struct elf_prstatus'. */
+/* #undef HAVE_STRUCT_ELF_PRSTATUS */
+
+/* Define to 1 if the system has the type `struct prstatus'. */
+/* #undef HAVE_STRUCT_PRSTATUS */
+
+/* Defined if __sync atomics are available */
+#define HAVE_SYNC_ATOMICS 1
+
+/* Define to 1 if you have the <sys/elf.h> header file. */
+/* #undef HAVE_SYS_ELF_H */
+
+/* Define to 1 if you have the <sys/endian.h> header file. */
+#define HAVE_SYS_ENDIAN_H 1
+
+/* Define to 1 if you have the <sys/link.h> header file. */
+/* #undef HAVE_SYS_LINK_H */
+
+/* Define to 1 if you have the <sys/procfs.h> header file. */
+/* #undef HAVE_SYS_PROCFS_H */
+
+/* Define to 1 if you have the <sys/ptrace.h> header file. */
+#define HAVE_SYS_PTRACE_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uc_access.h> header file. */
+/* #undef HAVE_SYS_UC_ACCESS_H */
+
+/* Define to 1 if you have the `ttrace' function. */
+/* #undef HAVE_TTRACE */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Defined if __builtin_unreachable() is available */
+#define HAVE__BUILTIN_UNREACHABLE 1
+
+/* Defined if __builtin___clear_cache() is available */
+#define HAVE__BUILTIN___CLEAR_CACHE 1
+
+/* Define to 1 if __thread keyword is supported by the C compiler. */
+#define HAVE___THREAD 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* Name of package */
+#define PACKAGE "libunwind"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "libunwind-devel@nongnu.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libunwind"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "libunwind 1.1"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "libunwind"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.1"
+
+/* The size of `off_t', as computed by sizeof. */
+#define SIZEOF_OFF_T 4
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "1.1"
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
diff --git a/external/libunwind/include/libunwind-common.h b/external/libunwind/include/libunwind-common.h
new file mode 100644
index 0000000000..f4cbc88afb
--- /dev/null
+++ b/external/libunwind/include/libunwind-common.h
@@ -0,0 +1,308 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2001-2004 Hewlett-Packard Co
+	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+/* ANDROID support update. */
+#include <sys/types.h>
+/* End of ANDROID update. */
+
+#define UNW_VERSION_MAJOR	1
+#define UNW_VERSION_MINOR	1
+#define UNW_VERSION_EXTRA	
+
+#define UNW_VERSION_CODE(maj,min)	(((maj) << 16) | (min))
+#define UNW_VERSION	UNW_VERSION_CODE(UNW_VERSION_MAJOR, UNW_VERSION_MINOR)
+
+#define UNW_PASTE2(x,y)	x##y
+#define UNW_PASTE(x,y)	UNW_PASTE2(x,y)
+#define UNW_OBJ(fn)	UNW_PASTE(UNW_PREFIX, fn)
+#define UNW_ARCH_OBJ(fn) UNW_PASTE(UNW_PASTE(UNW_PASTE(_U,UNW_TARGET),_), fn)
+
+#ifdef UNW_LOCAL_ONLY
+# ifdef UNW_ADDITIONAL_PREFIX
+#  define UNW_PREFIX	UNW_PASTE(UNW_PASTE(_UUL,UNW_TARGET),_)
+# else
+#  define UNW_PREFIX	UNW_PASTE(UNW_PASTE(_UL,UNW_TARGET),_)
+# endif
+#else /* !UNW_LOCAL_ONLY */
+# ifdef UNW_ADDITIONAL_PREFIX
+#  define UNW_PREFIX	UNW_PASTE(UNW_PASTE(_UU,UNW_TARGET),_)
+# else
+#  define UNW_PREFIX	UNW_PASTE(UNW_PASTE(_U,UNW_TARGET),_)
+# endif
+#endif /* !UNW_LOCAL_ONLY */
+
+/* Error codes.  The unwind routines return the *negated* values of
+   these error codes on error and a non-negative value on success.  */
+typedef enum
+  {
+    UNW_ESUCCESS = 0,		/* no error */
+    UNW_EUNSPEC,		/* unspecified (general) error */
+    UNW_ENOMEM,			/* out of memory */
+    UNW_EBADREG,		/* bad register number */
+    UNW_EREADONLYREG,		/* attempt to write read-only register */
+    UNW_ESTOPUNWIND,		/* stop unwinding */
+    UNW_EINVALIDIP,		/* invalid IP */
+    UNW_EBADFRAME,		/* bad frame */
+    UNW_EINVAL,			/* unsupported operation or bad value */
+    UNW_EBADVERSION,		/* unwind info has unsupported version */
+    UNW_ENOINFO			/* no unwind info found */
+  }
+unw_error_t;
+
+/* The following enum defines the indices for a couple of
+   (pseudo-)registers which have the same meaning across all
+   platforms.  (RO) means read-only.  (RW) means read-write.  General
+   registers (aka "integer registers") are expected to start with
+   index 0.  The number of such registers is architecture-dependent.
+   The remaining indices can be used as an architecture sees fit.  The
+   last valid register index is given by UNW_REG_LAST.  */
+typedef enum
+  {
+    UNW_REG_IP = UNW_TDEP_IP,		/* (rw) instruction pointer (pc) */
+    UNW_REG_SP = UNW_TDEP_SP,		/* (ro) stack pointer */
+    UNW_REG_EH = UNW_TDEP_EH,		/* (rw) exception-handling reg base */
+    UNW_REG_LAST = UNW_TDEP_LAST_REG
+  }
+unw_frame_regnum_t;
+
+/* Number of exception-handler argument registers: */
+#define UNW_NUM_EH_REGS		UNW_TDEP_NUM_EH_REGS
+
+typedef enum
+  {
+    UNW_CACHE_NONE,			/* no caching */
+    UNW_CACHE_GLOBAL,			/* shared global cache */
+    UNW_CACHE_PER_THREAD		/* per-thread caching */
+  }
+unw_caching_policy_t;
+
+typedef int unw_regnum_t;
+
+/* The unwind cursor starts at the youngest (most deeply nested) frame
+   and is used to track the frame state as the unwinder steps from
+   frame to frame.  It is safe to make (shallow) copies of variables
+   of this type.  */
+typedef struct unw_cursor
+  {
+    unw_word_t opaque[UNW_TDEP_CURSOR_LEN];
+  }
+unw_cursor_t;
+
+/* This type encapsulates the entire (preserved) machine-state.  */
+typedef unw_tdep_context_t unw_context_t;
+
+/* unw_getcontext() fills the unw_context_t pointed to by UC with the
+   machine state as it exists at the call-site.  For implementation
+   reasons, this needs to be a target-dependent macro.  It's easiest
+   to think of unw_getcontext() as being identical to getcontext(). */
+#define unw_getcontext(uc)		unw_tdep_getcontext(uc)
+
+/* Return 1 if register number R is a floating-point register, zero
+   otherwise.
+   This routine is signal-safe.  */
+#define unw_is_fpreg(r)			unw_tdep_is_fpreg(r)
+
+typedef unw_tdep_fpreg_t unw_fpreg_t;
+
+typedef struct unw_addr_space *unw_addr_space_t;
+
+/* Each target may define it's own set of flags, but bits 0-15 are
+   reserved for general libunwind-use.  */
+#define UNW_PI_FLAG_FIRST_TDEP_BIT	16
+/* The information comes from a .debug_frame section.  */
+#define UNW_PI_FLAG_DEBUG_FRAME	32
+
+typedef struct unw_proc_info
+  {
+    unw_word_t start_ip;	/* first IP covered by this procedure */
+    unw_word_t end_ip;		/* first IP NOT covered by this procedure */
+    unw_word_t lsda;		/* address of lang.-spec. data area (if any) */
+    unw_word_t handler;		/* optional personality routine */
+    unw_word_t gp;		/* global-pointer value for this procedure */
+    unw_word_t flags;		/* misc. flags */
+
+    int format;			/* unwind-info format (arch-specific) */
+    int unwind_info_size;	/* size of the information (if applicable) */
+    void *unwind_info;		/* unwind-info (arch-specific) */
+    unw_tdep_proc_info_t extra;	/* target-dependent auxiliary proc-info */
+  }
+unw_proc_info_t;
+
+/* These are backend callback routines that provide access to the
+   state of a "remote" process.  This can be used, for example, to
+   unwind another process through the ptrace() interface.  */
+typedef struct unw_accessors
+  {
+    /* Look up the unwind info associated with instruction-pointer IP.
+       On success, the routine fills in the PROC_INFO structure.  */
+    int (*find_proc_info) (unw_addr_space_t, unw_word_t, unw_proc_info_t *,
+			   int, void *);
+
+    /* Release any resources (e.g., memory) that were allocated for
+       the unwind info returned in by a previous call to
+       find_proc_info() with NEED_UNWIND_INFO set to 1.  */
+    void (*put_unwind_info) (unw_addr_space_t, unw_proc_info_t *, void *);
+
+    /* Return the list-head of the dynamically registered unwind
+       info.  */
+    int (*get_dyn_info_list_addr) (unw_addr_space_t, unw_word_t *, void *);
+
+    /* Access aligned word at address ADDR.  The value is returned
+       according to the endianness of the host (e.g., if the host is
+       little-endian and the target is big-endian, access_mem() needs
+       to byte-swap the value before returning it).  */
+    int (*access_mem) (unw_addr_space_t, unw_word_t, unw_word_t *, int,
+		       void *);
+
+    /* Access register number REG at address ADDR.  */
+    int (*access_reg) (unw_addr_space_t, unw_regnum_t, unw_word_t *, int,
+		       void *);
+
+    /* Access register number REG at address ADDR.  */
+    int (*access_fpreg) (unw_addr_space_t, unw_regnum_t,
+			 unw_fpreg_t *, int, void *);
+
+    int (*resume) (unw_addr_space_t, unw_cursor_t *, void *);
+
+    /* Optional call back to obtain the name of a (static) procedure.
+       Dynamically generated procedures are handled automatically by
+       libunwind.  This callback is optional and may be set to
+       NULL.  */
+    int (*get_proc_name) (unw_addr_space_t, unw_word_t, char *, size_t,
+			  unw_word_t *, void *);
+  }
+unw_accessors_t;
+
+typedef enum unw_save_loc_type
+  {
+    UNW_SLT_NONE,	/* register is not saved ("not an l-value") */
+    UNW_SLT_MEMORY,	/* register has been saved in memory */
+    UNW_SLT_REG		/* register has been saved in (another) register */
+  }
+unw_save_loc_type_t;
+
+typedef struct unw_save_loc
+  {
+    unw_save_loc_type_t type;
+    union
+      {
+	unw_word_t addr;	/* valid if type==UNW_SLT_MEMORY */
+	unw_regnum_t regnum;	/* valid if type==UNW_SLT_REG */
+      }
+    u;
+    unw_tdep_save_loc_t extra;	/* target-dependent additional information */
+  }
+unw_save_loc_t;
+
+/* ANDROID support update. */
+typedef struct unw_map_cursor
+  {
+    void *map_list;
+    void *cur_map;
+  }
+unw_map_cursor_t;
+
+typedef struct unw_map
+  {
+    unw_word_t start;
+    unw_word_t end;
+    unw_word_t offset;
+    unw_word_t load_base;
+    char *path;
+    int flags;
+  }
+unw_map_t;
+/* End of ANDROID update. */
+
+/* These routines work both for local and remote unwinding.  */
+
+#define unw_local_access_addr_space_init UNW_OBJ(local_access_addr_space_init)
+#define unw_local_addr_space	UNW_OBJ(local_addr_space)
+#define unw_create_addr_space	UNW_OBJ(create_addr_space)
+#define unw_destroy_addr_space	UNW_OBJ(destroy_addr_space)
+#define unw_get_accessors	UNW_ARCH_OBJ(get_accessors)
+#define unw_init_local		UNW_OBJ(init_local)
+#define unw_init_remote		UNW_OBJ(init_remote)
+#define unw_step		UNW_OBJ(step)
+#define unw_resume		UNW_OBJ(resume)
+#define unw_get_proc_info	UNW_OBJ(get_proc_info)
+#define unw_get_proc_info_by_ip	UNW_OBJ(get_proc_info_by_ip)
+#define unw_get_reg		UNW_OBJ(get_reg)
+#define unw_set_reg		UNW_OBJ(set_reg)
+#define unw_get_fpreg		UNW_OBJ(get_fpreg)
+#define unw_set_fpreg		UNW_OBJ(set_fpreg)
+#define unw_get_save_loc	UNW_OBJ(get_save_loc)
+#define unw_is_signal_frame	UNW_OBJ(is_signal_frame)
+#define unw_handle_signal_frame	UNW_OBJ(handle_signal_frame)
+#define unw_get_proc_name	UNW_OBJ(get_proc_name)
+#define unw_get_proc_name_by_ip	UNW_OBJ(get_proc_name_by_ip)
+#define unw_set_caching_policy	UNW_OBJ(set_caching_policy)
+#define unw_regname		UNW_ARCH_OBJ(regname)
+#define unw_flush_cache		UNW_ARCH_OBJ(flush_cache)
+#define unw_strerror		UNW_ARCH_OBJ(strerror)
+
+extern void unw_local_access_addr_space_init (unw_addr_space_t);
+extern unw_addr_space_t unw_create_addr_space (unw_accessors_t *, int);
+extern void unw_destroy_addr_space (unw_addr_space_t);
+extern unw_accessors_t *unw_get_accessors (unw_addr_space_t);
+extern void unw_flush_cache (unw_addr_space_t, unw_word_t, unw_word_t);
+extern int unw_set_caching_policy (unw_addr_space_t, unw_caching_policy_t);
+extern const char *unw_regname (unw_regnum_t);
+
+extern int unw_init_local (unw_cursor_t *, unw_context_t *);
+extern int unw_init_remote (unw_cursor_t *, unw_addr_space_t, void *);
+extern int unw_step (unw_cursor_t *);
+extern int unw_resume (unw_cursor_t *);
+extern int unw_get_proc_info (unw_cursor_t *, unw_proc_info_t *);
+extern int unw_get_proc_info_by_ip (unw_addr_space_t, unw_word_t,
+				    unw_proc_info_t *, void *);
+extern int unw_get_reg (unw_cursor_t *, int, unw_word_t *);
+extern int unw_set_reg (unw_cursor_t *, int, unw_word_t);
+extern int unw_get_fpreg (unw_cursor_t *, int, unw_fpreg_t *);
+extern int unw_set_fpreg (unw_cursor_t *, int, unw_fpreg_t);
+extern int unw_get_save_loc (unw_cursor_t *, int, unw_save_loc_t *);
+extern int unw_is_signal_frame (unw_cursor_t *);
+extern int unw_handle_signal_frame (unw_cursor_t *);
+extern int unw_get_proc_name (unw_cursor_t *, char *, size_t, unw_word_t *);
+extern int unw_get_proc_name_by_ip (unw_addr_space_t, unw_word_t, char *,
+				    size_t, unw_word_t *, void *);
+extern const char *unw_strerror (int);
+extern int unw_backtrace (void **, int);
+
+/* ANDROID support update. */
+extern int unw_map_local_cursor_valid (unw_map_cursor_t *);
+extern void unw_map_local_cursor_get (unw_map_cursor_t *);
+extern int unw_map_local_cursor_get_next (unw_map_cursor_t *, unw_map_t *);
+extern int unw_map_local_create (void);
+extern void unw_map_local_destroy (void);
+extern void unw_map_set (unw_addr_space_t, unw_map_cursor_t *);
+extern void unw_map_cursor_reset (unw_map_cursor_t *);
+extern void unw_map_cursor_clear (unw_map_cursor_t *);
+extern int unw_map_cursor_create (unw_map_cursor_t *, pid_t);
+extern void unw_map_cursor_destroy (unw_map_cursor_t *);
+extern int unw_map_cursor_get_next (unw_map_cursor_t *, unw_map_t *);
+/* End of ANDROID update. */
+
+extern unw_addr_space_t unw_local_addr_space;
diff --git a/external/libusb/linux/config.h b/external/libusb/linux/config.h
new file mode 100644
index 0000000000..f50f5abb73
--- /dev/null
+++ b/external/libusb/linux/config.h
@@ -0,0 +1,159 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Default visibility */
+#define DEFAULT_VISIBILITY __attribute__((visibility("default")))
+
+/* Start with debug message logging enabled */
+/* #undef ENABLE_DEBUG_LOGGING */
+
+/* Message logging */
+#define ENABLE_LOGGING 1
+
+/* Define to 1 if you have the <asm/types.h> header file. */
+#define HAVE_ASM_TYPES_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `udev' library (-ludev). */
+/* #undef HAVE_LIBUDEV */
+
+/* Define to 1 if you have the <libudev.h> header file. */
+/* #undef HAVE_LIBUDEV_H */
+
+/* Define to 1 if you have the <linux/netlink.h> header file. */
+#define HAVE_LINUX_NETLINK_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if the system has the type `struct timespec'. */
+#define HAVE_STRUCT_TIMESPEC 1
+
+/* syslog() function available */
+#define HAVE_SYSLOG_FUNC 1
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#define HAVE_SYSLOG_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Darwin backend */
+/* #undef OS_DARWIN */
+
+/* Haiku backend */
+/* #undef OS_HAIKU */
+
+/* Linux backend */
+#define OS_LINUX 1
+
+/* NetBSD backend */
+/* #undef OS_NETBSD */
+
+/* OpenBSD backend */
+/* #undef OS_OPENBSD */
+
+/* SunOS backend */
+/* #undef OS_SUNOS */
+
+/* Windows backend */
+/* #undef OS_WINDOWS */
+
+/* Name of package */
+#define PACKAGE "libusb"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "libusb-devel@lists.sourceforge.net"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libusb"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "libusb 1.0.21-rc5"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "libusb"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "http://libusb.info"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.0.21-rc5"
+
+/* type of second poll() argument */
+#define POLL_NFDS_TYPE nfds_t
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Use POSIX Threads */
+#define THREADS_POSIX 1
+
+/* timerfd headers available */
+#define USBI_TIMERFD_AVAILABLE 1
+
+/* Enable output to system log */
+/* #undef USE_SYSTEM_LOGGING_FACILITY */
+
+/* Use udev for device enumeration/hotplug */
+/* #undef USE_UDEV */
+
+/* Use UsbDk Windows backend */
+/* #undef USE_USBDK */
+
+/* Version number of package */
+#define VERSION "1.0.21-rc5"
+
+/* Oldest Windows version supported */
+/* #undef WINVER */
+
+/* Use GNU extensions */
+#define _GNU_SOURCE 1
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
diff --git a/external/libusb/windows/config.h b/external/libusb/windows/config.h
new file mode 100644
index 0000000000..835160d852
--- /dev/null
+++ b/external/libusb/windows/config.h
@@ -0,0 +1,159 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Default visibility */
+#define DEFAULT_VISIBILITY __attribute__((visibility("default")))
+
+/* Start with debug message logging enabled */
+/* #undef ENABLE_DEBUG_LOGGING */
+
+/* Message logging */
+#define ENABLE_LOGGING 1
+
+/* Define to 1 if you have the <asm/types.h> header file. */
+/* #undef HAVE_ASM_TYPES_H */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `udev' library (-ludev). */
+/* #undef HAVE_LIBUDEV */
+
+/* Define to 1 if you have the <libudev.h> header file. */
+/* #define HAVE_LIBUDEV_H */
+
+/* Define to 1 if you have the <linux/netlink.h> header file. */
+/* #undef HAVE_LINUX_NETLINK_H */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+/* #undef HAVE_POLL_H */
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if the system has the type `struct timespec'. */
+#define HAVE_STRUCT_TIMESPEC 1
+
+/* syslog() function available */
+/* #undef HAVE_SYSLOG_FUNC */
+
+/* Define to 1 if you have the <syslog.h> header file. */
+/* #undef HAVE_SYSLOG_H */
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+/* #undef HAVE_SYS_SOCKET_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Darwin backend */
+/* #undef OS_DARWIN */
+
+/* Haiku backend */
+/* #undef OS_HAIKU */
+
+/* Linux backend */
+/* #define OS_LINUX 1 */
+
+/* NetBSD backend */
+/* #undef OS_NETBSD */
+
+/* OpenBSD backend */
+/* #undef OS_OPENBSD */
+
+/* SunOS backend */
+/* #undef OS_SUNOS */
+
+/* Windows backend */
+#define OS_WINDOWS 1
+
+/* Name of package */
+#define PACKAGE "libusb"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "libusb-devel@lists.sourceforge.net"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libusb"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "libusb 1.0.21-rc5"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "libusb"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "http://libusb.info"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.0.21-rc5"
+
+/* type of second poll() argument */
+#define POLL_NFDS_TYPE unsigned int
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Use POSIX Threads */
+/* #undef THREADS_POSIX */
+
+/* timerfd headers available */
+/* #undef USBI_TIMERFD_AVAILABLE */
+
+/* Enable output to system log */
+/* #undef USE_SYSTEM_LOGGING_FACILITY */
+
+/* Use udev for device enumeration/hotplug */
+/* #undef USE_UDEV */
+
+/* Use UsbDk Windows backend */
+/* #undef USE_USBDK */
+
+/* Version number of package */
+#define VERSION "1.0.21-rc5"
+
+/* Oldest Windows version supported */
+/* #undef WINVER */
+
+/* Use GNU extensions */
+/* #undef _GNU_SOURCE */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
diff --git a/external/one-true-awk/proctab.c b/external/one-true-awk/proctab.c
new file mode 100644
index 0000000000..ff212c416c
--- /dev/null
+++ b/external/one-true-awk/proctab.c
@@ -0,0 +1,209 @@
+#include <stdio.h>
+#include "awk.h"
+#include "ytab.h"
+
+static char *printname[94] = {
+	(char *) "FIRSTTOKEN",	/* 258 */
+	(char *) "PROGRAM",	/* 259 */
+	(char *) "PASTAT",	/* 260 */
+	(char *) "PASTAT2",	/* 261 */
+	(char *) "XBEGIN",	/* 262 */
+	(char *) "XEND",	/* 263 */
+	(char *) "NL",	/* 264 */
+	(char *) "ARRAY",	/* 265 */
+	(char *) "MATCH",	/* 266 */
+	(char *) "NOTMATCH",	/* 267 */
+	(char *) "MATCHOP",	/* 268 */
+	(char *) "FINAL",	/* 269 */
+	(char *) "DOT",	/* 270 */
+	(char *) "ALL",	/* 271 */
+	(char *) "CCL",	/* 272 */
+	(char *) "NCCL",	/* 273 */
+	(char *) "CHAR",	/* 274 */
+	(char *) "OR",	/* 275 */
+	(char *) "STAR",	/* 276 */
+	(char *) "QUEST",	/* 277 */
+	(char *) "PLUS",	/* 278 */
+	(char *) "EMPTYRE",	/* 279 */
+	(char *) "AND",	/* 280 */
+	(char *) "BOR",	/* 281 */
+	(char *) "APPEND",	/* 282 */
+	(char *) "EQ",	/* 283 */
+	(char *) "GE",	/* 284 */
+	(char *) "GT",	/* 285 */
+	(char *) "LE",	/* 286 */
+	(char *) "LT",	/* 287 */
+	(char *) "NE",	/* 288 */
+	(char *) "IN",	/* 289 */
+	(char *) "ARG",	/* 290 */
+	(char *) "BLTIN",	/* 291 */
+	(char *) "BREAK",	/* 292 */
+	(char *) "CLOSE",	/* 293 */
+	(char *) "CONTINUE",	/* 294 */
+	(char *) "DELETE",	/* 295 */
+	(char *) "DO",	/* 296 */
+	(char *) "EXIT",	/* 297 */
+	(char *) "FOR",	/* 298 */
+	(char *) "FUNC",	/* 299 */
+	(char *) "SUB",	/* 300 */
+	(char *) "GSUB",	/* 301 */
+	(char *) "IF",	/* 302 */
+	(char *) "INDEX",	/* 303 */
+	(char *) "LSUBSTR",	/* 304 */
+	(char *) "MATCHFCN",	/* 305 */
+	(char *) "NEXT",	/* 306 */
+	(char *) "NEXTFILE",	/* 307 */
+	(char *) "ADD",	/* 308 */
+	(char *) "MINUS",	/* 309 */
+	(char *) "MULT",	/* 310 */
+	(char *) "DIVIDE",	/* 311 */
+	(char *) "MOD",	/* 312 */
+	(char *) "ASSIGN",	/* 313 */
+	(char *) "ASGNOP",	/* 314 */
+	(char *) "ADDEQ",	/* 315 */
+	(char *) "SUBEQ",	/* 316 */
+	(char *) "MULTEQ",	/* 317 */
+	(char *) "DIVEQ",	/* 318 */
+	(char *) "MODEQ",	/* 319 */
+	(char *) "POWEQ",	/* 320 */
+	(char *) "PRINT",	/* 321 */
+	(char *) "PRINTF",	/* 322 */
+	(char *) "SPRINTF",	/* 323 */
+	(char *) "ELSE",	/* 324 */
+	(char *) "INTEST",	/* 325 */
+	(char *) "CONDEXPR",	/* 326 */
+	(char *) "POSTINCR",	/* 327 */
+	(char *) "PREINCR",	/* 328 */
+	(char *) "POSTDECR",	/* 329 */
+	(char *) "PREDECR",	/* 330 */
+	(char *) "VAR",	/* 331 */
+	(char *) "IVAR",	/* 332 */
+	(char *) "VARNF",	/* 333 */
+	(char *) "CALL",	/* 334 */
+	(char *) "NUMBER",	/* 335 */
+	(char *) "STRING",	/* 336 */
+	(char *) "REGEXPR",	/* 337 */
+	(char *) "GETLINE",	/* 338 */
+	(char *) "RETURN",	/* 339 */
+	(char *) "SPLIT",	/* 340 */
+	(char *) "SUBSTR",	/* 341 */
+	(char *) "WHILE",	/* 342 */
+	(char *) "CAT",	/* 343 */
+	(char *) "NOT",	/* 344 */
+	(char *) "UMINUS",	/* 345 */
+	(char *) "UPLUS",	/* 346 */
+	(char *) "POWER",	/* 347 */
+	(char *) "DECR",	/* 348 */
+	(char *) "INCR",	/* 349 */
+	(char *) "INDIRECT",	/* 350 */
+	(char *) "LASTTOKEN",	/* 351 */
+};
+
+
+Cell *(*proctab[94])(Node **, int) = {
+	nullproc,	/* FIRSTTOKEN */
+	program,	/* PROGRAM */
+	pastat,	/* PASTAT */
+	dopa2,	/* PASTAT2 */
+	nullproc,	/* XBEGIN */
+	nullproc,	/* XEND */
+	nullproc,	/* NL */
+	array,	/* ARRAY */
+	matchop,	/* MATCH */
+	matchop,	/* NOTMATCH */
+	nullproc,	/* MATCHOP */
+	nullproc,	/* FINAL */
+	nullproc,	/* DOT */
+	nullproc,	/* ALL */
+	nullproc,	/* CCL */
+	nullproc,	/* NCCL */
+	nullproc,	/* CHAR */
+	nullproc,	/* OR */
+	nullproc,	/* STAR */
+	nullproc,	/* QUEST */
+	nullproc,	/* PLUS */
+	nullproc,	/* EMPTYRE */
+	boolop,	/* AND */
+	boolop,	/* BOR */
+	nullproc,	/* APPEND */
+	relop,	/* EQ */
+	relop,	/* GE */
+	relop,	/* GT */
+	relop,	/* LE */
+	relop,	/* LT */
+	relop,	/* NE */
+	instat,	/* IN */
+	arg,	/* ARG */
+	bltin,	/* BLTIN */
+	jump,	/* BREAK */
+	closefile,	/* CLOSE */
+	jump,	/* CONTINUE */
+	awkdelete,	/* DELETE */
+	dostat,	/* DO */
+	jump,	/* EXIT */
+	forstat,	/* FOR */
+	nullproc,	/* FUNC */
+	sub,	/* SUB */
+	gsub,	/* GSUB */
+	ifstat,	/* IF */
+	sindex,	/* INDEX */
+	nullproc,	/* LSUBSTR */
+	matchop,	/* MATCHFCN */
+	jump,	/* NEXT */
+	jump,	/* NEXTFILE */
+	arith,	/* ADD */
+	arith,	/* MINUS */
+	arith,	/* MULT */
+	arith,	/* DIVIDE */
+	arith,	/* MOD */
+	assign,	/* ASSIGN */
+	nullproc,	/* ASGNOP */
+	assign,	/* ADDEQ */
+	assign,	/* SUBEQ */
+	assign,	/* MULTEQ */
+	assign,	/* DIVEQ */
+	assign,	/* MODEQ */
+	assign,	/* POWEQ */
+	printstat,	/* PRINT */
+	awkprintf,	/* PRINTF */
+	awksprintf,	/* SPRINTF */
+	nullproc,	/* ELSE */
+	intest,	/* INTEST */
+	condexpr,	/* CONDEXPR */
+	incrdecr,	/* POSTINCR */
+	incrdecr,	/* PREINCR */
+	incrdecr,	/* POSTDECR */
+	incrdecr,	/* PREDECR */
+	nullproc,	/* VAR */
+	nullproc,	/* IVAR */
+	getnf,	/* VARNF */
+	call,	/* CALL */
+	nullproc,	/* NUMBER */
+	nullproc,	/* STRING */
+	nullproc,	/* REGEXPR */
+	awkgetline,	/* GETLINE */
+	jump,	/* RETURN */
+	split,	/* SPLIT */
+	substr,	/* SUBSTR */
+	whilestat,	/* WHILE */
+	cat,	/* CAT */
+	boolop,	/* NOT */
+	arith,	/* UMINUS */
+	arith,	/* UPLUS */
+	arith,	/* POWER */
+	nullproc,	/* DECR */
+	nullproc,	/* INCR */
+	indirect,	/* INDIRECT */
+	nullproc,	/* LASTTOKEN */
+};
+
+char *tokname(int n)
+{
+	static char buf[100];
+
+	if (n < FIRSTTOKEN || n > LASTTOKEN) {
+		sprintf(buf, "token %d", n);
+		return buf;
+	}
+	return printname[n-FIRSTTOKEN];
+}
diff --git a/external/one-true-awk/ytab.c b/external/one-true-awk/ytab.c
new file mode 100644
index 0000000000..9222f012d7
--- /dev/null
+++ b/external/one-true-awk/ytab.c
@@ -0,0 +1,3693 @@
+/* A Bison parser, made by GNU Bison 3.0.4.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.4"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 25 "awkgram.y" /* yacc.c:339  */
+
+#include <stdio.h>
+#include <string.h>
+#include "awk.h"
+
+void checkdup(Node *list, Cell *item);
+int yywrap(void) { return(1); }
+
+Node	*beginloc = 0;
+Node	*endloc = 0;
+int	infunc	= 0;	/* = 1 if in arglist or body of func */
+int	inloop	= 0;	/* = 1 if in while, for, do */
+char	*curfname = 0;	/* current function name */
+Node	*arglist = 0;	/* list of args for current function */
+
+#line 82 "y.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "y.tab.h".  */
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    FIRSTTOKEN = 258,
+    PROGRAM = 259,
+    PASTAT = 260,
+    PASTAT2 = 261,
+    XBEGIN = 262,
+    XEND = 263,
+    NL = 264,
+    ARRAY = 265,
+    MATCH = 266,
+    NOTMATCH = 267,
+    MATCHOP = 268,
+    FINAL = 269,
+    DOT = 270,
+    ALL = 271,
+    CCL = 272,
+    NCCL = 273,
+    CHAR = 274,
+    OR = 275,
+    STAR = 276,
+    QUEST = 277,
+    PLUS = 278,
+    EMPTYRE = 279,
+    AND = 280,
+    BOR = 281,
+    APPEND = 282,
+    EQ = 283,
+    GE = 284,
+    GT = 285,
+    LE = 286,
+    LT = 287,
+    NE = 288,
+    IN = 289,
+    ARG = 290,
+    BLTIN = 291,
+    BREAK = 292,
+    CLOSE = 293,
+    CONTINUE = 294,
+    DELETE = 295,
+    DO = 296,
+    EXIT = 297,
+    FOR = 298,
+    FUNC = 299,
+    SUB = 300,
+    GSUB = 301,
+    IF = 302,
+    INDEX = 303,
+    LSUBSTR = 304,
+    MATCHFCN = 305,
+    NEXT = 306,
+    NEXTFILE = 307,
+    ADD = 308,
+    MINUS = 309,
+    MULT = 310,
+    DIVIDE = 311,
+    MOD = 312,
+    ASSIGN = 313,
+    ASGNOP = 314,
+    ADDEQ = 315,
+    SUBEQ = 316,
+    MULTEQ = 317,
+    DIVEQ = 318,
+    MODEQ = 319,
+    POWEQ = 320,
+    PRINT = 321,
+    PRINTF = 322,
+    SPRINTF = 323,
+    ELSE = 324,
+    INTEST = 325,
+    CONDEXPR = 326,
+    POSTINCR = 327,
+    PREINCR = 328,
+    POSTDECR = 329,
+    PREDECR = 330,
+    VAR = 331,
+    IVAR = 332,
+    VARNF = 333,
+    CALL = 334,
+    NUMBER = 335,
+    STRING = 336,
+    REGEXPR = 337,
+    GETLINE = 338,
+    RETURN = 339,
+    SPLIT = 340,
+    SUBSTR = 341,
+    WHILE = 342,
+    CAT = 343,
+    NOT = 344,
+    UMINUS = 345,
+    UPLUS = 346,
+    POWER = 347,
+    DECR = 348,
+    INCR = 349,
+    INDIRECT = 350,
+    LASTTOKEN = 351
+  };
+#endif
+/* Tokens.  */
+#define FIRSTTOKEN 258
+#define PROGRAM 259
+#define PASTAT 260
+#define PASTAT2 261
+#define XBEGIN 262
+#define XEND 263
+#define NL 264
+#define ARRAY 265
+#define MATCH 266
+#define NOTMATCH 267
+#define MATCHOP 268
+#define FINAL 269
+#define DOT 270
+#define ALL 271
+#define CCL 272
+#define NCCL 273
+#define CHAR 274
+#define OR 275
+#define STAR 276
+#define QUEST 277
+#define PLUS 278
+#define EMPTYRE 279
+#define AND 280
+#define BOR 281
+#define APPEND 282
+#define EQ 283
+#define GE 284
+#define GT 285
+#define LE 286
+#define LT 287
+#define NE 288
+#define IN 289
+#define ARG 290
+#define BLTIN 291
+#define BREAK 292
+#define CLOSE 293
+#define CONTINUE 294
+#define DELETE 295
+#define DO 296
+#define EXIT 297
+#define FOR 298
+#define FUNC 299
+#define SUB 300
+#define GSUB 301
+#define IF 302
+#define INDEX 303
+#define LSUBSTR 304
+#define MATCHFCN 305
+#define NEXT 306
+#define NEXTFILE 307
+#define ADD 308
+#define MINUS 309
+#define MULT 310
+#define DIVIDE 311
+#define MOD 312
+#define ASSIGN 313
+#define ASGNOP 314
+#define ADDEQ 315
+#define SUBEQ 316
+#define MULTEQ 317
+#define DIVEQ 318
+#define MODEQ 319
+#define POWEQ 320
+#define PRINT 321
+#define PRINTF 322
+#define SPRINTF 323
+#define ELSE 324
+#define INTEST 325
+#define CONDEXPR 326
+#define POSTINCR 327
+#define PREINCR 328
+#define POSTDECR 329
+#define PREDECR 330
+#define VAR 331
+#define IVAR 332
+#define VARNF 333
+#define CALL 334
+#define NUMBER 335
+#define STRING 336
+#define REGEXPR 337
+#define GETLINE 338
+#define RETURN 339
+#define SPLIT 340
+#define SUBSTR 341
+#define WHILE 342
+#define CAT 343
+#define NOT 344
+#define UMINUS 345
+#define UPLUS 346
+#define POWER 347
+#define DECR 348
+#define INCR 349
+#define INDIRECT 350
+#define LASTTOKEN 351
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+
+union YYSTYPE
+{
+#line 41 "awkgram.y" /* yacc.c:355  */
+
+	Node	*p;
+	Cell	*cp;
+	int	i;
+	char	*s;
+
+#line 321 "y.tab.c" /* yacc.c:355  */
+};
+
+typedef union YYSTYPE YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 338 "y.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  8
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   4699
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  113
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  49
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  185
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  368
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   351
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,   104,     2,     2,
+      12,    16,   103,   101,    10,   102,     2,    15,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    94,    14,
+       2,     2,     2,    93,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,    18,     2,    19,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    11,    13,    17,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
+      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    95,    96,
+      97,    98,    99,   100,   105,   106,   107,   108,   109,   110,
+     111,   112
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,    98,    98,   100,   104,   104,   108,   108,   112,   112,
+     116,   116,   120,   120,   124,   124,   126,   126,   128,   128,
+     133,   134,   138,   142,   142,   146,   146,   150,   151,   155,
+     156,   161,   162,   166,   167,   171,   175,   176,   177,   178,
+     179,   180,   182,   184,   184,   189,   190,   194,   195,   199,
+     200,   202,   204,   206,   207,   212,   213,   214,   215,   216,
+     220,   221,   223,   225,   227,   228,   229,   230,   231,   232,
+     233,   234,   239,   240,   241,   244,   247,   248,   249,   253,
+     254,   258,   259,   263,   264,   265,   269,   269,   273,   273,
+     273,   273,   277,   277,   281,   283,   287,   287,   291,   291,
+     295,   298,   301,   304,   305,   306,   307,   308,   312,   313,
+     317,   319,   321,   321,   321,   323,   324,   325,   326,   327,
+     328,   329,   332,   335,   336,   337,   338,   338,   339,   343,
+     344,   348,   348,   352,   353,   354,   355,   356,   357,   358,
+     359,   360,   361,   362,   363,   364,   365,   366,   367,   368,
+     369,   370,   371,   372,   373,   374,   375,   376,   378,   381,
+     382,   384,   389,   390,   392,   394,   396,   397,   398,   400,
+     405,   407,   412,   414,   416,   420,   421,   422,   423,   427,
+     428,   429,   435,   436,   437,   442
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "FIRSTTOKEN", "PROGRAM", "PASTAT",
+  "PASTAT2", "XBEGIN", "XEND", "NL", "','", "'{'", "'('", "'|'", "';'",
+  "'/'", "')'", "'}'", "'['", "']'", "ARRAY", "MATCH", "NOTMATCH",
+  "MATCHOP", "FINAL", "DOT", "ALL", "CCL", "NCCL", "CHAR", "OR", "STAR",
+  "QUEST", "PLUS", "EMPTYRE", "AND", "BOR", "APPEND", "EQ", "GE", "GT",
+  "LE", "LT", "NE", "IN", "ARG", "BLTIN", "BREAK", "CLOSE", "CONTINUE",
+  "DELETE", "DO", "EXIT", "FOR", "FUNC", "SUB", "GSUB", "IF", "INDEX",
+  "LSUBSTR", "MATCHFCN", "NEXT", "NEXTFILE", "ADD", "MINUS", "MULT",
+  "DIVIDE", "MOD", "ASSIGN", "ASGNOP", "ADDEQ", "SUBEQ", "MULTEQ", "DIVEQ",
+  "MODEQ", "POWEQ", "PRINT", "PRINTF", "SPRINTF", "ELSE", "INTEST",
+  "CONDEXPR", "POSTINCR", "PREINCR", "POSTDECR", "PREDECR", "VAR", "IVAR",
+  "VARNF", "CALL", "NUMBER", "STRING", "REGEXPR", "'?'", "':'", "GETLINE",
+  "RETURN", "SPLIT", "SUBSTR", "WHILE", "CAT", "'+'", "'-'", "'*'", "'%'",
+  "NOT", "UMINUS", "UPLUS", "POWER", "DECR", "INCR", "INDIRECT",
+  "LASTTOKEN", "$accept", "program", "and", "bor", "comma", "do", "else",
+  "for", "$@1", "$@2", "$@3", "funcname", "if", "lbrace", "nl", "opt_nl",
+  "opt_pst", "opt_simple_stmt", "pas", "pa_pat", "pa_stat", "$@4",
+  "pa_stats", "patlist", "ppattern", "pattern", "plist", "pplist", "prarg",
+  "print", "pst", "rbrace", "re", "reg_expr", "$@5", "rparen",
+  "simple_stmt", "st", "stmt", "$@6", "$@7", "$@8", "stmtlist", "subop",
+  "term", "var", "varlist", "varname", "while", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+      44,   123,    40,   124,    59,    47,    41,   125,    91,    93,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
+     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
+     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
+     335,   336,   337,    63,    58,   338,   339,   340,   341,   342,
+     343,    43,    45,    42,    37,   344,   345,   346,   347,   348,
+     349,   350,   351
+};
+# endif
+
+#define YYPACT_NINF -314
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-314)))
+
+#define YYTABLE_NINF -32
+
+#define yytable_value_is_error(Yytable_value) \
+  (!!((Yytable_value) == (-32)))
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int16 yypact[] =
+{
+     681,  -314,  -314,  -314,    29,  1600,  -314,   142,  -314,    40,
+      40,  -314,  4229,  -314,  -314,    50,  4588,   -42,  -314,  -314,
+      53,    76,    78,  -314,  -314,  -314,    92,  -314,  -314,   -12,
+     149,   160,  4588,  4588,  4287,    19,    19,  4588,   812,    90,
+    -314,   143,  3515,  -314,  -314,   165,    -6,    11,    36,  -314,
+    -314,   812,   812,  2202,    45,   -19,  4044,  4229,  4588,    -6,
+     102,  -314,  -314,   172,  4229,  4229,  4229,  4102,  4588,   121,
+    4229,  4229,    80,    80,  -314,    80,  -314,  -314,  -314,  -314,
+    -314,   177,   144,   144,    -9,  -314,  1752,   179,   182,   144,
+     144,  -314,  -314,  1752,   184,   205,  -314,  1426,   812,  3515,
+    4345,   144,  -314,   880,  -314,   177,   812,  1600,   122,  4229,
+    -314,  -314,  4229,  4229,  4229,  4229,  4229,  4229,    -9,  4229,
+    1810,  1868,    -6,  4229,  4403,  4588,  4588,  4588,  4588,  4588,
+    4229,  -314,  -314,  4229,   948,  1016,  -314,  -314,  1926,   174,
+    1926,   209,  -314,    62,  3515,  2693,   134,  2602,  2602,   107,
+    -314,   108,    -6,  4588,  2602,  2602,  -314,   218,  -314,   177,
+     218,  -314,  -314,   214,  1694,  -314,  1484,  4229,  -314,  -314,
+    1694,  -314,  4229,  -314,  1426,   154,  1084,  4229,  3917,   224,
+      30,  -314,    -6,    16,  -314,  -314,  -314,  1426,  4229,  1152,
+    -314,    19,  3766,  -314,  3766,  3766,  3766,  3766,  3766,  3766,
+    -314,  2784,  -314,  3686,  -314,  3606,  2602,   224,  4588,    80,
+      42,    42,    80,    80,    80,  3515,    15,  -314,  -314,  -314,
+    3515,    -9,  3515,  -314,  -314,  1926,  -314,   117,  1926,  1926,
+    -314,  -314,    -6,     1,  1926,  -314,  -314,  4229,  -314,   222,
+    -314,     4,  2875,  -314,  2875,  -314,  -314,  1222,  -314,   239,
+     125,  4461,    -9,  4461,  1984,  2042,    -6,  2100,  4588,  4588,
+    4588,  4461,  -314,    40,  -314,  -314,  4229,  1926,  1926,    -6,
+    -314,  -314,  3515,  -314,    -5,   240,  2966,   234,  3057,   235,
+     126,  2304,    21,   151,    -9,   240,   240,   153,  -314,  -314,
+    -314,   210,  4229,  4530,  -314,  -314,  3837,  4171,  3986,  3917,
+      -6,    -6,    -6,  3917,   812,  3515,  2406,  2508,  -314,  -314,
+      40,  -314,  -314,  -314,  -314,  -314,  1926,  -314,  1926,  -314,
+     177,  4229,   241,   243,    -9,   139,  4461,  1290,  -314,     5,
+    -314,     5,   812,  3148,   242,  3239,  1542,  3333,   240,  4229,
+    -314,   210,  3917,  -314,   247,   250,  1358,  -314,  -314,  -314,
+     241,   177,  1426,  3424,  -314,  -314,  -314,   240,  1542,  -314,
+     144,  1426,   241,  -314,  -314,   240,  1426,  -314
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,     3,    88,    89,     0,    33,     2,    30,     1,     0,
+       0,    23,     0,    96,   183,   145,     0,     0,   131,   132,
+       0,     0,     0,   182,   177,   184,     0,   162,   167,   156,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    36,
+      45,    29,    35,    77,    94,     0,    78,   174,   175,    90,
+      91,     0,     0,     0,     0,     0,     0,     0,     0,   148,
+     174,    20,    21,     0,     0,     0,     0,     0,     0,   155,
+       0,     0,   141,   140,    95,   142,   149,   150,   178,   107,
+      24,    27,     0,     0,     0,    10,     0,     0,     0,     0,
+       0,    86,    87,     0,     0,   112,   117,     0,     0,   106,
+      83,     0,   129,     0,   126,    27,     0,    34,     0,     0,
+       4,     6,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    76,     0,     0,     0,     0,     0,     0,     0,
+       0,   151,   152,     0,     0,     0,     8,   159,     0,     0,
+       0,     0,   143,     0,    47,     0,   179,     0,     0,     0,
+     146,     0,   154,     0,     0,     0,    25,    28,   128,    27,
+     108,   110,   111,   105,     0,   116,     0,     0,   121,   122,
+       0,   124,     0,    11,     0,   119,     0,     0,    81,    84,
+     103,    58,    59,   174,   125,    40,   130,     0,     0,     0,
+      46,    75,    71,    70,    64,    65,    66,    67,    68,    69,
+      72,     0,     5,    63,     7,    62,     0,    94,     0,   137,
+     134,   135,   136,   138,   139,    60,     0,    41,    42,     9,
+      79,     0,    80,    97,   144,     0,   180,     0,     0,     0,
+     166,   147,   153,     0,     0,    26,   109,     0,   115,     0,
+      32,   175,     0,   123,     0,   113,    12,     0,    92,   120,
+       0,     0,     0,     0,     0,     0,    57,     0,     0,     0,
+       0,     0,   127,    38,    37,    74,     0,     0,     0,   133,
+     176,    73,    48,    98,     0,    43,     0,    94,     0,    94,
+       0,     0,     0,    27,     0,    22,   185,     0,    13,   118,
+      93,    85,     0,    54,    53,    55,     0,    52,    51,    82,
+     100,   101,   102,    49,     0,    61,     0,     0,   181,    99,
+       0,   157,   158,   161,   160,   165,     0,   173,     0,   104,
+      27,     0,     0,     0,     0,     0,     0,     0,   169,     0,
+     168,     0,     0,     0,    94,     0,     0,     0,    18,     0,
+      56,     0,    50,    39,     0,     0,     0,   163,   164,   172,
+       0,    27,     0,     0,   171,   170,    44,    16,     0,    19,
+       0,     0,     0,   114,    17,    14,     0,    15
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -314,  -314,  -129,   -96,    61,  -314,  -314,  -314,  -314,  -314,
+    -314,  -314,  -314,    -4,   -73,   -90,   229,  -313,  -314,    86,
+     169,  -314,  -314,   -39,    18,   527,  -170,  -314,  -314,  -314,
+    -314,  -314,   -32,   -85,  -314,  -203,  -163,   -30,   310,  -314,
+    -314,  -314,   -40,  -314,   270,   -16,  -314,    87,  -314
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     4,   120,   121,   225,    95,   247,    96,   366,   361,
+     352,    63,    97,    98,   160,   158,     5,   239,     6,    39,
+      40,   310,    41,   143,   178,    99,    54,   179,   180,   100,
+       7,   249,    43,    44,    55,   275,   101,   161,   102,   174,
+     287,   187,   103,    45,    46,    47,   227,    48,   104
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_int16 yytable[] =
+{
+      60,    38,    74,   240,   219,    51,    52,   250,   157,   124,
+     219,   134,   135,    69,   219,   188,    60,    60,    60,    76,
+      77,    60,   133,   350,   193,   136,    60,   149,   151,     8,
+      68,   136,   157,    14,   270,   106,    14,    60,   207,   285,
+     319,   286,    60,   258,    61,   362,    14,    62,   284,   254,
+      14,    11,    60,   162,   133,   136,   165,   124,   176,   168,
+     169,   139,    56,   171,    14,    64,   189,   259,   181,   236,
+     260,   184,   136,   141,    23,    24,    25,    23,   224,    25,
+     130,   308,   255,    60,   183,   261,   157,    23,    65,    25,
+      66,    23,    24,    25,   216,   125,   126,   127,   128,    37,
+     105,    11,   129,    38,    67,    23,    24,    25,    60,    60,
+      60,    60,    60,    60,   138,   140,    37,   136,   136,   338,
+     131,   132,   325,   230,   231,   131,   132,   136,    60,    60,
+      37,    60,    60,   273,   238,   136,   136,    60,    60,    60,
+     243,   291,   315,   277,   279,   127,   128,   357,    60,   136,
+     129,    49,     2,   156,    60,   341,    50,     3,   159,   365,
+     156,    70,    60,   153,   254,   320,   294,   254,   254,   254,
+     254,   163,    71,   240,   254,   265,    60,   123,    60,    60,
+      60,    60,    60,    60,   146,    60,   156,    60,   129,    60,
+      60,   166,    60,   321,   167,   240,   172,   255,   282,    60,
+     255,   255,   255,   255,    60,   200,    60,   255,   228,   229,
+     157,   131,   132,   254,   173,   233,   234,   191,   221,   181,
+     226,   181,   181,   181,   223,   181,    60,   235,    60,   181,
+     336,   334,   237,   246,   136,   183,   283,   183,   183,   183,
+     257,   183,    60,    60,    60,   183,   255,   157,   290,   309,
+     312,   314,   323,   241,   324,   339,    60,   273,   348,   304,
+      60,   358,    60,   354,   327,    60,   355,   267,   268,   293,
+     107,   296,   297,   298,   263,   299,   190,    60,   157,   303,
+      60,    60,    60,    60,     0,     0,    59,    60,   274,    60,
+      60,    60,   346,     0,   181,     0,     0,     0,     0,     0,
+       0,     0,    72,    73,    75,     0,   332,    78,   271,     0,
+     183,   140,   122,   344,     0,   345,     0,    60,     0,    60,
+     280,    60,     0,   122,     0,     0,    60,     0,    75,     0,
+     363,     0,     0,     0,     0,     0,     0,    60,   152,   295,
+       0,   316,   318,     0,   342,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   329,   331,   122,
+     182,   322,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   140,     0,     0,     0,
+       0,     0,     0,     0,   209,   210,   211,   212,   213,   214,
+       0,     0,     0,     0,     0,     0,     0,   175,     0,     0,
+       0,   340,     0,   186,   122,   122,     0,   122,   122,     0,
+       0,     0,     0,   232,   122,   122,     0,     0,     0,     0,
+       0,     0,     0,     0,   122,     0,     0,     0,     0,     0,
+     122,     0,     0,     0,   186,   186,     0,     0,   256,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   122,     0,   122,   122,   122,   122,   122,   122,
+       0,   122,     0,   122,     0,   122,   122,     0,   269,     0,
+       0,     0,     0,     0,   245,   122,   186,     0,     0,     0,
+     122,     0,   122,     0,     0,     0,     0,   262,     0,   186,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   122,     0,   122,     0,     0,     0,     0,     0,
+       0,   182,     0,   182,   182,   182,     0,   182,   300,   301,
+     302,   182,    42,     0,     0,     0,     0,     0,     0,    53,
+       0,     0,   122,     0,     0,     0,   122,     0,   122,     0,
+       0,   122,     0,     0,     0,     0,     0,   289,     0,     0,
+       0,     0,     0,   256,     0,     0,   256,   256,   256,   256,
+       0,     0,     0,   256,     0,   122,   122,   122,     0,     0,
+       0,     0,     0,   144,   145,     0,     0,     0,     0,     0,
+       0,   147,   148,   144,   144,     0,   182,   154,   155,     0,
+       0,     0,     0,   122,     0,   122,     0,   122,     0,     0,
+       0,     0,   256,   164,     0,     0,     0,     0,     0,     0,
+     170,     0,     0,   122,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    42,     0,   192,   186,     0,   194,
+     195,   196,   197,   198,   199,     0,   201,   203,   205,     0,
+     206,     0,     0,     0,     0,     0,   186,   215,     0,     0,
+     144,     0,   359,     0,     0,   220,     0,   222,     0,     0,
+       0,   364,     0,     0,     0,     0,   367,     0,     0,     0,
+       0,   -29,     1,     0,     0,     0,     0,     0,   -29,   -29,
+       2,     0,   -29,   -29,   242,     3,   -29,     0,     0,   244,
+       0,     0,     0,     0,    53,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    42,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   -29,   -29,     0,   -29,
+       0,     0,     0,     0,     0,   -29,   -29,   -29,     0,   -29,
+       0,   -29,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   272,     0,     0,   276,   278,     0,     0,   -29,
+       0,   281,     0,     0,   144,     0,     0,   -29,   -29,   -29,
+     -29,   -29,   -29,     0,     0,     0,   -29,     0,   -29,   -29,
+       0,     0,   -29,   -29,     0,     0,   -29,     0,     0,     0,
+     -29,   -29,   -29,   305,   306,   307,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    79,     0,     0,     0,     0,     0,    53,
+       0,    80,     0,    11,    12,     0,    81,    13,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,   333,     0,   335,     0,     0,   337,     0,
+       0,     0,     0,     0,     0,     0,     0,    14,    15,    82,
+      16,    83,    84,    85,    86,    87,   353,    18,    19,    88,
+      20,     0,    21,    89,    90,     0,     0,     0,     0,     0,
+       0,    79,     0,     0,     0,     0,     0,     0,    91,    92,
+      22,    11,    12,     0,    81,    13,     0,   185,    23,    24,
+      25,    26,    27,    28,     0,     0,     0,    29,    93,    30,
+      31,    94,     0,    32,    33,     0,     0,    34,     0,     0,
+       0,    35,    36,    37,     0,    14,    15,    82,    16,    83,
+      84,    85,    86,    87,     0,    18,    19,    88,    20,     0,
+      21,    89,    90,     0,     0,     0,     0,     0,     0,    79,
+       0,     0,     0,     0,     0,     0,    91,    92,    22,    11,
+      12,     0,    81,    13,     0,   217,    23,    24,    25,    26,
+      27,    28,     0,     0,     0,    29,    93,    30,    31,    94,
+       0,    32,    33,     0,     0,    34,     0,     0,     0,    35,
+      36,    37,     0,    14,    15,    82,    16,    83,    84,    85,
+      86,    87,     0,    18,    19,    88,    20,     0,    21,    89,
+      90,     0,     0,     0,     0,     0,     0,    79,     0,     0,
+       0,     0,     0,     0,    91,    92,    22,    11,    12,     0,
+      81,    13,     0,   218,    23,    24,    25,    26,    27,    28,
+       0,     0,     0,    29,    93,    30,    31,    94,     0,    32,
+      33,     0,     0,    34,     0,     0,     0,    35,    36,    37,
+       0,    14,    15,    82,    16,    83,    84,    85,    86,    87,
+       0,    18,    19,    88,    20,     0,    21,    89,    90,     0,
+       0,     0,     0,     0,     0,    79,     0,     0,     0,     0,
+       0,     0,    91,    92,    22,    11,    12,     0,    81,    13,
+       0,   248,    23,    24,    25,    26,    27,    28,     0,     0,
+       0,    29,    93,    30,    31,    94,     0,    32,    33,     0,
+       0,    34,     0,     0,     0,    35,    36,    37,     0,    14,
+      15,    82,    16,    83,    84,    85,    86,    87,     0,    18,
+      19,    88,    20,     0,    21,    89,    90,     0,     0,     0,
+       0,     0,     0,    79,     0,     0,     0,     0,     0,     0,
+      91,    92,    22,    11,    12,     0,    81,    13,     0,   264,
+      23,    24,    25,    26,    27,    28,     0,     0,     0,    29,
+      93,    30,    31,    94,     0,    32,    33,     0,     0,    34,
+       0,     0,     0,    35,    36,    37,     0,    14,    15,    82,
+      16,    83,    84,    85,    86,    87,     0,    18,    19,    88,
+      20,     0,    21,    89,    90,     0,     0,     0,     0,     0,
+       0,     0,     0,    79,     0,     0,     0,     0,    91,    92,
+      22,   288,     0,    11,    12,     0,    81,    13,    23,    24,
+      25,    26,    27,    28,     0,     0,     0,    29,    93,    30,
+      31,    94,     0,    32,    33,     0,     0,    34,     0,     0,
+       0,    35,    36,    37,     0,     0,     0,    14,    15,    82,
+      16,    83,    84,    85,    86,    87,     0,    18,    19,    88,
+      20,     0,    21,    89,    90,     0,     0,     0,     0,     0,
+       0,    79,     0,     0,     0,     0,     0,     0,    91,    92,
+      22,    11,    12,     0,    81,    13,     0,   343,    23,    24,
+      25,    26,    27,    28,     0,     0,     0,    29,    93,    30,
+      31,    94,     0,    32,    33,     0,     0,    34,     0,     0,
+       0,    35,    36,    37,     0,    14,    15,    82,    16,    83,
+      84,    85,    86,    87,     0,    18,    19,    88,    20,     0,
+      21,    89,    90,     0,     0,     0,     0,     0,     0,    79,
+       0,     0,     0,     0,     0,     0,    91,    92,    22,    11,
+      12,     0,    81,    13,     0,   356,    23,    24,    25,    26,
+      27,    28,     0,     0,     0,    29,    93,    30,    31,    94,
+       0,    32,    33,     0,     0,    34,     0,     0,     0,    35,
+      36,    37,     0,    14,    15,    82,    16,    83,    84,    85,
+      86,    87,     0,    18,    19,    88,    20,     0,    21,    89,
+      90,     0,     0,     0,     0,     0,     0,    79,     0,     0,
+       0,     0,     0,     0,    91,    92,    22,    11,    12,     0,
+      81,    13,     0,     0,    23,    24,    25,    26,    27,    28,
+       0,     0,     0,    29,    93,    30,    31,    94,     0,    32,
+      33,     0,     0,    34,     0,     0,     0,    35,    36,    37,
+       0,    14,    15,    82,    16,    83,    84,    85,    86,    87,
+       0,    18,    19,    88,    20,    79,    21,    89,    90,     0,
+       0,     0,     0,     0,     0,     0,    12,     0,   -31,    13,
+       0,     0,    91,    92,    22,     0,     0,     0,     0,     0,
+       0,     0,    23,    24,    25,    26,    27,    28,     0,     0,
+       0,    29,    93,    30,    31,    94,     0,    32,    33,    14,
+      15,    34,    16,     0,    84,    35,    36,    37,     0,    18,
+      19,     0,    20,    79,    21,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    12,     0,     0,    13,   -31,     0,
+      91,    92,    22,     0,     0,     0,     0,     0,     0,     0,
+      23,    24,    25,    26,    27,    28,     0,     0,     0,    29,
+       0,    30,    31,     0,     0,    32,    33,    14,    15,    34,
+      16,     0,    84,    35,    36,    37,     0,    18,    19,     0,
+      20,     0,    21,     0,     0,     0,     0,     9,    10,     0,
+       0,    11,    12,     0,     0,    13,     0,     0,    91,    92,
+      22,     0,     0,     0,     0,     0,     0,     0,    23,    24,
+      25,    26,    27,    28,     0,     0,     0,    29,     0,    30,
+      31,     0,     0,    32,    33,    14,    15,    34,    16,     0,
+       0,    35,    36,    37,    17,    18,    19,     0,    20,     0,
+      21,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    22,     0,
+       0,     0,     0,     0,     0,     0,    23,    24,    25,    26,
+      27,    28,     0,     0,     0,    29,     0,    30,    31,     0,
+       0,    32,    33,   156,     0,    34,    57,   108,   159,    35,
+      36,    37,     0,     0,     0,     0,     0,   109,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,   110,
+     111,     0,   112,   113,   114,   115,   116,   117,   118,    14,
+      15,     0,    16,     0,     0,     0,     0,     0,     0,    18,
+      19,     0,    20,     0,    21,     0,     0,     0,     0,     0,
+       0,   156,     0,     0,    12,     0,   159,    13,     0,     0,
+       0,     0,    22,     0,     0,     0,     0,     0,     0,     0,
+      23,    24,    25,    26,    27,    28,     0,   119,     0,    29,
+       0,    30,    31,     0,     0,    32,    33,    14,    15,    58,
+      16,     0,     0,    35,    36,    37,     0,    18,    19,     0,
+      20,     0,    21,     0,     0,     0,     0,     0,     0,   202,
+       0,     0,    12,     0,     0,    13,     0,     0,     0,     0,
+      22,     0,     0,     0,     0,     0,     0,     0,    23,    24,
+      25,    26,    27,    28,     0,     0,     0,    29,     0,    30,
+      31,     0,     0,    32,    33,    14,    15,    34,    16,     0,
+       0,    35,    36,    37,     0,    18,    19,     0,    20,     0,
+      21,     0,     0,     0,     0,     0,     0,   204,     0,     0,
+      12,     0,     0,    13,     0,     0,     0,     0,    22,     0,
+       0,     0,     0,     0,     0,     0,    23,    24,    25,    26,
+      27,    28,     0,     0,     0,    29,     0,    30,    31,     0,
+       0,    32,    33,    14,    15,    34,    16,     0,     0,    35,
+      36,    37,     0,    18,    19,     0,    20,     0,    21,     0,
+       0,     0,     0,     0,     0,   219,     0,     0,    12,     0,
+       0,    13,     0,     0,     0,     0,    22,     0,     0,     0,
+       0,     0,     0,     0,    23,    24,    25,    26,    27,    28,
+       0,     0,     0,    29,     0,    30,    31,     0,     0,    32,
+      33,    14,    15,    34,    16,     0,     0,    35,    36,    37,
+       0,    18,    19,     0,    20,     0,    21,     0,     0,     0,
+       0,     0,     0,   202,     0,     0,   292,     0,     0,    13,
+       0,     0,     0,     0,    22,     0,     0,     0,     0,     0,
+       0,     0,    23,    24,    25,    26,    27,    28,     0,     0,
+       0,    29,     0,    30,    31,     0,     0,    32,    33,    14,
+      15,    34,    16,     0,     0,    35,    36,    37,     0,    18,
+      19,     0,    20,     0,    21,     0,     0,     0,     0,     0,
+       0,   204,     0,     0,   292,     0,     0,    13,     0,     0,
+       0,     0,    22,     0,     0,     0,     0,     0,     0,     0,
+      23,    24,    25,    26,    27,    28,     0,     0,     0,    29,
+       0,    30,    31,     0,     0,    32,    33,    14,    15,    34,
+      16,     0,     0,    35,    36,    37,     0,    18,    19,     0,
+      20,     0,    21,     0,     0,     0,     0,     0,     0,   219,
+       0,     0,   292,     0,     0,    13,     0,     0,     0,     0,
+      22,     0,     0,     0,     0,     0,     0,     0,    23,    24,
+      25,    26,    27,    28,     0,     0,     0,    29,     0,    30,
+      31,     0,     0,    32,    33,    14,    15,    34,    16,     0,
+       0,    35,    36,    37,     0,    18,    19,     0,    20,     0,
+      21,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    22,     0,
+       0,     0,     0,     0,     0,     0,    23,    24,    25,    26,
+      27,    28,     0,     0,     0,    29,     0,    30,    31,     0,
+       0,    32,    33,     0,     0,    34,     0,     0,     0,    35,
+      36,    37,   136,     0,    57,   108,     0,     0,   137,     0,
+       0,     0,     0,     0,     0,   109,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   110,   111,     0,
+     112,   113,   114,   115,   116,   117,   118,    14,    15,     0,
+      16,     0,     0,     0,     0,     0,     0,    18,    19,     0,
+      20,     0,    21,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      22,     0,     0,     0,     0,     0,     0,     0,    23,    24,
+      25,    26,    27,    28,     0,   119,     0,    29,     0,    30,
+      31,     0,     0,    32,    33,     0,     0,    58,     0,     0,
+       0,    35,    36,    37,   136,     0,    57,   108,     0,     0,
+     317,     0,     0,     0,     0,     0,     0,   109,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,   110,
+     111,     0,   112,   113,   114,   115,   116,   117,   118,    14,
+      15,     0,    16,     0,     0,     0,     0,     0,     0,    18,
+      19,     0,    20,     0,    21,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    22,     0,     0,     0,     0,     0,     0,     0,
+      23,    24,    25,    26,    27,    28,     0,   119,     0,    29,
+       0,    30,    31,     0,     0,    32,    33,     0,     0,    58,
+       0,     0,     0,    35,    36,    37,   136,     0,    57,   108,
+       0,     0,   328,     0,     0,     0,     0,     0,     0,   109,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   110,   111,     0,   112,   113,   114,   115,   116,   117,
+     118,    14,    15,     0,    16,     0,     0,     0,     0,     0,
+       0,    18,    19,     0,    20,     0,    21,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    22,     0,     0,     0,     0,     0,
+       0,     0,    23,    24,    25,    26,    27,    28,     0,   119,
+       0,    29,     0,    30,    31,     0,     0,    32,    33,     0,
+       0,    58,     0,     0,     0,    35,    36,    37,   136,     0,
+      57,   108,     0,     0,   330,     0,     0,     0,     0,     0,
+       0,   109,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,   110,   111,     0,   112,   113,   114,   115,
+     116,   117,   118,    14,    15,     0,    16,     0,     0,     0,
+       0,     0,     0,    18,    19,     0,    20,     0,    21,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    22,     0,     0,     0,
+       0,     0,     0,     0,    23,    24,    25,    26,    27,    28,
+       0,   119,     0,    29,     0,    30,    31,     0,     0,    32,
+      33,     0,   136,    58,    57,   108,     0,    35,    36,    37,
+       0,     0,     0,     0,     0,   109,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   110,   111,     0,
+     112,   113,   114,   115,   116,   117,   118,    14,    15,     0,
+      16,     0,     0,     0,     0,     0,     0,    18,    19,     0,
+      20,     0,    21,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      22,     0,     0,     0,     0,     0,     0,     0,    23,    24,
+      25,    26,    27,    28,     0,   119,     0,    29,     0,    30,
+      31,     0,     0,    32,    33,    57,   108,    58,     0,   137,
+       0,    35,    36,    37,     0,     0,   109,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,   110,   111,
+       0,   112,   113,   114,   115,   116,   117,   118,    14,    15,
+       0,    16,     0,     0,     0,     0,     0,     0,    18,    19,
+       0,    20,     0,    21,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    22,     0,     0,     0,     0,     0,     0,     0,    23,
+      24,    25,    26,    27,    28,     0,   119,     0,    29,     0,
+      30,    31,     0,     0,    32,    33,    57,   108,    58,     0,
+       0,     0,    35,    36,    37,     0,     0,   109,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,   110,
+     111,     0,   112,   113,   114,   115,   116,   117,   118,    14,
+      15,     0,    16,     0,     0,     0,     0,     0,     0,    18,
+      19,     0,    20,     0,    21,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    22,     0,     0,     0,     0,     0,     0,     0,
+      23,    24,    25,    26,    27,    28,     0,   119,   266,    29,
+       0,    30,    31,     0,     0,    32,    33,    57,   108,    58,
+       0,   273,     0,    35,    36,    37,     0,     0,   109,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     110,   111,     0,   112,   113,   114,   115,   116,   117,   118,
+      14,    15,     0,    16,     0,     0,     0,     0,     0,     0,
+      18,    19,     0,    20,     0,    21,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    22,     0,     0,     0,     0,     0,     0,
+       0,    23,    24,    25,    26,    27,    28,     0,   119,     0,
+      29,     0,    30,    31,     0,     0,    32,    33,    57,   108,
+      58,     0,   311,     0,    35,    36,    37,     0,     0,   109,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   110,   111,     0,   112,   113,   114,   115,   116,   117,
+     118,    14,    15,     0,    16,     0,     0,     0,     0,     0,
+       0,    18,    19,     0,    20,     0,    21,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    22,     0,     0,     0,     0,     0,
+       0,     0,    23,    24,    25,    26,    27,    28,     0,   119,
+       0,    29,     0,    30,    31,     0,     0,    32,    33,    57,
+     108,    58,     0,   313,     0,    35,    36,    37,     0,     0,
+     109,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   110,   111,     0,   112,   113,   114,   115,   116,
+     117,   118,    14,    15,     0,    16,     0,     0,     0,     0,
+       0,     0,    18,    19,     0,    20,     0,    21,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    22,     0,     0,     0,     0,
+       0,     0,     0,    23,    24,    25,    26,    27,    28,     0,
+     119,     0,    29,     0,    30,    31,     0,     0,    32,    33,
+      57,   108,    58,     0,   347,     0,    35,    36,    37,     0,
+       0,   109,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,   110,   111,     0,   112,   113,   114,   115,
+     116,   117,   118,    14,    15,     0,    16,     0,     0,     0,
+       0,     0,     0,    18,    19,     0,    20,     0,    21,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    22,     0,     0,     0,
+       0,     0,     0,     0,    23,    24,    25,    26,    27,    28,
+       0,   119,     0,    29,     0,    30,    31,     0,     0,    32,
+      33,    57,   108,    58,     0,   349,     0,    35,    36,    37,
+       0,     0,   109,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,   110,   111,     0,   112,   113,   114,
+     115,   116,   117,   118,    14,    15,     0,    16,     0,     0,
+       0,     0,     0,     0,    18,    19,     0,    20,     0,    21,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    22,     0,     0,
+       0,     0,     0,     0,     0,    23,    24,    25,    26,    27,
+      28,     0,   119,     0,    29,     0,    30,    31,     0,     0,
+      32,    33,     0,     0,    58,    57,   108,   351,    35,    36,
+      37,     0,     0,     0,     0,     0,   109,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,   110,   111,
+       0,   112,   113,   114,   115,   116,   117,   118,    14,    15,
+       0,    16,     0,     0,     0,     0,     0,     0,    18,    19,
+       0,    20,     0,    21,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    22,     0,     0,     0,     0,     0,     0,     0,    23,
+      24,    25,    26,    27,    28,     0,   119,     0,    29,     0,
+      30,    31,     0,     0,    32,    33,    57,   108,    58,     0,
+     360,     0,    35,    36,    37,     0,     0,   109,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,   110,
+     111,     0,   112,   113,   114,   115,   116,   117,   118,    14,
+      15,     0,    16,     0,     0,     0,     0,     0,     0,    18,
+      19,     0,    20,     0,    21,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    22,     0,     0,     0,     0,     0,     0,     0,
+      23,    24,    25,    26,    27,    28,     0,   119,     0,    29,
+       0,    30,    31,     0,     0,    32,    33,    57,   108,    58,
+       0,     0,     0,    35,    36,    37,     0,     0,   109,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     110,   111,     0,   112,   113,   114,   115,   116,   117,   118,
+      14,    15,     0,    16,     0,     0,     0,     0,     0,     0,
+      18,    19,     0,    20,     0,    21,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    22,     0,     0,     0,     0,     0,     0,
+       0,    23,    24,    25,    26,    27,    28,     0,   119,     0,
+      29,     0,    30,    31,     0,     0,    32,    33,    57,   108,
+      58,     0,     0,     0,    35,    36,    37,     0,     0,   109,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   110,     0,     0,   112,   113,   114,   115,   116,   117,
+     118,    14,    15,     0,    16,     0,     0,     0,     0,     0,
+       0,    18,    19,     0,    20,     0,    21,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    22,     0,     0,     0,     0,     0,
+       0,     0,    23,    24,    25,    26,    27,    28,    57,   108,
+       0,    29,     0,    30,    31,     0,     0,    32,    33,   109,
+       0,    58,     0,     0,     0,    35,    36,    37,     0,     0,
+       0,     0,     0,     0,   112,   113,   114,   115,   116,   117,
+     118,    14,    15,     0,    16,     0,     0,     0,     0,     0,
+       0,    18,    19,     0,    20,     0,    21,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    22,     0,     0,     0,     0,     0,
+       0,     0,    23,    24,    25,    26,    27,    28,    57,   -32,
+       0,    29,     0,    30,    31,     0,     0,    32,    33,   -32,
+       0,    58,     0,     0,     0,    35,    36,    37,     0,     0,
+       0,     0,     0,     0,   -32,   -32,   -32,   -32,   -32,   -32,
+     -32,    14,    15,     0,    16,     0,     0,     0,     0,     0,
+       0,    18,    19,     0,    20,     0,    21,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    22,     0,     0,     0,     0,    57,
+       0,     0,    23,    24,    25,    26,    27,    28,     0,     0,
+     251,     0,     0,    30,    31,     0,     0,    32,    33,     0,
+       0,    58,   110,   111,     0,    35,    36,    37,     0,     0,
+       0,   252,    14,    15,     0,    16,     0,     0,     0,     0,
+       0,     0,    18,    19,     0,    20,     0,    21,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    22,     0,     0,     0,     0,
+       0,     0,     0,    23,    24,    25,    26,    27,    28,    57,
+     253,   326,    29,     0,    30,    31,     0,     0,    32,    33,
+     251,     0,    58,     0,     0,     0,    35,    36,    37,     0,
+       0,     0,   110,   111,     0,     0,     0,     0,     0,     0,
+       0,   252,    14,    15,     0,    16,     0,     0,     0,     0,
+       0,     0,    18,    19,     0,    20,     0,    21,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    22,     0,     0,    57,     0,
+       0,     0,     0,    23,    24,    25,    26,    27,    28,   251,
+     253,     0,    29,     0,    30,    31,     0,     0,    32,    33,
+       0,   110,    58,     0,     0,     0,    35,    36,    37,     0,
+     252,    14,    15,     0,    16,     0,     0,     0,     0,     0,
+       0,    18,    19,     0,    20,     0,    21,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    12,     0,     0,    13,
+     142,     0,     0,     0,    22,     0,     0,     0,     0,     0,
+       0,     0,    23,    24,    25,    26,    27,    28,     0,     0,
+       0,    29,     0,    30,    31,     0,     0,    32,    33,    14,
+      15,    58,    16,     0,     0,    35,    36,    37,     0,    18,
+      19,     0,    20,     0,    21,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    12,     0,     0,    13,   150,     0,
+       0,     0,    22,     0,     0,     0,     0,     0,     0,     0,
+      23,    24,    25,    26,    27,    28,     0,     0,     0,    29,
+       0,    30,    31,     0,     0,    32,    33,    14,    15,    34,
+      16,     0,     0,    35,    36,    37,     0,    18,    19,     0,
+      20,     0,    21,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      22,     0,     0,    57,     0,     0,     0,     0,    23,    24,
+      25,    26,    27,    28,   251,     0,     0,    29,     0,    30,
+      31,     0,     0,    32,    33,     0,     0,    34,     0,     0,
+       0,    35,    36,    37,     0,   252,    14,    15,     0,    16,
+       0,     0,     0,     0,     0,     0,    18,    19,     0,    20,
+       0,    21,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    12,     0,     0,    13,     0,     0,     0,     0,    22,
+       0,     0,     0,     0,     0,     0,     0,    23,    24,    25,
+      26,    27,    28,     0,     0,     0,    29,     0,    30,    31,
+       0,     0,    32,    33,    14,    15,    58,    16,     0,     0,
+      35,    36,    37,     0,    18,    19,     0,    20,     0,    21,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    57,
+       0,     0,    13,     0,     0,     0,     0,    22,     0,     0,
+       0,     0,     0,     0,     0,    23,    24,    25,    26,    27,
+      28,     0,     0,     0,    29,     0,    30,    31,     0,     0,
+      32,    33,    14,    15,    34,    16,     0,     0,    35,    36,
+      37,     0,    18,    19,     0,    20,     0,    21,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   177,     0,     0,
+      13,     0,     0,     0,     0,    22,     0,     0,     0,     0,
+       0,     0,     0,    23,    24,    25,    26,    27,    28,     0,
+       0,     0,    29,     0,    30,    31,     0,     0,    32,    33,
+      14,    15,    34,    16,     0,     0,    35,    36,    37,     0,
+      18,    19,     0,    20,     0,    21,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    57,     0,     0,     0,     0,
+       0,     0,     0,    22,     0,     0,     0,     0,     0,     0,
+       0,    23,    24,    25,    26,    27,    28,     0,     0,     0,
+      29,     0,    30,    31,     0,     0,    32,    33,    14,    15,
+      34,    16,     0,     0,    35,    36,    37,     0,    18,    19,
+       0,    20,     0,    21,     0,     0,     0,     0,     0,     0,
+       0,     0,   208,   292,     0,     0,    13,     0,     0,     0,
+       0,    22,     0,     0,     0,     0,     0,     0,     0,    23,
+      24,    25,    26,    27,    28,     0,     0,     0,    29,     0,
+      30,    31,     0,     0,    32,    33,    14,    15,    58,    16,
+       0,     0,    35,    36,    37,     0,    18,    19,     0,    20,
+       0,    21,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    22,
+       0,     0,    57,     0,     0,     0,     0,    23,    24,    25,
+      26,    27,    28,   -32,     0,     0,    29,     0,    30,    31,
+       0,     0,    32,    33,     0,     0,    34,     0,     0,     0,
+      35,    36,    37,     0,   -32,    14,    15,     0,    16,     0,
+       0,     0,     0,     0,     0,    18,    19,     0,    20,     0,
+      21,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      57,     0,     0,     0,     0,     0,     0,     0,    22,     0,
+       0,     0,     0,     0,     0,     0,    23,    24,    25,    26,
+      27,    28,     0,     0,     0,     0,     0,    30,    31,     0,
+       0,    32,    33,    14,    15,    58,    16,     0,     0,    35,
+      36,    37,     0,    18,    19,     0,    20,     0,    21,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    22,     0,     0,     0,
+       0,     0,     0,     0,    23,    24,    25,    26,    27,    28,
+       0,     0,     0,    29,     0,    30,    31,     0,     0,    32,
+      33,     0,     0,    58,     0,     0,     0,    35,    36,    37
+};
+
+static const yytype_int16 yycheck[] =
+{
+      16,     5,    34,   166,     9,     9,    10,   177,    81,    15,
+       9,    51,    52,    29,     9,   105,    32,    33,    34,    35,
+      36,    37,    18,   336,   109,    10,    42,    66,    67,     0,
+      42,    10,   105,    45,    19,    39,    45,    53,   123,   242,
+      19,   244,    58,    13,    86,   358,    45,    89,    44,   178,
+      45,    11,    68,    83,    18,    10,    86,    15,    98,    89,
+      90,    16,    12,    93,    45,    12,   106,    37,   100,   159,
+      40,   101,    10,    92,    86,    87,    88,    86,    16,    88,
+      69,    86,   178,    99,   100,    69,   159,    86,    12,    88,
+      12,    86,    87,    88,   133,   101,   102,   103,   104,   111,
+      10,    11,   108,   107,    12,    86,    87,    88,   124,   125,
+     126,   127,   128,   129,    53,    54,   111,    10,    10,   322,
+     109,   110,   292,    16,    16,   109,   110,    10,   144,   145,
+     111,   147,   148,    16,   164,    10,    10,   153,   154,   155,
+     170,    16,    16,   228,   229,   103,   104,   350,   164,    10,
+     108,     9,     9,     9,   170,    16,    14,    14,    14,   362,
+       9,    12,   178,    42,   293,    14,   251,   296,   297,   298,
+     299,    84,    12,   336,   303,   191,   192,    12,   194,   195,
+     196,   197,   198,   199,    12,   201,     9,   203,   108,   205,
+     206,    12,   208,   283,    12,   358,    12,   293,   237,   215,
+     296,   297,   298,   299,   220,   118,   222,   303,   147,   148,
+     283,   109,   110,   342,     9,   154,   155,    95,    44,   251,
+      86,   253,   254,   255,    15,   257,   242,     9,   244,   261,
+     320,   316,    18,    79,    10,   251,    14,   253,   254,   255,
+     179,   257,   258,   259,   260,   261,   342,   320,     9,     9,
+      16,    16,    99,   166,    44,    12,   272,    16,    16,   263,
+     276,   351,   278,    16,   304,   281,    16,   206,   207,   251,
+      41,   253,   254,   255,   188,   257,   107,   293,   351,   261,
+     296,   297,   298,   299,    -1,    -1,    16,   303,   227,   305,
+     306,   307,   332,    -1,   326,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    32,    33,    34,    -1,   310,    37,   221,    -1,
+     326,   250,    42,   329,    -1,   331,    -1,   333,    -1,   335,
+     233,   337,    -1,    53,    -1,    -1,   342,    -1,    58,    -1,
+     360,    -1,    -1,    -1,    -1,    -1,    -1,   353,    68,   252,
+      -1,   280,   281,    -1,   326,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,   306,   307,    99,
+     100,   284,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   325,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   124,   125,   126,   127,   128,   129,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    97,    -1,    -1,
+      -1,   324,    -1,   103,   144,   145,    -1,   147,   148,    -1,
+      -1,    -1,    -1,   153,   154,   155,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   164,    -1,    -1,    -1,    -1,    -1,
+     170,    -1,    -1,    -1,   134,   135,    -1,    -1,   178,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   192,    -1,   194,   195,   196,   197,   198,   199,
+      -1,   201,    -1,   203,    -1,   205,   206,    -1,   208,    -1,
+      -1,    -1,    -1,    -1,   174,   215,   176,    -1,    -1,    -1,
+     220,    -1,   222,    -1,    -1,    -1,    -1,   187,    -1,   189,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   242,    -1,   244,    -1,    -1,    -1,    -1,    -1,
+      -1,   251,    -1,   253,   254,   255,    -1,   257,   258,   259,
+     260,   261,     5,    -1,    -1,    -1,    -1,    -1,    -1,    12,
+      -1,    -1,   272,    -1,    -1,    -1,   276,    -1,   278,    -1,
+      -1,   281,    -1,    -1,    -1,    -1,    -1,   247,    -1,    -1,
+      -1,    -1,    -1,   293,    -1,    -1,   296,   297,   298,   299,
+      -1,    -1,    -1,   303,    -1,   305,   306,   307,    -1,    -1,
+      -1,    -1,    -1,    56,    57,    -1,    -1,    -1,    -1,    -1,
+      -1,    64,    65,    66,    67,    -1,   326,    70,    71,    -1,
+      -1,    -1,    -1,   333,    -1,   335,    -1,   337,    -1,    -1,
+      -1,    -1,   342,    86,    -1,    -1,    -1,    -1,    -1,    -1,
+      93,    -1,    -1,   353,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   107,    -1,   109,   327,    -1,   112,
+     113,   114,   115,   116,   117,    -1,   119,   120,   121,    -1,
+     123,    -1,    -1,    -1,    -1,    -1,   346,   130,    -1,    -1,
+     133,    -1,   352,    -1,    -1,   138,    -1,   140,    -1,    -1,
+      -1,   361,    -1,    -1,    -1,    -1,   366,    -1,    -1,    -1,
+      -1,     0,     1,    -1,    -1,    -1,    -1,    -1,     7,     8,
+       9,    -1,    11,    12,   167,    14,    15,    -1,    -1,   172,
+      -1,    -1,    -1,    -1,   177,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,   188,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    45,    46,    -1,    48,
+      -1,    -1,    -1,    -1,    -1,    54,    55,    56,    -1,    58,
+      -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   225,    -1,    -1,   228,   229,    -1,    -1,    78,
+      -1,   234,    -1,    -1,   237,    -1,    -1,    86,    87,    88,
+      89,    90,    91,    -1,    -1,    -1,    95,    -1,    97,    98,
+      -1,    -1,   101,   102,    -1,    -1,   105,    -1,    -1,    -1,
+     109,   110,   111,   266,   267,   268,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,     1,    -1,    -1,    -1,    -1,    -1,   292,
+      -1,     9,    -1,    11,    12,    -1,    14,    15,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,   316,    -1,   318,    -1,    -1,   321,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    45,    46,    47,
+      48,    49,    50,    51,    52,    53,   339,    55,    56,    57,
+      58,    -1,    60,    61,    62,    -1,    -1,    -1,    -1,    -1,
+      -1,     1,    -1,    -1,    -1,    -1,    -1,    -1,    76,    77,
+      78,    11,    12,    -1,    14,    15,    -1,    17,    86,    87,
+      88,    89,    90,    91,    -1,    -1,    -1,    95,    96,    97,
+      98,    99,    -1,   101,   102,    -1,    -1,   105,    -1,    -1,
+      -1,   109,   110,   111,    -1,    45,    46,    47,    48,    49,
+      50,    51,    52,    53,    -1,    55,    56,    57,    58,    -1,
+      60,    61,    62,    -1,    -1,    -1,    -1,    -1,    -1,     1,
+      -1,    -1,    -1,    -1,    -1,    -1,    76,    77,    78,    11,
+      12,    -1,    14,    15,    -1,    17,    86,    87,    88,    89,
+      90,    91,    -1,    -1,    -1,    95,    96,    97,    98,    99,
+      -1,   101,   102,    -1,    -1,   105,    -1,    -1,    -1,   109,
+     110,   111,    -1,    45,    46,    47,    48,    49,    50,    51,
+      52,    53,    -1,    55,    56,    57,    58,    -1,    60,    61,
+      62,    -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,    -1,
+      -1,    -1,    -1,    -1,    76,    77,    78,    11,    12,    -1,
+      14,    15,    -1,    17,    86,    87,    88,    89,    90,    91,
+      -1,    -1,    -1,    95,    96,    97,    98,    99,    -1,   101,
+     102,    -1,    -1,   105,    -1,    -1,    -1,   109,   110,   111,
+      -1,    45,    46,    47,    48,    49,    50,    51,    52,    53,
+      -1,    55,    56,    57,    58,    -1,    60,    61,    62,    -1,
+      -1,    -1,    -1,    -1,    -1,     1,    -1,    -1,    -1,    -1,
+      -1,    -1,    76,    77,    78,    11,    12,    -1,    14,    15,
+      -1,    17,    86,    87,    88,    89,    90,    91,    -1,    -1,
+      -1,    95,    96,    97,    98,    99,    -1,   101,   102,    -1,
+      -1,   105,    -1,    -1,    -1,   109,   110,   111,    -1,    45,
+      46,    47,    48,    49,    50,    51,    52,    53,    -1,    55,
+      56,    57,    58,    -1,    60,    61,    62,    -1,    -1,    -1,
+      -1,    -1,    -1,     1,    -1,    -1,    -1,    -1,    -1,    -1,
+      76,    77,    78,    11,    12,    -1,    14,    15,    -1,    17,
+      86,    87,    88,    89,    90,    91,    -1,    -1,    -1,    95,
+      96,    97,    98,    99,    -1,   101,   102,    -1,    -1,   105,
+      -1,    -1,    -1,   109,   110,   111,    -1,    45,    46,    47,
+      48,    49,    50,    51,    52,    53,    -1,    55,    56,    57,
+      58,    -1,    60,    61,    62,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,     1,    -1,    -1,    -1,    -1,    76,    77,
+      78,     9,    -1,    11,    12,    -1,    14,    15,    86,    87,
+      88,    89,    90,    91,    -1,    -1,    -1,    95,    96,    97,
+      98,    99,    -1,   101,   102,    -1,    -1,   105,    -1,    -1,
+      -1,   109,   110,   111,    -1,    -1,    -1,    45,    46,    47,
+      48,    49,    50,    51,    52,    53,    -1,    55,    56,    57,
+      58,    -1,    60,    61,    62,    -1,    -1,    -1,    -1,    -1,
+      -1,     1,    -1,    -1,    -1,    -1,    -1,    -1,    76,    77,
+      78,    11,    12,    -1,    14,    15,    -1,    17,    86,    87,
+      88,    89,    90,    91,    -1,    -1,    -1,    95,    96,    97,
+      98,    99,    -1,   101,   102,    -1,    -1,   105,    -1,    -1,
+      -1,   109,   110,   111,    -1,    45,    46,    47,    48,    49,
+      50,    51,    52,    53,    -1,    55,    56,    57,    58,    -1,
+      60,    61,    62,    -1,    -1,    -1,    -1,    -1,    -1,     1,
+      -1,    -1,    -1,    -1,    -1,    -1,    76,    77,    78,    11,
+      12,    -1,    14,    15,    -1,    17,    86,    87,    88,    89,
+      90,    91,    -1,    -1,    -1,    95,    96,    97,    98,    99,
+      -1,   101,   102,    -1,    -1,   105,    -1,    -1,    -1,   109,
+     110,   111,    -1,    45,    46,    47,    48,    49,    50,    51,
+      52,    53,    -1,    55,    56,    57,    58,    -1,    60,    61,
+      62,    -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,    -1,
+      -1,    -1,    -1,    -1,    76,    77,    78,    11,    12,    -1,
+      14,    15,    -1,    -1,    86,    87,    88,    89,    90,    91,
+      -1,    -1,    -1,    95,    96,    97,    98,    99,    -1,   101,
+     102,    -1,    -1,   105,    -1,    -1,    -1,   109,   110,   111,
+      -1,    45,    46,    47,    48,    49,    50,    51,    52,    53,
+      -1,    55,    56,    57,    58,     1,    60,    61,    62,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    12,    -1,    14,    15,
+      -1,    -1,    76,    77,    78,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    86,    87,    88,    89,    90,    91,    -1,    -1,
+      -1,    95,    96,    97,    98,    99,    -1,   101,   102,    45,
+      46,   105,    48,    -1,    50,   109,   110,   111,    -1,    55,
+      56,    -1,    58,     1,    60,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    12,    -1,    -1,    15,    16,    -1,
+      76,    77,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      86,    87,    88,    89,    90,    91,    -1,    -1,    -1,    95,
+      -1,    97,    98,    -1,    -1,   101,   102,    45,    46,   105,
+      48,    -1,    50,   109,   110,   111,    -1,    55,    56,    -1,
+      58,    -1,    60,    -1,    -1,    -1,    -1,     7,     8,    -1,
+      -1,    11,    12,    -1,    -1,    15,    -1,    -1,    76,    77,
+      78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,    87,
+      88,    89,    90,    91,    -1,    -1,    -1,    95,    -1,    97,
+      98,    -1,    -1,   101,   102,    45,    46,   105,    48,    -1,
+      -1,   109,   110,   111,    54,    55,    56,    -1,    58,    -1,
+      60,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    86,    87,    88,    89,
+      90,    91,    -1,    -1,    -1,    95,    -1,    97,    98,    -1,
+      -1,   101,   102,     9,    -1,   105,    12,    13,    14,   109,
+     110,   111,    -1,    -1,    -1,    -1,    -1,    23,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    35,
+      36,    -1,    38,    39,    40,    41,    42,    43,    44,    45,
+      46,    -1,    48,    -1,    -1,    -1,    -1,    -1,    -1,    55,
+      56,    -1,    58,    -1,    60,    -1,    -1,    -1,    -1,    -1,
+      -1,     9,    -1,    -1,    12,    -1,    14,    15,    -1,    -1,
+      -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      86,    87,    88,    89,    90,    91,    -1,    93,    -1,    95,
+      -1,    97,    98,    -1,    -1,   101,   102,    45,    46,   105,
+      48,    -1,    -1,   109,   110,   111,    -1,    55,    56,    -1,
+      58,    -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,     9,
+      -1,    -1,    12,    -1,    -1,    15,    -1,    -1,    -1,    -1,
+      78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,    87,
+      88,    89,    90,    91,    -1,    -1,    -1,    95,    -1,    97,
+      98,    -1,    -1,   101,   102,    45,    46,   105,    48,    -1,
+      -1,   109,   110,   111,    -1,    55,    56,    -1,    58,    -1,
+      60,    -1,    -1,    -1,    -1,    -1,    -1,     9,    -1,    -1,
+      12,    -1,    -1,    15,    -1,    -1,    -1,    -1,    78,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    86,    87,    88,    89,
+      90,    91,    -1,    -1,    -1,    95,    -1,    97,    98,    -1,
+      -1,   101,   102,    45,    46,   105,    48,    -1,    -1,   109,
+     110,   111,    -1,    55,    56,    -1,    58,    -1,    60,    -1,
+      -1,    -1,    -1,    -1,    -1,     9,    -1,    -1,    12,    -1,
+      -1,    15,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    86,    87,    88,    89,    90,    91,
+      -1,    -1,    -1,    95,    -1,    97,    98,    -1,    -1,   101,
+     102,    45,    46,   105,    48,    -1,    -1,   109,   110,   111,
+      -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,
+      -1,    -1,    -1,     9,    -1,    -1,    12,    -1,    -1,    15,
+      -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    86,    87,    88,    89,    90,    91,    -1,    -1,
+      -1,    95,    -1,    97,    98,    -1,    -1,   101,   102,    45,
+      46,   105,    48,    -1,    -1,   109,   110,   111,    -1,    55,
+      56,    -1,    58,    -1,    60,    -1,    -1,    -1,    -1,    -1,
+      -1,     9,    -1,    -1,    12,    -1,    -1,    15,    -1,    -1,
+      -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      86,    87,    88,    89,    90,    91,    -1,    -1,    -1,    95,
+      -1,    97,    98,    -1,    -1,   101,   102,    45,    46,   105,
+      48,    -1,    -1,   109,   110,   111,    -1,    55,    56,    -1,
+      58,    -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,     9,
+      -1,    -1,    12,    -1,    -1,    15,    -1,    -1,    -1,    -1,
+      78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,    87,
+      88,    89,    90,    91,    -1,    -1,    -1,    95,    -1,    97,
+      98,    -1,    -1,   101,   102,    45,    46,   105,    48,    -1,
+      -1,   109,   110,   111,    -1,    55,    56,    -1,    58,    -1,
+      60,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    86,    87,    88,    89,
+      90,    91,    -1,    -1,    -1,    95,    -1,    97,    98,    -1,
+      -1,   101,   102,    -1,    -1,   105,    -1,    -1,    -1,   109,
+     110,   111,    10,    -1,    12,    13,    -1,    -1,    16,    -1,
+      -1,    -1,    -1,    -1,    -1,    23,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    35,    36,    -1,
+      38,    39,    40,    41,    42,    43,    44,    45,    46,    -1,
+      48,    -1,    -1,    -1,    -1,    -1,    -1,    55,    56,    -1,
+      58,    -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,    87,
+      88,    89,    90,    91,    -1,    93,    -1,    95,    -1,    97,
+      98,    -1,    -1,   101,   102,    -1,    -1,   105,    -1,    -1,
+      -1,   109,   110,   111,    10,    -1,    12,    13,    -1,    -1,
+      16,    -1,    -1,    -1,    -1,    -1,    -1,    23,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    35,
+      36,    -1,    38,    39,    40,    41,    42,    43,    44,    45,
+      46,    -1,    48,    -1,    -1,    -1,    -1,    -1,    -1,    55,
+      56,    -1,    58,    -1,    60,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      86,    87,    88,    89,    90,    91,    -1,    93,    -1,    95,
+      -1,    97,    98,    -1,    -1,   101,   102,    -1,    -1,   105,
+      -1,    -1,    -1,   109,   110,   111,    10,    -1,    12,    13,
+      -1,    -1,    16,    -1,    -1,    -1,    -1,    -1,    -1,    23,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    35,    36,    -1,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    -1,    48,    -1,    -1,    -1,    -1,    -1,
+      -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    86,    87,    88,    89,    90,    91,    -1,    93,
+      -1,    95,    -1,    97,    98,    -1,    -1,   101,   102,    -1,
+      -1,   105,    -1,    -1,    -1,   109,   110,   111,    10,    -1,
+      12,    13,    -1,    -1,    16,    -1,    -1,    -1,    -1,    -1,
+      -1,    23,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    35,    36,    -1,    38,    39,    40,    41,
+      42,    43,    44,    45,    46,    -1,    48,    -1,    -1,    -1,
+      -1,    -1,    -1,    55,    56,    -1,    58,    -1,    60,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    86,    87,    88,    89,    90,    91,
+      -1,    93,    -1,    95,    -1,    97,    98,    -1,    -1,   101,
+     102,    -1,    10,   105,    12,    13,    -1,   109,   110,   111,
+      -1,    -1,    -1,    -1,    -1,    23,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    35,    36,    -1,
+      38,    39,    40,    41,    42,    43,    44,    45,    46,    -1,
+      48,    -1,    -1,    -1,    -1,    -1,    -1,    55,    56,    -1,
+      58,    -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,    87,
+      88,    89,    90,    91,    -1,    93,    -1,    95,    -1,    97,
+      98,    -1,    -1,   101,   102,    12,    13,   105,    -1,    16,
+      -1,   109,   110,   111,    -1,    -1,    23,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    35,    36,
+      -1,    38,    39,    40,    41,    42,    43,    44,    45,    46,
+      -1,    48,    -1,    -1,    -1,    -1,    -1,    -1,    55,    56,
+      -1,    58,    -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,
+      87,    88,    89,    90,    91,    -1,    93,    -1,    95,    -1,
+      97,    98,    -1,    -1,   101,   102,    12,    13,   105,    -1,
+      -1,    -1,   109,   110,   111,    -1,    -1,    23,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    35,
+      36,    -1,    38,    39,    40,    41,    42,    43,    44,    45,
+      46,    -1,    48,    -1,    -1,    -1,    -1,    -1,    -1,    55,
+      56,    -1,    58,    -1,    60,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      86,    87,    88,    89,    90,    91,    -1,    93,    94,    95,
+      -1,    97,    98,    -1,    -1,   101,   102,    12,    13,   105,
+      -1,    16,    -1,   109,   110,   111,    -1,    -1,    23,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      35,    36,    -1,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    -1,    48,    -1,    -1,    -1,    -1,    -1,    -1,
+      55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    86,    87,    88,    89,    90,    91,    -1,    93,    -1,
+      95,    -1,    97,    98,    -1,    -1,   101,   102,    12,    13,
+     105,    -1,    16,    -1,   109,   110,   111,    -1,    -1,    23,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    35,    36,    -1,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    -1,    48,    -1,    -1,    -1,    -1,    -1,
+      -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    86,    87,    88,    89,    90,    91,    -1,    93,
+      -1,    95,    -1,    97,    98,    -1,    -1,   101,   102,    12,
+      13,   105,    -1,    16,    -1,   109,   110,   111,    -1,    -1,
+      23,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    35,    36,    -1,    38,    39,    40,    41,    42,
+      43,    44,    45,    46,    -1,    48,    -1,    -1,    -1,    -1,
+      -1,    -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    86,    87,    88,    89,    90,    91,    -1,
+      93,    -1,    95,    -1,    97,    98,    -1,    -1,   101,   102,
+      12,    13,   105,    -1,    16,    -1,   109,   110,   111,    -1,
+      -1,    23,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    35,    36,    -1,    38,    39,    40,    41,
+      42,    43,    44,    45,    46,    -1,    48,    -1,    -1,    -1,
+      -1,    -1,    -1,    55,    56,    -1,    58,    -1,    60,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    86,    87,    88,    89,    90,    91,
+      -1,    93,    -1,    95,    -1,    97,    98,    -1,    -1,   101,
+     102,    12,    13,   105,    -1,    16,    -1,   109,   110,   111,
+      -1,    -1,    23,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    35,    36,    -1,    38,    39,    40,
+      41,    42,    43,    44,    45,    46,    -1,    48,    -1,    -1,
+      -1,    -1,    -1,    -1,    55,    56,    -1,    58,    -1,    60,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    86,    87,    88,    89,    90,
+      91,    -1,    93,    -1,    95,    -1,    97,    98,    -1,    -1,
+     101,   102,    -1,    -1,   105,    12,    13,    14,   109,   110,
+     111,    -1,    -1,    -1,    -1,    -1,    23,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    35,    36,
+      -1,    38,    39,    40,    41,    42,    43,    44,    45,    46,
+      -1,    48,    -1,    -1,    -1,    -1,    -1,    -1,    55,    56,
+      -1,    58,    -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,
+      87,    88,    89,    90,    91,    -1,    93,    -1,    95,    -1,
+      97,    98,    -1,    -1,   101,   102,    12,    13,   105,    -1,
+      16,    -1,   109,   110,   111,    -1,    -1,    23,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    35,
+      36,    -1,    38,    39,    40,    41,    42,    43,    44,    45,
+      46,    -1,    48,    -1,    -1,    -1,    -1,    -1,    -1,    55,
+      56,    -1,    58,    -1,    60,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      86,    87,    88,    89,    90,    91,    -1,    93,    -1,    95,
+      -1,    97,    98,    -1,    -1,   101,   102,    12,    13,   105,
+      -1,    -1,    -1,   109,   110,   111,    -1,    -1,    23,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      35,    36,    -1,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    -1,    48,    -1,    -1,    -1,    -1,    -1,    -1,
+      55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    86,    87,    88,    89,    90,    91,    -1,    93,    -1,
+      95,    -1,    97,    98,    -1,    -1,   101,   102,    12,    13,
+     105,    -1,    -1,    -1,   109,   110,   111,    -1,    -1,    23,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    35,    -1,    -1,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    -1,    48,    -1,    -1,    -1,    -1,    -1,
+      -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    86,    87,    88,    89,    90,    91,    12,    13,
+      -1,    95,    -1,    97,    98,    -1,    -1,   101,   102,    23,
+      -1,   105,    -1,    -1,    -1,   109,   110,   111,    -1,    -1,
+      -1,    -1,    -1,    -1,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    -1,    48,    -1,    -1,    -1,    -1,    -1,
+      -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    86,    87,    88,    89,    90,    91,    12,    13,
+      -1,    95,    -1,    97,    98,    -1,    -1,   101,   102,    23,
+      -1,   105,    -1,    -1,    -1,   109,   110,   111,    -1,    -1,
+      -1,    -1,    -1,    -1,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    -1,    48,    -1,    -1,    -1,    -1,    -1,
+      -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    12,
+      -1,    -1,    86,    87,    88,    89,    90,    91,    -1,    -1,
+      23,    -1,    -1,    97,    98,    -1,    -1,   101,   102,    -1,
+      -1,   105,    35,    36,    -1,   109,   110,   111,    -1,    -1,
+      -1,    44,    45,    46,    -1,    48,    -1,    -1,    -1,    -1,
+      -1,    -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    86,    87,    88,    89,    90,    91,    12,
+      93,    94,    95,    -1,    97,    98,    -1,    -1,   101,   102,
+      23,    -1,   105,    -1,    -1,    -1,   109,   110,   111,    -1,
+      -1,    -1,    35,    36,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    44,    45,    46,    -1,    48,    -1,    -1,    -1,    -1,
+      -1,    -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    12,    -1,
+      -1,    -1,    -1,    86,    87,    88,    89,    90,    91,    23,
+      93,    -1,    95,    -1,    97,    98,    -1,    -1,   101,   102,
+      -1,    35,   105,    -1,    -1,    -1,   109,   110,   111,    -1,
+      44,    45,    46,    -1,    48,    -1,    -1,    -1,    -1,    -1,
+      -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    12,    -1,    -1,    15,
+      16,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    86,    87,    88,    89,    90,    91,    -1,    -1,
+      -1,    95,    -1,    97,    98,    -1,    -1,   101,   102,    45,
+      46,   105,    48,    -1,    -1,   109,   110,   111,    -1,    55,
+      56,    -1,    58,    -1,    60,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    12,    -1,    -1,    15,    16,    -1,
+      -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      86,    87,    88,    89,    90,    91,    -1,    -1,    -1,    95,
+      -1,    97,    98,    -1,    -1,   101,   102,    45,    46,   105,
+      48,    -1,    -1,   109,   110,   111,    -1,    55,    56,    -1,
+      58,    -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      78,    -1,    -1,    12,    -1,    -1,    -1,    -1,    86,    87,
+      88,    89,    90,    91,    23,    -1,    -1,    95,    -1,    97,
+      98,    -1,    -1,   101,   102,    -1,    -1,   105,    -1,    -1,
+      -1,   109,   110,   111,    -1,    44,    45,    46,    -1,    48,
+      -1,    -1,    -1,    -1,    -1,    -1,    55,    56,    -1,    58,
+      -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    12,    -1,    -1,    15,    -1,    -1,    -1,    -1,    78,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,    87,    88,
+      89,    90,    91,    -1,    -1,    -1,    95,    -1,    97,    98,
+      -1,    -1,   101,   102,    45,    46,   105,    48,    -1,    -1,
+     109,   110,   111,    -1,    55,    56,    -1,    58,    -1,    60,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    12,
+      -1,    -1,    15,    -1,    -1,    -1,    -1,    78,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    86,    87,    88,    89,    90,
+      91,    -1,    -1,    -1,    95,    -1,    97,    98,    -1,    -1,
+     101,   102,    45,    46,   105,    48,    -1,    -1,   109,   110,
+     111,    -1,    55,    56,    -1,    58,    -1,    60,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    12,    -1,    -1,
+      15,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    86,    87,    88,    89,    90,    91,    -1,
+      -1,    -1,    95,    -1,    97,    98,    -1,    -1,   101,   102,
+      45,    46,   105,    48,    -1,    -1,   109,   110,   111,    -1,
+      55,    56,    -1,    58,    -1,    60,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    12,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    86,    87,    88,    89,    90,    91,    -1,    -1,    -1,
+      95,    -1,    97,    98,    -1,    -1,   101,   102,    45,    46,
+     105,    48,    -1,    -1,   109,   110,   111,    -1,    55,    56,
+      -1,    58,    -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    69,    12,    -1,    -1,    15,    -1,    -1,    -1,
+      -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,
+      87,    88,    89,    90,    91,    -1,    -1,    -1,    95,    -1,
+      97,    98,    -1,    -1,   101,   102,    45,    46,   105,    48,
+      -1,    -1,   109,   110,   111,    -1,    55,    56,    -1,    58,
+      -1,    60,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,
+      -1,    -1,    12,    -1,    -1,    -1,    -1,    86,    87,    88,
+      89,    90,    91,    23,    -1,    -1,    95,    -1,    97,    98,
+      -1,    -1,   101,   102,    -1,    -1,   105,    -1,    -1,    -1,
+     109,   110,   111,    -1,    44,    45,    46,    -1,    48,    -1,
+      -1,    -1,    -1,    -1,    -1,    55,    56,    -1,    58,    -1,
+      60,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      12,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    86,    87,    88,    89,
+      90,    91,    -1,    -1,    -1,    -1,    -1,    97,    98,    -1,
+      -1,   101,   102,    45,    46,   105,    48,    -1,    -1,   109,
+     110,   111,    -1,    55,    56,    -1,    58,    -1,    60,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    86,    87,    88,    89,    90,    91,
+      -1,    -1,    -1,    95,    -1,    97,    98,    -1,    -1,   101,
+     102,    -1,    -1,   105,    -1,    -1,    -1,   109,   110,   111
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     1,     9,    14,   114,   129,   131,   143,     0,     7,
+       8,    11,    12,    15,    45,    46,    48,    54,    55,    56,
+      58,    60,    78,    86,    87,    88,    89,    90,    91,    95,
+      97,    98,   101,   102,   105,   109,   110,   111,   126,   132,
+     133,   135,   138,   145,   146,   156,   157,   158,   160,     9,
+      14,   126,   126,   138,   139,   147,    12,    12,   105,   157,
+     158,    86,    89,   124,    12,    12,    12,    12,    42,   158,
+      12,    12,   157,   157,   145,   157,   158,   158,   157,     1,
+       9,    14,    47,    49,    50,    51,    52,    53,    57,    61,
+      62,    76,    77,    96,    99,   118,   120,   125,   126,   138,
+     142,   149,   151,   155,   161,    10,   126,   129,    13,    23,
+      35,    36,    38,    39,    40,    41,    42,    43,    44,    93,
+     115,   116,   157,    12,    15,   101,   102,   103,   104,   108,
+      69,   109,   110,    18,   155,   155,    10,    16,   117,    16,
+     117,    92,    16,   136,   138,   138,    12,   138,   138,   136,
+      16,   136,   157,    42,   138,   138,     9,   127,   128,    14,
+     127,   150,   150,   160,   138,   150,    12,    12,   150,   150,
+     138,   150,    12,     9,   152,   151,   155,    12,   137,   140,
+     141,   145,   157,   158,   150,    17,   151,   154,   128,   155,
+     133,    95,   138,   146,   138,   138,   138,   138,   138,   138,
+     160,   138,     9,   138,     9,   138,   138,   146,    69,   157,
+     157,   157,   157,   157,   157,   138,   136,    17,    17,     9,
+     138,    44,   138,    15,    16,   117,    86,   159,   117,   117,
+      16,    16,   157,   117,   117,     9,   128,    18,   150,   130,
+     149,   160,   138,   150,   138,   151,    79,   119,    17,   144,
+     139,    23,    44,    93,   115,   116,   157,   117,    13,    37,
+      40,    69,   151,   132,    17,   158,    94,   117,   117,   157,
+      19,   160,   138,    16,   117,   148,   138,   146,   138,   146,
+     160,   138,   136,    14,    44,   148,   148,   153,     9,   151,
+       9,    16,    12,   137,   146,   160,   137,   137,   137,   137,
+     157,   157,   157,   137,   126,   138,   138,   138,    86,     9,
+     134,    16,    16,    16,    16,    16,   117,    16,   117,    19,
+      14,   128,   160,    99,    44,   139,    94,   155,    16,   117,
+      16,   117,   126,   138,   146,   138,   128,   138,   148,    12,
+     160,    16,   137,    17,   158,   158,   155,    16,    16,    16,
+     130,    14,   123,   138,    16,    16,    17,   148,   128,   151,
+      16,   122,   130,   150,   151,   148,   121,   151
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,   113,   114,   114,   115,   115,   116,   116,   117,   117,
+     118,   118,   119,   119,   121,   120,   122,   120,   123,   120,
+     124,   124,   125,   126,   126,   127,   127,   128,   128,   129,
+     129,   130,   130,   131,   131,   132,   133,   133,   133,   133,
+     133,   133,   133,   134,   133,   135,   135,   136,   136,   137,
+     137,   137,   137,   137,   137,   137,   137,   137,   137,   137,
+     138,   138,   138,   138,   138,   138,   138,   138,   138,   138,
+     138,   138,   138,   138,   138,   138,   138,   138,   138,   139,
+     139,   140,   140,   141,   141,   141,   142,   142,   143,   143,
+     143,   143,   144,   144,   145,   145,   147,   146,   148,   148,
+     149,   149,   149,   149,   149,   149,   149,   149,   150,   150,
+     151,   151,   152,   153,   151,   151,   151,   151,   151,   151,
+     151,   151,   151,   151,   151,   151,   154,   151,   151,   155,
+     155,   156,   156,   157,   157,   157,   157,   157,   157,   157,
+     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
+     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
+     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
+     157,   157,   157,   157,   157,   158,   158,   158,   158,   159,
+     159,   159,   160,   160,   160,   161
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     1,     1,     2,     1,     2,     1,     2,
+       1,     2,     1,     2,     0,    12,     0,    10,     0,     8,
+       1,     1,     4,     1,     2,     1,     2,     0,     1,     0,
+       1,     0,     1,     1,     3,     1,     1,     4,     4,     7,
+       3,     4,     4,     0,     9,     1,     3,     1,     3,     3,
+       5,     3,     3,     3,     3,     3,     5,     2,     1,     1,
+       3,     5,     3,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     5,     4,     3,     2,     1,     1,     3,
+       3,     1,     3,     0,     1,     3,     1,     1,     1,     1,
+       2,     2,     1,     2,     1,     2,     0,     4,     1,     2,
+       4,     4,     4,     2,     5,     2,     1,     1,     1,     2,
+       2,     2,     0,     0,     9,     3,     2,     1,     4,     2,
+       3,     2,     2,     3,     2,     2,     0,     3,     2,     1,
+       2,     1,     1,     4,     3,     3,     3,     3,     3,     3,
+       2,     2,     2,     3,     4,     1,     3,     4,     2,     2,
+       2,     2,     2,     4,     3,     2,     1,     6,     6,     3,
+       6,     6,     1,     8,     8,     6,     4,     1,     6,     6,
+       8,     8,     8,     6,     1,     1,     4,     1,     2,     0,
+       1,     3,     1,     1,     1,     4
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 98 "awkgram.y" /* yacc.c:1646  */
+    { if (errorflag==0)
+			winner = (Node *)stat3(PROGRAM, beginloc, (yyvsp[0].p), endloc); }
+#line 2552 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 3:
+#line 100 "awkgram.y" /* yacc.c:1646  */
+    { yyclearin; bracecheck(); SYNTAX("bailing out"); }
+#line 2558 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 14:
+#line 124 "awkgram.y" /* yacc.c:1646  */
+    {inloop++;}
+#line 2564 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 125 "awkgram.y" /* yacc.c:1646  */
+    { --inloop; (yyval.p) = stat4(FOR, (yyvsp[-9].p), notnull((yyvsp[-6].p)), (yyvsp[-3].p), (yyvsp[0].p)); }
+#line 2570 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 126 "awkgram.y" /* yacc.c:1646  */
+    {inloop++;}
+#line 2576 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 127 "awkgram.y" /* yacc.c:1646  */
+    { --inloop; (yyval.p) = stat4(FOR, (yyvsp[-7].p), NIL, (yyvsp[-3].p), (yyvsp[0].p)); }
+#line 2582 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 128 "awkgram.y" /* yacc.c:1646  */
+    {inloop++;}
+#line 2588 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 129 "awkgram.y" /* yacc.c:1646  */
+    { --inloop; (yyval.p) = stat3(IN, (yyvsp[-5].p), makearr((yyvsp[-3].p)), (yyvsp[0].p)); }
+#line 2594 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 20:
+#line 133 "awkgram.y" /* yacc.c:1646  */
+    { setfname((yyvsp[0].cp)); }
+#line 2600 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 21:
+#line 134 "awkgram.y" /* yacc.c:1646  */
+    { setfname((yyvsp[0].cp)); }
+#line 2606 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 22:
+#line 138 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = notnull((yyvsp[-1].p)); }
+#line 2612 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 27:
+#line 150 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.i) = 0; }
+#line 2618 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 29:
+#line 155 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.i) = 0; }
+#line 2624 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 31:
+#line 161 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = 0; }
+#line 2630 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 33:
+#line 166 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = 0; }
+#line 2636 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 34:
+#line 167 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = (yyvsp[-1].p); }
+#line 2642 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 35:
+#line 171 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = notnull((yyvsp[0].p)); }
+#line 2648 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 36:
+#line 175 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat2(PASTAT, (yyvsp[0].p), stat2(PRINT, rectonode(), NIL)); }
+#line 2654 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 37:
+#line 176 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat2(PASTAT, (yyvsp[-3].p), (yyvsp[-1].p)); }
+#line 2660 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 38:
+#line 177 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = pa2stat((yyvsp[-3].p), (yyvsp[0].p), stat2(PRINT, rectonode(), NIL)); }
+#line 2666 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 39:
+#line 178 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = pa2stat((yyvsp[-6].p), (yyvsp[-3].p), (yyvsp[-1].p)); }
+#line 2672 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 40:
+#line 179 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat2(PASTAT, NIL, (yyvsp[-1].p)); }
+#line 2678 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 41:
+#line 181 "awkgram.y" /* yacc.c:1646  */
+    { beginloc = linkum(beginloc, (yyvsp[-1].p)); (yyval.p) = 0; }
+#line 2684 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 42:
+#line 183 "awkgram.y" /* yacc.c:1646  */
+    { endloc = linkum(endloc, (yyvsp[-1].p)); (yyval.p) = 0; }
+#line 2690 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 43:
+#line 184 "awkgram.y" /* yacc.c:1646  */
+    {infunc++;}
+#line 2696 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 44:
+#line 185 "awkgram.y" /* yacc.c:1646  */
+    { infunc--; curfname=0; defn((Cell *)(yyvsp[-7].p), (yyvsp[-5].p), (yyvsp[-1].p)); (yyval.p) = 0; }
+#line 2702 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 46:
+#line 190 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = linkum((yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2708 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 48:
+#line 195 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = linkum((yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2714 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 49:
+#line 199 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2((yyvsp[-1].i), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2720 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 50:
+#line 201 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(CONDEXPR, notnull((yyvsp[-4].p)), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2726 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 51:
+#line 203 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(BOR, notnull((yyvsp[-2].p)), notnull((yyvsp[0].p))); }
+#line 2732 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 52:
+#line 205 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(AND, notnull((yyvsp[-2].p)), notnull((yyvsp[0].p))); }
+#line 2738 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 53:
+#line 206 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3((yyvsp[-1].i), NIL, (yyvsp[-2].p), (Node*)makedfa((yyvsp[0].s), 0)); }
+#line 2744 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 54:
+#line 208 "awkgram.y" /* yacc.c:1646  */
+    { if (constnode((yyvsp[0].p)))
+			(yyval.p) = op3((yyvsp[-1].i), NIL, (yyvsp[-2].p), (Node*)makedfa(strnode((yyvsp[0].p)), 0));
+		  else
+			(yyval.p) = op3((yyvsp[-1].i), (Node *)1, (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2753 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 55:
+#line 212 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(INTEST, (yyvsp[-2].p), makearr((yyvsp[0].p))); }
+#line 2759 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 56:
+#line 213 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(INTEST, (yyvsp[-3].p), makearr((yyvsp[0].p))); }
+#line 2765 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 57:
+#line 214 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(CAT, (yyvsp[-1].p), (yyvsp[0].p)); }
+#line 2771 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 60:
+#line 220 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2((yyvsp[-1].i), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2777 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 61:
+#line 222 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(CONDEXPR, notnull((yyvsp[-4].p)), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2783 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 62:
+#line 224 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(BOR, notnull((yyvsp[-2].p)), notnull((yyvsp[0].p))); }
+#line 2789 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 63:
+#line 226 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(AND, notnull((yyvsp[-2].p)), notnull((yyvsp[0].p))); }
+#line 2795 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 64:
+#line 227 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2((yyvsp[-1].i), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2801 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 65:
+#line 228 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2((yyvsp[-1].i), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2807 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 66:
+#line 229 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2((yyvsp[-1].i), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2813 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 67:
+#line 230 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2((yyvsp[-1].i), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2819 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 68:
+#line 231 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2((yyvsp[-1].i), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2825 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 69:
+#line 232 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2((yyvsp[-1].i), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2831 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 70:
+#line 233 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3((yyvsp[-1].i), NIL, (yyvsp[-2].p), (Node*)makedfa((yyvsp[0].s), 0)); }
+#line 2837 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 71:
+#line 235 "awkgram.y" /* yacc.c:1646  */
+    { if (constnode((yyvsp[0].p)))
+			(yyval.p) = op3((yyvsp[-1].i), NIL, (yyvsp[-2].p), (Node*)makedfa(strnode((yyvsp[0].p)), 0));
+		  else
+			(yyval.p) = op3((yyvsp[-1].i), (Node *)1, (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2846 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 72:
+#line 239 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(INTEST, (yyvsp[-2].p), makearr((yyvsp[0].p))); }
+#line 2852 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 73:
+#line 240 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(INTEST, (yyvsp[-3].p), makearr((yyvsp[0].p))); }
+#line 2858 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 74:
+#line 241 "awkgram.y" /* yacc.c:1646  */
+    { 
+			if (safe) SYNTAX("cmd | getline is unsafe");
+			else (yyval.p) = op3(GETLINE, (yyvsp[0].p), itonp((yyvsp[-2].i)), (yyvsp[-3].p)); }
+#line 2866 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 75:
+#line 244 "awkgram.y" /* yacc.c:1646  */
+    { 
+			if (safe) SYNTAX("cmd | getline is unsafe");
+			else (yyval.p) = op3(GETLINE, (Node*)0, itonp((yyvsp[-1].i)), (yyvsp[-2].p)); }
+#line 2874 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 76:
+#line 247 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(CAT, (yyvsp[-1].p), (yyvsp[0].p)); }
+#line 2880 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 79:
+#line 253 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = linkum((yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2886 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 80:
+#line 254 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = linkum((yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2892 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 82:
+#line 259 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = linkum((yyvsp[-2].p), (yyvsp[0].p)); }
+#line 2898 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 83:
+#line 263 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = rectonode(); }
+#line 2904 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 85:
+#line 265 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = (yyvsp[-1].p); }
+#line 2910 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 94:
+#line 282 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(MATCH, NIL, rectonode(), (Node*)makedfa((yyvsp[0].s), 0)); }
+#line 2916 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 95:
+#line 283 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(NOT, notnull((yyvsp[0].p))); }
+#line 2922 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 96:
+#line 287 "awkgram.y" /* yacc.c:1646  */
+    {startreg();}
+#line 2928 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 97:
+#line 287 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.s) = (yyvsp[-1].s); }
+#line 2934 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 100:
+#line 295 "awkgram.y" /* yacc.c:1646  */
+    { 
+			if (safe) SYNTAX("print | is unsafe");
+			else (yyval.p) = stat3((yyvsp[-3].i), (yyvsp[-2].p), itonp((yyvsp[-1].i)), (yyvsp[0].p)); }
+#line 2942 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 101:
+#line 298 "awkgram.y" /* yacc.c:1646  */
+    {
+			if (safe) SYNTAX("print >> is unsafe");
+			else (yyval.p) = stat3((yyvsp[-3].i), (yyvsp[-2].p), itonp((yyvsp[-1].i)), (yyvsp[0].p)); }
+#line 2950 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 102:
+#line 301 "awkgram.y" /* yacc.c:1646  */
+    {
+			if (safe) SYNTAX("print > is unsafe");
+			else (yyval.p) = stat3((yyvsp[-3].i), (yyvsp[-2].p), itonp((yyvsp[-1].i)), (yyvsp[0].p)); }
+#line 2958 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 103:
+#line 304 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat3((yyvsp[-1].i), (yyvsp[0].p), NIL, NIL); }
+#line 2964 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 104:
+#line 305 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat2(DELETE, makearr((yyvsp[-3].p)), (yyvsp[-1].p)); }
+#line 2970 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 105:
+#line 306 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat2(DELETE, makearr((yyvsp[0].p)), 0); }
+#line 2976 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 106:
+#line 307 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = exptostat((yyvsp[0].p)); }
+#line 2982 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 107:
+#line 308 "awkgram.y" /* yacc.c:1646  */
+    { yyclearin; SYNTAX("illegal statement"); }
+#line 2988 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 110:
+#line 317 "awkgram.y" /* yacc.c:1646  */
+    { if (!inloop) SYNTAX("break illegal outside of loops");
+				  (yyval.p) = stat1(BREAK, NIL); }
+#line 2995 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 111:
+#line 319 "awkgram.y" /* yacc.c:1646  */
+    {  if (!inloop) SYNTAX("continue illegal outside of loops");
+				  (yyval.p) = stat1(CONTINUE, NIL); }
+#line 3002 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 112:
+#line 321 "awkgram.y" /* yacc.c:1646  */
+    {inloop++;}
+#line 3008 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 113:
+#line 321 "awkgram.y" /* yacc.c:1646  */
+    {--inloop;}
+#line 3014 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 114:
+#line 322 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat2(DO, (yyvsp[-6].p), notnull((yyvsp[-2].p))); }
+#line 3020 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 115:
+#line 323 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat1(EXIT, (yyvsp[-1].p)); }
+#line 3026 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 116:
+#line 324 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat1(EXIT, NIL); }
+#line 3032 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 118:
+#line 326 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat3(IF, (yyvsp[-3].p), (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 3038 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 119:
+#line 327 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat3(IF, (yyvsp[-1].p), (yyvsp[0].p), NIL); }
+#line 3044 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 120:
+#line 328 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = (yyvsp[-1].p); }
+#line 3050 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 121:
+#line 329 "awkgram.y" /* yacc.c:1646  */
+    { if (infunc)
+				SYNTAX("next is illegal inside a function");
+			  (yyval.p) = stat1(NEXT, NIL); }
+#line 3058 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 122:
+#line 332 "awkgram.y" /* yacc.c:1646  */
+    { if (infunc)
+				SYNTAX("nextfile is illegal inside a function");
+			  (yyval.p) = stat1(NEXTFILE, NIL); }
+#line 3066 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 123:
+#line 335 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat1(RETURN, (yyvsp[-1].p)); }
+#line 3072 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 124:
+#line 336 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = stat1(RETURN, NIL); }
+#line 3078 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 126:
+#line 338 "awkgram.y" /* yacc.c:1646  */
+    {inloop++;}
+#line 3084 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 127:
+#line 338 "awkgram.y" /* yacc.c:1646  */
+    { --inloop; (yyval.p) = stat2(WHILE, (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 3090 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 128:
+#line 339 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = 0; }
+#line 3096 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 130:
+#line 344 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = linkum((yyvsp[-1].p), (yyvsp[0].p)); }
+#line 3102 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 133:
+#line 352 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(DIVEQ, (yyvsp[-3].p), (yyvsp[0].p)); }
+#line 3108 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 134:
+#line 353 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(ADD, (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 3114 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 135:
+#line 354 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(MINUS, (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 3120 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 136:
+#line 355 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(MULT, (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 3126 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 137:
+#line 356 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(DIVIDE, (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 3132 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 138:
+#line 357 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(MOD, (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 3138 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 139:
+#line 358 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(POWER, (yyvsp[-2].p), (yyvsp[0].p)); }
+#line 3144 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 140:
+#line 359 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(UMINUS, (yyvsp[0].p)); }
+#line 3150 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 141:
+#line 360 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(UPLUS, (yyvsp[0].p)); }
+#line 3156 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 142:
+#line 361 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(NOT, notnull((yyvsp[0].p))); }
+#line 3162 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 143:
+#line 362 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(BLTIN, itonp((yyvsp[-2].i)), rectonode()); }
+#line 3168 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 144:
+#line 363 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(BLTIN, itonp((yyvsp[-3].i)), (yyvsp[-1].p)); }
+#line 3174 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 145:
+#line 364 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(BLTIN, itonp((yyvsp[0].i)), rectonode()); }
+#line 3180 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 146:
+#line 365 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(CALL, celltonode((yyvsp[-2].cp),CVAR), NIL); }
+#line 3186 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 147:
+#line 366 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(CALL, celltonode((yyvsp[-3].cp),CVAR), (yyvsp[-1].p)); }
+#line 3192 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 148:
+#line 367 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(CLOSE, (yyvsp[0].p)); }
+#line 3198 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 149:
+#line 368 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(PREDECR, (yyvsp[0].p)); }
+#line 3204 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 150:
+#line 369 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(PREINCR, (yyvsp[0].p)); }
+#line 3210 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 151:
+#line 370 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(POSTDECR, (yyvsp[-1].p)); }
+#line 3216 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 152:
+#line 371 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(POSTINCR, (yyvsp[-1].p)); }
+#line 3222 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 153:
+#line 372 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(GETLINE, (yyvsp[-2].p), itonp((yyvsp[-1].i)), (yyvsp[0].p)); }
+#line 3228 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 154:
+#line 373 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(GETLINE, NIL, itonp((yyvsp[-1].i)), (yyvsp[0].p)); }
+#line 3234 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 155:
+#line 374 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(GETLINE, (yyvsp[0].p), NIL, NIL); }
+#line 3240 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 156:
+#line 375 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(GETLINE, NIL, NIL, NIL); }
+#line 3246 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 157:
+#line 377 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(INDEX, (yyvsp[-3].p), (yyvsp[-1].p)); }
+#line 3252 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 158:
+#line 379 "awkgram.y" /* yacc.c:1646  */
+    { SYNTAX("index() doesn't permit regular expressions");
+		  (yyval.p) = op2(INDEX, (yyvsp[-3].p), (Node*)(yyvsp[-1].s)); }
+#line 3259 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 159:
+#line 381 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = (yyvsp[-1].p); }
+#line 3265 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 160:
+#line 383 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(MATCHFCN, NIL, (yyvsp[-3].p), (Node*)makedfa((yyvsp[-1].s), 1)); }
+#line 3271 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 161:
+#line 385 "awkgram.y" /* yacc.c:1646  */
+    { if (constnode((yyvsp[-1].p)))
+			(yyval.p) = op3(MATCHFCN, NIL, (yyvsp[-3].p), (Node*)makedfa(strnode((yyvsp[-1].p)), 1));
+		  else
+			(yyval.p) = op3(MATCHFCN, (Node *)1, (yyvsp[-3].p), (yyvsp[-1].p)); }
+#line 3280 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 162:
+#line 389 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = celltonode((yyvsp[0].cp), CCON); }
+#line 3286 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 163:
+#line 391 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op4(SPLIT, (yyvsp[-5].p), makearr((yyvsp[-3].p)), (yyvsp[-1].p), (Node*)STRING); }
+#line 3292 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 164:
+#line 393 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op4(SPLIT, (yyvsp[-5].p), makearr((yyvsp[-3].p)), (Node*)makedfa((yyvsp[-1].s), 1), (Node *)REGEXPR); }
+#line 3298 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 165:
+#line 395 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op4(SPLIT, (yyvsp[-3].p), makearr((yyvsp[-1].p)), NIL, (Node*)STRING); }
+#line 3304 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 166:
+#line 396 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1((yyvsp[-3].i), (yyvsp[-1].p)); }
+#line 3310 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 167:
+#line 397 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = celltonode((yyvsp[0].cp), CCON); }
+#line 3316 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 168:
+#line 399 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op4((yyvsp[-5].i), NIL, (Node*)makedfa((yyvsp[-3].s), 1), (yyvsp[-1].p), rectonode()); }
+#line 3322 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 169:
+#line 401 "awkgram.y" /* yacc.c:1646  */
+    { if (constnode((yyvsp[-3].p)))
+			(yyval.p) = op4((yyvsp[-5].i), NIL, (Node*)makedfa(strnode((yyvsp[-3].p)), 1), (yyvsp[-1].p), rectonode());
+		  else
+			(yyval.p) = op4((yyvsp[-5].i), (Node *)1, (yyvsp[-3].p), (yyvsp[-1].p), rectonode()); }
+#line 3331 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 170:
+#line 406 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op4((yyvsp[-7].i), NIL, (Node*)makedfa((yyvsp[-5].s), 1), (yyvsp[-3].p), (yyvsp[-1].p)); }
+#line 3337 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 171:
+#line 408 "awkgram.y" /* yacc.c:1646  */
+    { if (constnode((yyvsp[-5].p)))
+			(yyval.p) = op4((yyvsp[-7].i), NIL, (Node*)makedfa(strnode((yyvsp[-5].p)), 1), (yyvsp[-3].p), (yyvsp[-1].p));
+		  else
+			(yyval.p) = op4((yyvsp[-7].i), (Node *)1, (yyvsp[-5].p), (yyvsp[-3].p), (yyvsp[-1].p)); }
+#line 3346 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 172:
+#line 413 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(SUBSTR, (yyvsp[-5].p), (yyvsp[-3].p), (yyvsp[-1].p)); }
+#line 3352 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 173:
+#line 415 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op3(SUBSTR, (yyvsp[-3].p), (yyvsp[-1].p), NIL); }
+#line 3358 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 176:
+#line 421 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op2(ARRAY, makearr((yyvsp[-3].p)), (yyvsp[-1].p)); }
+#line 3364 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 177:
+#line 422 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(INDIRECT, celltonode((yyvsp[0].cp), CVAR)); }
+#line 3370 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 178:
+#line 423 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(INDIRECT, (yyvsp[0].p)); }
+#line 3376 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 179:
+#line 427 "awkgram.y" /* yacc.c:1646  */
+    { arglist = (yyval.p) = 0; }
+#line 3382 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 180:
+#line 428 "awkgram.y" /* yacc.c:1646  */
+    { arglist = (yyval.p) = celltonode((yyvsp[0].cp),CVAR); }
+#line 3388 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 181:
+#line 429 "awkgram.y" /* yacc.c:1646  */
+    {
+			checkdup((yyvsp[-2].p), (yyvsp[0].cp));
+			arglist = (yyval.p) = linkum((yyvsp[-2].p),celltonode((yyvsp[0].cp),CVAR)); }
+#line 3396 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 182:
+#line 435 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = celltonode((yyvsp[0].cp), CVAR); }
+#line 3402 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 183:
+#line 436 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(ARG, itonp((yyvsp[0].i))); }
+#line 3408 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 184:
+#line 437 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = op1(VARNF, (Node *) (yyvsp[0].cp)); }
+#line 3414 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 185:
+#line 442 "awkgram.y" /* yacc.c:1646  */
+    { (yyval.p) = notnull((yyvsp[-1].p)); }
+#line 3420 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 3424 "y.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 445 "awkgram.y" /* yacc.c:1906  */
+
+
+void setfname(Cell *p)
+{
+	if (isarr(p))
+		SYNTAX("%s is an array, not a function", p->nval);
+	else if (isfcn(p))
+		SYNTAX("you can't define function %s more than once", p->nval);
+	curfname = p->nval;
+}
+
+int constnode(Node *p)
+{
+	return isvalue(p) && ((Cell *) (p->narg[0]))->csub == CCON;
+}
+
+char *strnode(Node *p)
+{
+	return ((Cell *)(p->narg[0]))->sval;
+}
+
+Node *notnull(Node *n)
+{
+	switch (n->nobj) {
+	case LE: case LT: case EQ: case NE: case GT: case GE:
+	case BOR: case AND: case NOT:
+		return n;
+	default:
+		return op2(NE, n, nullnode);
+	}
+}
+
+void checkdup(Node *vl, Cell *cp)	/* check if name already in list */
+{
+	char *s = cp->nval;
+	for ( ; vl; vl = vl->nnext) {
+		if (strcmp(s, ((Cell *)(vl->narg[0]))->nval) == 0) {
+			SYNTAX("duplicate argument %s", s);
+			break;
+		}
+	}
+}
diff --git a/external/one-true-awk/ytab.h b/external/one-true-awk/ytab.h
new file mode 100644
index 0000000000..21a855ff77
--- /dev/null
+++ b/external/one-true-awk/ytab.h
@@ -0,0 +1,265 @@
+/* A Bison parser, made by GNU Bison 3.0.4.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    FIRSTTOKEN = 258,
+    PROGRAM = 259,
+    PASTAT = 260,
+    PASTAT2 = 261,
+    XBEGIN = 262,
+    XEND = 263,
+    NL = 264,
+    ARRAY = 265,
+    MATCH = 266,
+    NOTMATCH = 267,
+    MATCHOP = 268,
+    FINAL = 269,
+    DOT = 270,
+    ALL = 271,
+    CCL = 272,
+    NCCL = 273,
+    CHAR = 274,
+    OR = 275,
+    STAR = 276,
+    QUEST = 277,
+    PLUS = 278,
+    EMPTYRE = 279,
+    AND = 280,
+    BOR = 281,
+    APPEND = 282,
+    EQ = 283,
+    GE = 284,
+    GT = 285,
+    LE = 286,
+    LT = 287,
+    NE = 288,
+    IN = 289,
+    ARG = 290,
+    BLTIN = 291,
+    BREAK = 292,
+    CLOSE = 293,
+    CONTINUE = 294,
+    DELETE = 295,
+    DO = 296,
+    EXIT = 297,
+    FOR = 298,
+    FUNC = 299,
+    SUB = 300,
+    GSUB = 301,
+    IF = 302,
+    INDEX = 303,
+    LSUBSTR = 304,
+    MATCHFCN = 305,
+    NEXT = 306,
+    NEXTFILE = 307,
+    ADD = 308,
+    MINUS = 309,
+    MULT = 310,
+    DIVIDE = 311,
+    MOD = 312,
+    ASSIGN = 313,
+    ASGNOP = 314,
+    ADDEQ = 315,
+    SUBEQ = 316,
+    MULTEQ = 317,
+    DIVEQ = 318,
+    MODEQ = 319,
+    POWEQ = 320,
+    PRINT = 321,
+    PRINTF = 322,
+    SPRINTF = 323,
+    ELSE = 324,
+    INTEST = 325,
+    CONDEXPR = 326,
+    POSTINCR = 327,
+    PREINCR = 328,
+    POSTDECR = 329,
+    PREDECR = 330,
+    VAR = 331,
+    IVAR = 332,
+    VARNF = 333,
+    CALL = 334,
+    NUMBER = 335,
+    STRING = 336,
+    REGEXPR = 337,
+    GETLINE = 338,
+    RETURN = 339,
+    SPLIT = 340,
+    SUBSTR = 341,
+    WHILE = 342,
+    CAT = 343,
+    NOT = 344,
+    UMINUS = 345,
+    UPLUS = 346,
+    POWER = 347,
+    DECR = 348,
+    INCR = 349,
+    INDIRECT = 350,
+    LASTTOKEN = 351
+  };
+#endif
+/* Tokens.  */
+#define FIRSTTOKEN 258
+#define PROGRAM 259
+#define PASTAT 260
+#define PASTAT2 261
+#define XBEGIN 262
+#define XEND 263
+#define NL 264
+#define ARRAY 265
+#define MATCH 266
+#define NOTMATCH 267
+#define MATCHOP 268
+#define FINAL 269
+#define DOT 270
+#define ALL 271
+#define CCL 272
+#define NCCL 273
+#define CHAR 274
+#define OR 275
+#define STAR 276
+#define QUEST 277
+#define PLUS 278
+#define EMPTYRE 279
+#define AND 280
+#define BOR 281
+#define APPEND 282
+#define EQ 283
+#define GE 284
+#define GT 285
+#define LE 286
+#define LT 287
+#define NE 288
+#define IN 289
+#define ARG 290
+#define BLTIN 291
+#define BREAK 292
+#define CLOSE 293
+#define CONTINUE 294
+#define DELETE 295
+#define DO 296
+#define EXIT 297
+#define FOR 298
+#define FUNC 299
+#define SUB 300
+#define GSUB 301
+#define IF 302
+#define INDEX 303
+#define LSUBSTR 304
+#define MATCHFCN 305
+#define NEXT 306
+#define NEXTFILE 307
+#define ADD 308
+#define MINUS 309
+#define MULT 310
+#define DIVIDE 311
+#define MOD 312
+#define ASSIGN 313
+#define ASGNOP 314
+#define ADDEQ 315
+#define SUBEQ 316
+#define MULTEQ 317
+#define DIVEQ 318
+#define MODEQ 319
+#define POWEQ 320
+#define PRINT 321
+#define PRINTF 322
+#define SPRINTF 323
+#define ELSE 324
+#define INTEST 325
+#define CONDEXPR 326
+#define POSTINCR 327
+#define PREINCR 328
+#define POSTDECR 329
+#define PREDECR 330
+#define VAR 331
+#define IVAR 332
+#define VARNF 333
+#define CALL 334
+#define NUMBER 335
+#define STRING 336
+#define REGEXPR 337
+#define GETLINE 338
+#define RETURN 339
+#define SPLIT 340
+#define SUBSTR 341
+#define WHILE 342
+#define CAT 343
+#define NOT 344
+#define UMINUS 345
+#define UPLUS 346
+#define POWER 347
+#define DECR 348
+#define INCR 349
+#define INDIRECT 350
+#define LASTTOKEN 351
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+
+union YYSTYPE
+{
+#line 41 "awkgram.y" /* yacc.c:1909  */
+
+	Node	*p;
+	Cell	*cp;
+	int	i;
+	char	*s;
+
+#line 253 "y.tab.h" /* yacc.c:1909  */
+};
+
+typedef union YYSTYPE YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
diff --git "a/frameworks/compile/slang/tests/P_str_escape/str\\\\escape.rs" b/frameworks/compile/slang/tests/P_str_escape/str/escape.rs
similarity index 100%
rename from "frameworks/compile/slang/tests/P_str_escape/str\\\\escape.rs"
rename to frameworks/compile/slang/tests/P_str_escape/str/escape.rs
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/config.h
new file mode 100755
index 0000000000..ef932db0b0
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/config.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+
+struct config_control
+{
+    const char *ctl_name; //name of control.
+    const char *str_val; //value of control, which type is stream.
+    const int int_val[2]; //left and right value of control, which type are int.
+};
+
+struct config_route
+{
+    const int sound_card;
+    const int devices;
+    const struct config_control *controls;
+    const unsigned controls_count;
+};
+
+struct config_route_table
+{
+    const struct config_route speaker_normal;
+    const struct config_route speaker_incall;
+    const struct config_route speaker_ringtone;
+    const struct config_route speaker_voip;
+
+    const struct config_route earpiece_normal;
+    const struct config_route earpiece_incall;
+    const struct config_route earpiece_ringtone;
+    const struct config_route earpiece_voip;
+
+    const struct config_route headphone_normal;
+    const struct config_route headphone_incall;
+    const struct config_route headphone_ringtone;
+    const struct config_route speaker_headphone_normal;
+    const struct config_route speaker_headphone_ringtone;
+    const struct config_route headphone_voip;
+
+    const struct config_route headset_normal;
+    const struct config_route headset_incall;
+    const struct config_route headset_ringtone;
+    const struct config_route headset_voip;
+
+    const struct config_route bluetooth_normal;
+    const struct config_route bluetooth_incall;
+    const struct config_route bluetooth_voip;
+
+    const struct config_route main_mic_capture;
+    const struct config_route hands_free_mic_capture;
+    const struct config_route bluetooth_sco_mic_capture;
+
+    const struct config_route playback_off;
+    const struct config_route capture_off;
+    const struct config_route incall_off;
+    const struct config_route voip_off;
+
+    const struct config_route hdmi_normal;
+
+    const struct config_route usb_normal;
+    const struct config_route usb_capture;
+
+    const struct config_route spdif_normal;
+
+    const struct config_route hdmiin_normal;
+    const struct config_route hdmiin_off;
+    const struct config_route hdmiin_captrue;
+    const struct config_route hdmiin_captrue_off;
+};
+
+#define on 1
+#define off 0
+
+#define DEVICES_0 0
+#define DEVICES_0_1 1
+#define DEVICES_0_2 2
+#define DEVICES_0_1_2 3
+
+#endif //_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/config_list.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/config_list.h
new file mode 100644
index 0000000000..ff26863c7d
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/config_list.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file config_list.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _CONFIG_LIST_H_
+#define _CONFIG_LIST_H_
+
+#include "config.h"
+#include "default_config.h"
+#include "rk616_config.h"
+#include "rt3261_config.h"
+#include "rt5616_config.h"
+#include "rt5640_config.h"
+#include "rt5678_config.h"
+#include "rt3224_config.h"
+#include "wm8960_config.h"
+#include "es8388_config.h"
+#include "es8396_config.h"
+#include "rt5651_config.h"
+#include "es8316_config.h"
+#include "cx2072_config.h"
+#include "hdmi_analog_config.h"
+
+struct alsa_sound_card_config
+{
+    const char *sound_card_name;
+    const struct config_route_table *route_table;
+};
+
+/*
+* List of sound card name and config table.
+* Audio will get config_route_table and set route 
+* according to the name of sound card 0 and sound_card_name.
+*/
+struct alsa_sound_card_config sound_card_config_list[] = {
+    {
+        .sound_card_name = "RKRK616",
+        .route_table = &rk616_config_table,
+    },
+    {
+        .sound_card_name = "RK29RT3224",
+        .route_table = &rt3224_config_table,
+    },
+    {
+        .sound_card_name = "rockchiprt5640c",
+        .route_table = &rt5640_config_table,
+    },
+    {
+        .sound_card_name = "realtekrt5678co",
+        .route_table = &rt5678_config_table,
+    },
+    {
+        .sound_card_name = "rockchipes8388",
+        .route_table = &es8388_config_table,
+    },
+    {
+        .sound_card_name = "rockchipes8388c",
+        .route_table = &es8388_config_table,
+    },
+    {
+        .sound_card_name = "rockchipes8396c",
+        .route_table = &es8396_config_table,
+    },
+    {
+        .sound_card_name = "RK29RT3261",
+        .route_table = &rt3261_config_table,
+    },
+    {
+        .sound_card_name = "RK29WM8960",
+        .route_table = &wm8960_config_table,
+    },
+    {
+        .sound_card_name = "RKRT3224",
+        .route_table = &rt3224_config_table,
+    },
+    {
+        .sound_card_name = "RKRT3261",
+        .route_table = &rt3261_config_table,
+    },
+    {
+        .sound_card_name = "RKWM8960",
+        .route_table = &wm8960_config_table,
+    },
+    {
+        .sound_card_name = "RKRT5616",
+        .route_table = &rt5616_config_table,
+    },
+    {
+        .sound_card_name = "realtekrt5651co",
+        .route_table = &rt5651_config_table,
+    },
+    {
+        .sound_card_name = "rockchipes8316c",
+        .route_table = &es8316_config_table,
+    },
+    {
+        .sound_card_name = "rockchipcx2072x",
+        .route_table = &cx2072_config_table,
+    },
+    {
+        .sound_card_name = "rkhdmianalogsnd",
+        .route_table = &hdmi_analog_config_table,
+    }
+};
+
+#endif //_CONFIG_LIST_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/cx2072_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/cx2072_config.h
new file mode 100644
index 0000000000..2460ea8025
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/cx2072_config.h
@@ -0,0 +1,332 @@
+#ifndef _CX2072_CONFIG_H_
+#define _CX2072_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control cx2072_speaker_normal_controls[] = {
+    {
+        .ctl_name = "PortG Mux",
+        .int_val = {0},
+    },
+};
+
+const struct config_control cx2072_speaker_incall_controls[] = {
+};
+
+const struct config_control cx2072_speaker_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_speaker_voip_controls[] = {
+};
+
+const struct config_control cx2072_earpiece_normal_controls[] = {
+};
+
+const struct config_control cx2072_earpiece_incall_controls[] = {
+};
+
+const struct config_control cx2072_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_earpiece_voip_controls[] = {
+};
+
+const struct config_control cx2072_headphone_normal_controls[] = {
+    {
+        .ctl_name = "PortG Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control cx2072_headphone_incall_controls[] = {
+};
+
+const struct config_control cx2072_headphone_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control cx2072_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_headphone_voip_controls[] = {
+};
+
+const struct config_control cx2072_headset_normal_controls[] = {
+    {
+        .ctl_name = "PortG Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control cx2072_headset_incall_controls[] = {
+};
+
+const struct config_control cx2072_headset_ringtone_controls[] = {
+};
+
+const struct config_control cx2072_headset_voip_controls[] = {
+};
+
+const struct config_control cx2072_bluetooth_normal_controls[] = {
+};
+
+const struct config_control cx2072_bluetooth_incall_controls[] = {
+};
+
+const struct config_control cx2072_bluetooth_voip_controls[] = {
+};
+
+const struct config_control cx2072_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "ADC1 Mux",
+        .int_val = {2},
+    },
+    {
+        .ctl_name = "PortC Boost",
+        .int_val = {2, 2},
+    },
+};
+
+const struct config_control cx2072_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "ADC1 Mux",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "PortD Boost",
+        .int_val = {2, 2},
+    },
+};
+
+const struct config_control cx2072_bluetooth_sco_mic_capture_controls[] = {
+    {
+        .ctl_name = "PortG Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control cx2072_playback_off_controls[] = {
+};
+
+const struct config_control cx2072_capture_off_controls[] = {
+};
+
+const struct config_control cx2072_incall_off_controls[] = {
+};
+
+const struct config_control cx2072_voip_off_controls[] = {
+};
+
+const struct config_route_table cx2072_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_normal_controls,
+        .controls_count = sizeof(cx2072_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_incall_controls,
+        .controls_count = sizeof(cx2072_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_ringtone_controls,
+        .controls_count = sizeof(cx2072_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_voip_controls,
+        .controls_count = sizeof(cx2072_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_earpiece_normal_controls,
+        .controls_count = sizeof(cx2072_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_earpiece_incall_controls,
+        .controls_count = sizeof(cx2072_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_earpiece_ringtone_controls,
+        .controls_count = sizeof(cx2072_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_earpiece_voip_controls,
+        .controls_count = sizeof(cx2072_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headphone_normal_controls,
+        .controls_count = sizeof(cx2072_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headphone_incall_controls,
+        .controls_count = sizeof(cx2072_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headphone_ringtone_controls,
+        .controls_count = sizeof(cx2072_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_headphone_normal_controls,
+        .controls_count = sizeof(cx2072_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(cx2072_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headphone_voip_controls,
+        .controls_count = sizeof(cx2072_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headset_normal_controls,
+        .controls_count = sizeof(cx2072_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headset_incall_controls,
+        .controls_count = sizeof(cx2072_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headset_ringtone_controls,
+        .controls_count = sizeof(cx2072_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_headset_voip_controls,
+        .controls_count = sizeof(cx2072_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_bluetooth_normal_controls,
+        .controls_count = sizeof(cx2072_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = cx2072_bluetooth_incall_controls,
+        .controls_count = sizeof(cx2072_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = cx2072_bluetooth_voip_controls,
+        .controls_count = sizeof(cx2072_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_main_mic_capture_controls,
+        .controls_count = sizeof(cx2072_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = cx2072_hands_free_mic_capture_controls,
+        .controls_count = sizeof(cx2072_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = cx2072_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(cx2072_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = cx2072_playback_off_controls,
+        .controls_count = sizeof(cx2072_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = cx2072_capture_off_controls,
+        .controls_count = sizeof(cx2072_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = cx2072_incall_off_controls,
+        .controls_count = sizeof(cx2072_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = cx2072_voip_off_controls,
+        .controls_count = sizeof(cx2072_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_CX2072_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/default_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/default_config.h
new file mode 100755
index 0000000000..a55449261a
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/default_config.h
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file default_config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _DEFAULT_CONFIG_H_
+#define _DEFAULT_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control default_speaker_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK",
+    },
+};
+
+const struct config_control default_speaker_incall_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK",
+    },
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "SPK",
+    },
+};
+
+const struct config_control default_speaker_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RING_SPK",
+    },
+};
+
+const struct config_control default_speaker_voip_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK",
+    },
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "SPK",
+    },
+};
+
+const struct config_control default_earpiece_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RCV",
+    },
+};
+
+const struct config_control default_earpiece_incall_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK",
+    },
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "RCV",
+    },
+};
+
+const struct config_control default_earpiece_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RCV",
+    },
+};
+
+const struct config_control default_earpiece_voip_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RCV",
+    },
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "RCV",
+    },
+};
+
+const struct config_control default_headphone_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP_NO_MIC",
+    },
+};
+
+const struct config_control default_headphone_incall_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP_NO_MIC",
+    },
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "HP_NO_MIC",
+    },
+};
+
+const struct config_control default_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RING_HP_NO_MIC",
+    },
+};
+
+const struct config_control default_speaker_headphone_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "SPK_HP",
+    },
+};
+
+const struct config_control default_speaker_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RING_SPK_HP",
+    },
+};
+
+const struct config_control default_headphone_voip_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP_NO_MIC",
+    },
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "HP_NO_MIC",
+    },
+};
+
+const struct config_control default_headset_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP",
+    },
+};
+
+const struct config_control default_headset_incall_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP",
+    },
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "HP",
+    },
+};
+
+const struct config_control default_headset_ringtone_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "RING_HP",
+    },
+};
+
+const struct config_control default_headset_voip_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "HP",
+    },
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "HP",
+    },
+};
+
+const struct config_control default_bluetooth_normal_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "BT",
+    },
+};
+
+const struct config_control default_bluetooth_incall_controls[] = {
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "BT",
+    },
+};
+
+const struct config_control default_bluetooth_voip_controls[] = {
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "BT",
+    },
+};
+
+const struct config_control default_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture MIC Path",
+        .str_val = "Main Mic",
+    },
+};
+
+const struct config_control default_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture MIC Path",
+        .str_val = "Hands Free Mic",
+    },
+};
+
+const struct config_control default_bluetooth_sco_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture MIC Path",
+        .str_val = "BT Sco Mic",
+    },
+};
+
+const struct config_control default_playback_off_controls[] = {
+    {
+        .ctl_name = "Playback Path",
+        .str_val = "OFF",
+    },
+};
+
+const struct config_control default_capture_off_controls[] = {
+    {
+        .ctl_name = "Capture MIC Path",
+        .str_val = "MIC OFF",
+    },
+};
+
+const struct config_control default_incall_off_controls[] = {
+    {
+        .ctl_name = "Voice Call Path",
+        .str_val = "OFF",
+    },
+};
+
+const struct config_control default_voip_off_controls[] = {
+    {
+        .ctl_name = "Voip Path",
+        .str_val = "OFF",
+    },
+};
+
+const struct config_route_table default_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_normal_controls,
+        .controls_count = sizeof(default_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_incall_controls,
+        .controls_count = sizeof(default_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_ringtone_controls,
+        .controls_count = sizeof(default_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_voip_controls,
+        .controls_count = sizeof(default_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_earpiece_normal_controls,
+        .controls_count = sizeof(default_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_earpiece_incall_controls,
+        .controls_count = sizeof(default_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_earpiece_ringtone_controls,
+        .controls_count = sizeof(default_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_earpiece_voip_controls,
+        .controls_count = sizeof(default_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headphone_normal_controls,
+        .controls_count = sizeof(default_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headphone_incall_controls,
+        .controls_count = sizeof(default_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headphone_ringtone_controls,
+        .controls_count = sizeof(default_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_headphone_normal_controls,
+        .controls_count = sizeof(default_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(default_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headphone_voip_controls,
+        .controls_count = sizeof(default_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headset_normal_controls,
+        .controls_count = sizeof(default_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headset_incall_controls,
+        .controls_count = sizeof(default_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headset_ringtone_controls,
+        .controls_count = sizeof(default_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_headset_voip_controls,
+        .controls_count = sizeof(default_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_bluetooth_normal_controls,
+        .controls_count = sizeof(default_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = default_bluetooth_incall_controls,
+        .controls_count = sizeof(default_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = default_bluetooth_voip_controls,
+        .controls_count = sizeof(default_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_main_mic_capture_controls,
+        .controls_count = sizeof(default_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = default_hands_free_mic_capture_controls,
+        .controls_count = sizeof(default_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = default_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(default_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = default_playback_off_controls,
+        .controls_count = sizeof(default_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = default_capture_off_controls,
+        .controls_count = sizeof(default_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = default_incall_off_controls,
+        .controls_count = sizeof(default_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = default_voip_off_controls,
+        .controls_count = sizeof(default_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_DEFAULT_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/es8316_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/es8316_config.h
new file mode 100644
index 0000000000..75a8e59f71
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/es8316_config.h
@@ -0,0 +1,363 @@
+#ifndef _ES8316_CONFIG_H_
+#define _ES8316_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control es8316_speaker_normal_controls[] = {
+    {
+        .ctl_name = "DAC Playback Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Left Headphone Mixer Left DAC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Headphone Mixer Right DAC Switch",
+	.int_val = {on},
+    },
+};
+
+const struct config_control es8316_speaker_incall_controls[] = {
+};
+
+const struct config_control es8316_speaker_ringtone_controls[] = {
+};
+
+const struct config_control es8316_speaker_voip_controls[] = {
+};
+
+const struct config_control es8316_earpiece_normal_controls[] = {
+};
+
+const struct config_control es8316_earpiece_incall_controls[] = {
+};
+
+const struct config_control es8316_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control es8316_earpiece_voip_controls[] = {
+};
+
+const struct config_control es8316_headphone_normal_controls[] = {
+    {
+        .ctl_name = "DAC Playback Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Left Headphone Mixer Left DAC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Headphone Mixer Right DAC Switch",
+	.int_val = {on},
+    },
+};
+
+const struct config_control es8316_headphone_incall_controls[] = {
+};
+
+const struct config_control es8316_headphone_ringtone_controls[] = {
+};
+
+const struct config_control es8316_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control es8316_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control es8316_headphone_voip_controls[] = {
+};
+
+const struct config_control es8316_headset_normal_controls[] = {
+    {
+        .ctl_name = "DAC Playback Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Left Headphone Mixer Left DAC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Headphone Mixer Right DAC Switch",
+    },
+};
+
+const struct config_control es8316_headset_incall_controls[] = {
+};
+
+const struct config_control es8316_headset_ringtone_controls[] = {
+};
+
+const struct config_control es8316_headset_voip_controls[] = {
+};
+
+const struct config_control es8316_bluetooth_normal_controls[] = {
+};
+
+const struct config_control es8316_bluetooth_incall_controls[] = {
+};
+
+const struct config_control es8316_bluetooth_voip_controls[] = {
+};
+
+const struct config_control es8316_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {192},
+    },
+    {
+        .ctl_name = "Differential Mux",
+        .int_val = {0},
+    },
+};
+
+const struct config_control es8316_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {192},
+    },
+    {
+        .ctl_name = "Differential Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control es8316_bluetooth_sco_mic_capture_controls[] = {
+};
+
+const struct config_control es8316_playback_off_controls[] = {
+    {
+        .ctl_name = "DAC Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Left Headphone Mixer Left DAC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Headphone Mixer Right DAC Switch",
+	.int_val = {off},
+    },
+};
+
+const struct config_control es8316_capture_off_controls[] = {
+};
+
+const struct config_control es8316_incall_off_controls[] = {
+};
+
+const struct config_control es8316_voip_off_controls[] = {
+};
+
+const struct config_route_table es8316_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_normal_controls,
+        .controls_count = sizeof(es8316_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_incall_controls,
+        .controls_count = sizeof(es8316_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_ringtone_controls,
+        .controls_count = sizeof(es8316_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_voip_controls,
+        .controls_count = sizeof(es8316_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_earpiece_normal_controls,
+        .controls_count = sizeof(es8316_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_earpiece_incall_controls,
+        .controls_count = sizeof(es8316_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_earpiece_ringtone_controls,
+        .controls_count = sizeof(es8316_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_earpiece_voip_controls,
+        .controls_count = sizeof(es8316_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headphone_normal_controls,
+        .controls_count = sizeof(es8316_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headphone_incall_controls,
+        .controls_count = sizeof(es8316_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headphone_ringtone_controls,
+        .controls_count = sizeof(es8316_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_headphone_normal_controls,
+        .controls_count = sizeof(es8316_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(es8316_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headphone_voip_controls,
+        .controls_count = sizeof(es8316_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headset_normal_controls,
+        .controls_count = sizeof(es8316_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headset_incall_controls,
+        .controls_count = sizeof(es8316_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headset_ringtone_controls,
+        .controls_count = sizeof(es8316_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_headset_voip_controls,
+        .controls_count = sizeof(es8316_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_bluetooth_normal_controls,
+        .controls_count = sizeof(es8316_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8316_bluetooth_incall_controls,
+        .controls_count = sizeof(es8316_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8316_bluetooth_voip_controls,
+        .controls_count = sizeof(es8316_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_main_mic_capture_controls,
+        .controls_count = sizeof(es8316_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8316_hands_free_mic_capture_controls,
+        .controls_count = sizeof(es8316_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8316_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(es8316_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = es8316_playback_off_controls,
+        .controls_count = sizeof(es8316_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = es8316_capture_off_controls,
+        .controls_count = sizeof(es8316_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = es8316_incall_off_controls,
+        .controls_count = sizeof(es8316_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = es8316_voip_off_controls,
+        .controls_count = sizeof(es8316_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_ES8316_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/es8388_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/es8388_config.h
new file mode 100644
index 0000000000..af943f80d2
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/es8388_config.h
@@ -0,0 +1,428 @@
+#ifndef _es8388_CONFIG_H_
+#define _es8388_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control es8388_speaker_normal_controls[] = {
+    {
+        .ctl_name = "Left Mixer Left Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Mixer Right Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Output 2 Playback Volume",
+        .int_val = {27, 27},
+    },
+    {
+        .ctl_name = "aw87xxx_profile_switch_0",
+        .str_val = "Music",
+    },
+    {
+        .ctl_name = "aw87xxx_profile_switch_1",
+        .str_val = "Music",
+    },
+};
+
+const struct config_control es8388_speaker_incall_controls[] = {
+};
+
+const struct config_control es8388_speaker_ringtone_controls[] = {
+};
+
+const struct config_control es8388_speaker_voip_controls[] = {
+};
+
+const struct config_control es8388_earpiece_normal_controls[] = {
+};
+
+const struct config_control es8388_earpiece_incall_controls[] = {
+};
+
+const struct config_control es8388_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control es8388_earpiece_voip_controls[] = {
+};
+
+const struct config_control es8388_headphone_normal_controls[] = {
+    {
+        .ctl_name = "Left Mixer Left Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Mixer Right Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Output 1 Playback Volume",
+        .int_val = {27, 27},
+    },
+};
+
+const struct config_control es8388_headphone_incall_controls[] = {
+};
+
+const struct config_control es8388_headphone_ringtone_controls[] = {
+};
+
+const struct config_control es8388_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control es8388_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control es8388_headphone_voip_controls[] = {
+};
+
+const struct config_control es8388_headset_normal_controls[] = {
+    {
+        .ctl_name = "Left Mixer Left Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Mixer Right Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Output 1 Playback Volume",
+        .int_val = {27, 27},
+    },
+};
+
+const struct config_control es8388_headset_incall_controls[] = {
+};
+
+const struct config_control es8388_headset_ringtone_controls[] = {
+};
+
+const struct config_control es8388_headset_voip_controls[] = {
+};
+
+const struct config_control es8388_bluetooth_normal_controls[] = {
+};
+
+const struct config_control es8388_bluetooth_incall_controls[] = {
+};
+
+const struct config_control es8388_bluetooth_voip_controls[] = {
+};
+
+const struct config_control es8388_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture Digital Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Capture Mute",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Channel Capture Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "Right Channel Capture Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "Right PGA Mux",
+        .str_val = "DifferentialR",
+    },
+    {
+        .ctl_name = "Left PGA Mux",
+        .str_val = "DifferentialL",
+    },
+    {
+        .ctl_name = "Differential Mux",
+        .str_val = "Line 2",
+    },
+};
+
+const struct config_control es8388_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture Digital Volume",
+        .int_val = {192, 192},
+    },
+    {
+        .ctl_name = "Capture Mute",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Channel Capture Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "Right Channel Capture Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "Right PGA Mux",
+        .str_val = "DifferentialR",
+    },
+    {
+        .ctl_name = "Left PGA Mux",
+        .str_val = "DifferentialL",
+    },
+    {
+        .ctl_name = "Differential Mux",
+        .str_val = "Line 1",
+    },
+};
+
+const struct config_control es8388_bluetooth_sco_mic_capture_controls[] = {
+};
+
+const struct config_control es8388_playback_off_controls[] = {
+    {
+        .ctl_name = "Left Mixer Left Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Mixer Right Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Output 2 Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Output 1 Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "aw87xxx_profile_switch_0",
+        .str_val = "Off",
+    },
+    {
+        .ctl_name = "aw87xxx_profile_switch_1",
+        .str_val = "Off",
+    },
+};
+
+const struct config_control es8388_capture_off_controls[] = {
+    {
+        .ctl_name = "Capture Mute",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8388_incall_off_controls[] = {
+};
+
+const struct config_control es8388_voip_off_controls[] = {
+};
+
+const struct config_route_table es8388_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_normal_controls,
+        .controls_count = sizeof(es8388_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_incall_controls,
+        .controls_count = sizeof(es8388_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_ringtone_controls,
+        .controls_count = sizeof(es8388_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_voip_controls,
+        .controls_count = sizeof(es8388_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_earpiece_normal_controls,
+        .controls_count = sizeof(es8388_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_earpiece_incall_controls,
+        .controls_count = sizeof(es8388_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_earpiece_ringtone_controls,
+        .controls_count = sizeof(es8388_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_earpiece_voip_controls,
+        .controls_count = sizeof(es8388_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headphone_normal_controls,
+        .controls_count = sizeof(es8388_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headphone_incall_controls,
+        .controls_count = sizeof(es8388_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headphone_ringtone_controls,
+        .controls_count = sizeof(es8388_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_headphone_normal_controls,
+        .controls_count = sizeof(es8388_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(es8388_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headphone_voip_controls,
+        .controls_count = sizeof(es8388_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headset_normal_controls,
+        .controls_count = sizeof(es8388_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headset_incall_controls,
+        .controls_count = sizeof(es8388_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headset_ringtone_controls,
+        .controls_count = sizeof(es8388_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_headset_voip_controls,
+        .controls_count = sizeof(es8388_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_bluetooth_normal_controls,
+        .controls_count = sizeof(es8388_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8388_bluetooth_incall_controls,
+        .controls_count = sizeof(es8388_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8388_bluetooth_voip_controls,
+        .controls_count = sizeof(es8388_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_main_mic_capture_controls,
+        .controls_count = sizeof(es8388_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8388_hands_free_mic_capture_controls,
+        .controls_count = sizeof(es8388_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = es8388_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(es8388_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = es8388_playback_off_controls,
+        .controls_count = sizeof(es8388_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = es8388_capture_off_controls,
+        .controls_count = sizeof(es8388_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = es8388_incall_off_controls,
+        .controls_count = sizeof(es8388_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = es8388_voip_off_controls,
+        .controls_count = sizeof(es8388_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_es8388_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/es8396_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/es8396_config.h
new file mode 100644
index 0000000000..2260f7121a
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/es8396_config.h
@@ -0,0 +1,377 @@
+#ifndef _ES8396_CONFIG_H_
+#define _ES8396_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control es8396_speaker_normal_controls[] = {
+/*
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+// for BT client call
+const struct config_control es8396_speaker_incall_controls[] = {
+    /*down link*/
+    {
+        .ctl_name = "DACSRC Mux",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {on},
+    },
+    /*up link*/
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MASTERSDPO Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8396_headphone_normal_controls[] = {
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8396_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "VOICESDPO Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8396_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "VOICESDPO Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control es8396_playback_off_controls[] = {
+#if 0
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {off},
+    },
+#endif
+};
+
+const struct config_control es8396_capture_off_controls[] = {
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "VOICESDPO Mux",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control es8396_incall_off_controls[] = {
+    /*TODO*/
+    /*downlink*/
+    {
+        .ctl_name = "HPR Mix DACR2HPMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPL Mix DACL2HPMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC_1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP Amp Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DACSRC Mux",
+        .int_val = {0},
+    },
+    /*uplink*/
+    {
+        .ctl_name = "LLNMIX2LPGA Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RLNMIX2RPGA Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LLNIN Mix PMICDSE2LLNMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RLNIN Mix NMICDSE2RLNMIX Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "AMIC Mux Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MASTERSDPO Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC_1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Internal Mic Switch",
+        .int_val = {off},
+    },
+#if 1
+    {
+        .ctl_name = "RDMIX2 Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LDMIX2 Mux",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RDMIX1 Mux",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "LDMIX1 Mux",
+        .int_val = {0},
+    },
+#endif
+};
+
+const struct config_route_table es8396_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_speaker_normal_controls,
+        .controls_count = sizeof(es8396_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_speaker_incall_controls,
+        .controls_count = sizeof(es8396_speaker_incall_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_headphone_normal_controls,
+        .controls_count = sizeof(es8396_headphone_normal_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_main_mic_capture_controls,
+        .controls_count = sizeof(es8396_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = es8396_hands_free_mic_capture_controls,
+        .controls_count = sizeof(es8396_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = es8396_playback_off_controls,
+        .controls_count = sizeof(es8396_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = es8396_capture_off_controls,
+        .controls_count = sizeof(es8396_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = es8396_incall_off_controls,
+        .controls_count = sizeof(es8396_incall_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+#endif //_ES8396_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/hdmi_analog_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/hdmi_analog_config.h
new file mode 100755
index 0000000000..73483e49c2
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/hdmi_analog_config.h
@@ -0,0 +1,324 @@
+#ifndef _HDMI_ANALOG_CONFIG_H_
+#define _HDMI_ANALOG_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control hdmi_analog_speaker_normal_controls[] = {
+	{
+		.ctl_name = "DAC Playback Volume",
+		.int_val = {192, 192},
+	},
+};
+
+const struct config_control hdmi_analog_speaker_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_speaker_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_speaker_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_earpiece_normal_controls[] = {
+};
+
+const struct config_control hdmi_analog_earpiece_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_earpiece_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_headphone_normal_controls[] = {
+	{
+		.ctl_name = "DAC Playback Volume",
+		.int_val = {192, 192},
+	},
+};
+
+const struct config_control hdmi_analog_hdmi_normal_controls[] = {
+	{
+		.ctl_name = "DAC Playback Volume",
+		.int_val = {0, 0},
+	},
+};
+
+const struct config_control hdmi_analog_headphone_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_headphone_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control hdmi_analog_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_headphone_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_headset_normal_controls[] = {
+};
+
+const struct config_control hdmi_analog_headset_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_headset_ringtone_controls[] = {
+};
+
+const struct config_control hdmi_analog_headset_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_bluetooth_normal_controls[] = {
+};
+
+const struct config_control hdmi_analog_bluetooth_incall_controls[] = {
+};
+
+const struct config_control hdmi_analog_bluetooth_voip_controls[] = {
+};
+
+const struct config_control hdmi_analog_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Differential Mux",
+        .int_val = {0},
+    },
+};
+
+const struct config_control hdmi_analog_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "Differential Mux",
+        .int_val = {1},
+    },
+};
+
+const struct config_control hdmi_analog_bluetooth_sco_mic_capture_controls[] = {
+};
+
+const struct config_control hdmi_analog_playback_off_controls[] = {
+};
+
+const struct config_control hdmi_analog_capture_off_controls[] = {
+};
+
+const struct config_control hdmi_analog_incall_off_controls[] = {
+};
+
+const struct config_control hdmi_analog_voip_off_controls[] = {
+};
+
+const struct config_route_table hdmi_analog_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_normal_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_incall_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_voip_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_earpiece_normal_controls,
+        .controls_count = sizeof(hdmi_analog_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_earpiece_incall_controls,
+        .controls_count = sizeof(hdmi_analog_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_earpiece_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_earpiece_voip_controls,
+        .controls_count = sizeof(hdmi_analog_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headphone_normal_controls,
+        .controls_count = sizeof(hdmi_analog_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headphone_incall_controls,
+        .controls_count = sizeof(hdmi_analog_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headphone_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_headphone_normal_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headphone_voip_controls,
+        .controls_count = sizeof(hdmi_analog_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headset_normal_controls,
+        .controls_count = sizeof(hdmi_analog_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headset_incall_controls,
+        .controls_count = sizeof(hdmi_analog_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headset_ringtone_controls,
+        .controls_count = sizeof(hdmi_analog_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_headset_voip_controls,
+        .controls_count = sizeof(hdmi_analog_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_bluetooth_normal_controls,
+        .controls_count = sizeof(hdmi_analog_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = hdmi_analog_bluetooth_incall_controls,
+        .controls_count = sizeof(hdmi_analog_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = hdmi_analog_bluetooth_voip_controls,
+        .controls_count = sizeof(hdmi_analog_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_main_mic_capture_controls,
+        .controls_count = sizeof(hdmi_analog_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_hands_free_mic_capture_controls,
+        .controls_count = sizeof(hdmi_analog_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = hdmi_analog_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(hdmi_analog_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = hdmi_analog_playback_off_controls,
+        .controls_count = sizeof(hdmi_analog_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = hdmi_analog_capture_off_controls,
+        .controls_count = sizeof(hdmi_analog_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = hdmi_analog_incall_off_controls,
+        .controls_count = sizeof(hdmi_analog_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = hdmi_analog_voip_off_controls,
+        .controls_count = sizeof(hdmi_analog_voip_off_controls) / sizeof(struct config_control),
+    },
+#ifdef BOX_HAL
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+#else
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = hdmi_analog_hdmi_normal_controls,
+        .controls_count = sizeof(hdmi_analog_hdmi_normal_controls) / sizeof(struct config_control),
+    },
+#endif
+    //spdif
+    .spdif_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_HDMI_ANALOG_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/rk616_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rk616_config.h
new file mode 100755
index 0000000000..a6336749c1
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rk616_config.h
@@ -0,0 +1,1607 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rk616_config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RK616_CONFIG_H_
+#define _RK616_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rk616_speaker_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {22, 22},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_speaker_incall_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //mic1-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTL",
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "BST_L Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Main Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {29},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P ---> SPK
+    {
+        .ctl_name = "HPMix Mux",
+        .str_val = "DIFFIN",
+    },
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIFFIN Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXR Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_speaker_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_speaker_voip_controls[] = {
+
+};
+
+const struct config_control rk616_earpiece_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {22, 22},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_earpiece_incall_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //mic1-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTL",
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "BST_L Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Main Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {29},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P ---> SPK
+    {
+        .ctl_name = "HPMix Mux",
+        .str_val = "DIFFIN",
+    },
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIFFIN Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXR Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_earpiece_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_earpiece_voip_controls[] = {
+
+};
+
+const struct config_control rk616_headphone_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headphone_incall_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //mic1-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTL",
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "BST_L Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Main Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {29},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P ---> HP
+    {
+        .ctl_name = "HPMix Mux",
+        .str_val = "DIFFIN",
+    },
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIFFIN Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXR Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_speaker_headphone_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rk616_speaker_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {on},
+    }, 
+};
+
+const struct config_control rk616_headphone_voip_controls[] = {
+
+};
+
+const struct config_control rk616_headset_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headset_incall_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //mic2-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTR",
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Micbias2 Voltage",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "BST_R Mode",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Headset Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Headset Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {29},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P ---> HP
+    {
+        .ctl_name = "HPMix Mux",
+        .str_val = "DIFFIN",
+    },
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIFFIN Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "HPMIX MUX to HPMIXR Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headset_ringtone_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "High",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPMIXR DACR Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPR Mux",
+        .str_val = "HPMIXR",
+    },
+    {
+        .ctl_name = "HPL Mux",
+        .str_val = "HPMIXL",
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rk616_headset_voip_controls[] = {
+
+};
+
+const struct config_control rk616_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rk616_bluetooth_incall_controls[] = {
+    //DACL --> line1/2
+    {
+        .ctl_name = "LINEMIX DACL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {on},
+    },
+    //IN1N/P-->ADCL
+    {
+        .ctl_name = "MIXINL IN1P Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IN1P to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    }, 
+};
+
+const struct config_control rk616_bluetooth_voip_controls[] = {
+
+};
+
+const struct config_control rk616_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Headset Mic Capture Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTL",
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Main Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "BST_L Mode",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {31},
+    },
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    }, 
+};
+
+const struct config_control rk616_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Micbias1 Voltage",
+        .int_val = {0},
+    },
+
+    {
+        .ctl_name = "Headset Mic Capture Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mic Mux",
+        .str_val = "BSTR",
+    },
+    {
+        .ctl_name = "MUXMIC to MIXINL Volume",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Headset Mic Capture Volume",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "BST_R Mode",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Micbias2 Voltage",
+        .int_val = {7},
+    },
+    {
+        .ctl_name = "PGAL Capture Volume",
+        .int_val = {25},
+    },
+    {
+        .ctl_name = "Headset Jack Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {on},
+    }, 
+};
+
+const struct config_control rk616_bluetooth_sco_mic_capture_controls[] = {
+
+};
+
+const struct config_control rk616_playback_off_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPMIXL DACL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Headphone Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Headphone Playback Switch",
+        .int_val = {off, off},
+    },
+};
+
+const struct config_control rk616_capture_off_controls[] = {
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Headset Mic Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Headset Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {off},
+    }, 
+};
+
+const struct config_control rk616_incall_off_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "HP GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "RCV GPIO Control",
+        .str_val = "Low",
+    },
+
+    //close mic1-->line1/2
+    {
+        .ctl_name = "Mic Jack Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MIXINL MUXMIC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Main Mic Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "MIXINL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "PGAL Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINEMIX PGAL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINEOUT1 Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINEOUT2 Playback Switch",
+        .int_val = {off},
+    },
+    //clsoe IN1N/P ---> SPK
+    {
+        .ctl_name = "HPMIXR HPMix Mux Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPMIXL HPMix Mux Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Ext Spk Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DIFFIN Capture Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+};
+
+const struct config_control rk616_voip_off_controls[] = {
+
+};
+
+const struct config_route_table rk616_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_normal_controls,
+        .controls_count = sizeof(rk616_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_incall_controls,
+        .controls_count = sizeof(rk616_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_ringtone_controls,
+        .controls_count = sizeof(rk616_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_voip_controls,
+        .controls_count = sizeof(rk616_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_earpiece_normal_controls,
+        .controls_count = sizeof(rk616_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_earpiece_incall_controls,
+        .controls_count = sizeof(rk616_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_earpiece_ringtone_controls,
+        .controls_count = sizeof(rk616_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_earpiece_voip_controls,
+        .controls_count = sizeof(rk616_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headphone_normal_controls,
+        .controls_count = sizeof(rk616_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headphone_incall_controls,
+        .controls_count = sizeof(rk616_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headphone_ringtone_controls,
+        .controls_count = sizeof(rk616_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rk616_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rk616_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headphone_voip_controls,
+        .controls_count = sizeof(rk616_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headset_normal_controls,
+        .controls_count = sizeof(rk616_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headset_incall_controls,
+        .controls_count = sizeof(rk616_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headset_ringtone_controls,
+        .controls_count = sizeof(rk616_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_headset_voip_controls,
+        .controls_count = sizeof(rk616_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_bluetooth_normal_controls,
+        .controls_count = sizeof(rk616_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_bluetooth_incall_controls,
+        .controls_count = sizeof(rk616_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_bluetooth_voip_controls,
+        .controls_count = sizeof(rk616_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_main_mic_capture_controls,
+        .controls_count = sizeof(rk616_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rk616_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rk616_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rk616_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rk616_playback_off_controls,
+        .controls_count = sizeof(rk616_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rk616_capture_off_controls,
+        .controls_count = sizeof(rk616_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rk616_incall_off_controls,
+        .controls_count = sizeof(rk616_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rk616_voip_off_controls,
+        .controls_count = sizeof(rk616_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+#endif //_RK616_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt3224_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt3224_config.h
new file mode 100755
index 0000000000..c395c5b110
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt3224_config.h
@@ -0,0 +1,3969 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rt3224_config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RT3224_CONFIG_H_
+#define _RT3224_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt3224_speaker_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",               
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_speaker_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset incall
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_speaker_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_speaker_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",               
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control rt3224_earpiece_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset incall
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_earpiece_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_earpiece_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",               
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3224_headphone_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headphone_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headphone_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_speaker_headphone_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_speaker_headphone_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headphone_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headset_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headset_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN3 Mode Control",
+        .str_val = "Single ended",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN3 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headset_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_headset_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },  
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+*/
+};
+
+const struct config_control rt3224_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt3224_bluetooth_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },  
+
+    //INF1_DAC -> DAC MIXL
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {on},
+    },
+
+    {
+        .ctl_name = "Mono ADC Capture Volume",        
+        .int_val = {127, 127},
+    },
+    {
+        .ctl_name = "Mono DAC Playback Volume",       
+        .int_val = {175, 175},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=39
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {39, 39},
+    },
+
+    //IN2 -> ADC_L -> Stereo_ADC_Mixer_L -> IF1_ADC_L  
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {45, 45},
+    },   
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset incall
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3224_bluetooth_voip_controls[] = {
+    //close speaker
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",             
+        .int_val = {off},
+    },
+
+    // IF2 DAC L ->DAC L2 Volume ->DIG MIXL ->Stereo ADC L2 Mux ->Stereo ADC MIXL ->IF1_ADC_L 
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L2 Mux",  
+        .str_val = "DMIC1",
+    },
+    {
+        .ctl_name = "Stereo ADC L2 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC R2 Mux",  
+        .str_val = "DMIC1",
+    },
+    {
+        .ctl_name = "Stereo ADC R2 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {on},
+    },
+    // MX-2C[15]   MX-2C[11] 
+    {
+        .ctl_name = "DIG MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    // MX-29[15]   MX-29[7]  
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",  
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",  
+        .int_val = {off},
+    },
+    // DIG MIXL ->Stereo ADC L1 Mux ->Stereo ADC MIXL 
+    {
+        .ctl_name = "Stereo ADC L1 Mux",  
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC R1 Mux",  
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC R1 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },    
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L1 Switch",  
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+/*
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+*/
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Enable",
+    },      
+
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "ADC Capture Volume", 
+        .int_val = {47, 47},
+    },
+};
+
+const struct config_control rt3224_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {off},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "right copy to left",
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {5},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {60, 60},
+    },
+};
+
+const struct config_control rt3224_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "right copy to left",
+    },
+
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN3 Mode Control",
+        .str_val = "Single ended",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN3 Boost",
+        .int_val = {5},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {60, 60},
+    },
+};
+
+const struct config_control rt3224_bluetooth_sco_mic_capture_controls[] = {
+    // IF1_DAC_L -> DACL1 -> Mono_DAC_Mixer_L -> Mono ADC L1 Mux  ->Mono ADC MIXL->IF2 ADC L Mux->  IF2_ADC_L  
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC L1 Mux",  
+        .str_val = "Mono DAC MIXL",
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC L Mux",
+        .str_val = "Mono ADC MIXL",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "Normal",
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",  
+        .str_val = "Mono DAC MIXR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    //  MX-2B[12]       MX-2B[10]      MX-2B[4]       MX-2B[2]  
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt3224_playback_off_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+/*
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //speaker incall
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+*/
+};
+
+const struct config_control rt3224_capture_off_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3224_incall_off_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3224_voip_off_controls[] = {
+
+};
+
+const struct config_route_table rt3224_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_normal_controls,
+        .controls_count = sizeof(rt3224_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_incall_controls,
+        .controls_count = sizeof(rt3224_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_ringtone_controls,
+        .controls_count = sizeof(rt3224_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_voip_controls,
+        .controls_count = sizeof(rt3224_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_earpiece_normal_controls,
+        .controls_count = sizeof(rt3224_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_earpiece_incall_controls,
+        .controls_count = sizeof(rt3224_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt3224_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_earpiece_voip_controls,
+        .controls_count = sizeof(rt3224_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headphone_normal_controls,
+        .controls_count = sizeof(rt3224_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headphone_incall_controls,
+        .controls_count = sizeof(rt3224_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headphone_ringtone_controls,
+        .controls_count = sizeof(rt3224_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt3224_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt3224_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headphone_voip_controls,
+        .controls_count = sizeof(rt3224_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headset_normal_controls,
+        .controls_count = sizeof(rt3224_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headset_incall_controls,
+        .controls_count = sizeof(rt3224_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headset_ringtone_controls,
+        .controls_count = sizeof(rt3224_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_headset_voip_controls,
+        .controls_count = sizeof(rt3224_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_bluetooth_normal_controls,
+        .controls_count = sizeof(rt3224_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3224_bluetooth_incall_controls,
+        .controls_count = sizeof(rt3224_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3224_bluetooth_voip_controls,
+        .controls_count = sizeof(rt3224_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_main_mic_capture_controls,
+        .controls_count = sizeof(rt3224_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3224_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt3224_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3224_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt3224_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt3224_playback_off_controls,
+        .controls_count = sizeof(rt3224_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt3224_capture_off_controls,
+        .controls_count = sizeof(rt3224_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt3224_incall_off_controls,
+        .controls_count = sizeof(rt3224_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt3224_voip_off_controls,
+        .controls_count = sizeof(rt3224_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_RT3224_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt3261_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt3261_config.h
new file mode 100755
index 0000000000..2b4a2e75c6
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt3261_config.h
@@ -0,0 +1,3758 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rt3261_config.h
+ * @brief 
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RT3261_CONFIG_H_
+#define _RT3261_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt3261_speaker_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",                
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_speaker_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",                
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {on},
+    },
+    //SEND DOWNSTREAM INTO DSP
+    {
+        .ctl_name = "RxDP1 Mux",
+        .str_val = "DAC1",
+    },
+    {
+        .ctl_name = "RxDP Mux",
+        .str_val = "RxDP1",
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //SEND UPSTREAM INTO DSP
+    {
+        .ctl_name = "RECMIXR BST1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RxDC Mux",
+        .str_val = "Mono_ADC",
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "TxDP",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {71, 71},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //headphone && headset incall
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_speaker_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_speaker_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control rt3261_earpiece_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {on},
+    },
+    //SEND DOWNSTREAM INTO DSP
+    {
+        .ctl_name = "RxDP1 Mux",
+        .str_val = "DAC1",
+    },
+    {
+        .ctl_name = "RxDP Mux",
+        .str_val = "RxDP1",
+    },
+
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //SEND UPSTREAM INTO DSP
+    {
+        .ctl_name = "RECMIXR BST1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RxDC Mux",
+        .str_val = "Mono_ADC",
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "TxDP",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {71, 71},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //headphone && headset incall
+
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_earpiece_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+};
+
+const struct config_control rt3261_earpiece_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //speaker incall
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_headphone_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headphone_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headphone_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_speaker_headphone_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_speaker_headphone_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {31, 31},
+    },
+    //min=0,max=10
+    {
+        .ctl_name = "Class D SPK Ratio Control",
+        .int_val = {10},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headphone_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headset_normal_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headset_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},  
+    },
+    //OPEN ROUTE 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",                  
+        .int_val = {55, 55},
+    },
+    {
+        .ctl_name = "RECMIXR BST3 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDP_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_ADC",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {on},
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN3 Mode Control",
+        .str_val = "Single ended",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN3 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //OPEN KEY TONE
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {on},
+    },
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXR BST1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headset_ringtone_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_headset_voip_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },        
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "DAC L2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux", 
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=31
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {31, 31},
+    },
+    //dBscale-min=-65.625dB,step=0.375dB,min=0,max=175
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {175, 175},
+    },
+    //speaker normal
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt3261_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt3261_bluetooth_incall_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+        
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {1},
+    },
+    //INF1_DAC -> DAC MIXL
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Volume",        
+        .int_val = {127, 127},
+    },
+    {
+        .ctl_name = "Mono DAC Playback Volume",       
+        .int_val = {175, 175},
+    },
+    //dBscale-min=-46.50dB,step=1.50dB,min=0,max=39
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {39, 39},
+    },
+    //IN2 -> ADC_L -> Stereo_ADC_Mixer_L -> IF1_ADC_L  
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {45, 45},
+    },   
+
+    //speaker normal
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //headphone && headset incall
+
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_bluetooth_voip_controls[] = {
+    // IF2 DAC L ->DAC L2 Volume ->DIG MIXL ->Stereo ADC L2 Mux ->Stereo ADC MIXL ->IF1_ADC_L 
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC L2 Mux",  
+        .str_val = "DMIC1",
+    },
+    {
+        .ctl_name = "Stereo ADC L2 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Mono dacr Mux",
+        .str_val = "TxDC_R",
+    },
+    {
+        .ctl_name = "DACR Select",
+        .str_val = "IF2_DAC",
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC R2 Mux",  
+        .str_val = "DMIC1",
+    },
+    {
+        .ctl_name = "Stereo ADC R2 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {on},
+    },
+    //  MX-2C[15]   MX-2C[11] 
+    // 下行必须关掉的，否则上行的声音会导到下行，蓝牙耳机能听到自己的回环侧音 
+    {
+        .ctl_name = "DIG MIXL DAC L1 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    //  MX-29[15]   MX-29[7]  
+    // 下行可以不关掉的，可以通过它把下行导到喇叭，原理上关不关都不影响
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",  
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",  
+        .int_val = {off},
+    },
+    //  DIG MIXL ->Stereo ADC L1 Mux ->Stereo ADC MIXL 
+    {
+        .ctl_name = "Stereo ADC L1 Mux",  
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC L1 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC R1 Mux",  
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC R1 Mux",  
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    // 测试下行声音从普通耳机放出
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L1 Switch",  
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "SPOL MIX SPKVOL L Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},    
+    },
+    {
+        .ctl_name = "HP mute Switch",
+        .int_val = {off},
+    },
+    //enable ASRC，同时操作了reg61[7](打开则上行有声)，reg62[15](打开则下行有声)，实测必须放通路最后，否则reg61[7]位仍然会被关掉，reg62[15]不会被关
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Enable",
+    },      
+
+    {
+        .ctl_name = "Mono DAC Playback Volume",
+        .int_val = {127, 127},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",  
+        .int_val = {47, 47},   
+    },
+};
+
+const struct config_control rt3261_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RxDC Mux",
+        .str_val = "Mono_ADC",
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "TxDP",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "right copy to left",
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN1 Mode Control",
+        .str_val = "Differential",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {71, 71},
+    },
+};
+
+const struct config_control rt3261_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    //OPEN ROUTE
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "ADCR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RxDC Mux",
+        .str_val = "Mono_ADC",
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "TxDP",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "right copy to left",
+    },
+    //"Single ended"=0, "Differential"=1
+    {
+        .ctl_name = "IN3 Mode Control",
+        .str_val = "Single ended",
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN3 Boost",
+        .int_val = {0},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127  
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {71, 71},
+    },
+};
+
+const struct config_control rt3261_bluetooth_sco_mic_capture_controls[] = {
+    // IF1_DAC_L -> DACL1 -> Mono_DAC_Mixer_L -> Mono ADC L1 Mux  ->Mono ADC MIXL->IF2 ADC L Mux->  IF2_ADC_L  
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC L1 Mux",  
+        .str_val = "Mono DAC MIXL",
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC L Mux",
+        .str_val = "Mono ADC MIXL",
+    },
+    {
+        .ctl_name = "ADC IF2 Data Switch",
+        .str_val = "Normal",
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",  
+        .str_val = "Mono DAC MIXR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IF2 ADC R Mux",
+        .str_val = "Mono ADC MIXR",
+    },
+    //  MX-2B[12]       MX-2B[10]      MX-2B[4]       MX-2B[2]    
+    //  上行必须必须关掉的，否则下行的声音会导到上行(IF2 DAC为下行)，对方能听到自己的回音
+    {
+        .ctl_name = "Mono DAC MIXL DAC L2 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R2 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC R2 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC L2 Switch",
+        .int_val = {off},    
+    },
+    {
+        .ctl_name = "Mono ADC Capture Volume",
+        .int_val = {127, 127},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume", 
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt3261_playback_off_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_capture_off_controls[] = {
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_incall_off_controls[] = {
+    //disable ASRC
+    {
+        .ctl_name = "ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "Speaker Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "Modem Input Switch",
+        .int_val = {0},
+    },
+    //speaker incall 
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXL OUT MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "SPK MIXR OUT MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    //headphone && headset normal
+    {
+        .ctl_name = "OUT MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    //bt incall
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch", 
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",  
+        .int_val = {off},
+    },
+    //close other mixer 
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",             
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt3261_voip_off_controls[] = {
+
+};
+
+const struct config_route_table rt3261_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_normal_controls,
+        .controls_count = sizeof(rt3261_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_incall_controls,
+        .controls_count = sizeof(rt3261_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_ringtone_controls,
+        .controls_count = sizeof(rt3261_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_voip_controls,
+        .controls_count = sizeof(rt3261_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_earpiece_normal_controls,
+        .controls_count = sizeof(rt3261_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_earpiece_incall_controls,
+        .controls_count = sizeof(rt3261_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt3261_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_earpiece_voip_controls,
+        .controls_count = sizeof(rt3261_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headphone_normal_controls,
+        .controls_count = sizeof(rt3261_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headphone_incall_controls,
+        .controls_count = sizeof(rt3261_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headphone_ringtone_controls,
+        .controls_count = sizeof(rt3261_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt3261_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt3261_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headphone_voip_controls,
+        .controls_count = sizeof(rt3261_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headset_normal_controls,
+        .controls_count = sizeof(rt3261_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headset_incall_controls,
+        .controls_count = sizeof(rt3261_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headset_ringtone_controls,
+        .controls_count = sizeof(rt3261_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_headset_voip_controls,
+        .controls_count = sizeof(rt3261_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_bluetooth_normal_controls,
+        .controls_count = sizeof(rt3261_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3261_bluetooth_incall_controls,
+        .controls_count = sizeof(rt3261_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3261_bluetooth_voip_controls,
+        .controls_count = sizeof(rt3261_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_main_mic_capture_controls,
+        .controls_count = sizeof(rt3261_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt3261_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt3261_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt3261_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt3261_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt3261_playback_off_controls,
+        .controls_count = sizeof(rt3261_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt3261_capture_off_controls,
+        .controls_count = sizeof(rt3261_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt3261_incall_off_controls,
+        .controls_count = sizeof(rt3261_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt3261_voip_off_controls,
+        .controls_count = sizeof(rt3261_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_RT3261_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5616_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5616_config.h
new file mode 100755
index 0000000000..aadfc1ba00
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5616_config.h
@@ -0,0 +1,890 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rt5616_config.h
+ * @brief 
+ * @author  RKAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RT5616_CONFIG_H_
+#define _RT5616_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt5616_speaker_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {on},
+    },/*
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {on},
+    },
+      {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {31, 31},
+    }, 
+    */
+};
+
+const struct config_control rt5616_speaker_incall_controls[] = {
+
+};
+
+const struct config_control rt5616_speaker_ringtone_controls[] = {    
+ 
+};
+
+const struct config_control rt5616_speaker_voip_controls[] = {
+ 
+};
+
+const struct config_control rt5616_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control rt5616_earpiece_incall_controls[] = {
+
+};
+
+const struct config_control rt5616_earpiece_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5616_earpiece_voip_controls[] = {
+
+};
+
+const struct config_control rt5616_headphone_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    /*{
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    }, */
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {on},
+    },/*
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    }, */
+};
+
+const struct config_control rt5616_headphone_incall_controls[] = {
+ 
+};
+
+const struct config_control rt5616_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5616_speaker_headphone_normal_controls[] = {
+ 
+};
+
+const struct config_control rt5616_speaker_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5616_headphone_voip_controls[] = {
+
+};
+
+const struct config_control rt5616_headset_normal_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "HP Playback Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {off, off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    /*{
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    }, */
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {on},
+    },/*
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    }, */
+};
+
+const struct config_control rt5616_headset_incall_controls[] = {
+
+};
+
+const struct config_control rt5616_headset_ringtone_controls[] = {
+ 
+};
+
+const struct config_control rt5616_headset_voip_controls[] = {
+ 
+};
+
+const struct config_control rt5616_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt5616_bluetooth_incall_controls[] = {
+ 
+};
+
+const struct config_control rt5616_bluetooth_voip_controls[] = {
+ 
+};
+
+const struct config_control rt5616_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL INL1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+   {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "IN2 Mode Control",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {32,32},
+    },
+    {
+        .ctl_name = "ADC Boost Gain",
+        .int_val = {3,3},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5616_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL INL1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+   {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "IN1 Mode Control",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {40,40},
+    },
+    {
+        .ctl_name = "ADC Boost Gain",
+        .int_val = {1,1},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {on},
+    },
+ 
+};
+
+const struct config_control rt5616_bluetooth_sco_mic_capture_controls[] = {
+ 
+};
+
+const struct config_control rt5616_playback_off_controls[] = {
+    {
+        .ctl_name = "SPK GPIO Control",
+        .str_val = "Low",
+    },
+/*
+    {
+        .ctl_name = "OUT Playback Switch",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "OUT Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "HP Playback Switch",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "OUT Channel Switch",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC L1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LOUT MIX DAC R1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "HPO MIX DAC1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR REC MIXR Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL INL1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL REC MIXL Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {0},
+    },   
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC L1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC R1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC MIXR Stereo ADC Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC MIXL Stereo ADC Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {0, 0},
+    }, 
+*/ 
+};
+
+const struct config_control rt5616_capture_off_controls[] = {
+    {
+        .ctl_name = "RECMIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL INL1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {0,0},
+    },
+   {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "IN1 Mode Control",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN2 Mode Control",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {0,0},
+    },
+    {
+        .ctl_name = "ADC Boost Gain",
+        .int_val = {0,0},
+    },
+    {
+        .ctl_name = "IN Capture Volume",
+        .int_val = {0,0},
+    },
+    {
+        .ctl_name = "RECMIXR INR1 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RECMIXL INL1 Switch",
+        .int_val = {0},
+    },
+};
+
+const struct config_control rt5616_incall_off_controls[] = {
+ 
+};
+
+const struct config_control rt5616_voip_off_controls[] = {
+
+};
+
+const struct config_route_table rt5616_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_normal_controls,
+        .controls_count = sizeof(rt5616_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_incall_controls,
+        .controls_count = sizeof(rt5616_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_ringtone_controls,
+        .controls_count = sizeof(rt5616_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_voip_controls,
+        .controls_count = sizeof(rt5616_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_earpiece_normal_controls,
+        .controls_count = sizeof(rt5616_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_earpiece_incall_controls,
+        .controls_count = sizeof(rt5616_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt5616_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_earpiece_voip_controls,
+        .controls_count = sizeof(rt5616_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headphone_normal_controls,
+        .controls_count = sizeof(rt5616_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headphone_incall_controls,
+        .controls_count = sizeof(rt5616_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5616_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt5616_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5616_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headphone_voip_controls,
+        .controls_count = sizeof(rt5616_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headset_normal_controls,
+        .controls_count = sizeof(rt5616_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headset_incall_controls,
+        .controls_count = sizeof(rt5616_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headset_ringtone_controls,
+        .controls_count = sizeof(rt5616_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_headset_voip_controls,
+        .controls_count = sizeof(rt5616_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_bluetooth_normal_controls,
+        .controls_count = sizeof(rt5616_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5616_bluetooth_incall_controls,
+        .controls_count = sizeof(rt5616_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5616_bluetooth_voip_controls,
+        .controls_count = sizeof(rt5616_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_main_mic_capture_controls,
+        .controls_count = sizeof(rt5616_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5616_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt5616_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5616_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt5616_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt5616_playback_off_controls,
+        .controls_count = sizeof(rt5616_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt5616_capture_off_controls,
+        .controls_count = sizeof(rt5616_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt5616_incall_off_controls,
+        .controls_count = sizeof(rt5616_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt5616_voip_off_controls,
+        .controls_count = sizeof(rt5616_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_RT5616_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5640_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5640_config.h
new file mode 100644
index 0000000000..2b650d9285
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5640_config.h
@@ -0,0 +1,1468 @@
+#ifndef _RT5640_CONFIG_H_
+#define _RT5640_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt5640_speaker_normal_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPOL MIX SPKVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPOR MIX SPKVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {30, 33},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {on,on},
+    },
+};
+
+const struct config_control rt5640_speaker_incall_controls[] = {
+
+};
+
+const struct config_control rt5640_speaker_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5640_speaker_voip_controls[] = {
+
+};
+
+const struct config_control rt5640_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control rt5640_earpiece_incall_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_earpiece_ringtone_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_earpiece_voip_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_headphone_normal_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+};
+
+const struct config_control rt5640_headphone_incall_controls[] = {
+
+};
+
+const struct config_control rt5640_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5640_speaker_headphone_normal_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPK MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPOL MIX SPKVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "SPOR MIX SPKVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {30, 33},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+};
+
+const struct config_control rt5640_speaker_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5640_headphone_voip_controls[] = {
+
+};
+
+
+const struct config_control rt5640_headpset_normal_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+};
+
+const struct config_control rt5640_headset_incall_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_headset_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5640_headset_voip_controls[] = {
+
+};
+
+
+const struct config_control rt5640_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt5640_bluetooth_incall_controls[] = {
+
+};
+
+const struct config_control rt5640_bluetooth_voip_controls[] = {
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+       .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC L1 Mux",
+        .str_val = "Mono DAC MIXL",
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "Mono DAC MIXR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "BT Up Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "BT Down Switch",
+        .int_val = {on},
+    },
+};
+
+
+const struct config_control rt5640_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Int Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "DAI select",
+        .str_val = "1:1|2:2",
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker Channel Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off}
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on}
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    //min=0,max=8, bypass=0=0db, 30db=3, 52db=8
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {4},
+    },
+    //dBscale-min=-17.625dB,step=0.375dB,min=0,max=127
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {100, 100},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+     },
+     {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_bluetooth_sco_mic_capture_controls[] = {
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC1 Mux",
+        .str_val = "DIG MIX",
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC L1 Mux",
+        .str_val = "Mono DAC MIXL",
+    },
+    {
+        .ctl_name = "Mono ADC R1 Mux",
+        .str_val = "Mono DAC MIXR",
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Switch",
+        .int_val = {on,on},
+    },
+    {
+        .ctl_name = "BT Up Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "BT Down Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5640_playback_off_controls[] = {
+    {
+        .ctl_name = "HP L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP R Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HP Channel Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker L Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Speaker R Playback Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt5640_capture_off_controls[] = {
+    {
+        .ctl_name = "RECMIXL BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXR BST1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Int Mic Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt5640_incall_off_controls[] = {
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Int Mic Switch",
+        .int_val = {off},
+    },
+};
+
+const struct config_control rt5640_voip_off_controls[] = {
+    {
+        .ctl_name = "DIG MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "DIG MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono DAC MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC MIXL ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC MIXR ADC1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Mono ADC Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Headset Mic Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Int Mic Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "BT Up Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "BT Down Switch",
+        .int_val = {off},
+    },
+};
+
+
+const struct config_route_table rt5640_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_normal_controls,
+        .controls_count = sizeof(rt5640_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_incall_controls,
+        .controls_count = sizeof(rt5640_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_ringtone_controls,
+        .controls_count = sizeof(rt5640_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_voip_controls,
+        .controls_count = sizeof(rt5640_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_earpiece_normal_controls,
+        .controls_count = sizeof(rt5640_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_earpiece_incall_controls,
+        .controls_count = sizeof(rt5640_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt5640_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_earpiece_voip_controls,
+        .controls_count = sizeof(rt5640_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headphone_normal_controls,
+        .controls_count = sizeof(rt5640_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headphone_incall_controls,
+        .controls_count = sizeof(rt5640_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5640_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt5640_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5640_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headphone_voip_controls,
+        .controls_count = sizeof(rt5640_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headpset_normal_controls,
+        .controls_count = sizeof(rt5640_headpset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headset_incall_controls,
+        .controls_count = sizeof(rt5640_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headset_ringtone_controls,
+        .controls_count = sizeof(rt5640_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_headset_voip_controls,
+        .controls_count = sizeof(rt5640_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_bluetooth_normal_controls,
+        .controls_count = sizeof(rt5640_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_bluetooth_incall_controls,
+        .controls_count = sizeof(rt5640_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_bluetooth_voip_controls,
+        .controls_count = sizeof(rt5640_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_main_mic_capture_controls,
+        .controls_count = sizeof(rt5640_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt5640_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5640_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt5640_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt5640_playback_off_controls,
+        .controls_count = sizeof(rt5640_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt5640_capture_off_controls,
+        .controls_count = sizeof(rt5640_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt5640_incall_off_controls,
+        .controls_count = sizeof(rt5640_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt5640_voip_off_controls,
+        .controls_count = sizeof(rt5640_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+#endif //_RT5640_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5651_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5651_config.h
new file mode 100644
index 0000000000..fa16c4251d
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5651_config.h
@@ -0,0 +1,1234 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file rt5651_config.h
+ * @brief
+ * @author  RkAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _RT5651_CONFIG_H_
+#define _RT5651_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt5651_speaker_normal_controls[] = {
+    /*
+    	{
+            .ctl_name = "DAC MIXL INF1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "DAC MIXR INF1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "OUT MIXL DAC L1 Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "OUT MIXR DAC R1 Switch",
+            .int_val = {on},
+        },
+        	{
+            .ctl_name = "OUTVOL L Switch",
+            .int_val = {on},
+        },
+        	{
+            .ctl_name = "OUTVOL R Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "LOUT MIX OUTVOL L Switch",
+            .int_val = {on},
+        },
+    	{
+            .ctl_name = "LOUT MIX OUTVOL R Switch",
+            .int_val = {on},
+        },
+        {
+            .ctl_name = "LOUT L Playback Switch",
+            .int_val = {on},
+        },
+          {
+            .ctl_name = "LOUT R Playback Switch",
+            .int_val = {on},
+        },
+    */
+     {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+
+};
+
+const struct config_control rt5651_speaker_incall_controls[] = {
+
+
+};
+
+const struct config_control rt5651_speaker_ringtone_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUTVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUTVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT R Playback Switch",
+        .int_val = {on},
+    },
+
+};
+
+const struct config_control rt5651_speaker_voip_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUTVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUTVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT MIX OUTVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "LOUT R Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control rt5651_earpiece_normal_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+
+};
+
+const struct config_control rt5651_earpiece_incall_controls[] = {
+
+};
+
+const struct config_control rt5651_earpiece_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5651_earpiece_voip_controls[] = {
+
+};
+
+const struct config_control rt5651_headphone_normal_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_headphone_incall_controls[] = {
+
+};
+
+const struct config_control rt5651_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_speaker_headphone_normal_controls[] = {
+
+};
+
+const struct config_control rt5651_speaker_headphone_ringtone_controls[] = {
+
+};
+
+const struct config_control rt5651_headphone_voip_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_headset_normal_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_headset_incall_controls[] = {
+
+};
+
+const struct config_control rt5651_headset_ringtone_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_headset_voip_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "DAC MIXL INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC MIXR INF1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+};
+
+const struct config_control rt5651_bluetooth_normal_controls[] = {
+
+};
+
+const struct config_control rt5651_bluetooth_incall_controls[] = {
+
+};
+
+const struct config_control rt5651_bluetooth_voip_controls[] = {
+
+};
+
+const struct config_control rt5651_hands_free_mic_capture_controls[] = {
+    {
+        .ctl_name = "RECMIXL BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RECMIXR BST3 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo1 ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo1 ADC R1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "IN1 Boost",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+
+};
+
+const struct config_control rt5651_main_mic_capture_controls[] = {
+    /* {
+         .ctl_name = "Stereo1 ADC L2 Mux",
+         .str_val = "DMIC",
+     },
+    {
+         .ctl_name = "Stereo1 ADC R2 Mux",
+         .str_val = "DMIC",
+     },
+    {
+         .ctl_name = "Stereo1 ADC MIXL ADC2 Switch",
+         .int_val = {on},
+     },
+    {
+         .ctl_name = "Stereo1 ADC MIXR ADC2 Switch",
+         .int_val = {on},
+     },*/
+    {
+        .ctl_name = "RECMIXL BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "RECMIXR BST2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo1 ADC L1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo1 ADC R1 Mux",
+        .str_val = "ADC",
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXL ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXR ADC1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {on, on},
+    },
+    {
+        .ctl_name = "IN2 Boost",
+        .int_val = {2},
+    },
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+
+};
+
+const struct config_control rt5651_bluetooth_sco_mic_capture_controls[] = {
+
+};
+
+const struct config_control rt5651_playback_off_controls[] = {
+
+};
+
+const struct config_control rt5651_capture_off_controls[] = {
+
+};
+
+const struct config_control rt5651_incall_off_controls[] = {
+
+};
+
+const struct config_control rt5651_voip_off_controls[] = {
+
+};
+
+const struct config_control rt5651_hdmiin_normal_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Enable",
+    },
+    {
+        .ctl_name = "IF2 ASRC Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXL DAC L1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "OUT MIXR DAC R1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL L Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPOVOL R Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO MIX HPVOL Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO L Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HPO R Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "HP Playback Volume",
+        .int_val = {31, 31},
+    },
+    {
+        .ctl_name = "DAC1 Playback Volume",
+        .int_val = {175, 175},
+    },
+
+};
+
+const struct config_control rt5651_hdmiin_off_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .str_val = "Disable",
+    },
+    {
+        .ctl_name = "IF2 ASRC Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXL DAC L2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Stereo DAC MIXR DAC R2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {1, 1},
+    },
+};
+
+const struct config_control rt5651_hdmiin_captrue_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "IF2 ASRC Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DAC L2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DAC R2 Mux",
+        .str_val = "IF2",
+    },
+    {
+        .ctl_name = "DD MIXL DAC L2 Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "DD MIXR DAC R2 Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Stereo1 ADC L2 Mux",
+        .str_val = "DD MIX",
+    },
+    {
+        .ctl_name = "Stereo1 ADC R2 Mux",
+        .str_val = "DD MIX",
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXL ADC2 Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXR ADC2 Switch",
+        .int_val = {1},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {1, 1},
+    },
+
+    {
+        .ctl_name = "ADC Capture Volume",
+        .int_val = {47, 47},
+    },
+};
+
+const struct config_control rt5651_hdmiin_captrue_off_controls[] = {
+    {
+        .ctl_name = "RT5651 ASRC Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "IF2 ASRC Switch",
+        .int_val = {0},
+    },
+
+    {
+        .ctl_name = "DD MIXL DAC L2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "DD MIXR DAC R2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXL ADC2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Stereo1 ADC MIXR ADC2 Switch",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "ADC Capture Switch",
+        .int_val = {0, 0},
+    },
+};
+
+const struct config_route_table rt5651_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_normal_controls,
+        .controls_count = sizeof(rt5651_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_incall_controls,
+        .controls_count = sizeof(rt5651_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_ringtone_controls,
+        .controls_count = sizeof(rt5651_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_voip_controls,
+        .controls_count = sizeof(rt5651_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_earpiece_normal_controls,
+        .controls_count = sizeof(rt5651_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_earpiece_incall_controls,
+        .controls_count = sizeof(rt5651_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_earpiece_ringtone_controls,
+        .controls_count = sizeof(rt5651_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_earpiece_voip_controls,
+        .controls_count = sizeof(rt5651_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headphone_normal_controls,
+        .controls_count = sizeof(rt5651_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headphone_incall_controls,
+        .controls_count = sizeof(rt5651_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5651_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_headphone_normal_controls,
+        .controls_count = sizeof(rt5651_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(rt5651_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headphone_voip_controls,
+        .controls_count = sizeof(rt5651_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headset_normal_controls,
+        .controls_count = sizeof(rt5651_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headset_incall_controls,
+        .controls_count = sizeof(rt5651_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headset_ringtone_controls,
+        .controls_count = sizeof(rt5651_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_headset_voip_controls,
+        .controls_count = sizeof(rt5651_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_bluetooth_normal_controls,
+        .controls_count = sizeof(rt5651_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5651_bluetooth_incall_controls,
+        .controls_count = sizeof(rt5651_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5651_bluetooth_voip_controls,
+        .controls_count = sizeof(rt5651_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_main_mic_capture_controls,
+        .controls_count = sizeof(rt5651_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = rt5651_hands_free_mic_capture_controls,
+        .controls_count = sizeof(rt5651_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0_1,
+        .controls = rt5651_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(rt5651_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = rt5651_playback_off_controls,
+        .controls_count = sizeof(rt5651_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = rt5651_capture_off_controls,
+        .controls_count = sizeof(rt5651_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = rt5651_incall_off_controls,
+        .controls_count = sizeof(rt5651_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = rt5651_voip_off_controls,
+        .controls_count = sizeof(rt5651_voip_off_controls) / sizeof(struct config_control),
+    },
+    .hdmiin_normal = {
+        .controls = rt5651_hdmiin_normal_controls,
+        .controls_count = sizeof(rt5651_hdmiin_normal_controls) / sizeof(struct config_control),
+    },
+
+    .hdmiin_off = {
+        .controls = rt5651_hdmiin_off_controls,
+        .controls_count = sizeof(rt5651_hdmiin_off_controls) / sizeof(struct config_control),
+    },
+
+    .hdmiin_captrue = {
+        .controls = rt5651_hdmiin_captrue_controls,
+        .controls_count = sizeof(rt5651_hdmiin_captrue_controls) / sizeof(struct config_control),
+    },
+    .hdmiin_captrue_off = {
+        .controls = rt5651_hdmiin_captrue_off_controls,
+        .controls_count = sizeof(rt5651_hdmiin_captrue_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+
+#endif //_RT5651_CONFIG_H_
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5678_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5678_config.h
new file mode 100644
index 0000000000..6d81dd37a2
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/rt5678_config.h
@@ -0,0 +1,308 @@
+#ifndef _RT5678_CONFIG_H_
+#define _RT5678_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control rt5678_speaker_normal_controls[] = {
+	{
+		.ctl_name = "DA STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "DAC1 Mux",
+		.str_val = "IF3 DAC",
+	},
+	{
+		.ctl_name = "DAC1 MIXL DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 MIXR DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXL DAC1 L Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXR DAC1 R Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 L Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC1 R Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC3 Source Mux",
+		.str_val = "STO1 DAC MIX",
+	},
+	{
+		.ctl_name = "LOUT1 Playback Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "LOUT2 Playback Switch",
+		.int_val = {on},
+	},
+};
+
+const struct config_control rt5678_headphone_normal_controls[] = {
+	{
+		.ctl_name = "DA STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "DAC1 Mux",
+		.str_val = "IF3 DAC",
+	},
+	{
+		.ctl_name = "DAC1 MIXL DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 MIXR DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXL DAC1 L Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXR DAC1 R Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 L Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC1 R Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC12 Source Mux",
+		.str_val = "STO1 DAC MIX",
+	},
+};
+
+const struct config_control rt5678_mono_normal_controls[] = {
+	{
+		.ctl_name = "DA STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "DAC1 Mux",
+		.str_val = "IF3 DAC",
+	},
+	{
+		.ctl_name = "DAC1 MIXL DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 MIXR DAC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXL DAC1 L Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXR DAC1 R Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "DAC1 L Mixer Source Mux",
+		.str_val = "Mixer",
+	},
+	{
+		.ctl_name = "DAC5 Source Mux",
+		.str_val = "STO1 DAC MIXL",
+	},
+};
+
+const struct config_control rt5678_headset_mic_capture_controls[] = {
+	{
+		.ctl_name = "AD STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "Stereo1 ADC Mux",
+		.str_val = "ADC12",
+	},
+	{
+		.ctl_name = "IN1 Capture Volume",
+		.int_val = {35},
+	},
+	{
+		.ctl_name = "IN2 Capture Volume",
+		.int_val = {35},
+	},
+	{
+		.ctl_name = "Stereo1 ADC1 Mux",
+		.str_val = "ADC/DMIC",
+	},
+	{
+		.ctl_name = "Sto1 ADC MIXL ADC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "IF3 ADC Mux",
+		.str_val =  "STO1 ADC MIX",
+	},
+	{
+		.ctl_name = "IF1 ADC1 Swap Mux",
+		.str_val =  "L/L",
+	},
+};
+
+const struct config_control rt5678_main_mic_capture_controls[] = {
+	{
+		.ctl_name = "AD STO1 ASRC Switch",
+		.str_val = "clk_sys3",
+	},
+	{
+		.ctl_name = "Stereo1 ADC Mux",
+		.str_val = "ADC34",
+	},
+	{
+		.ctl_name = "IN3 Capture Volume",
+		.int_val = {35},
+	},
+	{
+		.ctl_name = "IN4 Capture Volume",
+		.int_val = {35},
+	},
+	{
+		.ctl_name = "Stereo1 ADC1 Mux",
+		.str_val = "ADC/DMIC",
+	},
+	{
+		.ctl_name = "Sto1 ADC MIXL ADC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "Sto1 ADC MIXR ADC1 Switch",
+		.int_val = {on},
+	},
+	{
+		.ctl_name = "IF3 ADC Mux",
+		.str_val =  "STO1 ADC MIX",
+	},
+	{
+		.ctl_name = "IF3 ADC Swap Mux",
+		.str_val =  "R/R",
+	},
+};
+
+const struct config_control rt5678_playback_off_controls[] = {
+	{
+		.ctl_name = "DAC1 MIXL DAC1 Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "DAC1 MIXR DAC1 Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXL DAC1 L Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "Stereo DAC MIXR DAC1 R Switch",
+		.int_val = {off},
+	},
+};
+
+const struct config_control rt5678_capture_off_controls[] = {
+	{
+		.ctl_name = "Sto1 ADC MIXL ADC1 Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "Sto1 ADC MIXR ADC1 Switch",
+		.int_val = {off},
+	},
+	{
+		.ctl_name = "IF1 ADC1 Swap Mux",
+		.str_val =  "L/R",
+	},
+};
+
+const struct config_route_table rt5678_config_table = {
+	//speaker
+	.speaker_normal = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_speaker_normal_controls,
+		.controls_count = sizeof(rt5678_speaker_normal_controls) / sizeof(struct config_control),
+	},
+
+	//headphone
+	.headphone_normal = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_headphone_normal_controls,
+		.controls_count = sizeof(rt5678_headphone_normal_controls) / sizeof(struct config_control),
+	},
+
+#if 0
+	//mono
+	.mono_normal = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_mono_normal_controls,
+		.controls_count = sizeof(rt5678_mono_normal_controls) / sizeof(struct config_control),
+	},
+#endif
+
+	//capture
+	.hands_free_mic_capture = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_headset_mic_capture_controls,
+		.controls_count = sizeof(rt5678_headset_mic_capture_controls) / sizeof(struct config_control),
+	},
+
+	//capture
+	.main_mic_capture = {
+		.sound_card = 0,
+		.devices = DEVICES_0,
+		.controls = rt5678_main_mic_capture_controls,
+		.controls_count = sizeof(rt5678_main_mic_capture_controls) / sizeof(struct config_control),
+	},
+
+	//off
+	.playback_off = {
+		.controls = rt5678_playback_off_controls,
+		.controls_count = sizeof(rt5678_playback_off_controls) / sizeof(struct config_control),
+	},
+	.capture_off = {
+		.controls = rt5678_capture_off_controls,
+		.controls_count = sizeof(rt5678_capture_off_controls) / sizeof(struct config_control),
+	},
+
+	//hdmi
+	.hdmi_normal = {
+		.sound_card = 1,
+		.devices = DEVICES_0,
+		.controls_count = 0,
+	},
+
+	//usb audio
+	.usb_normal = {
+		.sound_card = 2,
+		.devices = DEVICES_0,
+		.controls_count = 0,
+	},
+	.usb_capture = {
+		.sound_card = 2,
+		.devices = DEVICES_0,
+		.controls_count = 0,
+	},
+};
+
+#endif //_RT5678_CONFIG_H_
\ No newline at end of file
diff --git a/hardware/rockchip/audio/tinyalsa_hal/codec_config/wm8960_config.h b/hardware/rockchip/audio/tinyalsa_hal/codec_config/wm8960_config.h
new file mode 100755
index 0000000000..bf6dbb1f00
--- /dev/null
+++ b/hardware/rockchip/audio/tinyalsa_hal/codec_config/wm8960_config.h
@@ -0,0 +1,869 @@
+/*
+ * Copyright (C) 2015 Rockchip Electronics Co., Ltd.
+*/
+/**
+ * @file wm8960_config.h
+ * @brief 
+ * @author  RKAudio
+ * @version 1.0.8
+ * @date 2015-08-24
+ */
+
+#ifndef _WM8960_CONFIG_H_
+#define _WM8960_CONFIG_H_
+
+#include "config.h"
+
+const struct config_control wm8960_speaker_normal_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {120, 120},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_speaker_incall_controls[] = {
+};
+
+const struct config_control wm8960_speaker_ringtone_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {120, 120},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_speaker_voip_controls[] = {
+
+};
+
+const struct config_control wm8960_earpiece_normal_controls[] = {
+
+};
+
+const struct config_control wm8960_earpiece_incall_controls[] = {
+};
+
+const struct config_control wm8960_earpiece_ringtone_controls[] = {
+};
+
+const struct config_control wm8960_earpiece_voip_controls[] = {
+
+};
+
+const struct config_control wm8960_headphone_normal_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {116, 116},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_headphone_incall_controls[] = {
+
+};
+
+const struct config_control wm8960_headphone_ringtone_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {116, 116},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+ };
+
+const struct config_control wm8960_speaker_headphone_normal_controls[] = {
+};
+
+const struct config_control wm8960_speaker_headphone_ringtone_controls[] = {
+};
+
+const struct config_control wm8960_headphone_voip_controls[] = {
+};
+
+const struct config_control wm8960_headset_normal_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {116, 116},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_headset_incall_controls[] = {
+ };
+
+const struct config_control wm8960_headset_ringtone_controls[] = {
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {255, 255},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {116, 116},
+    },
+    {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_headset_voip_controls[] = {
+
+};
+
+const struct config_control wm8960_bluetooth_normal_controls[] = {
+ };
+
+const struct config_control wm8960_bluetooth_incall_controls[] = { 
+};
+
+const struct config_control wm8960_bluetooth_voip_controls[] = {
+
+};
+
+const struct config_control wm8960_main_mic_capture_controls[] = {
+    {
+        .ctl_name = "Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC High Pass Filter Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT2 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINPUT2 To Left Boost Mixer Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "LINPUT3 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT2 To Right Boost Mixer Volume",
+        .int_val = {3},
+    },
+    {
+        .ctl_name = "RINPUT3 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Lmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Rmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Capture Volume",
+        .int_val = {63,63},
+    }, 
+    {
+        .ctl_name = "ADC PCM Capture Volume",
+        .int_val = {127,127},
+    }, 
+    {
+        .ctl_name = "Capture Volume Switch",
+        .int_val = {0,0},
+    }, 
+    {
+        .ctl_name = "Capture Switch",
+        .int_val = {on,on},
+    }, 
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {on},
+    },
+};
+
+const struct config_control wm8960_hands_free_mic_capture_controls[] = {
+  {
+        .ctl_name = "Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC High Pass Filter Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT1 Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINPUT2 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LINPUT3 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT2 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT3 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {on},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Lmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Rmic Boost",
+        .str_val = "13db",
+    },
+    {
+        .ctl_name = "Capture Volume",
+        .int_val = {0,63},
+    }, 
+    {
+        .ctl_name = "ADC PCM Capture Volume",
+        .int_val = {0,80},
+    }, 
+    {
+        .ctl_name = "Capture Volume Switch",
+        .int_val = {0,0},
+    }, 
+    {
+        .ctl_name = "Capture Switch",
+        .int_val = {off,on},
+    }, 
+};
+
+const struct config_control wm8960_bluetooth_sco_mic_capture_controls[] = {
+};
+
+const struct config_control wm8960_playback_off_controls[] = {
+   {
+        .ctl_name = "Right Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer PCM Playback Switch",
+        .int_val = {off},
+    },
+
+    {
+        .ctl_name = "Right Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer Boost Bypass Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Output Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Output Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Speaker Playback Volume",
+        .int_val = {0, 0},
+    },
+    {
+        .ctl_name = "Headphone Playback Volume",
+        .int_val = {0, 0},
+    }, 
+};
+
+const struct config_control wm8960_capture_off_controls[] = {
+    {
+        .ctl_name = "Capture Switch",
+        .int_val = {off,off},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "ADC High Pass Filter Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Boost Mixer RINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT1 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT2 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Left Boost Mixer LINPUT3 Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "LINPUT2 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "LINPUT3 To Left Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT2 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "RINPUT3 To Right Boost Mixer Volume",
+        .int_val = {0},
+    },
+    {
+        .ctl_name = "Left Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Right Input Mixer Boost Switch",
+        .int_val = {off},
+    },
+    {
+        .ctl_name = "Lmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Rmic Boost",
+        .str_val = "0db",
+    },
+    {
+        .ctl_name = "Capture Volume",
+        .int_val = {0,0},
+    }, 
+    {
+        .ctl_name = "ADC PCM Capture Volume",
+        .int_val = {0,0},
+    }, 
+    {
+        .ctl_name = "Capture Volume Switch",
+        .int_val = {0,0},
+    }, 
+};
+
+const struct config_control wm8960_incall_off_controls[] = { 
+};
+
+const struct config_control wm8960_voip_off_controls[] = {
+
+};
+
+const struct config_route_table wm8960_config_table = {
+    //speaker
+    .speaker_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_normal_controls,
+        .controls_count = sizeof(wm8960_speaker_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_incall_controls,
+        .controls_count = sizeof(wm8960_speaker_incall_controls) / sizeof(struct config_control),
+    },
+    .speaker_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_ringtone_controls,
+        .controls_count = sizeof(wm8960_speaker_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_voip_controls,
+        .controls_count = sizeof(wm8960_speaker_voip_controls) / sizeof(struct config_control),
+    },
+
+    //earpiece
+    .earpiece_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_earpiece_normal_controls,
+        .controls_count = sizeof(wm8960_earpiece_normal_controls) / sizeof(struct config_control),
+    },
+    .earpiece_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_earpiece_incall_controls,
+        .controls_count = sizeof(wm8960_earpiece_incall_controls) / sizeof(struct config_control),
+    },
+    .earpiece_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_earpiece_ringtone_controls,
+        .controls_count = sizeof(wm8960_earpiece_ringtone_controls) / sizeof(struct config_control),
+    },
+    .earpiece_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_earpiece_voip_controls,
+        .controls_count = sizeof(wm8960_earpiece_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headphone
+    .headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headphone_normal_controls,
+        .controls_count = sizeof(wm8960_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .headphone_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headphone_incall_controls,
+        .controls_count = sizeof(wm8960_headphone_incall_controls) / sizeof(struct config_control),
+    },
+    .headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headphone_ringtone_controls,
+        .controls_count = sizeof(wm8960_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_headphone_normal_controls,
+        .controls_count = sizeof(wm8960_speaker_headphone_normal_controls) / sizeof(struct config_control),
+    },
+    .speaker_headphone_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_speaker_headphone_ringtone_controls,
+        .controls_count = sizeof(wm8960_speaker_headphone_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headphone_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headphone_voip_controls,
+        .controls_count = sizeof(wm8960_headphone_voip_controls) / sizeof(struct config_control),
+    },
+
+    //headset
+    .headset_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headset_normal_controls,
+        .controls_count = sizeof(wm8960_headset_normal_controls) / sizeof(struct config_control),
+    },
+    .headset_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headset_incall_controls,
+        .controls_count = sizeof(wm8960_headset_incall_controls) / sizeof(struct config_control),
+    },
+    .headset_ringtone = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headset_ringtone_controls,
+        .controls_count = sizeof(wm8960_headset_ringtone_controls) / sizeof(struct config_control),
+    },
+    .headset_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_headset_voip_controls,
+        .controls_count = sizeof(wm8960_headset_voip_controls) / sizeof(struct config_control),
+    },
+
+    //bluetooth
+    .bluetooth_normal = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_bluetooth_normal_controls,
+        .controls_count = sizeof(wm8960_bluetooth_normal_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_incall = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_bluetooth_incall_controls,
+        .controls_count = sizeof(wm8960_bluetooth_incall_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_voip = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_bluetooth_voip_controls,
+        .controls_count = sizeof(wm8960_bluetooth_voip_controls) / sizeof(struct config_control),
+    },
+
+    //capture
+    .main_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_main_mic_capture_controls,
+        .controls_count = sizeof(wm8960_main_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .hands_free_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_hands_free_mic_capture_controls,
+        .controls_count = sizeof(wm8960_hands_free_mic_capture_controls) / sizeof(struct config_control),
+    },
+    .bluetooth_sco_mic_capture = {
+        .sound_card = 0,
+        .devices = DEVICES_0,
+        .controls = wm8960_bluetooth_sco_mic_capture_controls,
+        .controls_count = sizeof(wm8960_bluetooth_sco_mic_capture_controls) / sizeof(struct config_control),
+    },
+
+    //off
+    .playback_off = {
+        .controls = wm8960_playback_off_controls,
+        .controls_count = sizeof(wm8960_playback_off_controls) / sizeof(struct config_control),
+    },
+    .capture_off = {
+        .controls = wm8960_capture_off_controls,
+        .controls_count = sizeof(wm8960_capture_off_controls) / sizeof(struct config_control),
+    },
+    .incall_off = {
+        .controls = wm8960_incall_off_controls,
+        .controls_count = sizeof(wm8960_incall_off_controls) / sizeof(struct config_control),
+    },
+    .voip_off = {
+        .controls = wm8960_voip_off_controls,
+        .controls_count = sizeof(wm8960_voip_off_controls) / sizeof(struct config_control),
+    },
+
+    //hdmi
+    .hdmi_normal = {
+        .sound_card = 1,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    //usb audio
+    .usb_normal = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+    .usb_capture = {
+        .sound_card = 2,
+        .devices = DEVICES_0,
+        .controls_count = 0,
+    },
+};
+
+#endif //_wm8960_CONFIG_H_
diff --git a/hardware/rockchip/sensor/st/mma8452_kernel.h b/hardware/rockchip/sensor/st/mma8452_kernel.h
new file mode 100755
index 0000000000..bd9b7fa478
--- /dev/null
+++ b/hardware/rockchip/sensor/st/mma8452_kernel.h
@@ -0,0 +1,137 @@
+/*
+ * Definitions for mma8452 compass chip.
+ */
+#ifndef MMA8452_H
+#define MMA8452_H
+
+#include <linux/ioctl.h>
+
+/* Default register settings */
+#define RBUFF_SIZE		12	/* Rx buffer size */
+
+#define MMA8452_REG_STATUS   	    	0x0 //RO
+#define MMA8452_REG_X_OUT_MSB       	0x1 //RO
+#define MMA8452_REG_X_OUT_LSB       	0x2 //RO
+#define MMA8452_REG_Y_OUT_MSB       	0x3 //RO
+#define MMA8452_REG_Y_OUT_LSB       	0x4 //RO
+#define MMA8452_REG_Z_OUT_MSB       	0x5 //RO
+#define MMA8452_REG_Z_OUT_LSB       	0x6 //RO
+#define MMA8452_REG_F_SETUP		       	0x9 //RW
+
+#define MMA8452_REG_SYSMOD				0xB //RO
+#define MMA8452_REG_INTSRC	    		0xC //RO
+#define MMA8452_REG_WHO_AM_I      		0xD //RO
+#define MMA8452_REG_XYZ_DATA_CFG		0xE //RW
+#define MMA8452_REG_HP_FILTER_CUTOFF	0xF //RW
+#define MMA8452_REG_PL_STATUS			0x10 //RO
+#define MMA8452_REG_PL_CFG				0x11 //RW
+#define MMA8452_REG_PL_COUNT			0x12 //RW
+#define MMA8452_REG_PL_BF_ZCOMP			0x13 //RW
+#define MMA8452_REG_P_L_THS_REG			0x14 //RW
+#define MMA8452_REG_FF_MT_CFG			0x15 //RW
+#define MMA8452_REG_FF_MT_SRC			0x16 //RO
+#define MMA8452_REG_FF_MT_THS			0x17 //RW
+#define MMA8452_REG_FF_MT_COUNT			0x18 //RW
+#define MMA8452_REG_TRANSIENT_CFG		0x1D //RW
+#define MMA8452_REG_TRANSIENT_SRC		0x1E //RO
+#define MMA8452_REG_TRANSIENT_THS		0x1F //RW
+#define MMA8452_REG_TRANSIENT_COUNT		0x20 //RW
+#define MMA8452_REG_PULSE_CFG			0x21 //RW
+#define MMA8452_REG_PULSE_SRC			0x22 //RO
+#define MMA8452_REG_PULSE_THSX			0x23 //RW
+#define MMA8452_REG_PULSE_THSY			0x24 //RW
+#define MMA8452_REG_PULSE_THSZ			0x25 //RW
+#define MMA8452_REG_PULSE_TMLT			0x26 //RW
+#define MMA8452_REG_PULSE_LTCY			0x27 //RW
+#define MMA8452_REG_PULSE_WIND			0x28 //RW
+#define MMA8452_REG_ASLP_COUNT			0x29 //RW
+#define MMA8452_REG_CTRL_REG1			0x2A //RW
+#define MMA8452_REG_CTRL_REG2			0x2B //RW
+#define MMA8452_REG_CTRL_REG3			0x2C //RW
+#define MMA8452_REG_CTRL_REG4			0x2D //RW
+#define MMA8452_REG_CTRL_REG5			0x2E //RW
+#define MMA8452_REG_OFF_X				0x2F //RW
+#define MMA8452_REG_OFF_Y				0x30 //RW
+#define MMA8452_REG_OFF_Z				0x31 //RW
+
+#define GSENSOR_IOCTL_MAGIC				'a'
+
+/* IOCTLs for MMA8452 library */
+#define GSENSOR_IOCTL_INIT                  _IO(GSENSOR_IOCTL_MAGIC, 0x01)
+#define GSENSOR_IOCTL_RESET      	        _IO(GSENSOR_IOCTL_MAGIC, 0x04)
+#define GSENSOR_IOCTL_CLOSE		        _IO(GSENSOR_IOCTL_MAGIC, 0x02)
+#define GSENSOR_IOCTL_START		        _IO(GSENSOR_IOCTL_MAGIC, 0x03)
+#define GSENSOR_IOCTL_GETDATA               _IOR(GSENSOR_IOCTL_MAGIC, 0x08, char[RBUFF_SIZE+1])
+
+/* IOCTLs for APPs */
+#define GSENSOR_IOCTL_APP_SET_RATE		_IOW(GSENSOR_IOCTL_MAGIC, 0x10, short)
+#define GSENSOR_IOCTL_GET_CALIBRATION      _IOR(GSENSOR_IOCTL_MAGIC, 0x11, int[3])
+
+
+/* IOCTLs for MMA8452 library */
+#define MMA_IOCTL_INIT                  _IO(GSENSOR_IOCTL_MAGIC, 0x01)
+#define MMA_IOCTL_RESET      	        _IO(GSENSOR_IOCTL_MAGIC, 0x04)
+#define MMA_IOCTL_CLOSE		        _IO(GSENSOR_IOCTL_MAGIC, 0x02)
+#define MMA_IOCTL_START		        _IO(GSENSOR_IOCTL_MAGIC, 0x03)
+#define MMA_IOCTL_GETDATA               _IOR(GSENSOR_IOCTL_MAGIC, 0x08, char[RBUFF_SIZE+1])
+
+/* IOCTLs for APPs */
+#define MMA_IOCTL_APP_SET_RATE		_IOW(GSENSOR_IOCTL_MAGIC, 0x10, char)
+
+/*rate*/
+#define MMA8452_RATE_800          0
+#define MMA8452_RATE_400          1
+#define MMA8452_RATE_200          2
+#define MMA8452_RATE_100          3
+#define MMA8452_RATE_50        	  4
+#define MMA8452_RATE_12P5         5
+#define MMA8452_RATE_6P25         6
+#define MMA8452_RATE_1P56         7
+#define MMA8452_RATE_SHIFT		  3
+
+
+#define MMA8452_ASLP_RATE_50          0
+#define MMA8452_ASLP_RATE_12P5        1
+#define MMA8452_ASLP_RATE_6P25        2
+#define MMA8452_ASLP_RATE_1P56        3
+#define MMA8452_ASLP_RATE_SHIFT		  6
+
+#define ACTIVE_MASK				1
+#define FREAD_MASK				2
+
+
+
+
+/*status*/
+#define MMA8452_OPEN           1
+#define MMA8452_CLOSE          0
+
+//#define MMA8452_IIC_ADDR 	    0x98  
+#define MMA8452_REG_LEN         11
+#define MMA8452_GRAVITY_STEP    156 //2g full scale range
+#define MMA8452_PRECISION       8 //8bit data
+#define MMA8452_BOUNDARY        (0x1 << (MMA8452_PRECISION - 1))
+#define MMA8452_TOTAL_TIME      10
+
+
+/*
+struct mma8452_platform_data {
+	int reset;
+	int clk_on;
+	int intr;
+};
+
+*/
+
+struct sensor_axis {
+	int x;
+	int y;
+	int z;
+};
+
+
+#define  GSENSOR_DEV_PATH    "/dev/mma8452_daemon"
+
+
+#endif
+
